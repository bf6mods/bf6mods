var qT = Object.defineProperty;
var UE = V => {
    throw TypeError(V)
}
;
var QT = (V, X, J) => X in V ? qT(V, X, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: J
}) : V[X] = J;
var Tt = (V, X, J) => QT(V, typeof X != "symbol" ? X + "" : X, J)
  , Ap = (V, X, J) => X.has(V) || UE("Cannot " + J);
var It = (V, X, J) => (Ap(V, X, "read from private field"),
J ? J.call(V) : X.get(V))
  , _n = (V, X, J) => X.has(V) ? UE("Cannot add the same private member more than once") : X instanceof WeakSet ? X.add(V) : X.set(V, J)
  , hn = (V, X, J, ne) => (Ap(V, X, "write to private field"),
ne ? ne.call(V, J) : X.set(V, J),
J)
  , Cn = (V, X, J) => (Ap(V, X, "access private method"),
J);
var Vc = (V, X, J, ne) => ({
    set _(ue) {
        hn(V, X, ue, J)
    },
    get _() {
        return It(V, X, ne)
    }
});
function _mergeNamespaces(V, X) {
    for (var J = 0; J < X.length; J++) {
        const ne = X[J];
        if (typeof ne != "string" && !Array.isArray(ne)) {
            for (const ue in ne)
                if (ue !== "default" && !(ue in V)) {
                    const ce = Object.getOwnPropertyDescriptor(ne, ue);
                    ce && Object.defineProperty(V, ue, ce.get ? ce : {
                        enumerable: !0,
                        get: () => ne[ue]
                    })
                }
        }
    }
    return Object.freeze(Object.defineProperty(V, Symbol.toStringTag, {
        value: "Module"
    }))
}
(function() {
    const X = document.createElement("link").relList;
    if (X && X.supports && X.supports("modulepreload"))
        return;
    for (const ue of document.querySelectorAll('link[rel="modulepreload"]'))
        ne(ue);
    new MutationObserver(ue => {
        for (const ce of ue)
            if (ce.type === "childList")
                for (const me of ce.addedNodes)
                    me.tagName === "LINK" && me.rel === "modulepreload" && ne(me)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function J(ue) {
        const ce = {};
        return ue.integrity && (ce.integrity = ue.integrity),
        ue.referrerPolicy && (ce.referrerPolicy = ue.referrerPolicy),
        ue.crossOrigin === "use-credentials" ? ce.credentials = "include" : ue.crossOrigin === "anonymous" ? ce.credentials = "omit" : ce.credentials = "same-origin",
        ce
    }
    function ne(ue) {
        if (ue.ep)
            return;
        ue.ep = !0;
        const ce = J(ue);
        fetch(ue.href, ce)
    }
}
)();
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(V) {
    return V && V.__esModule && Object.prototype.hasOwnProperty.call(V, "default") ? V.default : V
}
var jsxRuntime = {
    exports: {}
}
  , reactJsxRuntime_production = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var REACT_ELEMENT_TYPE$2 = Symbol.for("react.transitional.element")
  , REACT_FRAGMENT_TYPE$2 = Symbol.for("react.fragment");
function jsxProd(V, X, J) {
    var ne = null;
    if (J !== void 0 && (ne = "" + J),
    X.key !== void 0 && (ne = "" + X.key),
    "key"in X) {
        J = {};
        for (var ue in X)
            ue !== "key" && (J[ue] = X[ue])
    } else
        J = X;
    return X = J.ref,
    {
        $$typeof: REACT_ELEMENT_TYPE$2,
        type: V,
        key: ne,
        ref: X !== void 0 ? X : null,
        props: J
    }
}
reactJsxRuntime_production.Fragment = REACT_FRAGMENT_TYPE$2;
reactJsxRuntime_production.jsx = jsxProd;
reactJsxRuntime_production.jsxs = jsxProd;
jsxRuntime.exports = reactJsxRuntime_production;
var jsxRuntimeExports = jsxRuntime.exports
  , QUERY_KEY = (V => (V.AUTH = "auth",
V.BLUEPRINT = "blueprint",
V.EA_NAV = "ea-nav",
V.EXPERIENCE_TEMPLATES = "experience-templates",
V.HELP_TEXT = "help-text",
V.LICENSE_REQUIREMENTS = "license-requirements",
V.LIST_MOD_DATA_VERSIONS = "list-mod-data-versions",
V.LIST_PLAY_ELEMENTS = "list-play-elements",
V.LOCAL_FOOTER = "local-footer",
V.NETWORK_FOOTER = "network-footer",
V.PLAY_ELEMENT = "play-element",
V.PROGRESSION_TYPES = "progression-types",
V.SCHEDULED_BLUEPRINTS = "scheduledBlueprints",
V.SDK_VERSION = "latestSdkVersion",
V.SHARE = "share",
V.SPATIAL_DEFAULTS = "spatial-defaults",
V.TRANSLATIONS = "translations",
V.MOD_TYPE = "mod-type",
V))(QUERY_KEY || {})
  , LOCAL_STORAGE_KEY = (V => (V.WEB_BLUEPRINT = "bf6webBlueprint",
V.BLUEPRINT_ID = "bf6blueprintId",
V.EXPERIENCE_UI_STATE = "bf6experienceUiState",
V.LOGGER = "bf6logger",
V.TELEMETRY_SESSION_ID = "bf6telemetrySessionId",
V))(LOCAL_STORAGE_KEY || {})
  , COOKIE_KEY = (V => (V.SESSION_ID = "bf6sessionId",
V.PLAYER = "bf6player",
V.LOCALE = "bf6portalLocale",
V.ACCEPTED_CONFLICT_DIALOG = "bf6acceptedConflictDialog",
V.DO_NOT_AGAIN_EQUALIZE_TEAMS_DIALOG = "bf6doNotShowAgainEqualizeTeamsDialog",
V.PATCH_VERSIONS = "bf6patchVersions",
V))(COOKIE_KEY || {})
  , react = {
    exports: {}
}
  , react_production = {};
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var REACT_ELEMENT_TYPE$1 = Symbol.for("react.transitional.element")
  , REACT_PORTAL_TYPE$2 = Symbol.for("react.portal")
  , REACT_FRAGMENT_TYPE$1 = Symbol.for("react.fragment")
  , REACT_STRICT_MODE_TYPE$1 = Symbol.for("react.strict_mode")
  , REACT_PROFILER_TYPE$1 = Symbol.for("react.profiler")
  , REACT_CONSUMER_TYPE$1 = Symbol.for("react.consumer")
  , REACT_CONTEXT_TYPE$1 = Symbol.for("react.context")
  , REACT_FORWARD_REF_TYPE$1 = Symbol.for("react.forward_ref")
  , REACT_SUSPENSE_TYPE$1 = Symbol.for("react.suspense")
  , REACT_MEMO_TYPE$1 = Symbol.for("react.memo")
  , REACT_LAZY_TYPE$1 = Symbol.for("react.lazy")
  , MAYBE_ITERATOR_SYMBOL$1 = Symbol.iterator;
function getIteratorFn$1(V) {
    return V === null || typeof V != "object" ? null : (V = MAYBE_ITERATOR_SYMBOL$1 && V[MAYBE_ITERATOR_SYMBOL$1] || V["@@iterator"],
    typeof V == "function" ? V : null)
}
var ReactNoopUpdateQueue = {
    isMounted: function() {
        return !1
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {}
}
  , assign$2 = Object.assign
  , emptyObject = {};
function Component(V, X, J) {
    this.props = V,
    this.context = X,
    this.refs = emptyObject,
    this.updater = J || ReactNoopUpdateQueue
}
Component.prototype.isReactComponent = {};
Component.prototype.setState = function(V, X) {
    if (typeof V != "object" && typeof V != "function" && V != null)
        throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, V, X, "setState")
}
;
Component.prototype.forceUpdate = function(V) {
    this.updater.enqueueForceUpdate(this, V, "forceUpdate")
}
;
function ComponentDummy() {}
ComponentDummy.prototype = Component.prototype;
function PureComponent(V, X, J) {
    this.props = V,
    this.context = X,
    this.refs = emptyObject,
    this.updater = J || ReactNoopUpdateQueue
}
var pureComponentPrototype = PureComponent.prototype = new ComponentDummy;
pureComponentPrototype.constructor = PureComponent;
assign$2(pureComponentPrototype, Component.prototype);
pureComponentPrototype.isPureReactComponent = !0;
var isArrayImpl$1 = Array.isArray
  , ReactSharedInternals$2 = {
    H: null,
    A: null,
    T: null,
    S: null,
    V: null
}
  , hasOwnProperty$3 = Object.prototype.hasOwnProperty;
function ReactElement(V, X, J, ne, ue, ce) {
    return J = ce.ref,
    {
        $$typeof: REACT_ELEMENT_TYPE$1,
        type: V,
        key: X,
        ref: J !== void 0 ? J : null,
        props: ce
    }
}
function cloneAndReplaceKey(V, X) {
    return ReactElement(V.type, X, void 0, void 0, void 0, V.props)
}
function isValidElement(V) {
    return typeof V == "object" && V !== null && V.$$typeof === REACT_ELEMENT_TYPE$1
}
function escape$2(V) {
    var X = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + V.replace(/[=:]/g, function(J) {
        return X[J]
    })
}
var userProvidedKeyEscapeRegex = /\/+/g;
function getElementKey(V, X) {
    return typeof V == "object" && V !== null && V.key != null ? escape$2("" + V.key) : X.toString(36)
}
function noop$1$1() {}
function resolveThenable(V) {
    switch (V.status) {
    case "fulfilled":
        return V.value;
    case "rejected":
        throw V.reason;
    default:
        switch (typeof V.status == "string" ? V.then(noop$1$1, noop$1$1) : (V.status = "pending",
        V.then(function(X) {
            V.status === "pending" && (V.status = "fulfilled",
            V.value = X)
        }, function(X) {
            V.status === "pending" && (V.status = "rejected",
            V.reason = X)
        })),
        V.status) {
        case "fulfilled":
            return V.value;
        case "rejected":
            throw V.reason
        }
    }
    throw V
}
function mapIntoArray(V, X, J, ne, ue) {
    var ce = typeof V;
    (ce === "undefined" || ce === "boolean") && (V = null);
    var me = !1;
    if (V === null)
        me = !0;
    else
        switch (ce) {
        case "bigint":
        case "string":
        case "number":
            me = !0;
            break;
        case "object":
            switch (V.$$typeof) {
            case REACT_ELEMENT_TYPE$1:
            case REACT_PORTAL_TYPE$2:
                me = !0;
                break;
            case REACT_LAZY_TYPE$1:
                return me = V._init,
                mapIntoArray(me(V._payload), X, J, ne, ue)
            }
        }
    if (me)
        return ue = ue(V),
        me = ne === "" ? "." + getElementKey(V, 0) : ne,
        isArrayImpl$1(ue) ? (J = "",
        me != null && (J = me.replace(userProvidedKeyEscapeRegex, "$&/") + "/"),
        mapIntoArray(ue, X, J, "", function(_e) {
            return _e
        })) : ue != null && (isValidElement(ue) && (ue = cloneAndReplaceKey(ue, J + (ue.key == null || V && V.key === ue.key ? "" : ("" + ue.key).replace(userProvidedKeyEscapeRegex, "$&/") + "/") + me)),
        X.push(ue)),
        1;
    me = 0;
    var ge = ne === "" ? "." : ne + ":";
    if (isArrayImpl$1(V))
        for (var Te = 0; Te < V.length; Te++)
            ne = V[Te],
            ce = ge + getElementKey(ne, Te),
            me += mapIntoArray(ne, X, J, ce, ue);
    else if (Te = getIteratorFn$1(V),
    typeof Te == "function")
        for (V = Te.call(V),
        Te = 0; !(ne = V.next()).done; )
            ne = ne.value,
            ce = ge + getElementKey(ne, Te++),
            me += mapIntoArray(ne, X, J, ce, ue);
    else if (ce === "object") {
        if (typeof V.then == "function")
            return mapIntoArray(resolveThenable(V), X, J, ne, ue);
        throw X = String(V),
        Error("Objects are not valid as a React child (found: " + (X === "[object Object]" ? "object with keys {" + Object.keys(V).join(", ") + "}" : X) + "). If you meant to render a collection of children, use an array instead.")
    }
    return me
}
function mapChildren(V, X, J) {
    if (V == null)
        return V;
    var ne = []
      , ue = 0;
    return mapIntoArray(V, ne, "", "", function(ce) {
        return X.call(J, ce, ue++)
    }),
    ne
}
function lazyInitializer(V) {
    if (V._status === -1) {
        var X = V._result;
        X = X(),
        X.then(function(J) {
            (V._status === 0 || V._status === -1) && (V._status = 1,
            V._result = J)
        }, function(J) {
            (V._status === 0 || V._status === -1) && (V._status = 2,
            V._result = J)
        }),
        V._status === -1 && (V._status = 0,
        V._result = X)
    }
    if (V._status === 1)
        return V._result.default;
    throw V._result
}
var reportGlobalError$1 = typeof reportError == "function" ? reportError : function(V) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
        var X = new window.ErrorEvent("error",{
            bubbles: !0,
            cancelable: !0,
            message: typeof V == "object" && V !== null && typeof V.message == "string" ? String(V.message) : String(V),
            error: V
        });
        if (!window.dispatchEvent(X))
            return
    } else if (typeof process == "object" && typeof process.emit == "function") {
        process.emit("uncaughtException", V);
        return
    }
    console.error(V)
}
;
function noop$9() {}
react_production.Children = {
    map: mapChildren,
    forEach: function(V, X, J) {
        mapChildren(V, function() {
            X.apply(this, arguments)
        }, J)
    },
    count: function(V) {
        var X = 0;
        return mapChildren(V, function() {
            X++
        }),
        X
    },
    toArray: function(V) {
        return mapChildren(V, function(X) {
            return X
        }) || []
    },
    only: function(V) {
        if (!isValidElement(V))
            throw Error("React.Children.only expected to receive a single React element child.");
        return V
    }
};
react_production.Component = Component;
react_production.Fragment = REACT_FRAGMENT_TYPE$1;
react_production.Profiler = REACT_PROFILER_TYPE$1;
react_production.PureComponent = PureComponent;
react_production.StrictMode = REACT_STRICT_MODE_TYPE$1;
react_production.Suspense = REACT_SUSPENSE_TYPE$1;
react_production.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals$2;
react_production.__COMPILER_RUNTIME = {
    __proto__: null,
    c: function(V) {
        return ReactSharedInternals$2.H.useMemoCache(V)
    }
};
react_production.cache = function(V) {
    return function() {
        return V.apply(null, arguments)
    }
}
;
react_production.cloneElement = function(V, X, J) {
    if (V == null)
        throw Error("The argument must be a React element, but you passed " + V + ".");
    var ne = assign$2({}, V.props)
      , ue = V.key
      , ce = void 0;
    if (X != null)
        for (me in X.ref !== void 0 && (ce = void 0),
        X.key !== void 0 && (ue = "" + X.key),
        X)
            !hasOwnProperty$3.call(X, me) || me === "key" || me === "__self" || me === "__source" || me === "ref" && X.ref === void 0 || (ne[me] = X[me]);
    var me = arguments.length - 2;
    if (me === 1)
        ne.children = J;
    else if (1 < me) {
        for (var ge = Array(me), Te = 0; Te < me; Te++)
            ge[Te] = arguments[Te + 2];
        ne.children = ge
    }
    return ReactElement(V.type, ue, void 0, void 0, ce, ne)
}
;
react_production.createContext = function(V) {
    return V = {
        $$typeof: REACT_CONTEXT_TYPE$1,
        _currentValue: V,
        _currentValue2: V,
        _threadCount: 0,
        Provider: null,
        Consumer: null
    },
    V.Provider = V,
    V.Consumer = {
        $$typeof: REACT_CONSUMER_TYPE$1,
        _context: V
    },
    V
}
;
react_production.createElement = function(V, X, J) {
    var ne, ue = {}, ce = null;
    if (X != null)
        for (ne in X.key !== void 0 && (ce = "" + X.key),
        X)
            hasOwnProperty$3.call(X, ne) && ne !== "key" && ne !== "__self" && ne !== "__source" && (ue[ne] = X[ne]);
    var me = arguments.length - 2;
    if (me === 1)
        ue.children = J;
    else if (1 < me) {
        for (var ge = Array(me), Te = 0; Te < me; Te++)
            ge[Te] = arguments[Te + 2];
        ue.children = ge
    }
    if (V && V.defaultProps)
        for (ne in me = V.defaultProps,
        me)
            ue[ne] === void 0 && (ue[ne] = me[ne]);
    return ReactElement(V, ce, void 0, void 0, null, ue)
}
;
react_production.createRef = function() {
    return {
        current: null
    }
}
;
react_production.forwardRef = function(V) {
    return {
        $$typeof: REACT_FORWARD_REF_TYPE$1,
        render: V
    }
}
;
react_production.isValidElement = isValidElement;
react_production.lazy = function(V) {
    return {
        $$typeof: REACT_LAZY_TYPE$1,
        _payload: {
            _status: -1,
            _result: V
        },
        _init: lazyInitializer
    }
}
;
react_production.memo = function(V, X) {
    return {
        $$typeof: REACT_MEMO_TYPE$1,
        type: V,
        compare: X === void 0 ? null : X
    }
}
;
react_production.startTransition = function(V) {
    var X = ReactSharedInternals$2.T
      , J = {};
    ReactSharedInternals$2.T = J;
    try {
        var ne = V()
          , ue = ReactSharedInternals$2.S;
        ue !== null && ue(J, ne),
        typeof ne == "object" && ne !== null && typeof ne.then == "function" && ne.then(noop$9, reportGlobalError$1)
    } catch (ce) {
        reportGlobalError$1(ce)
    } finally {
        ReactSharedInternals$2.T = X
    }
}
;
react_production.unstable_useCacheRefresh = function() {
    return ReactSharedInternals$2.H.useCacheRefresh()
}
;
react_production.use = function(V) {
    return ReactSharedInternals$2.H.use(V)
}
;
react_production.useActionState = function(V, X, J) {
    return ReactSharedInternals$2.H.useActionState(V, X, J)
}
;
react_production.useCallback = function(V, X) {
    return ReactSharedInternals$2.H.useCallback(V, X)
}
;
react_production.useContext = function(V) {
    return ReactSharedInternals$2.H.useContext(V)
}
;
react_production.useDebugValue = function() {}
;
react_production.useDeferredValue = function(V, X) {
    return ReactSharedInternals$2.H.useDeferredValue(V, X)
}
;
react_production.useEffect = function(V, X, J) {
    var ne = ReactSharedInternals$2.H;
    if (typeof J == "function")
        throw Error("useEffect CRUD overload is not enabled in this build of React.");
    return ne.useEffect(V, X)
}
;
react_production.useId = function() {
    return ReactSharedInternals$2.H.useId()
}
;
react_production.useImperativeHandle = function(V, X, J) {
    return ReactSharedInternals$2.H.useImperativeHandle(V, X, J)
}
;
react_production.useInsertionEffect = function(V, X) {
    return ReactSharedInternals$2.H.useInsertionEffect(V, X)
}
;
react_production.useLayoutEffect = function(V, X) {
    return ReactSharedInternals$2.H.useLayoutEffect(V, X)
}
;
react_production.useMemo = function(V, X) {
    return ReactSharedInternals$2.H.useMemo(V, X)
}
;
react_production.useOptimistic = function(V, X) {
    return ReactSharedInternals$2.H.useOptimistic(V, X)
}
;
react_production.useReducer = function(V, X, J) {
    return ReactSharedInternals$2.H.useReducer(V, X, J)
}
;
react_production.useRef = function(V) {
    return ReactSharedInternals$2.H.useRef(V)
}
;
react_production.useState = function(V) {
    return ReactSharedInternals$2.H.useState(V)
}
;
react_production.useSyncExternalStore = function(V, X, J) {
    return ReactSharedInternals$2.H.useSyncExternalStore(V, X, J)
}
;
react_production.useTransition = function() {
    return ReactSharedInternals$2.H.useTransition()
}
;
react_production.version = "19.1.1";
react.exports = react_production;
var reactExports = react.exports;
const React$2 = getDefaultExportFromCjs(reactExports);
var reactDom = {
    exports: {}
}
  , reactDom_production = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var React$1 = reactExports;
function formatProdErrorMessage$1(V) {
    var X = "https://react.dev/errors/" + V;
    if (1 < arguments.length) {
        X += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var J = 2; J < arguments.length; J++)
            X += "&args[]=" + encodeURIComponent(arguments[J])
    }
    return "Minified React error #" + V + "; visit " + X + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
function noop$8() {}
var Internals = {
    d: {
        f: noop$8,
        r: function() {
            throw Error(formatProdErrorMessage$1(522))
        },
        D: noop$8,
        C: noop$8,
        L: noop$8,
        m: noop$8,
        X: noop$8,
        S: noop$8,
        M: noop$8
    },
    p: 0,
    findDOMNode: null
}
  , REACT_PORTAL_TYPE$1 = Symbol.for("react.portal");
function createPortal$1(V, X, J) {
    var ne = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: REACT_PORTAL_TYPE$1,
        key: ne == null ? null : "" + ne,
        children: V,
        containerInfo: X,
        implementation: J
    }
}
var ReactSharedInternals$1 = React$1.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
function getCrossOriginStringAs(V, X) {
    if (V === "font")
        return "";
    if (typeof X == "string")
        return X === "use-credentials" ? X : ""
}
reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
reactDom_production.createPortal = function(V, X) {
    var J = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!X || X.nodeType !== 1 && X.nodeType !== 9 && X.nodeType !== 11)
        throw Error(formatProdErrorMessage$1(299));
    return createPortal$1(V, X, null, J)
}
;
reactDom_production.flushSync = function(V) {
    var X = ReactSharedInternals$1.T
      , J = Internals.p;
    try {
        if (ReactSharedInternals$1.T = null,
        Internals.p = 2,
        V)
            return V()
    } finally {
        ReactSharedInternals$1.T = X,
        Internals.p = J,
        Internals.d.f()
    }
}
;
reactDom_production.preconnect = function(V, X) {
    typeof V == "string" && (X ? (X = X.crossOrigin,
    X = typeof X == "string" ? X === "use-credentials" ? X : "" : void 0) : X = null,
    Internals.d.C(V, X))
}
;
reactDom_production.prefetchDNS = function(V) {
    typeof V == "string" && Internals.d.D(V)
}
;
reactDom_production.preinit = function(V, X) {
    if (typeof V == "string" && X && typeof X.as == "string") {
        var J = X.as
          , ne = getCrossOriginStringAs(J, X.crossOrigin)
          , ue = typeof X.integrity == "string" ? X.integrity : void 0
          , ce = typeof X.fetchPriority == "string" ? X.fetchPriority : void 0;
        J === "style" ? Internals.d.S(V, typeof X.precedence == "string" ? X.precedence : void 0, {
            crossOrigin: ne,
            integrity: ue,
            fetchPriority: ce
        }) : J === "script" && Internals.d.X(V, {
            crossOrigin: ne,
            integrity: ue,
            fetchPriority: ce,
            nonce: typeof X.nonce == "string" ? X.nonce : void 0
        })
    }
}
;
reactDom_production.preinitModule = function(V, X) {
    if (typeof V == "string")
        if (typeof X == "object" && X !== null) {
            if (X.as == null || X.as === "script") {
                var J = getCrossOriginStringAs(X.as, X.crossOrigin);
                Internals.d.M(V, {
                    crossOrigin: J,
                    integrity: typeof X.integrity == "string" ? X.integrity : void 0,
                    nonce: typeof X.nonce == "string" ? X.nonce : void 0
                })
            }
        } else
            X == null && Internals.d.M(V)
}
;
reactDom_production.preload = function(V, X) {
    if (typeof V == "string" && typeof X == "object" && X !== null && typeof X.as == "string") {
        var J = X.as
          , ne = getCrossOriginStringAs(J, X.crossOrigin);
        Internals.d.L(V, J, {
            crossOrigin: ne,
            integrity: typeof X.integrity == "string" ? X.integrity : void 0,
            nonce: typeof X.nonce == "string" ? X.nonce : void 0,
            type: typeof X.type == "string" ? X.type : void 0,
            fetchPriority: typeof X.fetchPriority == "string" ? X.fetchPriority : void 0,
            referrerPolicy: typeof X.referrerPolicy == "string" ? X.referrerPolicy : void 0,
            imageSrcSet: typeof X.imageSrcSet == "string" ? X.imageSrcSet : void 0,
            imageSizes: typeof X.imageSizes == "string" ? X.imageSizes : void 0,
            media: typeof X.media == "string" ? X.media : void 0
        })
    }
}
;
reactDom_production.preloadModule = function(V, X) {
    if (typeof V == "string")
        if (X) {
            var J = getCrossOriginStringAs(X.as, X.crossOrigin);
            Internals.d.m(V, {
                as: typeof X.as == "string" && X.as !== "script" ? X.as : void 0,
                crossOrigin: J,
                integrity: typeof X.integrity == "string" ? X.integrity : void 0
            })
        } else
            Internals.d.m(V)
}
;
reactDom_production.requestFormReset = function(V) {
    Internals.d.r(V)
}
;
reactDom_production.unstable_batchedUpdates = function(V, X) {
    return V(X)
}
;
reactDom_production.useFormState = function(V, X, J) {
    return ReactSharedInternals$1.H.useFormState(V, X, J)
}
;
reactDom_production.useFormStatus = function() {
    return ReactSharedInternals$1.H.useHostTransitionStatus()
}
;
reactDom_production.version = "19.1.1";
function checkDCE$1() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE$1)
        } catch (V) {
            console.error(V)
        }
}
checkDCE$1(),
reactDom.exports = reactDom_production;
var reactDomExports = reactDom.exports, PLACEMENT;
(function(V) {
    V.TOP = "top",
    V.RIGHT = "right",
    V.BOTTOM = "bottom",
    V.LEFT = "left",
    V.TOP_LEFT = "topLeft",
    V.TOP_RIGHT = "topRight",
    V.RIGHT_TOP = "rightTop",
    V.RIGHT_BOTTOM = "rightBottom",
    V.BOTTOM_RIGHT = "bottomRight",
    V.BOTTOM_LEFT = "bottomLeft",
    V.LEFT_BOTTOM = "leftBottom",
    V.LEFT_TOP = "leftTop"
}
)(PLACEMENT || (PLACEMENT = {}));
var BREAKPOINT_NAMES;
(function(V) {
    V.XXS = "xxs",
    V.XS = "xs",
    V.SM = "sm",
    V.MD = "md",
    V.LG = "lg",
    V.XL = "xl",
    V.XXL = "xxl"
}
)(BREAKPOINT_NAMES || (BREAKPOINT_NAMES = {}));
const theme = {
    widths: {
        sidebar: "240px",
        sidebarCollapsed: "60px",
        pageWide: "1920px",
        pageNarrow: "1120px"
    },
    breakpoints: {
        xxs: "0",
        xs: "480px",
        sm: "576px",
        md: "768px",
        lg: "992px",
        xl: "1200px",
        xxl: "1456px"
    },
    colors: {
        white: "#fff",
        black: "#000",
        gray100: "#9dadb8",
        gray200: "#8b9aa3",
        gray300: "#75828a",
        gray400: "#606a70",
        gray500: "#464d52",
        gray600: "#343a3d",
        gray700: "#272b2e",
        gray800: "#111314",
        gray900: "#090a0a",
        gray1000: "#1a1d1f",
        gray1100: "#141617",
        neutral100: "#aec0cc",
        neutral200: "#bfcad1",
        neutral700: "#4B5459",
        neutral800: "#2B3033",
        neutralT100: "rgba(174, 192, 204, 0.25)",
        neutralT200: "rgba(174, 192, 204, 0.1)",
        neutralT300: "rgba(174, 192, 204, 0.5)",
        neutralT400: "rgba(174, 192, 204, 0.75)",
        neutralT500: "rgba(174, 192, 204, 0.05)",
        blue100: "#59bff8",
        blue200: "#50acdf",
        blue300: "#4799c6",
        blue400: "#3c81a7",
        blue500: "#316988",
        blue600: "#244c63",
        blue700: "#1b394a",
        blue800: "#142B38",
        yellow100T25: "rgba(242, 197, 115, 0.25)",
        yellow100: "#f2c573",
        yellow900: "#18140B",
        green100: "#8eed6c",
        green200: "#80d561",
        green300: "#72be56",
        green400: "#60a049",
        green500: "#4e823b",
        green600: "#395f2b",
        green700: "#2b4720",
        green800: "#203518",
        orange100: "#f79800",
        orange200: "#de8900",
        orange300: "#c67a00",
        orange400: "#a76700",
        orange500: "#885400",
        orange600: "#633d00",
        orange700: "#4a2e00",
        orange800: "#382200",
        red100: "#fb694d",
        red200: "#e25e45",
        red300: "#c9543e",
        red400: "#a94734",
        red500: "#8a3a2a",
        red600: "#642a1f",
        red700: "#4b1f17",
        red800: "#381811",
        red900: "#190600",
        red100T75: "rgba(255, 21, 21, 0.75)",
        brand100: "#ff3c00",
        shade100: "var(--tmln-colors-gray700)",
        shade200: "var(--tmln-colors-gray800)",
        shade300: "var(--tmln-colors-gray600)",
        primary: "var(--tmln-colors-neutral-100)",
        primaryDisabled: "var(--tmln-colors-gray700)",
        secondary: "var(--tmln-colors-red100)",
        secondaryDisabled: "var(--tmln-colors-red800)",
        tertiary: "var(--tmln-colors-blue100)",
        tertiaryDisabled: "var(--tmln-colors-blue800)",
        positiveVibrant: "var(--tmln-colors-green100)",
        positiveDull: "var(--tmln-colors-green700)",
        warningVibrant: "var(--tmln-colors-orange100)",
        warningDull: "var(--tmln-colors-orange700)",
        dangerVibrant: "var(--tmln-colors-red100)",
        dangerDull: "var(--tmln-colors-red700)",
        scrimGray100: "color-mix(in srgb, var(--tmln-colors-gray100) 20%, transparent)",
        scrimGray200: "color-mix(in srgb, var(--tmln-colors-gray100) 40%, transparent)",
        scrimGray300: "color-mix(in srgb, var(--tmln-colors-gray100) 60%, transparent)",
        scrimGray400: "color-mix(in srgb, var(--tmln-colors-gray100) 80%, transparent)",
        scrim100: "color-mix(in srgb, var(--tmln-colors-black) 40%, transparent)",
        scrim200: "color-mix(in srgb, var(--tmln-colors-black) 60%, transparent)",
        scrim300: "color-mix(in srgb, var(--tmln-colors-black) 80%, transparent)",
        text: "var(--tmln-colors-neutral-100)",
        textInvert: "var(--tmln-colors-black)",
        bodyBg: "var(--tmln-colors-gray600)",
        skeletonBorderColor: "var(--tmln-colors-gray400)",
        skeletonBg: "var(--tmln-colors-gray800)",
        skeletonMg: "var(--tmln-colors-gray700)",
        skeletonFg: "var(--tmln-colors-gray400)"
    },
    font: {
        titlePrimary: "BFTitle-Narrow-Bold",
        titleSecondary: "BFTitle-Semi-Bold",
        headingPrimary: "BFSubHeadline-Bold",
        headingSecondary: "BFSubHeadline-Medium",
        textPrimary: "BFText-Regular",
        textSecondary: "BFText-Bold",
        textTertiary: "BFText-Light",
        codePrimary: "BFMono-Bold",
        codeSecondary: "BFMono-Book"
    },
    fontSizes: {
        xs: "10px",
        sm: "12px",
        md: "16px",
        lg: "20px",
        xl: "24px",
        xxl: "34px",
        xxxl: "45px",
        xxxxl: "56px",
        jumbo: "102px"
    },
    spacings: {
        xxxs: "4px",
        xxs: "6px",
        xs: "8px",
        sm: "12px",
        md: "16px",
        lg: "24px",
        xl: "32px",
        xxl: "40px",
        xxxl: "48px",
        jumbo: "64px"
    }
}
  , getPercentage = (V, X, J=0) => !V || !X ? 0 : roundToPrecision((V / X + Number.EPSILON) * 100, J)
  , precisionToStep = V => {
    let X = "1";
    return V === 1 ? X = "0.1" : V > 1 && (X = `0.${Array.from({
        length: V - 1
    }).reduce(J => "0" + J, "1")}`),
    Number.parseFloat(X)
}
  , roundToPrecision = (V, X=0) => {
    const J = Array.from({
        length: X
    }).reduce(ne => ne * 10, 1);
    return Math.round(V * J) / J
}
  , roundToStep = (V, X) => {
    const J = X.toString().split(".")
      , ne = (J.length === 2 ? J[1].length : 1) * 10
      , ue = V * ne
      , ce = X * ne;
    return (ue % ce > ce / 2 ? Math.ceil(ue / ce) : Math.floor(ue / ce)) * ce / ne
}
  , noop$7 = () => {}
  , getIsOutOfViewport = (V, X, J) => {
    const {top: ne, left: ue, bottom: ce, right: me} = V.getBoundingClientRect()
      , ge = {
        top: ne < 0,
        right: me > X,
        bottom: ce > J,
        left: ue < 0
    };
    return [ge.top || ge.right || ge.bottom || ge.left, ge]
}
  , enumToArray = V => Object.values(V).reduce( (X, J) => (typeof J == "string" && X.push(J),
X), [])
  , checkAndAdjustPlacement = ({currentAttempts: V, viewportDetails: {top: X, right: J, bottom: ne, left: ue}}) => {
    const ce = enumToArray(PLACEMENT);
    if (J && !V.has(PLACEMENT.LEFT))
        return PLACEMENT.LEFT;
    if (ue && !V.has(PLACEMENT.RIGHT))
        return PLACEMENT.RIGHT;
    if (X && !V.has(PLACEMENT.BOTTOM))
        return PLACEMENT.BOTTOM;
    if (ne && !V.has(PLACEMENT.TOP))
        return PLACEMENT.TOP;
    {
        const me = ce.find(ge => !V.has(ge));
        if (me)
            return me
    }
}
  , calculatePlacementPosition = (V, X, J, ne=0, ue, ce) => {
    const me = {
        x: 0,
        y: 0
    };
    switch (V) {
    case PLACEMENT.TOP:
    case PLACEMENT.BOTTOM:
        me.x = J.x + J.w / 2 - X.w / 2;
        break;
    case PLACEMENT.TOP_LEFT:
    case PLACEMENT.BOTTOM_LEFT:
        ce ? me.x = ue ? J.x + J.w - X.w : J.x : me.x = ue ? J.x + J.w - X.w / 2 : J.x - X.w / 2;
        break;
    case PLACEMENT.TOP_RIGHT:
    case PLACEMENT.BOTTOM_RIGHT:
        ce ? me.x = ue ? J.x : J.x + J.w - X.w : me.x = ue ? J.x - X.w / 2 : J.x + J.w - X.w / 2;
        break;
    case PLACEMENT.RIGHT:
    case PLACEMENT.RIGHT_TOP:
    case PLACEMENT.RIGHT_BOTTOM:
        me.x = ue ? J.x - X.w - ne : J.x + J.w + ne;
        break;
    case PLACEMENT.LEFT:
    case PLACEMENT.LEFT_BOTTOM:
    case PLACEMENT.LEFT_TOP:
        me.x = ue ? J.x + J.w + ne : J.x - X.w - ne;
        break
    }
    switch (V) {
    case PLACEMENT.TOP:
    case PLACEMENT.TOP_LEFT:
    case PLACEMENT.TOP_RIGHT:
        me.y = J.y - X.h - ne;
        break;
    case PLACEMENT.LEFT:
    case PLACEMENT.RIGHT:
        me.y = J.y + J.h / 2 - X.h / 2;
        break;
    case PLACEMENT.RIGHT_TOP:
    case PLACEMENT.LEFT_TOP:
        me.y = ce ? J.y : J.y - X.h / 2;
        break;
    case PLACEMENT.BOTTOM:
    case PLACEMENT.BOTTOM_LEFT:
    case PLACEMENT.BOTTOM_RIGHT:
        me.y = J.y + J.h + ne;
        break;
    case PLACEMENT.LEFT_BOTTOM:
    case PLACEMENT.RIGHT_BOTTOM:
        me.y = ce ? J.y + J.h - X.h : J.y + J.h - X.h / 2;
        break
    }
    return me
}
  , classNames = (...V) => V.reduce( (X, J) => (J && typeof J == "string" && (X === void 0 ? X = J : X = `${X} ${J}`),
X), void 0)
  , getMobileFirstOption = (V, X, J) => {
    if (V && typeof V == "object" && (BREAKPOINT_NAMES.XXS in V || BREAKPOINT_NAMES.XS in V || BREAKPOINT_NAMES.SM in V || BREAKPOINT_NAMES.MD in V || BREAKPOINT_NAMES.LG in V || BREAKPOINT_NAMES.XL in V || BREAKPOINT_NAMES.XXL in V)) {
        const ne = Object.keys(V)
          , ue = pxStringToNum(J[X])
          , me = ne.map(ge => ({
            key: ge,
            value: pxStringToNum(J[ge])
        })).reduce( (ge, {value: Te, key: _e}) => (ue >= Te && ge.value <= Te && (ge = {
            value: Te,
            key: _e
        }),
        ge), {
            key: BREAKPOINT_NAMES.XXS,
            value: 0
        }).key;
        return V[me]
    }
    return V
}
  , concatOptionalName = (V, X) => {
    const J = [V];
    return X && J.push(X),
    J.join(" ")
}
  , copyToClipboard = async V => {
    try {
        await navigator.clipboard.writeText(V)
    } catch (X) {
        console.error("Failed to copy: ", X)
    }
}
  , moveArrayElem = (V, X, J) => {
    const ne = [...V];
    return ne.splice(J, 0, ne.splice(X, 1)[0]),
    ne
}
  , insertIntoArrayAtPosition = (V, X, J) => [...V.slice(0, J), X, ...V.slice(J)]
  , camelToKebabCase = V => V.replace(/[A-Z]+(?![a-z])|[A-Z]/g, (X, J) => (J ? "-" : "") + X.toLowerCase())
  , kebabToCamelCase = V => V.split("-").map( (X, J) => J === 0 ? X : X.charAt(0).toUpperCase() + X.slice(1)).join("")
  , pxStringToNum = V => {
    const X = V != null && V.includes("px") ? Number(V.slice(0, -2)) : Number(V);
    return isNaN(X) ? 0 : X
}
  , clamp = (V, X, J) => Math.min(Math.max(V, X), J)
  , computeRelativeCoordinates = ({placement: V, target: X, elementToPlace: J, isRtl: ne, offset: ue=0, alignToEdge: ce}) => {
    const me = X.getBoundingClientRect()
      , ge = J.getBoundingClientRect();
    return calculatePlacementPosition(V, {
        x: ge.left + window.scrollX,
        y: ge.top + window.scrollY,
        w: ge.width,
        h: ge.height
    }, {
        x: me.x + window.scrollX,
        y: me.top + window.scrollY,
        w: me.width,
        h: me.height
    }, ue, ne, ce)
}
;
var common_utils = Object.freeze({
    __proto__: null,
    calculatePlacementPosition,
    camelToKebabCase,
    checkAndAdjustPlacement,
    clamp,
    classNames,
    computeRelativeCoordinates,
    concatOptionalName,
    copyToClipboard,
    enumToArray,
    getIsOutOfViewport,
    getMobileFirstOption,
    getPercentage,
    insertIntoArrayAtPosition,
    kebabToCamelCase,
    moveArrayElem,
    noop: noop$7,
    precisionToStep,
    pxStringToNum,
    roundToPrecision,
    roundToStep
})
  , styles$15 = {
    wrapper: "prompt-box-module_wrapper__7cDYo",
    border: "prompt-box-module_border__Ky431",
    innerBorder: "prompt-box-module_innerBorder__zBFhM"
};
const PromptBox = ({children: V, className: X}) => jsxRuntimeExports.jsx("div", {
    className: classNames(styles$15.wrapper, X),
    children: jsxRuntimeExports.jsx("div", {
        className: styles$15.border,
        children: jsxRuntimeExports.jsx("div", {
            className: styles$15.innerBorder,
            children: jsxRuntimeExports.jsx("div", {
                className: styles$15.container,
                children: V
            })
        })
    })
});
var styles$14 = {
    wrapper: "dialog-module_wrapper__HLwtM",
    isOpen: "dialog-module_isOpen__ve31S",
    content: "dialog-module_content__8IGXs",
    dialog: "dialog-module_dialog__-Hn1o"
};
const Dialog = reactExports.forwardRef( ({dialogId: V, children: X, isOpen: J}, ne) => jsxRuntimeExports.jsx("div", {
    className: classNames(styles$14.wrapper, J && styles$14.isOpen),
    ...J && {
        style: {
            top: `${window.scrollY}px`
        }
    },
    children: jsxRuntimeExports.jsx("div", {
        className: styles$14.content,
        children: jsxRuntimeExports.jsx(PromptBox, {
            children: jsxRuntimeExports.jsx("div", {
                className: styles$14.dialog,
                id: V,
                ref: ne,
                children: X
            })
        })
    })
}));
Dialog.displayName = "Dialog";
var DIALOG_STATE;
(function(V) {
    V.CLOSED = "closed",
    V.SUBMITTED = "submitted",
    V.OPENED = "opened"
}
)(DIALOG_STATE || (DIALOG_STATE = {}));
const DialogContext = reactExports.createContext({
    setIsOpen: noop$7,
    state: DIALOG_STATE.CLOSED
})
  , DialogProvider = ({children: V, mountId: X="dialog-mount"}) => {
    const [J,ne] = reactExports.useState(!1)
      , [ue,ce] = reactExports.useState()
      , me = reactExports.useRef(null)
      , ge = reactExports.useRef(null)
      , [Te,_e] = reactExports.useState(DIALOG_STATE.CLOSED);
    reactExports.useEffect( () => {
        var ve, ke;
        const Ie = () => {
            ne(!1),
            _e(DIALOG_STATE.CLOSED)
        }
          , ye = xe => {
            xe.stopPropagation()
        }
          , $e = xe => {
            xe.code === "Escape" && (ne(!1),
            _e(DIALOG_STATE.CLOSED))
        }
          , Ne = () => {
            var xe, we;
            document.removeEventListener("keydown", $e),
            (xe = ge.current) == null || xe.removeEventListener("close", Ie),
            (we = ge.current) == null || we.removeEventListener("mousedown", ye)
        }
        ;
        return J ? (document.body.classList.add("no-scroll-scrim-blur"),
        document.addEventListener("keydown", $e),
        (ve = ge.current) == null || ve.addEventListener("mousedown", ye),
        (ke = ge.current) == null || ke.addEventListener("close", Ie)) : (document.body.classList.remove("no-scroll-scrim-blur"),
        ce(void 0),
        Ne()),
        () => {
            document.body.classList.remove("no-scroll-scrim-blur"),
            Ne()
        }
    }
    , [J]);
    const Se = (Ie=!0, ye) => {
        ne(Ie),
        _e(ye)
    }
    ;
    return jsxRuntimeExports.jsxs(DialogContext.Provider, {
        value: {
            portalDestination: me,
            setIsOpen: Se,
            dialogRef: ge,
            setActiveId: ce,
            activeId: ue,
            state: Te
        },
        children: [jsxRuntimeExports.jsx(Dialog, {
            ref: ge,
            dialogId: X,
            isOpen: J,
            children: jsxRuntimeExports.jsx("div", {
                ref: me
            })
        }), V]
    })
}
;
var ICON_NAMES;
(function(V) {
    V.ASSAULT = "assault",
    V.BOT = "bot",
    V.BOT2 = "bot2",
    V.CHECK = "check",
    V.CHECK2 = "check2",
    V.CHECK3 = "check3",
    V.CHEVRON_DOWN = "chevron-down",
    V.CHEVRON_DOWN_90 = "chevron-down-90",
    V.CHEVRON_LEFT = "chevron-left",
    V.CHEVRON_RIGHT = "chevron-right",
    V.CHEVRON_UP_90 = "chevron-up-90",
    V.CLOCK = "clock",
    V.CLOSE = "close",
    V.COG = "cog",
    V.COPY = "copy",
    V.CROSSED_OUT = "crossed-out",
    V.DASHED_CORNER = "dashed-corner",
    V.DOWNLOAD = "download",
    V.DOWNLOAD2 = "download2",
    V.ENGINEER = "engineer",
    V.ERROR = "error",
    V.EXPORT = "export",
    V.EXPORT2 = "export2",
    V.EYE = "eye",
    V.FLAG = "flag",
    V.FOLDER = "folder",
    V.GUN = "gun",
    V.HAMBURGER = "hamburger",
    V.IMPORT = "import",
    V.IMPORT_EXPORT = "importExport",
    V.INFINITY = "infinity",
    V.INFO = "info",
    V.INFO_BLOCK = "infoBlock",
    V.INTERNAL_USE_TOOLTIP_ARROW = "internal-use-tooltip-arrow",
    V.LINK = "link",
    V.LINK_OUT = "link-out",
    V.LOCKED = "locked",
    V.LOGO = "logo",
    V.MAGNIFYING_GLASS = "magnifying-glass",
    V.MANAGE = "manage",
    V.MAP_PIN = "map-pin",
    V.MINUS = "minus",
    V.MINUS2 = "minus2",
    V.MODE_BR = "mode-battle_royale",
    V.MODE_BR_FRAMED = "mode-battle_royale-framed",
    V.MODE_BREAKTHROUGH = "mode-breakthrough",
    V.MODE_BREAKTHROUGH_FRAMED = "mode-breakthrough-framed",
    V.MODE_CONQUEST = "mode-conquest",
    V.MODE_CONQUEST_FRAMED = "mode-conquest-framed",
    V.MODE_CUSTOM = "wrench-hammer",
    V.MODE_GAUNTLET = "mode-gauntlet",
    V.MODE_GAUNTLET_FRAMED = "mode-gauntlet-framed",
    V.MODE_RUSH = "mode-rush",
    V.MODE_RUSH_FRAMED = "mode-rush-framed",
    V.NO_XP = "no-xp",
    V.PENCIL = "pencil",
    V.PENCIL2 = "pencil2",
    V.PLAYER = "player",
    V.PLAYERS = "players",
    V.PLUS = "plus",
    V.PLUS2 = "plus2",
    V.PRICE_TAG = "price-tag",
    V.QUESTION_MARK = "question-mark",
    V.RECON = "recon",
    V.RESET = "reset",
    V.SAVE = "save",
    V.SETTINGS = "settings",
    V.SHARE = "share",
    V.SKULL = "skull",
    V.SPEECH_BUBBLE = "speech-bubble",
    V.SUMMARY = "summary",
    V.SUPPORT = "support",
    V.THUMBS_UP = "thumbs-up",
    V.TRASH = "trash",
    V.TRIANGLE = "triangle",
    V.UNLINK = "unlink",
    V.UPLOAD = "upload",
    V.UPLOAD2 = "upload2",
    V.VERTICAL_DOTS = "vertical-dots",
    V.WARNING = "warning",
    V.WARNING_CIRCLE = "warning-circle",
    V.WARNING_DIAMOND = "warning-diamond",
    V.WRENCH = "wrench",
    V.XP = "xp"
}
)(ICON_NAMES || (ICON_NAMES = {}));
var ICON_SIZES;
(function(V) {
    V.XS = "16px",
    V.SM = "20px",
    V.MD = "24px",
    V.LG = "32px",
    V.JUMBO = "90px",
    V.FILL = "100%"
}
)(ICON_SIZES || (ICON_SIZES = {}));
var ICON_VARIANTS;
(function(V) {
    V.DEFAULT = "default",
    V.CIRCLE = "circle"
}
)(ICON_VARIANTS || (ICON_VARIANTS = {}));
var styles$13 = {
    container: "icon-module_container__o0wjp",
    icon: "icon-module_icon__K4BP-",
    circle: "icon-module_circle__E4fJf"
};
const Icon = ({name: V, src: X, rotate: J=0, prefix: ne="icon", color: ue="currentColor", circleColor: ce, className: me="", size: ge=ICON_SIZES.MD, variant: Te=ICON_VARIANTS.DEFAULT}) => {
    const _e = `#${ne}-${V}`
      , Se = Te === ICON_VARIANTS.CIRCLE ? "12px" : ge;
    return jsxRuntimeExports.jsx("div", {
        style: {
            ...J && {
                transform: `rotate(${J}deg)`
            },
            ...ue && {
                color: ue
            },
            ...Te === ICON_VARIANTS.CIRCLE ? {
                borderColor: ce ?? ue
            } : {
                height: Se,
                width: Se
            }
        },
        className: classNames(styles$13.container, Te === ICON_VARIANTS.CIRCLE && styles$13.circle, me),
        children: V ? jsxRuntimeExports.jsx("svg", {
            name: V,
            "aria-hidden": "true",
            width: Se,
            height: Se,
            className: styles$13.icon,
            children: jsxRuntimeExports.jsx("use", {
                href: _e,
                fill: ue
            })
        }) : jsxRuntimeExports.jsx("img", {
            width: Se,
            height: Se,
            className: styles$13.icon,
            src: X
        })
    })
}
  , ThemeContext = reactExports.createContext({
    widths: {},
    breakpoints: {},
    colors: {},
    font: {},
    fontSizes: {},
    spacings: {}
})
  , ThemeProvider = ({children: V, themeOverrides: X}) => {
    const J = {
        widths: {
            ...theme.widths,
            ...X == null ? void 0 : X.widths
        },
        breakpoints: {
            ...theme.breakpoints,
            ...X == null ? void 0 : X.breakpoints
        },
        colors: {
            ...theme.colors,
            ...X == null ? void 0 : X.colors
        },
        font: {
            ...theme.font,
            ...X == null ? void 0 : X.font
        },
        fontSizes: {
            ...theme.fontSizes,
            ...X == null ? void 0 : X.fontSizes
        },
        spacings: {
            ...theme.spacings,
            ...X == null ? void 0 : X.spacings
        }
    };
    return jsxRuntimeExports.jsx(ThemeContext.Provider, {
        value: {
            ...J
        },
        children: V
    })
}
;
var BUTTON_TYPES$1;
(function(V) {
    V.SUBMIT = "submit",
    V.BUTTON = "button",
    V.RESET = "reset"
}
)(BUTTON_TYPES$1 || (BUTTON_TYPES$1 = {}));
var styles$12 = {
    button: "icon-button-module_button__KJTSK",
    disabled: "icon-button-module_disabled__GQjNs",
    transparent: "icon-button-module_transparent__5jZcW",
    themed: "icon-button-module_themed__NhENV",
    secondary: "icon-button-module_secondary__eNmEU",
    variantTransparent: "icon-button-module_variantTransparent__0nNDB",
    sizeMd: "icon-button-module_sizeMd__mdyX6",
    sizeSm: "icon-button-module_sizeSm__B-FkL",
    sizeXs: "icon-button-module_sizeXs__f7R2a",
    sizeXxs: "icon-button-module_sizeXxs__RE3pB",
    sizeXxxs: "icon-button-module_sizeXxxs__By9hH",
    content: "icon-button-module_content__DPjht"
}, ICON_BUTTON_SIZE;
(function(V) {
    V.XXXS = "xxxs",
    V.XXS = "xxs",
    V.XS = "xs",
    V.SM = "sm",
    V.MD = "md"
}
)(ICON_BUTTON_SIZE || (ICON_BUTTON_SIZE = {}));
var ICON_BUTTON_VARIANT;
(function(V) {
    V.PRIMARY = "primary",
    V.SECONDARY = "secondary",
    V.THEMED = "themed",
    V.TRANSPARENT = "transparent"
}
)(ICON_BUTTON_VARIANT || (ICON_BUTTON_VARIANT = {}));
const buttonSizesToIconSizesMap = {
    [ICON_BUTTON_SIZE.MD]: ICON_SIZES.MD,
    [ICON_BUTTON_SIZE.SM]: ICON_SIZES.MD,
    [ICON_BUTTON_SIZE.XS]: ICON_SIZES.SM,
    [ICON_BUTTON_SIZE.XXS]: ICON_SIZES.SM,
    [ICON_BUTTON_SIZE.XXXS]: ICON_SIZES.SM
}
  , IconButton = ({icon: V, label: X, variant: J, color: ne, hoverColor: ue, transparent: ce, isDisabled: me, size: ge=ICON_BUTTON_SIZE.MD, className: Te, stopPropagation: _e, testId: Se, onClick: Ie}) => {
    const ye = reactExports.useContext(ThemeContext)
      , $e = reactExports.useId()
      , Ne = Ie ? "button" : "div"
      , ve = xe => {
        _e && xe.stopPropagation(),
        Ie && Ie()
    }
      , ke = J === ICON_BUTTON_VARIANT.THEMED ? ye.colors.warningVibrant : J === ICON_BUTTON_VARIANT.SECONDARY ? ye.colors.gray600 : ye.colors.primary;
    return jsxRuntimeExports.jsxs(Ne, {
        type: BUTTON_TYPES$1.BUTTON,
        disabled: me,
        "aria-labelledby": $e,
        style: {
            "--color": ne ?? ke,
            "--hover-color": ue ?? ne ?? ke
        },
        className: classNames(styles$12.button, ce && styles$12.transparent, me && styles$12.disabled, ge === ICON_BUTTON_SIZE.MD && styles$12.sizeMd, ge === ICON_BUTTON_SIZE.SM && styles$12.sizeSm, ge === ICON_BUTTON_SIZE.XS && styles$12.sizeXs, ge === ICON_BUTTON_SIZE.XXS && styles$12.sizeXxs, ge === ICON_BUTTON_SIZE.XXXS && styles$12.sizeXxxs, J === ICON_BUTTON_VARIANT.SECONDARY && styles$12.secondary, J === ICON_BUTTON_VARIANT.THEMED && styles$12.themed, J === ICON_BUTTON_VARIANT.TRANSPARENT && styles$12.variantTransparent, Te),
        "data-testid": Se,
        onClick: ve,
        children: [X && jsxRuntimeExports.jsx("span", {
            id: $e,
            hidden: !0,
            children: X
        }), jsxRuntimeExports.jsx("div", {
            className: styles$12.content,
            children: jsxRuntimeExports.jsx(Icon, {
                name: V,
                size: buttonSizesToIconSizesMap[ge]
            })
        })]
    })
}
;
var styles$11 = {
    container: "dialog-content-module_container__BkkQ3",
    modalVariant: "dialog-content-module_modalVariant__sfVSx",
    overlayVariant: "dialog-content-module_overlayVariant__4Fy7y",
    close: "dialog-content-module_close__gobWm",
    header: "dialog-content-module_header__a60Rl",
    content: "dialog-content-module_content__pP1Nj",
    body: "dialog-content-module_body__EJHnw",
    footer: "dialog-content-module_footer__dobT3"
}, DIALOG_VARIANT;
(function(V) {
    V.MODAL = "modal",
    V.OVERLAY = "overlay"
}
)(DIALOG_VARIANT || (DIALOG_VARIANT = {}));
const DialogContent = ({id: V, children: X, header: J, footer: ne, variant: ue=DIALOG_VARIANT.MODAL, onClose: ce, onOpen: me}) => {
    const {activeId: ge, portalDestination: Te, setIsOpen: _e} = reactExports.useContext(DialogContext)
      , Se = reactExports.useRef(!1)
      , Ie = $e => {
        _e(!1, DIALOG_STATE.SUBMITTED),
        $e.preventDefault()
    }
      , ye = () => {
        _e(!1, DIALOG_STATE.CLOSED)
    }
    ;
    return reactExports.useEffect( () => {
        ge === V ? Se.current || (Se.current = !0,
        me && me()) : Se.current && (Se.current = !1,
        ce && ce())
    }
    , [ge]),
    V === ge ? jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
        children: (Te == null ? void 0 : Te.current) && reactDomExports.createPortal(jsxRuntimeExports.jsxs("form", {
            method: "dialog",
            onSubmit: Ie,
            className: classNames(styles$11.container, ue === DIALOG_VARIANT.MODAL && styles$11.modalVariant, ue === DIALOG_VARIANT.OVERLAY && styles$11.overlayVariant),
            children: [jsxRuntimeExports.jsxs("header", {
                className: styles$11.header,
                children: [jsxRuntimeExports.jsx("span", {
                    children: J
                }), jsxRuntimeExports.jsx(IconButton, {
                    className: styles$11.close,
                    onClick: ye,
                    icon: ICON_NAMES.CLOSE,
                    transparent: !0
                })]
            }), jsxRuntimeExports.jsx("div", {
                className: classNames(styles$11.body, styles$11.content),
                children: X
            }), ne && jsxRuntimeExports.jsx("div", {
                className: classNames(styles$11.content, styles$11.footer),
                children: ne
            })]
        }), Te.current)
    }) : null
}
;
var styles$10 = {
    container: "off-canvas-module_container__1or9g",
    isOpen: "off-canvas-module_isOpen__gUSCW",
    isFluidWidth: "off-canvas-module_isFluidWidth__aEbMm"
};
const OffCanvas = reactExports.forwardRef( ({children: V, offCanvasId: X, isOpen: J, fluidWidth: ne}, ue) => {
    const [ce,me] = reactExports.useState(0);
    return reactExports.useEffect( () => {
        J && me(document.documentElement.scrollTop)
    }
    , [J]),
    jsxRuntimeExports.jsx("div", {
        id: X,
        ref: ue,
        style: {
            top: ce
        },
        className: classNames(styles$10.container, J && styles$10.isOpen, ne && styles$10.isFluidWidth),
        children: V
    })
}
);
OffCanvas.displayName = "OffCanvas";
var styles$$ = {
    content: "off-canvas-module_content__jvL8x"
};
const OffCanvasContext = reactExports.createContext({
    setIsOpen: noop$7,
    forceClose: noop$7
})
  , OffCanvasProvider = ({children: V, mountId: X="off-canvas-mount"}) => {
    const J = reactExports.useRef(null)
      , [ne,ue] = reactExports.useState(!1)
      , [ce,me] = reactExports.useState(!1)
      , [ge,Te] = reactExports.useState()
      , _e = reactExports.useRef(null);
    reactExports.useEffect( () => {
        var ke, xe;
        const ye = we => {
            var Fe;
            (Fe = J == null ? void 0 : J.current) != null && Fe.contains(we.target) || ue(!1)
        }
          , $e = we => {
            we.stopPropagation()
        }
          , Ne = we => {
            we.code === "Escape" && ue(!1)
        }
          , ve = () => {
            var we, Fe;
            document.removeEventListener("keydown", Ne),
            document.removeEventListener("mousedown", ye),
            (Fe = (we = J.current) == null ? void 0 : we.firstChild) == null || Fe.removeEventListener("mousedown", $e)
        }
        ;
        return ne ? (document.body.classList.add("no-scroll-scrim"),
        document.addEventListener("keydown", Ne),
        document.addEventListener("mousedown", ye),
        (xe = (ke = J.current) == null ? void 0 : ke.firstChild) == null || xe.addEventListener("mousedown", $e)) : (Te(void 0),
        document.body.classList.remove("no-scroll-scrim"),
        ve()),
        () => {
            ve(),
            document.body.classList.remove("no-scroll-scrim")
        }
    }
    , [ne]);
    const Se = ({newState: ye, id: $e, isFluidWidth: Ne}) => {
        (ge === $e || !ge) && (ue(ye),
        me(!!(ye && Ne)))
    }
      , Ie = () => {
        ue(!1)
    }
    ;
    return jsxRuntimeExports.jsxs(OffCanvasContext.Provider, {
        value: {
            setIsOpen: Se,
            portalDestination: _e,
            dialogRef: J,
            setActiveId: Te,
            activeId: ge,
            forceClose: Ie
        },
        children: [jsxRuntimeExports.jsx(OffCanvas, {
            ref: J,
            offCanvasId: X,
            isOpen: ne,
            fluidWidth: ce,
            children: jsxRuntimeExports.jsx("div", {
                ref: _e,
                className: styles$$.content
            })
        }), V]
    })
}
;
var styles$_ = {
    content: "off-canvas-content-module_content__eYbo1",
    header: "off-canvas-content-module_header__BXZKc",
    body: "off-canvas-content-module_body__dG9m6",
    footer: "off-canvas-content-module_footer__t3eyi"
};
const OffCanvasContent = ({id: V, children: X, header: J, footer: ne}) => {
    const {activeId: ue, portalDestination: ce, setIsOpen: me} = reactExports.useContext(OffCanvasContext)
      , {colors: ge} = reactExports.useContext(ThemeContext)
      , Te = () => {
        me({
            newState: !1,
            id: V
        })
    }
    ;
    return V === ue ? jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
        children: (ce == null ? void 0 : ce.current) && reactDomExports.createPortal(jsxRuntimeExports.jsxs("div", {
            className: styles$_.content,
            children: [J && jsxRuntimeExports.jsxs("div", {
                className: styles$_.header,
                children: [J, jsxRuntimeExports.jsx(IconButton, {
                    icon: ICON_NAMES.CLOSE,
                    size: ICON_BUTTON_SIZE.XS,
                    transparent: !0,
                    hoverColor: ge.gray400,
                    onClick: Te
                })]
            }), jsxRuntimeExports.jsx("div", {
                className: styles$_.body,
                children: X
            }), ne && jsxRuntimeExports.jsx("div", {
                className: styles$_.footer,
                children: ne
            })]
        }), ce.current)
    }) : null
}
  , ToastContext = reactExports.createContext({
    addToast: () => {}
    ,
    removeToast: () => {}
    ,
    removeAllToasts: () => {}
    ,
    toastList: [],
    toastsCount: 0
})
  , ToastProvider = ({children: V}) => {
    const X = reactExports.useRef([])
      , [J,ne] = reactExports.useState(0)
      , ue = ge => {
        const _e = {
            id: Date.now() + Math.ceil(Math.random() * 1e3),
            messageText: ge
        };
        X.current = [...X.current, _e],
        ne(X.current.length)
    }
      , ce = ge => {
        X.current = X.current.filter(Te => Te.id !== ge),
        ne(X.current.length)
    }
      , me = () => {
        X.current = [],
        ne(X.current.length)
    }
    ;
    return jsxRuntimeExports.jsx(ToastContext.Provider, {
        value: {
            addToast: ue,
            removeToast: ce,
            removeAllToasts: me,
            toastList: X.current,
            toastsCount: J
        },
        children: V
    })
}
  , useDebounce = (V, X=1e3) => {
    const J = reactExports.useRef(null);
    return reactExports.useEffect( () => () => {
        J.current && clearTimeout(J.current)
    }
    , []),
    [ (...ce) => {
        const me = setTimeout( () => {
            V(...ce)
        }
        , X);
        J.current && clearTimeout(J.current),
        J.current = me
    }
    , () => {
        J.current && clearTimeout(J.current)
    }
    ]
}
;
var styles$Z = {
    toast: "Toast-module_toast__B3G90",
    close: "Toast-module_close__Mb1kK"
};
const AUTO_DISMISS_TIMEOUT_MS = 3e3
  , Toast = ({messageText: V, id: X}) => {
    const {removeToast: J} = reactExports.useContext(ToastContext)
      , ne = reactExports.useRef(null)
      , ue = reactExports.useRef(void 0);
    reactExports.useEffect( () => {
        ue.current = setTimeout( () => {
            J(X),
            ue.current && clearTimeout(ue.current)
        }
        , AUTO_DISMISS_TIMEOUT_MS)
    }
    , [V, X, J]);
    const ce = () => {
        J(X)
    }
      , [me] = useDebounce( () => {
        ue.current && (clearTimeout(ue.current),
        ue.current = void 0)
    }
    , 100);
    return jsxRuntimeExports.jsxs("div", {
        className: styles$Z.toast,
        ref: ne,
        onMouseEnter: me,
        onFocus: me,
        children: [jsxRuntimeExports.jsx("span", {
            className: styles$Z.messageText,
            children: V
        }), jsxRuntimeExports.jsx("button", {
            type: BUTTON_TYPES$1.BUTTON,
            onClick: ce,
            className: styles$Z.close,
            children: jsxRuntimeExports.jsx(Icon, {
                name: ICON_NAMES.CLOSE
            })
        })]
    })
}
;
var styles$Y = {
    toastList: "ToastList-module_toastList__U2umx",
    toastOverflowHint: "ToastList-module_toastOverflowHint__ZxmcO"
};
const MAX_VISIBLE_TOAST_COUNT = 3
  , ToastList = ({maxVisibleToasts: V=MAX_VISIBLE_TOAST_COUNT}) => {
    const {toastList: X, toastsCount: J} = reactExports.useContext(ToastContext);
    return jsxRuntimeExports.jsxs("div", {
        className: styles$Y.toastList,
        children: [X.map( (ne, ue) => ue < V ? jsxRuntimeExports.jsx(Toast, {
            messageText: ne.messageText,
            id: ne.id
        }, ne.id) : null), J > V ? jsxRuntimeExports.jsx("div", {
            className: styles$Y.toastOverflowHint,
            children: jsxRuntimeExports.jsx(Icon, {
                name: ICON_NAMES.CHEVRON_DOWN
            })
        }) : null]
    })
}
;
var styles$X = {
    breadcrumb: "breadcrumb-module_breadcrumb__7qRtH",
    lastCrumb: "breadcrumb-module_lastCrumb__JjCfG"
};
const Breadcrumb = ({crumbs: V}) => jsxRuntimeExports.jsx("div", {
    className: styles$X.breadcrumb,
    children: V.map( (X, J) => jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [J !== 0 && jsxRuntimeExports.jsx("span", {
            children: " / "
        }), jsxRuntimeExports.jsx("span", {
            className: classNames(J + 1 === V.length && styles$X.lastCrumb),
            children: X
        })]
    }, `${X}-${J}`))
});
var styles$W = {
    chip: "chip-module_chip__Eh50w",
    primary: "chip-module_primary__UxgYt",
    secondary: "chip-module_secondary__TBDVB",
    danger: "chip-module_danger__nNqw8",
    positive: "chip-module_positive__sLC4B",
    warning: "chip-module_warning__58N0i",
    useOverflowControl: "chip-module_useOverflowControl__INVfz"
}, CHIP_VARIANT;
(function(V) {
    V.PRIMARY = "primary",
    V.SECONDARY = "secondary",
    V.POSITIVE = "positive",
    V.WARNING = "warning",
    V.DANGER = "danger"
}
)(CHIP_VARIANT || (CHIP_VARIANT = {}));
const Chip = ({children: V, variant: X=CHIP_VARIANT.PRIMARY, useOverflowControl: J, title: ne, className: ue, onClick: ce}) => jsxRuntimeExports.jsx("div", {
    title: ne,
    className: classNames(styles$W.chip, X === CHIP_VARIANT.PRIMARY && styles$W.primary, X === CHIP_VARIANT.SECONDARY && styles$W.secondary, X === CHIP_VARIANT.POSITIVE && styles$W.positive, X === CHIP_VARIANT.WARNING && styles$W.warning, X === CHIP_VARIANT.DANGER && styles$W.danger, ue),
    onClick: ce,
    children: jsxRuntimeExports.jsx("div", {
        className: classNames(J && styles$W.useOverflowControl),
        children: V
    })
});
var styles$V = {
    list: "chip-list-module_list__t-xCA"
};
const ChipList = ({children: V}) => jsxRuntimeExports.jsx("div", {
    className: styles$V.list,
    children: V
});
var styles$U = {
    divider: "divider-module_divider__rGjYB",
    vertical: "divider-module_vertical__nOwFw",
    trimBottom: "divider-module_trimBottom__rTHzP",
    trimTop: "divider-module_trimTop__2PqC6"
};
const Divider = ({trimTop: V, trimBottom: X, trimY: J, vertical: ne, className: ue}) => jsxRuntimeExports.jsx("div", {
    className: classNames(styles$U.divider, (V || J) && styles$U.trimTop, (X || J) && styles$U.trimBottom, ne && styles$U.vertical, ue)
})
  , useMediaQuery = V => {
    const X = window.matchMedia(V)
      , [J,ne] = reactExports.useState(X.matches);
    return reactExports.useEffect( () => {
        const ue = ce => {
            ne(ce.matches)
        }
        ;
        return X.addEventListener("change", ue),
        () => {
            X.addEventListener("change", ue)
        }
    }
    , []),
    J
}
  , CurrentBreakpointContext = reactExports.createContext(BREAKPOINT_NAMES.XXS)
  , CurrentBreakpointProvider = ({children: V}) => {
    var ce;
    const {breakpoints: X} = reactExports.useContext(ThemeContext)
      , J = (me, ge) => `(min-width: ${me}) and (max-width: ${ge - 1}px)`
      , ue = ((ce = [{
        test: useMediaQuery(J(X.xs, parseInt(X.sm, 10))),
        breakpoint: BREAKPOINT_NAMES.XS
    }, {
        test: useMediaQuery(J(X.sm, parseInt(X.md, 10))),
        breakpoint: BREAKPOINT_NAMES.SM
    }, {
        test: useMediaQuery(J(X.md, parseInt(X.lg, 10))),
        breakpoint: BREAKPOINT_NAMES.MD
    }, {
        test: useMediaQuery(J(X.lg, parseInt(X.xl, 10))),
        breakpoint: BREAKPOINT_NAMES.LG
    }, {
        test: useMediaQuery(J(X.xl, parseInt(X.xxl, 10))),
        breakpoint: BREAKPOINT_NAMES.XL
    }, {
        test: useMediaQuery(`(min-width: ${X.xxl})`),
        breakpoint: BREAKPOINT_NAMES.XXL
    }].find( ({test: me}) => me)) == null ? void 0 : ce.breakpoint) ?? BREAKPOINT_NAMES.XXS;
    return jsxRuntimeExports.jsx(CurrentBreakpointContext.Provider, {
        value: ue,
        children: V
    })
}
;
var styles$T = {
    container: "button-group-module_container__918-h",
    justifyCenter: "button-group-module_justifyCenter__HjlVJ",
    stacked: "button-group-module_stacked__aCURd",
    fillWidth: "button-group-module_fillWidth__Z-THE"
};
const ButtonGroup = ({children: V, fillWidth: X, gap: J, stacked: ne, justifyCenter: ue, className: ce}) => {
    const me = reactExports.useContext(CurrentBreakpointContext)
      , {breakpoints: ge} = reactExports.useContext(ThemeContext)
      , Te = getMobileFirstOption(ne, me, ge);
    return jsxRuntimeExports.jsx("div", {
        className: classNames(styles$T.container, (X || Te) && styles$T.fillWidth, Te && styles$T.stacked, ue && styles$T.justifyCenter, ce),
        ...J && {
            style: {
                gap: J
            }
        },
        children: V
    })
}
;
var styles$S = {
    container: "flip-tile-module_container__fBHoh",
    takeOverContainer: "flip-tile-module_takeOverContainer__8QpRe",
    customBg: "flip-tile-module_customBg__4mRwN",
    open: "flip-tile-module_open__-YgjS",
    close: "flip-tile-module_close__WrYyH",
    heading: "flip-tile-module_heading__2sOtX",
    title: "flip-tile-module_title__rTAK4",
    content: "flip-tile-module_content__Sey-f",
    controls: "flip-tile-module_controls__l-cQ3",
    details: "flip-tile-module_details__eA7yC"
};
const FlipTile = ({children: V, title: X, details: J, bgImageUrl: ne, actions: ue, testId: ce, flipIcon: me, flipTakeOver: ge, className: Te, dir: _e, onFlip: Se}) => {
    const [Ie,ye] = reactExports.useState(!1)
      , {spacings: $e} = reactExports.useContext(ThemeContext)
      , Ne = () => {
        ye(!Ie),
        Se && Se(!Ie)
    }
      , ve = jsxRuntimeExports.jsx(IconButton, {
        onClick: Ne,
        icon: Ie ? ICON_NAMES.CLOSE : (me == null ? void 0 : me.iconName) ?? ICON_NAMES.INFO,
        className: styles$S.close,
        transparent: (me == null ? void 0 : me.isTransparent) ?? !0,
        variant: me == null ? void 0 : me.variant,
        size: (me == null ? void 0 : me.size) ?? ICON_BUTTON_SIZE.SM
    })
      , ke = jsxRuntimeExports.jsx("div", {
        className: classNames(styles$S.details, ge && styles$S.takeOver, Ie && styles$S.open),
        children: J
    });
    return jsxRuntimeExports.jsxs("div", {
        className: classNames(styles$S.container, ne && styles$S.customBg, Ie && styles$S.open, ge && styles$S.takeOverContainer, Te),
        "data-testid": ce,
        ...ne && (!Ie && ge || !ge) && {
            style: {
                "--bg-image": `url(${ne})`
            }
        },
        ..._e && {
            dir: _e
        },
        children: [jsxRuntimeExports.jsxs("header", {
            className: styles$S.heading,
            children: [(!ge || ge && !Ie) && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                children: [jsxRuntimeExports.jsx("span", {
                    className: styles$S.title,
                    children: X
                }), jsxRuntimeExports.jsxs(ButtonGroup, {
                    gap: $e.xxxs,
                    children: [ue, J && ve]
                })]
            }), ge && Ie && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                children: [jsxRuntimeExports.jsx("span", {}), ve]
            })]
        }), J && ge && ke, jsxRuntimeExports.jsxs("div", {
            className: styles$S.content,
            children: [jsxRuntimeExports.jsx("div", {
                className: classNames(styles$S.controls, Ie && styles$S.open),
                children: V
            }), J && !ge && ke]
        })]
    })
}
;
var styles$R = {
    caption: "caption-module_caption__zlBd0",
    sizeMd: "caption-module_sizeMd__ks7EZ",
    sizeLg: "caption-module_sizeLg__VOs5Z"
}, CAPTION_SIZE;
(function(V) {
    V.MD = "md",
    V.LG = "lg"
}
)(CAPTION_SIZE || (CAPTION_SIZE = {}));
const Caption = ({size: V=CAPTION_SIZE.MD, children: X, className: J}) => jsxRuntimeExports.jsx("small", {
    className: classNames(styles$R.caption, V === CAPTION_SIZE.MD && styles$R.sizeMd, V === CAPTION_SIZE.LG && styles$R.sizeLg, J),
    children: X
});
var styles$Q = {
    header: "heading-module_header__bp2rs",
    hero: "heading-module_hero__JDUlz",
    pageTitle: "heading-module_pageTitle__AUI3-",
    heading: "heading-module_heading__gao0o",
    secondarySubheading: "heading-module_secondarySubheading__IuM4P",
    subheading: "heading-module_subheading__PUXzu",
    label: "heading-module_label__lj-in",
    trimY: "heading-module_trimY__7LXn1",
    content: "heading-module_content__6Yukp"
}, HEADING_VARIANT;
(function(V) {
    V.PAGE_TITLE = "pageTitle",
    V.HERO = "hero",
    V.HEADING = "heading",
    V.SUBHEADING = "subheading",
    V.SECONDARY_SUBHEADING = "secondarySubheading",
    V.FIELD_LABEL = "label"
}
)(HEADING_VARIANT || (HEADING_VARIANT = {}));
var HEADING_ELEMENT;
(function(V) {
    V.H1 = "h1",
    V.H2 = "h2",
    V.H3 = "h3",
    V.LABEL = "label"
}
)(HEADING_ELEMENT || (HEADING_ELEMENT = {}));
const VARIANT_ELEM_MAP = new Map([[HEADING_VARIANT.PAGE_TITLE, HEADING_ELEMENT.H1], [HEADING_VARIANT.HEADING, HEADING_ELEMENT.H2], [HEADING_VARIANT.SUBHEADING, HEADING_ELEMENT.H3], [HEADING_VARIANT.SECONDARY_SUBHEADING, HEADING_ELEMENT.H3], [HEADING_VARIANT.FIELD_LABEL, HEADING_ELEMENT.H2], [HEADING_VARIANT.HERO, HEADING_ELEMENT.H1]])
  , Heading = ({children: V, variant: X=HEADING_VARIANT.HEADING, trimY: J, element: ne, className: ue}) => {
    const ce = ne ?? VARIANT_ELEM_MAP.get(X) ?? HEADING_ELEMENT.H2;
    return jsxRuntimeExports.jsx(ce, {
        className: classNames(styles$Q.header, styles$Q[X], J && styles$Q.trimY, ue),
        children: jsxRuntimeExports.jsx("div", {
            className: styles$Q.content,
            children: V
        })
    })
}
;
var styles$P = {
    tile: "experience-tile-module_tile__-cpEm",
    flipTile: "experience-tile-module_flipTile__KrDil",
    headingContainer: "experience-tile-module_headingContainer__RziCT",
    heading: "experience-tile-module_heading__CgiiS"
};
const ExperienceTile = ({heading: V, subheading: X, tag: J, onFlip: ne, bgImage: ue, backSide: ce, actions: me}) => {
    const ge = Te => {
        ne && ne(Te)
    }
    ;
    return jsxRuntimeExports.jsx("section", {
        className: styles$P.tile,
        children: jsxRuntimeExports.jsxs(FlipTile, {
            className: styles$P.flipTile,
            flipIcon: {
                iconName: ICON_NAMES.VERTICAL_DOTS,
                variant: ICON_BUTTON_VARIANT.SECONDARY,
                size: ICON_BUTTON_SIZE.SM,
                isTransparent: !1
            },
            details: ce,
            onFlip: ge,
            bgImageUrl: ue,
            title: J,
            actions: me,
            flipTakeOver: !0,
            children: [jsxRuntimeExports.jsx("div", {
                className: styles$P.headingContainer,
                children: jsxRuntimeExports.jsx(Heading, {
                    className: styles$P.heading,
                    children: V
                })
            }), jsxRuntimeExports.jsx("footer", {
                children: jsxRuntimeExports.jsx(Caption, {
                    size: CAPTION_SIZE.LG,
                    children: X
                })
            })]
        })
    })
}
;
var styles$O = {
    section: "section-module_section__E6qYu",
    spacingSm: "section-module_spacingSm__OHrry",
    spacingMd: "section-module_spacingMd__-f1KX",
    spacingLg: "section-module_spacingLg__hO1TL",
    split: "section-module_split__SFfS4",
    subsection: "section-module_subsection__Af0pN",
    trimBottom: "section-module_trimBottom__9B5Ca",
    trimTop: "section-module_trimTop__08Hb6",
    trimY: "section-module_trimY__iLA-7",
    trimStart: "section-module_trimStart__XNqW5",
    trimEnd: "section-module_trimEnd__kiWLM"
}, SECTION_PADDING_SIZE;
(function(V) {
    V.SM = "Sm",
    V.MD = "Md",
    V.LG = "Lg"
}
)(SECTION_PADDING_SIZE || (SECTION_PADDING_SIZE = {}));
const Section = reactExports.forwardRef( ({children: V, className: X, split: J, trimY: ne, trimTop: ue, trimBottom: ce, trimX: me, trimStart: ge, trimEnd: Te, subsection: _e, paddingSize: Se=SECTION_PADDING_SIZE.MD}, Ie) => jsxRuntimeExports.jsx("section", {
    ref: Ie,
    className: classNames(styles$O.section, J && styles$O.split, ne && styles$O.trimY, ce && styles$O.trimBottom, ue && styles$O.trimTop, _e && styles$O.subsection, (ge || me) && styles$O.trimStart, (Te || me) && styles$O.trimEnd, styles$O[`spacing${Se}`], X),
    children: V
}));
Section.displayName = "Section";
var styles$N = {
    space: "space-module_space__sFlqH",
    noGap: "space-module_noGap__cPhNb",
    xxxs: "space-module_xxxs__ei5-F",
    xxs: "space-module_xxs__aKLCC",
    xs: "space-module_xs__S5AEx",
    sm: "space-module_sm__sk27e",
    md: "space-module_md__Qdbo0",
    lg: "space-module_lg__03QHV",
    alignCenter: "space-module_alignCenter__UH5Lg",
    alignStart: "space-module_alignStart__Nm6hM",
    alignEnd: "space-module_alignEnd__nhqSg",
    alignBaseline: "space-module_alignBaseline__d-Ke8",
    wrap: "space-module_wrap__-RpEt",
    column: "space-module_column__3f-xE"
}, SPACE_GAP_SIZE;
(function(V) {
    V.NONE = "none",
    V.XXXS = "xxxs",
    V.XXS = "xxs",
    V.XS = "xs",
    V.SM = "sm",
    V.MD = "md",
    V.LG = "lg"
}
)(SPACE_GAP_SIZE || (SPACE_GAP_SIZE = {}));
var SPACE_ALIGN;
(function(V) {
    V.CENTER = "center",
    V.START = "start",
    V.END = "end",
    V.BASELINE = "baseline"
}
)(SPACE_ALIGN || (SPACE_ALIGN = {}));
const Space = ({children: V, gapSize: X=SPACE_GAP_SIZE.MD, align: J=SPACE_ALIGN.CENTER, wrap: ne, column: ue, className: ce}) => jsxRuntimeExports.jsx("div", {
    className: classNames(styles$N.space, X === SPACE_GAP_SIZE.NONE && styles$N.noGap, X === SPACE_GAP_SIZE.XXXS && styles$N.xxxs, X === SPACE_GAP_SIZE.XXS && styles$N.xxs, X === SPACE_GAP_SIZE.XS && styles$N.xs, X === SPACE_GAP_SIZE.SM && styles$N.sm, X === SPACE_GAP_SIZE.MD && styles$N.md, X === SPACE_GAP_SIZE.LG && styles$N.lg, J === SPACE_ALIGN.CENTER && styles$N.alignCenter, J === SPACE_ALIGN.START && styles$N.alignStart, J === SPACE_ALIGN.END && styles$N.alignEnd, J === SPACE_ALIGN.BASELINE && styles$N.alignBaseline, ne && styles$N.wrap, ue && styles$N.column, ce),
    children: V
})
  , useOnWindowResize = V => {
    const [X,J] = reactExports.useState([0, 0])
      , [ne] = useDebounce( () => {
        J([document.body.clientWidth, document.body.clientHeight])
    }
    , V);
    return reactExports.useLayoutEffect( () => (window.addEventListener("resize", ne),
    ne(),
    () => window.removeEventListener("resize", ne)), []),
    X
}
;
var styles$M = {
    trigger: "tooltip-module_trigger__-jcdM",
    tip: "tooltip-module_tip__24MAk",
    active: "tooltip-module_active__aS7aS",
    arrow: "tooltip-module_arrow__ZyIza",
    top: "tooltip-module_top__im-pT",
    topLeft: "tooltip-module_topLeft__2IEbg",
    topRight: "tooltip-module_topRight__L4zQW",
    right: "tooltip-module_right__tcR9Q",
    rightBottom: "tooltip-module_rightBottom__F34ZE",
    rightTop: "tooltip-module_rightTop__AJXb1",
    left: "tooltip-module_left__vI9Mc",
    leftTop: "tooltip-module_leftTop__E5Zxs",
    leftBottom: "tooltip-module_leftBottom__448Cy",
    bottom: "tooltip-module_bottom__WcYQw",
    bottomLeft: "tooltip-module_bottomLeft__d6gP9",
    bottomRight: "tooltip-module_bottomRight__D98Sg"
};
const Tooltip = ({tip: V, children: X, placement: J=PLACEMENT.TOP}) => {
    const ue = reactExports.useRef(document.body)
      , ce = reactExports.useRef(null)
      , me = reactExports.useRef(null)
      , ge = reactExports.useRef(new Set)
      , Te = reactExports.useRef(J)
      , _e = document.documentElement.dir === "rtl"
      , [Se,Ie] = reactExports.useState(!1)
      , [ye,$e] = useOnWindowResize(500)
      , Ne = xe => {
        if (ce.current && me.current) {
            const {x: we, y: Fe} = computeRelativeCoordinates({
                target: ce.current,
                elementToPlace: me.current,
                offset: 14,
                isRtl: _e,
                placement: xe
            });
            me.current.style.left = `${we}px`,
            me.current.style.top = `${Fe}px`
        }
    }
      , ve = () => {
        Ie(!1)
    }
      , ke = () => {
        if (ce.current && me.current) {
            const xe = document.body.offsetWidth
              , we = document.body.offsetHeight
              , Fe = enumToArray(PLACEMENT).length;
            for (; ge.current.size <= Fe; ) {
                Ne(Te.current),
                Ne(Te.current),
                ge.current.add(Te.current);
                const [je,Xe] = getIsOutOfViewport(me.current, xe, we);
                if (je) {
                    const ze = checkAndAdjustPlacement({
                        currentAttempts: ge.current,
                        viewportDetails: Xe
                    });
                    if (!ze)
                        break;
                    Te.current = ze
                } else
                    break
            }
            ge.current = new Set,
            Ie(!0)
        }
    }
    ;
    return reactExports.useEffect( () => {
        Te.current = J,
        ge.current = new Set
    }
    , [$e, ye]),
    jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsx("div", {
            ref: ce,
            className: styles$M.trigger,
            onMouseEnter: ke,
            onMouseLeave: ve,
            children: X
        }), reactDomExports.createPortal(jsxRuntimeExports.jsxs("div", {
            ref: me,
            className: classNames(styles$M.tip, Se && styles$M.active, styles$M[Te.current]),
            children: [V, jsxRuntimeExports.jsx("div", {
                className: styles$M.arrow,
                children: jsxRuntimeExports.jsx(Icon, {
                    name: ICON_NAMES.INTERNAL_USE_TOOLTIP_ARROW,
                    size: ICON_SIZES.FILL
                })
            })]
        }), ue.current)]
    })
}
;
var styles$L = {
    maxLength: "field-module_maxLength__tVuxp",
    container: "field-module_container__RUgkT",
    icon: "field-module_icon__JqAuB"
};
const Field = ({label: V, children: X, tip: J, icon: ne, validation: ue, className: ce}) => jsxRuntimeExports.jsxs(Section, {
    subsection: !0,
    className: classNames(styles$L.container, ce),
    children: [jsxRuntimeExports.jsxs(Section, {
        subsection: !0,
        split: !0,
        trimY: !0,
        children: [jsxRuntimeExports.jsxs(Heading, {
            variant: HEADING_VARIANT.FIELD_LABEL,
            children: [ne && jsxRuntimeExports.jsx(Icon, {
                name: ne
            }), V]
        }), J && jsxRuntimeExports.jsxs(Space, {
            gapSize: SPACE_GAP_SIZE.XS,
            children: [ue && ue.maxLength ? jsxRuntimeExports.jsxs("span", {
                className: styles$L.maxLength,
                children: [jsxRuntimeExports.jsx("span", {
                    children: ue.currentLength ?? 0
                }), "/", ue.maxLength]
            }) : null, jsxRuntimeExports.jsx(Tooltip, {
                tip: J,
                placement: PLACEMENT.LEFT,
                children: jsxRuntimeExports.jsx("span", {
                    className: styles$L.icon,
                    children: jsxRuntimeExports.jsx(Icon, {
                        name: ICON_NAMES.INFO,
                        size: ICON_SIZES.SM
                    })
                })
            })]
        })]
    }), jsxRuntimeExports.jsx(Divider, {}), X]
});
var styles$K = {
    grid: "grid-module_grid__gdGCw"
};
const Grid = ({items: V}) => jsxRuntimeExports.jsx("div", {
    className: styles$K.grid,
    children: V.map( (X, J) => jsxRuntimeExports.jsx("div", {
        className: styles$K.item,
        children: X
    }, J))
});
var styles$J = {
    wrapper: "image-card-module_wrapper__ViWgM",
    listView: "image-card-module_listView__6ZeHM",
    threeFour: "image-card-module_threeFour__TeULt",
    warningTheme: "image-card-module_warningTheme__znoBv",
    dangerTheme: "image-card-module_dangerTheme__OHGo0",
    basicTheme: "image-card-module_basicTheme__aIRLG",
    container: "image-card-module_container__4AqnU",
    compactListView: "image-card-module_compactListView__Nd7rB",
    listViewLarge: "image-card-module_listViewLarge__LxlLt",
    isOverlay: "image-card-module_isOverlay__0YaXd",
    image: "image-card-module_image__8X5LZ",
    tile: "image-card-module_tile__0pn1S",
    caption: "image-card-module_caption__UcNtE",
    icon: "image-card-module_icon__B6--6",
    skeleton: "image-card-module_skeleton__ZsVRP",
    skeletonImage: "image-card-module_skeletonImage__M7Jbs",
    skeletonIcon: "image-card-module_skeletonIcon__cKW1t",
    skeletonContent: "image-card-module_skeletonContent__2q9D4",
    skeletonLine: "image-card-module_skeletonLine__SFmdg",
    skeletonLinePartial: "image-card-module_skeletonLinePartial__9rs-1"
}, IMAGE_CARD_VARIANT;
(function(V) {
    V.TILE = "tile",
    V.LIST_ITEM = "listView",
    V.COMPACT_LIST_ITEM = "compactListView",
    V.THREE_FOUR = "threeFour",
    V.CUSTOM = "custom"
}
)(IMAGE_CARD_VARIANT || (IMAGE_CARD_VARIANT = {}));
var IMAGE_CARD_THEME_VARIANT;
(function(V) {
    V.DANGER = "danger",
    V.WARNING = "warning",
    V.BASIC = "basic"
}
)(IMAGE_CARD_THEME_VARIANT || (IMAGE_CARD_THEME_VARIANT = {}));
const ImageCard = ({caption: V, imageSrc: X, icon: J, iconColor: ne, overlay: ue, variant: ce=IMAGE_CARD_VARIANT.TILE, themeVariant: me=IMAGE_CARD_THEME_VARIANT.BASIC, className: ge, imageClassName: Te}) => jsxRuntimeExports.jsx("div", {
    className: classNames(styles$J.wrapper, ce === IMAGE_CARD_VARIANT.CUSTOM && styles$J.custom, ce === IMAGE_CARD_VARIANT.THREE_FOUR && styles$J.threeFour, ce === IMAGE_CARD_VARIANT.TILE && styles$J.tile, ce === IMAGE_CARD_VARIANT.COMPACT_LIST_ITEM && styles$J.compactListView, ce === IMAGE_CARD_VARIANT.LIST_ITEM && styles$J.listViewLarge, (ce === IMAGE_CARD_VARIANT.LIST_ITEM || ce === IMAGE_CARD_VARIANT.COMPACT_LIST_ITEM) && styles$J.listView, ue && styles$J.isOverlay, ge),
    children: jsxRuntimeExports.jsxs("div", {
        className: classNames(styles$J.container, me === IMAGE_CARD_THEME_VARIANT.BASIC && styles$J.basicTheme, me === IMAGE_CARD_THEME_VARIANT.WARNING && styles$J.warningTheme, me === IMAGE_CARD_THEME_VARIANT.DANGER && styles$J.dangerTheme),
        children: [jsxRuntimeExports.jsxs("div", {
            className: classNames(styles$J.image, ce === IMAGE_CARD_VARIANT.CUSTOM && Te),
            style: {
                "--bg-image": `url(${X})`
            },
            children: [J && jsxRuntimeExports.jsx(Icon, {
                name: J,
                color: ne,
                className: styles$J.icon
            }), ue && ce === IMAGE_CARD_VARIANT.TILE && jsxRuntimeExports.jsx("div", {
                className: classNames(styles$J.caption, me === IMAGE_CARD_THEME_VARIANT.BASIC && styles$J.basicTheme, me === IMAGE_CARD_THEME_VARIANT.WARNING && styles$J.warningTheme, me === IMAGE_CARD_THEME_VARIANT.DANGER && styles$J.dangerTheme),
                children: V
            })]
        }), (!ue || ce !== IMAGE_CARD_VARIANT.TILE) && jsxRuntimeExports.jsx("div", {
            className: classNames(styles$J.caption, me === IMAGE_CARD_THEME_VARIANT.BASIC && styles$J.basicTheme, me === IMAGE_CARD_THEME_VARIANT.WARNING && styles$J.warningTheme, me === IMAGE_CARD_THEME_VARIANT.DANGER && styles$J.dangerTheme),
            children: V
        })]
    })
})
  , ImageCardSkeleton = ({variant: V=IMAGE_CARD_VARIANT.TILE}) => jsxRuntimeExports.jsxs("div", {
    className: classNames(styles$J.skeleton, V === IMAGE_CARD_VARIANT.CUSTOM && styles$J.custom, V === IMAGE_CARD_VARIANT.THREE_FOUR && styles$J.threeFour, V === IMAGE_CARD_VARIANT.TILE && styles$J.tile, V === IMAGE_CARD_VARIANT.COMPACT_LIST_ITEM && styles$J.listViewCompact, V === IMAGE_CARD_VARIANT.LIST_ITEM && styles$J.listViewLarge, (V === IMAGE_CARD_VARIANT.LIST_ITEM || V === IMAGE_CARD_VARIANT.COMPACT_LIST_ITEM) && styles$J.listView),
    children: [jsxRuntimeExports.jsx("div", {
        className: styles$J.skeletonImage,
        children: jsxRuntimeExports.jsx("div", {
            className: styles$J.skeletonIcon
        })
    }), jsxRuntimeExports.jsxs("div", {
        className: styles$J.skeletonContent,
        children: [jsxRuntimeExports.jsx("div", {
            className: styles$J.skeletonLine
        }), jsxRuntimeExports.jsx("div", {
            className: styles$J.skeletonLinePartial
        })]
    })]
});
var styles$I = {
    label: "label-module_label__HKoOD",
    primary: "label-module_primary__oQOTx",
    disabled: "label-module_disabled__bRLp2",
    secondary: "label-module_secondary__JaPlT",
    tertiary: "label-module_tertiary__iSN40",
    warning: "label-module_warning__9bL06",
    positive: "label-module_positive__VN0oi"
}, LABEL_THEME;
(function(V) {
    V.PRIMARY = "primary",
    V.SECONDARY = "secondary",
    V.TERTIARY = "tertiary",
    V.WARNING = "warning",
    V.POSITIVE = "positive"
}
)(LABEL_THEME || (LABEL_THEME = {}));
const Label = ({text: V, theme: X=LABEL_THEME.PRIMARY, disabled: J, className: ne}) => jsxRuntimeExports.jsx("span", {
    className: classNames(styles$I.label, X === LABEL_THEME.PRIMARY && styles$I.primary, X === LABEL_THEME.SECONDARY && styles$I.secondary, X === LABEL_THEME.TERTIARY && styles$I.tertiary, X === LABEL_THEME.WARNING && styles$I.warning, X === LABEL_THEME.POSITIVE && styles$I.positive, J && styles$I.disabled, ne),
    children: V
});
var styles$H = {
    list: "list-module_list__lx7OA"
};
const List = ({children: V, className: X}) => jsxRuntimeExports.jsx("div", {
    className: classNames(styles$H.list, X),
    children: V
});
var styles$G = {
    item: "listItem-module_item__uOqME",
    interactive: "listItem-module_interactive__FE9TI"
};
const ListItem = ({children: V, className: X, testId: J, onClick: ne}) => {
    const ue = ne !== void 0 ? "button" : "div";
    return jsxRuntimeExports.jsx(ue, {
        onClick: ne,
        "data-testid": J,
        className: classNames(styles$G.item, ne !== void 0 && styles$G.interactive, X),
        ...ue === "button" && {
            type: ue
        },
        children: V
    })
}
;
var styles$E$1 = {
    backdrop: "LoadingSpinner-module_backdrop__KqhUo",
    loadSpinnerContainer: "LoadingSpinner-module_loadSpinnerContainer__N6GcW",
    loadSpinner: "LoadingSpinner-module_loadSpinner__Kvcpu",
    statusText: "LoadingSpinner-module_statusText__JgGyw"
};
const LoadingSpinner = ({statusText: V}) => (reactExports.useEffect( () => (document.body.classList.add("no-scroll-scrim"),
() => {
    document.body.classList.remove("no-scroll-scrim")
}
), []),
jsxRuntimeExports.jsx("div", {
    className: styles$E$1.backdrop,
    children: jsxRuntimeExports.jsxs("div", {
        className: styles$E$1.loadSpinnerContainer,
        children: [jsxRuntimeExports.jsx("div", {
            className: styles$E$1.loadSpinner
        }), jsxRuntimeExports.jsx("div", {
            className: styles$E$1.statusText,
            children: V
        })]
    })
}));
var styles$D$1 = {
    wrapper: "page-wrapper-module_wrapper__VFv1R",
    paddingSm: "page-wrapper-module_paddingSm__bXc2p",
    wide: "page-wrapper-module_wide__LguiF",
    narrow: "page-wrapper-module_narrow__RNzWk",
    paddingMd: "page-wrapper-module_paddingMd__VUKMA",
    paddingLg: "page-wrapper-module_paddingLg__ipGsH",
    trimBottom: "page-wrapper-module_trimBottom__hChgK",
    trimTop: "page-wrapper-module_trimTop__L5tRE"
}, PAGE_WRAPPER_PADDING;
(function(V) {
    V.NONE = "none",
    V.SM = "sm",
    V.MD = "md",
    V.LG = "lg"
}
)(PAGE_WRAPPER_PADDING || (PAGE_WRAPPER_PADDING = {}));
var PAGE_WRAPPER_MAX_WIDTH;
(function(V) {
    V.NARROW = "narrow",
    V.WIDE = "wide"
}
)(PAGE_WRAPPER_MAX_WIDTH || (PAGE_WRAPPER_MAX_WIDTH = {}));
const PageWrapper = ({children: V, paddingSize: X=PAGE_WRAPPER_PADDING.MD, maxWidthSize: J=PAGE_WRAPPER_MAX_WIDTH.WIDE, className: ne, trimY: ue, trimTop: ce, trimBottom: me}) => jsxRuntimeExports.jsx("div", {
    className: classNames(styles$D$1.wrapper, J === PAGE_WRAPPER_MAX_WIDTH.WIDE && styles$D$1.wide, J === PAGE_WRAPPER_MAX_WIDTH.NARROW && styles$D$1.narrow, X === PAGE_WRAPPER_PADDING.SM && styles$D$1.paddingSm, X === PAGE_WRAPPER_PADDING.MD && styles$D$1.paddingMd, X === PAGE_WRAPPER_PADDING.LG && styles$D$1.paddingLg, (ue || ce) && styles$D$1.trimTop, (ue || me) && styles$D$1.trimBottom, ne),
    children: V
});
var styles$C$1 = {
    table: "table-module_table__omg7p",
    isEvenWidth: "table-module_isEvenWidth__YC-TD"
};
const Table = ({children: V, textAlign: X, evenWidth: J, className: ne}) => jsxRuntimeExports.jsx("table", {
    style: {
        textAlign: X
    },
    className: classNames(styles$C$1.table, J && styles$C$1.isEvenWidth, ne),
    children: jsxRuntimeExports.jsx("tbody", {
        children: V
    })
});
var styles$B$1 = {
    cell: "table-cell-module_cell__BMlSO"
};
const TableCell = ({children: V, color: X, textColor: J, textAlign: ne}) => jsxRuntimeExports.jsx("td", {
    style: {
        ...X && {
            backgroundColor: X
        },
        ...J && {
            color: J
        },
        textAlign: ne
    },
    className: styles$B$1.cell,
    children: V
});
var styles$A$1 = {
    row: "table-row-module_row__nvigA"
};
const TableRow = ({children: V, onClick: X}) => jsxRuntimeExports.jsx("tr", {
    onClick: X,
    className: styles$A$1.row,
    children: V
});
var styles$z$1 = {
    warning: "warning-module_warning__Bdy6m",
    error: "warning-module_error__ihyWK",
    prompt: "warning-module_prompt__UO0sp",
    text: "warning-module_text__i0cRC"
}, WARNING_VARIANTS;
(function(V) {
    V.ERROR = "error",
    V.WARNING = "warning",
    V.PROMPT = "prompt"
}
)(WARNING_VARIANTS || (WARNING_VARIANTS = {}));
const DEFAULT_VARIANT_TO_ICON_MAPPING = {
    [WARNING_VARIANTS.ERROR]: ICON_NAMES.WARNING,
    [WARNING_VARIANTS.WARNING]: ICON_NAMES.WARNING_CIRCLE,
    [WARNING_VARIANTS.PROMPT]: ICON_NAMES.CHECK2
}
  , Warning = ({text: V, icon: X, variant: J=WARNING_VARIANTS.WARNING}) => jsxRuntimeExports.jsxs("div", {
    className: classNames(styles$z$1.warning, J === WARNING_VARIANTS.WARNING && styles$z$1.warning, J === WARNING_VARIANTS.PROMPT && styles$z$1.prompt, J === WARNING_VARIANTS.ERROR && styles$z$1.error),
    children: [jsxRuntimeExports.jsx(Icon, {
        name: X === void 0 ? DEFAULT_VARIANT_TO_ICON_MAPPING[J] : X
    }), jsxRuntimeExports.jsx("span", {
        className: styles$z$1.text,
        children: V
    })]
});
var styles$y$1 = {
    list: "warning-list-module_list__6c37l"
};
const WarningList = ({children: V}) => jsxRuntimeExports.jsx("div", {
    className: styles$y$1.list,
    children: V
});
var styles$x$1 = {
    well: "well-module_well__lI0oB",
    primary: "well-module_primary__uTFHb",
    secondary: "well-module_secondary__WK0xp",
    lg: "well-module_lg__6BqSy",
    md: "well-module_md__eb0je",
    sm: "well-module_sm__6P1vA"
}, WELL_PADDING_SIZE;
(function(V) {
    V.SM = "sm",
    V.MD = "md",
    V.LG = "lg"
}
)(WELL_PADDING_SIZE || (WELL_PADDING_SIZE = {}));
var WELL_VARIANT;
(function(V) {
    V.PRIMARY = "primary",
    V.SECONDARY = "secondary"
}
)(WELL_VARIANT || (WELL_VARIANT = {}));
const Well = ({children: V, variant: X=WELL_VARIANT.PRIMARY, padding: J=WELL_PADDING_SIZE.LG, className: ne}) => jsxRuntimeExports.jsx("div", {
    className: classNames(styles$x$1.well, X === WELL_VARIANT.PRIMARY && styles$x$1.primary, X === WELL_VARIANT.SECONDARY && styles$x$1.secondary, J === WELL_PADDING_SIZE.SM && styles$x$1.sm, J === WELL_PADDING_SIZE.MD && styles$x$1.md, J === WELL_PADDING_SIZE.LG && styles$x$1.lg, ne),
    children: V
});
var styles$w$1 = {
    link: "button-module_link__Dqbey",
    fillWidth: "button-module_fillWidth__x5wWC",
    disabledLink: "button-module_disabledLink__erH4N",
    button: "button-module_button__51-il",
    noMax: "button-module_noMax__Dk1-u",
    sizeSm: "button-module_sizeSm__mBW7x",
    disabled: "button-module_disabled__Eg9kb",
    secondary: "button-module_secondary__-y83F",
    content: "button-module_content__2avKd",
    text: "button-module_text__s1xss",
    prefixIcon: "button-module_prefixIcon__-QJwZ",
    suffixIcon: "button-module_suffixIcon__4f2Hm"
}, BUTTON_VARIANTS;
(function(V) {
    V.PRIMARY = "primary",
    V.SECONDARY = "secondary"
}
)(BUTTON_VARIANTS || (BUTTON_VARIANTS = {}));
var BUTTON_SIZE;
(function(V) {
    V.SM = "sm",
    V.MD = "md"
}
)(BUTTON_SIZE || (BUTTON_SIZE = {}));
const Button = ({children: V, prefixIcon: X, suffixIcon: J, fillWidth: ne, color: ue, variant: ce=BUTTON_VARIANTS.PRIMARY, type: me=BUTTON_TYPES$1.BUTTON, className: ge, isDisabled: Te, size: _e=BUTTON_SIZE.MD, noMax: Se, testId: Ie, onClick: ye}) => {
    const $e = ye || me !== BUTTON_TYPES$1.BUTTON ? "button" : "div";
    return jsxRuntimeExports.jsx($e, {
        style: {
            "--button-color": ue ?? (ce === BUTTON_VARIANTS.SECONDARY ? "var(--tmln-ui-button-text-color-secondary)" : "var(--tmln-ui-button-border-color)")
        },
        type: me,
        disabled: Te,
        onClick: ye,
        "data-testid": Ie,
        className: classNames(styles$w$1.button, styles$w$1[ce], !!ne && styles$w$1.fillWidth, Te && styles$w$1.disabled, _e === BUTTON_SIZE.SM && styles$w$1.sizeSm, Se && styles$w$1.noMax, ge),
        children: jsxRuntimeExports.jsxs("div", {
            className: styles$w$1.content,
            children: [X ? jsxRuntimeExports.jsx("span", {
                className: styles$w$1.prefixIcon,
                children: jsxRuntimeExports.jsx(Icon, {
                    name: X
                })
            }) : null, jsxRuntimeExports.jsx("span", {
                className: styles$w$1.text,
                children: V
            }), J ? jsxRuntimeExports.jsx("span", {
                className: styles$w$1.suffixIcon,
                children: jsxRuntimeExports.jsx(Icon, {
                    name: J
                })
            }) : null]
        })
    })
}
;
var styles$v$1 = {
    inputWrapper: "textInput-module_inputWrapper__2mQGs",
    fillWidth: "textInput-module_fillWidth__HN6dL",
    unavailable: "textInput-module_unavailable__UZsWG",
    inputBase: "textInput-module_inputBase__EqKon",
    primary: "textInput-module_primary__RA35z",
    secondary: "textInput-module_secondary__52q5Q",
    disabled: "textInput-module_disabled__uOaQL",
    validationFailed: "textInput-module_validationFailed__4sRFI",
    numberFormat: "textInput-module_numberFormat__qhXzi",
    input: "textInput-module_input__w5OkU",
    mediumSize: "textInput-module_mediumSize__GjDVq",
    smallSize: "textInput-module_smallSize__p3Fc5",
    multiline: "textInput-module_multiline__zMRIO",
    resizeHorizontal: "textInput-module_resizeHorizontal__H94S5",
    resizeBoth: "textInput-module_resizeBoth__JDV8g",
    resizeNone: "textInput-module_resizeNone__m5G0E",
    label: "textInput-module_label__O9Ocg",
    inputContainer: "textInput-module_inputContainer__yHR39"
}, TEXT_INPUT_TYPES;
(function(V) {
    V.TEXT = "text",
    V.NUMBER = "number",
    V.MULTILINE = "multiline"
}
)(TEXT_INPUT_TYPES || (TEXT_INPUT_TYPES = {}));
var TEXT_ALIGNMENT_TYPES;
(function(V) {
    V.LEFT = "start",
    V.CENTER = "center",
    V.RIGHT = "end"
}
)(TEXT_ALIGNMENT_TYPES || (TEXT_ALIGNMENT_TYPES = {}));
var TEXT_INPUT_SIZE;
(function(V) {
    V.SMALL = "small",
    V.MEDIUM = "medium"
}
)(TEXT_INPUT_SIZE || (TEXT_INPUT_SIZE = {}));
var VALIDATION_RULE;
(function(V) {
    V.REQUIRED = "required",
    V.MAX_LENGTH = "maxLength",
    V.MAX_EXCEEDED = "maxExceeded",
    V.MIN_EXCEEDED = "minExceeded"
}
)(VALIDATION_RULE || (VALIDATION_RULE = {}));
var MULTILINE_RESIZE;
(function(V) {
    V.BOTH = "both",
    V.HORIZONTAL = "horizontal",
    V.NONE = "none",
    V.VERTICAL = "vertical"
}
)(MULTILINE_RESIZE || (MULTILINE_RESIZE = {}));
var TEXT_INPUT_VARIANT;
(function(V) {
    V.PRIMARY = "primary",
    V.SECONDARY = "secondary"
}
)(TEXT_INPUT_VARIANT || (TEXT_INPUT_VARIANT = {}));
const TextInput = ({label: V, variant: X=TEXT_INPUT_VARIANT.PRIMARY, action: J, value: ne="", type: ue=TEXT_INPUT_TYPES.TEXT, textAlign: ce=TEXT_ALIGNMENT_TYPES.LEFT, min: me, max: ge, step: Te, precision: _e, disabled: Se, placeholder: Ie="", className: ye, fillWidth: $e, size: Ne, validation: ve, resize: ke, unavailable: xe, readOnly: we, error: Fe, testId: je, dir: Xe, onChange: ze, onBlur: qe, onFocus: Ze, onValidationChange: et}) => {
    const it = reactExports.useRef(!0)
      , at = reactExports.useRef(ne)
      , [rt,ft] = reactExports.useState(new Set)
      , St = _e && precisionToStep(_e)
      , Ye = ({target: {value: Et}}) => {
        (ve == null ? void 0 : ve.maxLength) !== void 0 && (Et.toString().trim().length > ve.maxLength ? rt.add(VALIDATION_RULE.MAX_LENGTH) : rt.delete(VALIDATION_RULE.MAX_LENGTH),
        et && et(rt),
        ft(new Set([...rt]))),
        ze && ze(Et)
    }
      , We = ({target: {value: Et}}) => {
        const Ke = ge === void 0 && me === void 0 && ue === "number";
        if (!it.current && (ve != null && ve.required) && (ne === void 0 || ne === "" ? rt.add(VALIDATION_RULE.REQUIRED) : rt.delete(VALIDATION_RULE.REQUIRED),
        et && et(rt),
        ft(new Set([...rt]))),
        ue === "text" || ue === "multiline") {
            ze && ze(Et.toString().trim()),
            qe && qe(Et.toString().trim());
            return
        }
        const mt = +Et;
        if (ze) {
            const lt = me !== void 0 ? Number(me) : void 0
              , Qe = ge !== void 0 ? Number(ge) : void 0
              , gt = Qe !== void 0 && mt > Qe
              , Nt = lt !== void 0 && mt < lt;
            if (!isNaN(mt)) {
                const Gt = Te ? roundToStep(mt, Te).toString() : roundToPrecision(mt, _e).toString();
                Nt ? (qe && qe(lt.toString()),
                ze(lt.toString())) : gt ? (qe && qe(Qe.toString()),
                ze(Qe.toString())) : (qe && qe(Gt),
                ze(Gt));
                return
            }
            if (Ke) {
                qe && qe(Et),
                ze(Et);
                return
            }
        }
    }
    ;
    at.current !== ne && it.current && (it.current = !1);
    const nt = (ve == null ? void 0 : ve.required) && !it.current && !ne || (ve == null ? void 0 : ve.minExceeded) && typeof ne == "number" && me !== void 0 && ne < me || (ve == null ? void 0 : ve.maxExceeded) && typeof ne == "number" && ge !== void 0 && ne > ge
      , ct = [styles$v$1.inputBase, styles$v$1.input, X === TEXT_INPUT_VARIANT.PRIMARY && styles$v$1.primary, X === TEXT_INPUT_VARIANT.SECONDARY && styles$v$1.secondary, Se && styles$v$1.disabled, $e && styles$v$1.fillWidth, Ne && styles$v$1[`${Ne}Size`], (nt || Fe) && styles$v$1.validationFailed, we && styles$v$1.readOnly, ye];
    return jsxRuntimeExports.jsxs("label", {
        className: classNames(styles$v$1.label, $e && styles$v$1.fillWidth),
        children: [ue === TEXT_INPUT_TYPES.MULTILINE ? jsxRuntimeExports.jsx("div", {
            className: classNames(styles$v$1.inputWrapper, xe && styles$v$1.unavailable),
            children: jsxRuntimeExports.jsx("textarea", {
                disabled: Se,
                placeholder: Ie,
                className: classNames(...ct, styles$v$1.multiline, ke === MULTILINE_RESIZE.VERTICAL && styles$v$1.resizeVertical, ke === MULTILINE_RESIZE.HORIZONTAL && styles$v$1.resizeHorizontal, ke === MULTILINE_RESIZE.BOTH && styles$v$1.resizeBoth, ke === MULTILINE_RESIZE.NONE && styles$v$1.resizeNone),
                value: ne,
                "data-testid": je,
                onChange: Ye,
                onBlur: We,
                ...we && {
                    readOnly: !0
                },
                ...Xe && {
                    dir: Xe
                }
            })
        }) : jsxRuntimeExports.jsxs("div", {
            className: styles$v$1.inputContainer,
            children: [jsxRuntimeExports.jsx("div", {
                className: classNames(styles$v$1.inputWrapper, xe && styles$v$1.unavailable),
                children: jsxRuntimeExports.jsx("input", {
                    className: classNames(...ct, (me !== void 0 || ge !== void 0 || Te !== void 0 || ue === TEXT_INPUT_TYPES.NUMBER) && styles$v$1.numberFormat),
                    type: ue,
                    disabled: Se,
                    ...(_e || Te) && {
                        step: St || Te
                    },
                    ...me !== void 0 && {
                        min: me.toString()
                    },
                    ...ge !== void 0 && {
                        max: ge.toString()
                    },
                    value: ne,
                    style: {
                        textAlign: ce
                    },
                    placeholder: Ie,
                    "data-testid": je,
                    onChange: Ye,
                    onBlur: We,
                    onFocus: Ze,
                    ...(ve == null ? void 0 : ve.maxLength) && {
                        maxLength: ve == null ? void 0 : ve.maxLength
                    },
                    ...(ve == null ? void 0 : ve.required) && {
                        required: !0
                    },
                    ...we && {
                        readOnly: !0
                    },
                    ...Xe && {
                        dir: Xe
                    }
                })
            }), J && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                children: [!J.iconOnly && jsxRuntimeExports.jsx(Button, {
                    size: BUTTON_SIZE.SM,
                    prefixIcon: J.prefixIcon || J.icon,
                    suffixIcon: J.suffixIcon,
                    onClick: J.onClick,
                    children: J.text
                }), J.iconOnly && J.icon && jsxRuntimeExports.jsx(IconButton, {
                    size: ICON_BUTTON_SIZE.SM,
                    icon: J.icon,
                    label: J.text,
                    onClick: J.onClick
                })]
            })]
        }), jsxRuntimeExports.jsx("span", {
            className: "visuallyHidden",
            children: V
        })]
    })
}
;
var styles$u$1 = {
    container: "incrementor-module_container__2Lfd-",
    input: "incrementor-module_input__25OgN"
};
const Incrementor = ({labels: V, count: X, max: J, min: ne, step: ue, enforceStep: ce, isDisabled: me, unavailable: ge, error: Te, onChange: _e, onBlur: Se, onFocus: Ie}) => {
    const ye = ne && ne > 0 ? ne : 0
      , $e = ne !== void 0 && (X ?? ye) <= ne || me
      , Ne = J !== void 0 && (X ?? ye) >= J || me
      , [ve,ke] = reactExports.useState()
      , [xe,we] = reactExports.useState(!0)
      , Fe = (Ze, et, it=!0) => {
        const at = it ? Ze % et : et - Ze % et
          , rt = at ? et - at : et;
        return rt || et
    }
      , je = () => {
        const Ze = ue !== void 0 ? Fe(X ?? ye, ue, !1) : void 0
          , et = (X ?? ye) - (Ze === void 0 ? 1 : Ze)
          , it = ne === void 0 ? et : et < ne ? ne : et;
        ke(it),
        _e && _e(it)
    }
      , Xe = () => {
        const Ze = ue !== void 0 ? Fe(X ?? ye, ue) : void 0
          , et = (X ?? ye) + (Ze === void 0 ? 1 : Ze)
          , it = J === void 0 ? et : et > J ? J : et;
        ke(it),
        _e && _e(it)
    }
      , ze = Ze => {
        const et = Ze === void 0 || isNaN(+Ze) || Ze === "" ? void 0 : +Ze
          , it = typeof et == "number" && J !== void 0 && et > J
          , at = typeof et == "number" && ne !== void 0 && et < ne;
        it || at ? (ke(Ze),
        we(!1)) : (ke(et),
        _e && _e(et))
    }
      , qe = Ze => {
        const et = Ze === void 0 || isNaN(+Ze) || Ze === "" ? void 0 : +Ze;
        Se && Se(et),
        ke(et),
        xe || (we(!0),
        _e && _e(et))
    }
    ;
    return jsxRuntimeExports.jsxs("div", {
        className: styles$u$1.container,
        children: [jsxRuntimeExports.jsx(IconButton, {
            variant: ICON_BUTTON_VARIANT.SECONDARY,
            label: V.decrement,
            icon: ICON_NAMES.MINUS2,
            onClick: je,
            isDisabled: $e,
            size: ICON_BUTTON_SIZE.XS
        }), jsxRuntimeExports.jsx("div", {
            className: styles$u$1.input,
            children: jsxRuntimeExports.jsx(TextInput, {
                type: TEXT_INPUT_TYPES.NUMBER,
                fillWidth: !0,
                label: V.count,
                max: J,
                min: ne,
                step: ce ? ue : void 0,
                value: xe ? X : ve,
                textAlign: TEXT_ALIGNMENT_TYPES.CENTER,
                disabled: me,
                onChange: ze,
                onBlur: qe,
                onFocus: Ie,
                validation: {
                    maxExceeded: !0,
                    minExceeded: !0
                },
                unavailable: ge,
                error: Te
            })
        }), jsxRuntimeExports.jsx(IconButton, {
            variant: ICON_BUTTON_VARIANT.SECONDARY,
            label: V.increment,
            icon: ICON_NAMES.PLUS2,
            onClick: Xe,
            isDisabled: Ne,
            size: ICON_BUTTON_SIZE.XS
        })]
    })
}
;
var styles$t$1 = {
    container: "checkbox-module_container__hou41",
    icon: "checkbox-module_icon__KTp43",
    label: "checkbox-module_label__L3VFY",
    frame: "checkbox-module_frame__a4cOW",
    checked: "checkbox-module_checked__rN6rj",
    unavailable: "checkbox-module_unavailable__PdHGh",
    positive: "checkbox-module_positive__xNM1T",
    facade: "checkbox-module_facade__XGZyI",
    disabled: "checkbox-module_disabled__1YZYQ",
    unavailableIcon: "checkbox-module_unavailableIcon__sK1zi",
    checkboxContainer: "checkbox-module_checkboxContainer__qjE3M",
    checkbox: "checkbox-module_checkbox__-dxMw"
};
const Checkbox = ({label: V, checked: X=!1, disabled: J=!1, tabIndex: ne, children: ue, testId: ce, unavailable: me, positive: ge, stopPropagation: Te, labelClassName: _e, onChange: Se, onClick: Ie}) => {
    const ye = reactExports.useId()
      , $e = Ne => {
        Te && Ne.stopPropagation(),
        Se && Se(Ne.target.checked)
    }
    ;
    return jsxRuntimeExports.jsxs("div", {
        className: styles$t$1.container,
        children: [jsxRuntimeExports.jsxs("div", {
            className: classNames(styles$t$1.frame, X && styles$t$1.checked, J && styles$t$1.disabled, me && styles$t$1.unavailable, ge && styles$t$1.positive, !Se && !Ie && styles$t$1.facade),
            children: [(Se || Ie) && jsxRuntimeExports.jsx("input", {
                onClick: Ie,
                id: ye,
                className: styles$t$1.checkbox,
                onChange: $e,
                type: "checkbox",
                disabled: J,
                checked: X,
                ...ce && {
                    "data-testid": ce
                },
                ...ne !== void 0 && {
                    tabIndex: ne
                }
            }), jsxRuntimeExports.jsx("div", {
                className: styles$t$1.checkboxContainer,
                children: me ? jsxRuntimeExports.jsx("div", {
                    className: styles$t$1.unavailableIcon
                }) : X ? jsxRuntimeExports.jsx(Icon, {
                    size: ICON_SIZES.XS,
                    name: ICON_NAMES.CHECK3,
                    className: styles$t$1.icon
                }) : null
            })]
        }), V || ue ? jsxRuntimeExports.jsx("label", {
            className: classNames(styles$t$1.label, ue ? void 0 : "visuallyHidden", _e),
            htmlFor: ye,
            children: ue || V
        }) : null]
    })
}
;
var styles$s$1 = {
    container: "asset-tile-module_container__U01vv",
    disabled: "asset-tile-module_disabled__ONEc7",
    infoBtn: "asset-tile-module_infoBtn__9Y9FA",
    selected: "asset-tile-module_selected__6K1s0",
    readOnly: "asset-tile-module_readOnly__C2dro",
    unavailable: "asset-tile-module_unavailable__LvQaz",
    portrait: "asset-tile-module_portrait__LgkR1",
    landscape: "asset-tile-module_landscape__eGCiq",
    toggleArea: "asset-tile-module_toggleArea__4PEHF",
    imgWrapper: "asset-tile-module_imgWrapper__-gKQk",
    img: "asset-tile-module_img__tXzdf",
    footer: "asset-tile-module_footer__EzB3I",
    incrementorFooter: "asset-tile-module_incrementorFooter__wRTfM",
    text: "asset-tile-module_text__t7K7p",
    iconGroup: "asset-tile-module_iconGroup__itveY",
    checkbox: "asset-tile-module_checkbox__gpTHm"
}, ASSET_TILE_ORIENTATION;
(function(V) {
    V.LANDSCAPE = "landscape",
    V.PORTRAIT = "portrait"
}
)(ASSET_TILE_ORIENTATION || (ASSET_TILE_ORIENTATION = {}));
const COUNT_MIN = 0
  , AssetTile = ({image: V, name: X, orientation: J=ASSET_TILE_ORIENTATION.LANDSCAPE, isSelected: ne=!1, icons: ue, disabled: ce=!1, unavailable: me=!1, readOnly: ge=!1, countData: Te, testId: _e, onImageLoadFailed: Se, onChange: Ie, onDisabledClick: ye, onInfoClick: $e}) => {
    const Ne = reactExports.useId()
      , ve = () => {
        $e && $e()
    }
      , ke = ze => {
        Te && Te.onChange(ze ? 1 : 0),
        Ie && Ie(ze)
    }
      , xe = () => {
        ce ? !ge && ye && ye() : ke(!ne)
    }
      , we = () => {
        ce && ye && ye()
    }
      , Fe = ({target: ze}) => {
        ke(ze.checked)
    }
      , je = ze => {
        Te == null || Te.onChange(ze)
    }
      , Xe = ue ? jsxRuntimeExports.jsx("div", {
        className: styles$s$1.iconGroup,
        onClick: xe,
        children: ue.map( ({name: ze, tooltip: qe, src: Ze}) => jsxRuntimeExports.jsx(Tooltip, {
            tip: qe,
            children: jsxRuntimeExports.jsx(Icon, {
                name: ze,
                src: Ze,
                size: ICON_SIZES.XS
            }, ze)
        }, ze || Ze))
    }) : null;
    return jsxRuntimeExports.jsx("div", {
        className: classNames(styles$s$1.container, J === ASSET_TILE_ORIENTATION.PORTRAIT && styles$s$1.portrait, J === ASSET_TILE_ORIENTATION.LANDSCAPE && styles$s$1.landscape, ne && styles$s$1.selected, ce && styles$s$1.disabled, ge && styles$s$1.readOnly, me && styles$s$1.unavailable),
        style: J === ASSET_TILE_ORIENTATION.PORTRAIT ? {
            backgroundImage: `url(${V})`
        } : {},
        ...typeof X == "string" ? {
            title: X
        } : {},
        children: jsxRuntimeExports.jsxs("div", {
            className: styles$s$1.toggleArea,
            "data-testid": _e,
            onClick: we,
            children: [jsxRuntimeExports.jsx("label", {
                className: "visuallyHidden",
                htmlFor: Ne,
                children: X
            }), jsxRuntimeExports.jsx("input", {
                checked: ne,
                onChange: Fe,
                type: "checkbox",
                id: Ne,
                disabled: ce || ge,
                readOnly: ge,
                className: styles$s$1.checkbox
            }), jsxRuntimeExports.jsxs("div", {
                className: styles$s$1.imgWrapper,
                children: [$e && jsxRuntimeExports.jsx(IconButton, {
                    size: ICON_BUTTON_SIZE.XXS,
                    className: styles$s$1.infoBtn,
                    icon: ICON_NAMES.INFO,
                    onClick: ve,
                    transparent: !0,
                    stopPropagation: !0
                }), V && J === ASSET_TILE_ORIENTATION.LANDSCAPE && jsxRuntimeExports.jsx("img", {
                    className: styles$s$1.img,
                    src: V,
                    loading: "lazy",
                    onError: Se
                }), J === ASSET_TILE_ORIENTATION.LANDSCAPE && Xe]
            }), jsxRuntimeExports.jsxs("footer", {
                className: styles$s$1.footer,
                children: [J === ASSET_TILE_ORIENTATION.PORTRAIT && Xe, jsxRuntimeExports.jsx("span", {
                    className: styles$s$1.text,
                    children: X
                }), Te === void 0 && jsxRuntimeExports.jsx(Checkbox, {
                    onChange: ke,
                    disabled: ce || ge,
                    unavailable: me,
                    checked: ne,
                    stopPropagation: !0,
                    positive: ne && !ge
                })]
            }), Te !== void 0 && jsxRuntimeExports.jsx("footer", {
                className: styles$s$1.incrementorFooter,
                children: jsxRuntimeExports.jsx(Incrementor, {
                    count: Te.count ? Number(Te.count) : COUNT_MIN,
                    min: ne ? 1 : COUNT_MIN,
                    max: Te.max,
                    labels: Te.labels,
                    onChange: je
                })
            })]
        })
    })
}
;
var styles$r$1 = {
    header: "accordion-module_header__E47MF",
    isTrigger: "accordion-module_isTrigger__-aV9-",
    trigger: "accordion-module_trigger__EPAl-",
    body: "accordion-module_body__uYANl",
    open: "accordion-module_open__Q1o7w"
};
const Accordion = ({items: V, activeIds: X=new Set, iconNames: J={
    open: ICON_NAMES.CHEVRON_UP_90,
    closed: ICON_NAMES.CHEVRON_DOWN_90
}, iconSize: ne=ICON_SIZES.MD, iconColor: ue, className: ce, headerIsTrigger: me, onChange: ge}) => {
    const {colors: Te} = reactExports.useContext(ThemeContext)
      , _e = Se => Ie => {
        Ie.stopPropagation(),
        X.has(Se) ? X.delete(Se) : X.add(Se),
        ge(X)
    }
    ;
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
        children: V.map( ({header: Se, body: Ie, id: ye}) => {
            const $e = X.has(ye);
            return jsxRuntimeExports.jsxs(reactExports.Fragment, {
                children: [jsxRuntimeExports.jsxs("div", {
                    className: classNames(styles$r$1.header, ce, me && styles$r$1.isTrigger),
                    ...me && {
                        onClick: _e(ye)
                    },
                    children: [Se, Ie && jsxRuntimeExports.jsx("button", {
                        type: BUTTON_TYPES$1.BUTTON,
                        className: styles$r$1.trigger,
                        onClick: _e(ye),
                        "aria-expanded": $e,
                        "aria-controls": ye,
                        children: jsxRuntimeExports.jsx(Icon, {
                            name: J.open && $e ? J.open : J.closed,
                            rotate: !J.open && $e ? 180 : 0,
                            size: ne,
                            color: ue ?? Te.white
                        })
                    })]
                }), jsxRuntimeExports.jsx("div", {
                    className: classNames(styles$r$1.body, $e && styles$r$1.open),
                    "aria-labelledby": ye,
                    role: "region",
                    children: $e && Ie
                })]
            }, ye)
        }
        )
    })
}
;
var styles$q$1 = {
    sectionHeaderContainer: "asset-tile-sections-module_sectionHeaderContainer__btovu",
    conflict: "asset-tile-sections-module_conflict__MkigK",
    sectionHeader: "asset-tile-sections-module_sectionHeader__D5gAv",
    header: "asset-tile-sections-module_header__s4j4i",
    dividerBox: "asset-tile-sections-module_dividerBox__cFnu6",
    count: "asset-tile-sections-module_count__e-0-A",
    selectedCount: "asset-tile-sections-module_selectedCount__HUqEk"
};
const AssetTileSections = ({sections: V, selectedIds: X=new Set, countData: J, onChange: ne}) => {
    const {colors: ue} = reactExports.useContext(ThemeContext)
      , [ce,me] = reactExports.useState(new Set([V[0].id]))
      , ge = V.reduce( (Ie, {items: ye, id: $e}) => (ye.some( ({id: Ne}) => J ? J.countMapping.get(Ne) : X.has(Ne)) && Ie.add($e),
    Ie), new Set)
      , Te = Ie => {
        me(new Set([...Ie]))
    }
      , _e = Ie => ye => {
        ye ? Ie.forEach($e => X.add($e)) : Ie.forEach($e => X.delete($e)),
        J != null && J.onCountsChange && J.onCountsChange(Ie.reduce( ($e, Ne) => ($e[Ne] = ye ? 1 : 0,
        $e), {})),
        ne && ne(X, Ie, ye)
    }
      , Se = Ie => {
        Ie.stopPropagation()
    }
    ;
    return jsxRuntimeExports.jsx(Accordion, {
        className: styles$q$1.sectionHeaderContainer,
        iconColor: ue.gray500,
        activeIds: ce,
        onChange: Te,
        headerIsTrigger: !0,
        iconSize: ICON_SIZES.XS,
        items: V.map( ({header: Ie, items: ye, id: $e}) => {
            const Ne = ye.some( ({isConflicted: ve}) => ve);
            return {
                header: jsxRuntimeExports.jsxs("div", {
                    className: classNames(styles$q$1.sectionHeader, Ne && styles$q$1.conflict),
                    children: [jsxRuntimeExports.jsx("div", {
                        className: styles$q$1.dividerBox,
                        children: jsxRuntimeExports.jsxs(Space, {
                            gapSize: SPACE_GAP_SIZE.SM,
                            children: [jsxRuntimeExports.jsx(Checkbox, {
                                testId: $e,
                                unavailable: Ne,
                                onClick: Se,
                                checked: ge.has($e),
                                disabled: ye.every( ({isDisabled: ve}) => ve),
                                onChange: _e(ye.map( ({id: ve}) => ve))
                            }), jsxRuntimeExports.jsx("div", {
                                className: styles$q$1.header,
                                children: Ie
                            })]
                        })
                    }), jsxRuntimeExports.jsxs("span", {
                        className: styles$q$1.count,
                        children: [jsxRuntimeExports.jsx("span", {
                            className: styles$q$1.selectedCount,
                            children: ye.filter( ({id: ve}) => X.has(ve)).length
                        }), "/", ye.length]
                    })]
                }),
                id: $e,
                body: jsxRuntimeExports.jsx(Grid, {
                    items: ye.map( ({assetTile: ve}) => ve)
                })
            }
        }
        )
    })
}
;
var styles$p$1 = {
    container: "mutator-module_container__0S7vr",
    error: "mutator-module_error__xfvTj",
    title: "mutator-module_title__9bLYS",
    errorTitle: "mutator-module_errorTitle__SgE5-",
    controlsContainer: "mutator-module_controlsContainer__27PCd",
    secondaryLayout: "mutator-module_secondaryLayout__CatXf",
    subtitle: "mutator-module_subtitle__RvNap",
    row: "mutator-module_row__DRxQr",
    rowOne: "mutator-module_rowOne__HXIXS",
    rowTwo: "mutator-module_rowTwo__OlnBn",
    link: "mutator-module_link__2mhHo",
    isDisabled: "mutator-module_isDisabled__fa9A9",
    linkIcon: "mutator-module_linkIcon__3j1he",
    footerContainer: "mutator-module_footerContainer__8CgIy",
    inputContainer: "mutator-module_inputContainer__-A1kv"
}, MUTATOR_LAYOUT;
(function(V) {
    V.PRIMARY = "primary",
    V.SECONDARY = "secondary"
}
)(MUTATOR_LAYOUT || (MUTATOR_LAYOUT = {}));
const Mutator$1 = ({title: V, input: X, subtitle: J, layout: ne=MUTATOR_LAYOUT.PRIMARY, caption: ue, isDisabled: ce, isLinked: me, error: ge, testId: Te, footer: _e, className: Se, onLink: Ie}) => {
    const ye = document.documentElement.dir === "rtl"
      , $e = "12px"
      , Ne = () => {
        Ie && Ie(!me)
    }
    ;
    return jsxRuntimeExports.jsxs(FlipTile, {
        title: jsxRuntimeExports.jsx("div", {
            className: classNames(styles$p$1.title, ge && styles$p$1.errorTitle),
            children: V
        }),
        details: ue,
        className: classNames(styles$p$1.container, ge && styles$p$1.error, Se),
        testId: Te,
        children: [Array.isArray(X) ? jsxRuntimeExports.jsxs("div", {
            className: classNames(styles$p$1.controlsContainer, ne === MUTATOR_LAYOUT.SECONDARY && styles$p$1.secondaryLayout),
            children: [jsxRuntimeExports.jsxs("div", {
                className: classNames(styles$p$1.row, styles$p$1.rowOne),
                children: [ne === MUTATOR_LAYOUT.PRIMARY && jsxRuntimeExports.jsx(Label, {
                    text: "T1"
                }), jsxRuntimeExports.jsx("div", {
                    className: styles$p$1.inputContainer,
                    children: X[0]
                })]
            }), jsxRuntimeExports.jsxs("div", {
                className: classNames(styles$p$1.row, styles$p$1.rowTwo),
                children: [ne === MUTATOR_LAYOUT.PRIMARY && jsxRuntimeExports.jsx(Label, {
                    text: "T2"
                }), jsxRuntimeExports.jsx("div", {
                    className: styles$p$1.inputContainer,
                    children: X[1]
                })]
            }), ne === MUTATOR_LAYOUT.SECONDARY && J && jsxRuntimeExports.jsx("h3", {
                className: styles$p$1.subtitle,
                children: J
            }), jsxRuntimeExports.jsxs("button", {
                className: classNames(styles$p$1.link, ce && styles$p$1.isDisabled),
                type: BUTTON_TYPES$1.BUTTON,
                disabled: ce,
                onClick: Ne,
                "data-testid": "link-button",
                children: [ne === MUTATOR_LAYOUT.PRIMARY && jsxRuntimeExports.jsx(Icon, {
                    name: ICON_NAMES.DASHED_CORNER,
                    size: $e,
                    rotate: ye ? 270 : 0
                }), jsxRuntimeExports.jsx(Icon, {
                    className: styles$p$1.linkIcon,
                    name: me ? ICON_NAMES.LINK : ICON_NAMES.UNLINK,
                    rotate: ne === MUTATOR_LAYOUT.PRIMARY ? 90 : 0
                }), ne === MUTATOR_LAYOUT.PRIMARY && jsxRuntimeExports.jsx(Icon, {
                    name: ICON_NAMES.DASHED_CORNER,
                    size: $e,
                    rotate: ye ? 180 : 90
                })]
            })]
        }) : null, Array.isArray(X) ? null : jsxRuntimeExports.jsx("div", {
            className: styles$p$1.inputContainer,
            children: X
        }), _e !== void 0 && jsxRuntimeExports.jsx("section", {
            className: styles$p$1.footerContainer,
            children: _e
        })]
    })
}
;
var styles$o$1 = {
    container: "switch-module_container__31zYn",
    disabled: "switch-module_disabled__fO0i-",
    track: "switch-module_track__nMAI1",
    unavailable: "switch-module_unavailable__2qYLT",
    active: "switch-module_active__nYyWp",
    thumb: "switch-module_thumb__0Y5It",
    checkbox: "switch-module_checkbox__QnTta"
};
const Switch = ({active: V, labels: X, disabled: J, tabIndex: ne, testId: ue, name: ce, unavailable: me, onChange: ge, onClick: Te}) => {
    const _e = reactExports.useId()
      , Se = Ie => {
        ge && ge(Ie.target.checked)
    }
    ;
    return jsxRuntimeExports.jsxs("div", {
        className: classNames(styles$o$1.container, J && styles$o$1.disabled),
        children: [jsxRuntimeExports.jsxs("div", {
            className: classNames(styles$o$1.track, V && styles$o$1.active, me && styles$o$1.unavailable),
            children: [jsxRuntimeExports.jsx("input", {
                name: ce,
                onClick: Te,
                id: _e,
                className: styles$o$1.checkbox,
                onChange: Se,
                type: "checkbox",
                disabled: J,
                checked: V,
                ...ue && {
                    "data-testid": ue
                },
                ...ne !== void 0 && {
                    tabIndex: ne
                }
            }), jsxRuntimeExports.jsx("div", {
                className: classNames(styles$o$1.thumb)
            })]
        }), me ? "--" : V ? X == null ? void 0 : X.on : X == null ? void 0 : X.off]
    })
}
  , BoolMutator = ({title: V, options: X, value: J, caption: ne, isDisabled: ue, unavailable: ce, testId: me, className: ge, onChange: Te}) => {
    const [_e,Se] = reactExports.useState(Array.isArray(J) ? J[0] === J[1] : !0)
      , Ie = Array.isArray(X) ? X : [X]
      , ye = Array.isArray(J) ? J : [J]
      , $e = xe => {
        const we = xe ? Ie[1].on.value : Ie[1].off.value;
        Te && Te([_e ? we : ye[0], we])
    }
      , Ne = xe => {
        const we = xe ? Ie[0].on.value : Ie[0].off.value;
        Te && Te(Array.isArray(X) ? [we, _e ? we : ye[1]] : we)
    }
      , ve = xe => {
        Se(xe)
    }
      , ke = Ie.map( ({name: xe, on: we, off: Fe}, je) => jsxRuntimeExports.jsx(Switch, {
        name: xe,
        onChange: je === 1 ? $e : Ne,
        labels: {
            on: we.label,
            off: Fe.label
        },
        disabled: _e && je === 1 || ue,
        active: ye == null ? void 0 : ye[_e ? 0 : je],
        testId: me && `${me}-switch-${je}`,
        unavailable: ce
    }, je));
    return jsxRuntimeExports.jsx(Mutator$1, {
        title: V,
        caption: ne,
        isDisabled: ue,
        onLink: ve,
        isLinked: _e,
        testId: me,
        input: ke.length === 1 ? ke[0] : ke,
        className: ge
    })
}
;
var styles$n$1 = {
    draggable: "draggable-module_draggable__DyPX8"
};
const Draggable = ({dropTargetRef: V, onDroppedOnTarget: X, onDropTargetHover: J, onDragFinish: ne, isDisabled: ue, className: ce, children: me}) => {
    const ge = reactExports.useRef(null)
      , [Te,_e] = reactExports.useState(!1)
      , Se = () => {
        _e(!0)
    }
    ;
    return reactExports.useEffect( () => {
        const Ie = () => {
            _e(!1),
            J && J(!1),
            ne && ne()
        }
        ;
        return ge.current && (Te ? ge.current.addEventListener("dragend", Ie) : ge.current.removeEventListener("dragend", Ie)),
        () => {
            ge.current && ge.current.removeEventListener("dragend", Ie)
        }
    }
    , [ne, J, Te]),
    reactExports.useEffect( () => {
        const Ie = ve => {
            ve.preventDefault()
        }
          , ye = () => {
            J && J(!0)
        }
          , $e = () => {
            J && J(!1)
        }
          , Ne = ve => {
            ve.preventDefault(),
            X && X(ge.current ?? void 0)
        }
        ;
        return V.current && (Te ? (V.current.addEventListener("dragenter", ye),
        V.current.addEventListener("dragover", Ie),
        V.current.addEventListener("drop", Ne),
        V.current.addEventListener("dragleave", $e)) : (V.current.removeEventListener("dragenter", ye),
        V.current.removeEventListener("dragover", Ie),
        V.current.removeEventListener("drop", Ne),
        V.current.removeEventListener("dragleave", $e))),
        () => {
            V.current && (V.current.removeEventListener("dragenter", ye),
            V.current.removeEventListener("dragover", Ie),
            V.current.removeEventListener("drop", Ne),
            V.current.removeEventListener("dragleave", $e))
        }
    }
    , [J, V, X, Te]),
    jsxRuntimeExports.jsx("div", {
        ref: ge,
        className: classNames(!ue && styles$n$1.draggable, ce),
        ...!ue && {
            onDragStart: Se,
            draggable: !0
        },
        children: me
    })
}
;
var styles$m$1 = {
    wrapper: "drag-sort-list-module_wrapper__ATyqb",
    list: "drag-sort-list-module_list__cmJJI",
    itemWrapper: "drag-sort-list-module_itemWrapper__GEpZK",
    isDisabled: "drag-sort-list-module_isDisabled__QRFgX",
    grip: "drag-sort-list-module_grip__xykhl",
    beingDragged: "drag-sort-list-module_beingDragged__q-0jw",
    itemContent: "drag-sort-list-module_itemContent__BAfWB",
    orderUpDownArrows: "drag-sort-list-module_orderUpDownArrows__b6KA4",
    preview: "drag-sort-list-module_preview__opoXl",
    previewParking: "drag-sort-list-module_previewParking__DjwWc",
    placeholder: "drag-sort-list-module_placeholder__q-wzB"
};
const DragSortList = reactExports.forwardRef( ({items: V=[], dropPlaceholder: X, emptyPlaceholder: J, isDraggable: ne=!0, isDisabled: ue, showEmptyPlaceholderBelowDropArea: ce, onChange: me, onDrop: ge, className: Te}, _e) => {
    const Se = reactExports.useRef(null)
      , Ie = V.map( () => reactExports.createRef())
      , ye = reactExports.useRef(null)
      , $e = reactExports.useRef(null)
      , Ne = reactExports.useRef(void 0)
      , ve = reactExports.useRef(void 0)
      , [ke,xe] = reactExports.useState()
      , [we,Fe] = reactExports.useState(!1)
      , je = at => () => {
        (Ne.current === void 0 || at !== Ne.current && !ue) && (Ne.current = at,
        xe(at))
    }
      , Xe = (at, rt) => () => {
        const ft = at + (rt ? -1 : 1);
        me(moveArrayElem(V, at, ft), {
            newPosition: ft
        })
    }
      , ze = reactExports.useCallback( (at, rt) => {
        var ft;
        if (ye.current && !ue) {
            const St = (ft = Ie.find( (Ye, We) => We === at)) == null ? void 0 : ft.current;
            Fe(!0),
            rt ? St == null || St.after(ye.current) : St == null || St.before(ye.current)
        }
    }
    , [ue, Ie])
      , qe = () => {
        ye.current && $e.current && ($e.current.append(ye.current),
        ve.current = void 0,
        Ne.current = void 0,
        xe(void 0),
        Fe(!1))
    }
      , Ze = () => {
        var at;
        ye.current && ve.current === void 0 && !ue && ne && (ve.current = V.length,
        (at = Se == null ? void 0 : Se.current) == null || at.append(ye.current),
        Fe(!0))
    }
      , et = at => {
        if (ve.current !== void 0 && Se.current && !ue && ne) {
            const rt = at.y || at.clientY
              , ft = at.x || at.clientX
              , {bottom: St, top: Ye, right: We, left: nt} = Se.current.getBoundingClientRect();
            (ft >= We || ft <= nt || rt >= St || rt <= Ye) && qe()
        }
    }
    ;
    reactExports.useEffect( () => {
        const at = V.map( (ft, St) => Ye => {
            const We = Ie[St].current;
            if (ye.current && We && !ue) {
                const nt = Ye.y || Ye.clientY
                  , {height: ct, top: Et} = We.getBoundingClientRect();
                ct / 2 >= nt - Et ? (ze(St),
                Ne.current !== void 0 ? ve.current = Ne.current >= St ? St : St - 1 : ve.current = St) : (ze(St, !0),
                Ne.current !== void 0 ? ve.current = Ne.current <= St ? St : St + 1 : ve.current = St + 1)
            }
        }
        )
          , rt = ft => {
            if (Se.current && ve.current !== void 0 && ge && Ne.current === void 0 && !ue && ne) {
                const St = ft.y || ft.clientY
                  , Ye = ft.x || ft.clientX
                  , {right: We, top: nt, bottom: ct, left: Et} = Se.current.getBoundingClientRect();
                Ye <= We && Ye >= Et && St <= ct && St >= nt && (ge(ve.current),
                qe())
            }
        }
        ;
        return Ie.forEach( (ft, St) => {
            var Ye;
            (Ye = ft.current) == null || Ye.addEventListener("dragover", at[St])
        }
        ),
        document.addEventListener("drop", rt),
        () => {
            Ie.forEach( (ft, St) => {
                var Ye;
                (Ye = ft.current) == null || Ye.removeEventListener("dragover", at[St])
            }
            ),
            document.removeEventListener("drop", rt)
        }
    }
    , [ze, Ie, V, ge, ue, ne]),
    reactExports.useEffect( () => {
        var at, rt;
        return (at = Se.current) == null || at.addEventListener("dragover", Ze),
        (rt = Se.current) == null || rt.addEventListener("dragleave", et),
        () => {
            var ft, St;
            (ft = Se.current) == null || ft.removeEventListener("dragover", Ze),
            (St = Se.current) == null || St.removeEventListener("dragleave", et)
        }
    }
    , [V.length]);
    const it = () => {
        Ne.current !== void 0 && ve.current !== void 0 && me(moveArrayElem(V, Ne.current, ve.current), {
            newPosition: Ne.current
        }),
        qe()
    }
    ;
    return jsxRuntimeExports.jsxs("div", {
        ref: _e,
        className: classNames(styles$m$1.wrapper, Te),
        children: [V.length === 0 && !we && jsxRuntimeExports.jsx("div", {
            className: styles$m$1.placeholder,
            children: J
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$m$1.list,
            ref: Se,
            children: [V.map( (at, rt) => jsxRuntimeExports.jsx("div", {
                className: classNames(styles$m$1.itemWrapper, rt === ke && styles$m$1.beingDragged, (ue || !ne) && styles$m$1.isDisabled),
                ref: Ie[rt],
                children: jsxRuntimeExports.jsxs(Draggable, {
                    onDropTargetHover: je(rt),
                    onDragFinish: it,
                    dropTargetRef: Se,
                    className: styles$m$1.itemContent,
                    isDisabled: ue || !ne,
                    children: [ne ? jsxRuntimeExports.jsx("div", {
                        className: styles$m$1.grip,
                        children: jsxRuntimeExports.jsx(Icon, {
                            name: ICON_NAMES.HAMBURGER,
                            className: styles$m$1.gripIcon,
                            size: ICON_SIZES.XS
                        })
                    }) : jsxRuntimeExports.jsxs("div", {
                        className: styles$m$1.orderUpDownArrows,
                        children: [jsxRuntimeExports.jsx(IconButton, {
                            icon: ICON_NAMES.CHEVRON_UP_90,
                            onClick: Xe(rt, !0),
                            isDisabled: rt <= 0
                        }), jsxRuntimeExports.jsx(IconButton, {
                            icon: ICON_NAMES.CHEVRON_DOWN_90,
                            onClick: Xe(rt, !1),
                            isDisabled: rt >= V.length - 1
                        })]
                    }), at]
                })
            }, rt)), ce && !!V.length && !we && J]
        }), jsxRuntimeExports.jsx("div", {
            className: styles$m$1.previewParking,
            ref: $e,
            children: jsxRuntimeExports.jsx("div", {
                className: styles$m$1.preview,
                ref: ye,
                children: X
            })
        })]
    })
}
);
DragSortList.displayName = "DragSortList";
var styles$l$1 = {
    container: "choice-sorter-module_container__pDyjs",
    isMobile: "choice-sorter-module_isMobile__OElLL",
    isCollapsed: "choice-sorter-module_isCollapsed__BpZfM",
    column: "choice-sorter-module_column__SNuln",
    list: "choice-sorter-module_list__3W-Ft",
    choices: "choice-sorter-module_choices__jXuai",
    choice: "choice-sorter-module_choice__doPkZ",
    isDisabled: "choice-sorter-module_isDisabled__G4MIl",
    heading: "choice-sorter-module_heading__q-JcH"
};
const ChoiceSorter = ({dropPlaceholder: V, emptyPlaceholder: X, choices: J=[], activeItems: ne=[], max: ue, choicesClassName: ce, containerClassName: me, columnClassName: ge, activeListClassName: Te, selectionsListClassName: _e, choicesTitle: Se, activeItemsTitle: Ie, isDisabled: ye, choicesSectionCollapsed: $e, activeItemsSectionCollapsed: Ne, showEmptyPlaceholderBelowDropArea: ve, mobileView: ke, onChange: xe}) => {
    const we = reactExports.useContext(CurrentBreakpointContext)
      , {breakpoints: Fe} = reactExports.useContext(ThemeContext)
      , je = ue !== void 0 && ne.length >= ue
      , Xe = reactExports.useRef(null)
      , ze = reactExports.useRef(void 0)
      , qe = getMobileFirstOption(ke, we, Fe) ?? !0
      , Ze = (at, {newPosition: rt}) => {
        xe && xe(at, {
            isNewItem: !1,
            newPosition: rt
        })
    }
      , et = at => () => {
        ze.current = at
    }
      , it = at => {
        if (ze.current !== void 0) {
            const rt = J[ze.current]
              , ft = insertIntoArrayAtPosition(ne, rt, at);
            xe && xe(ft, {
                isNewItem: !0,
                newPosition: at
            })
        }
    }
    ;
    return jsxRuntimeExports.jsxs("div", {
        className: classNames(styles$l$1.container, me, qe && styles$l$1.isMobile),
        children: [jsxRuntimeExports.jsxs("div", {
            className: classNames(styles$l$1.column, ge),
            children: [Se && jsxRuntimeExports.jsx("div", {
                className: styles$l$1.heading,
                children: Se
            }), jsxRuntimeExports.jsx("div", {
                className: classNames(styles$l$1.choices, ce, $e && qe && styles$l$1.isCollapsed),
                children: J.map( (at, rt) => jsxRuntimeExports.jsx(Draggable, {
                    isDisabled: je || ye || qe,
                    onDropTargetHover: et(rt),
                    dropTargetRef: Xe,
                    className: classNames(styles$l$1.choice, (je || qe) && styles$l$1.isDisabled),
                    children: at
                }, rt))
            })]
        }), jsxRuntimeExports.jsxs("div", {
            className: classNames(styles$l$1.column, styles$l$1.activeColumn, ge, Te),
            children: [Ie && jsxRuntimeExports.jsx("div", {
                className: styles$l$1.heading,
                children: Ie
            }), jsxRuntimeExports.jsx(DragSortList, {
                dropPlaceholder: V,
                emptyPlaceholder: X,
                className: classNames(styles$l$1.list, Ne && qe && styles$l$1.isCollapsed, _e),
                items: ne,
                isDisabled: ye,
                isDraggable: !qe,
                onChange: Ze,
                onDrop: it,
                showEmptyPlaceholderBelowDropArea: !qe && ve,
                ref: Xe
            })]
        })]
    })
}
;
var styles$k$1 = {
    container: "rangeInput-module_container__OjxtN",
    error: "rangeInput-module_error__KXLQE",
    sizeMd: "rangeInput-module_sizeMd__OknTj",
    sizeSm: "rangeInput-module_sizeSm__pgd9d",
    track: "rangeInput-module_track__hPX9a",
    disabled: "rangeInput-module_disabled__RlyxN",
    fill: "rangeInput-module_fill__0H3t7",
    unavailable: "rangeInput-module_unavailable__QQSDX",
    input: "rangeInput-module_input__1EfSK"
}, RANGE_INPUT_SIZE;
(function(V) {
    V.SM = "sm",
    V.MD = "md"
}
)(RANGE_INPUT_SIZE || (RANGE_INPUT_SIZE = {}));
const RangeInput = ({label: V, max: X, min: J=0, className: ne="", size: ue=RANGE_INPUT_SIZE.MD, step: ce, value: me=J, unavailable: ge, disabled: Te, error: _e, colors: Se, disabledColors: Ie, onChange: ye}) => {
    const $e = reactExports.useContext(ThemeContext)
      , Ne = reactExports.useRef(null)
      , ve = me === void 0 ? 100 : getPercentage(X - me, X - J)
      , ke = xe => {
        ye(Number(xe.target.value), X - Number(xe.target.value))
    }
    ;
    return jsxRuntimeExports.jsxs("div", {
        className: classNames(styles$k$1.container, Te && styles$k$1.disabled, _e && styles$k$1.error, ue === RANGE_INPUT_SIZE.MD && styles$k$1.sizeMd, ue === RANGE_INPUT_SIZE.SM && styles$k$1.sizeSm, ne),
        children: [jsxRuntimeExports.jsx("div", {
            className: styles$k$1.track,
            ref: Ne,
            style: (Se || Ie) && {
                backgroundColor: `${Te ? (Ie == null ? void 0 : Ie.remaining) ?? $e.colors.gray600 : (Se == null ? void 0 : Se.remaining) ?? $e.colors.primary}`
            },
            children: jsxRuntimeExports.jsx("div", {
                className: classNames(styles$k$1.fill, ge && styles$k$1.unavailable),
                style: {
                    right: `${ve}%`,
                    ...(Se || Ie) && {
                        backgroundColor: `${Te ? (Ie == null ? void 0 : Ie.fill) ?? $e.colors.gray700 : (Se == null ? void 0 : Se.fill) ?? $e.colors.gray300}`
                    }
                }
            })
        }), jsxRuntimeExports.jsx("label", {
            className: "visuallyHidden",
            children: V
        }), jsxRuntimeExports.jsx("input", {
            className: styles$k$1.input,
            type: "range",
            value: me,
            step: ce,
            min: J.toString(),
            max: X.toString(),
            disabled: Te,
            onChange: ke
        })]
    })
}
;
var styles$i$1 = {
    dropdown: "dropdown-module_dropdown__ky7s2",
    fillWidth: "dropdown-module_fillWidth__u3I69",
    trigger: "dropdown-module_trigger__NM4-2",
    unavailable: "dropdown-module_unavailable__Tasd-",
    disabled: "dropdown-module_disabled__QWBoG",
    label: "dropdown-module_label__ps9HB",
    list: "dropdown-module_list__mkxNl",
    open: "dropdown-module_open__b7w6e",
    listItem: "dropdown-module_listItem__H9udE",
    itemDisabled: "dropdown-module_itemDisabled__OK4ap",
    selected: "dropdown-module_selected__0r70J",
    listItemContent: "dropdown-module_listItemContent__qphyt",
    compact: "dropdown-module_compact__4weLJ"
};
const Dropdown = ({items: V, value: X, placeholder: J, fillWidth: ne=!1, compact: ue=!1, disabled: ce, unavailable: me, onChange: ge}) => {
    var at;
    const [Te,_e] = reactExports.useState(!1)
      , [Se,Ie] = reactExports.useState()
      , ye = reactExports.useRef(null)
      , $e = reactExports.useRef(null)
      , ve = `list-${reactExports.useId()}`
      , ke = document.documentElement.dir === "rtl"
      , [xe,we] = useOnWindowResize(30)
      , Fe = reactExports.useRef(document.body)
      , je = reactExports.useCallback( () => {
        if (ye.current && $e.current) {
            const {x: rt, y: ft} = computeRelativeCoordinates({
                target: ye.current,
                elementToPlace: $e.current,
                isRtl: ke,
                offset: 0,
                placement: PLACEMENT.BOTTOM_LEFT,
                alignToEdge: !0
            });
            $e.current.style.left = `${rt}px`,
            $e.current.style.top = `${ft}px`
        }
    }
    , [ke])
      , Xe = () => {
        _e(!Te)
    }
      , ze = reactExports.useCallback(rt => {
        ge && ge(rt)
    }
    , [ge])
      , qe = rt => {
        var ft;
        (ft = ye == null ? void 0 : ye.current) != null && ft.contains(rt.target) || _e(!1)
    }
      , Ze = reactExports.useCallback(rt => {
        var Ye, We;
        const ft = [...((Ye = $e.current) == null ? void 0 : Ye.children) ?? []]
          , St = et();
        if (St)
            if (rt) {
                const nt = St.nextSibling;
                nt == null || nt.focus()
            } else {
                const nt = St.previousSibling;
                nt == null || nt.focus()
            }
        else {
            const nt = X === void 0 ? (We = $e.current) == null ? void 0 : We.firstChild : ft.find(ct => X === ct.getAttribute("value"));
            nt && nt.focus()
        }
    }
    , [X])
      , et = () => {
        var St;
        const rt = document.activeElement;
        return [...((St = $e.current) == null ? void 0 : St.children) ?? []].find(Ye => Ye === rt)
    }
      , it = reactExports.useCallback(rt => {
        var ft;
        if (Te)
            switch (rt.preventDefault(),
            rt.stopPropagation(),
            rt.code) {
            case "Tab":
                rt.shiftKey ? Ze(!1) : Ze(!0);
                break;
            case "PageUp":
            case "ArrowUp":
                Ze(!1);
                break;
            case "PageDown":
            case "ArrowDown":
                Ze(!0);
                break;
            case "Space":
            case "Enter":
                {
                    const St = et();
                    if (St) {
                        const Ye = St.getAttribute("value")
                          , We = (ft = V[+(Ye ?? 0)]) == null ? void 0 : ft.value;
                        We && (ze(We),
                        _e(!1))
                    }
                    break
                }
            case "Escape":
                _e(!1)
            }
    }
    , [Te, Ze, V, ze]);
    return reactExports.useEffect( () => (Te ? document.addEventListener("keydown", it, !0) : document.removeEventListener("keydown", it, !0),
    () => document.removeEventListener("keydown", it, !0)), [Te, it]),
    reactExports.useEffect( () => {
        Te && (je(),
        $e.current && ye.current && Ie(ye.current.offsetWidth))
    }
    , [we, xe, Te, Se, je]),
    reactExports.useEffect( () => (Te ? document.addEventListener("click", qe, !0) : document.removeEventListener("click", qe, !0),
    () => {
        document.removeEventListener("click", qe, !0)
    }
    ), [Te]),
    jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsx("div", {
            className: classNames(styles$i$1.dropdown, ne && styles$i$1.fillWidth, ce && styles$i$1.disabled),
            children: jsxRuntimeExports.jsx("button", {
                className: classNames(styles$i$1.trigger, me && styles$i$1.unavailable),
                type: BUTTON_TYPES$1.BUTTON,
                ref: ye,
                onClick: Xe,
                role: "combobox",
                "aria-controls": ve,
                "aria-haspopup": "listbox",
                "aria-expanded": Te,
                tabIndex: 0,
                children: jsxRuntimeExports.jsxs("span", {
                    className: styles$i$1.label,
                    children: [me ? "--" : ((at = V.find( ({value: rt}) => rt === X)) == null ? void 0 : at.content) ?? J, " ", jsxRuntimeExports.jsx(Icon, {
                        name: ICON_NAMES.CHEVRON_DOWN_90
                    })]
                })
            })
        }), reactDomExports.createPortal(jsxRuntimeExports.jsx("div", {
            className: classNames(styles$i$1.list, Te && styles$i$1.open),
            role: "listbox",
            ref: $e,
            tabIndex: 0,
            ...Se && {
                style: {
                    minWidth: `${Se}px`
                }
            },
            children: V.map( ({value: rt, content: ft}, St) => jsxRuntimeExports.jsx("button", {
                type: BUTTON_TYPES$1.BUTTON,
                value: St,
                id: ve,
                tabIndex: -1,
                disabled: ce,
                className: classNames(styles$i$1.listItem, X === rt && styles$i$1.selected, ce && styles$i$1.itemDisabled),
                onClick: () => {
                    ze(rt)
                }
                ,
                children: jsxRuntimeExports.jsx("div", {
                    className: classNames(styles$i$1.listItemContent, ue && styles$i$1.compact),
                    children: ft
                })
            }, St))
        }), Fe.current)]
    })
}
;
var styles$h$1 = {
    container: "icon-tile-radio-module_container__mDFMo",
    button: "icon-tile-radio-module_button__Bim2-",
    active: "icon-tile-radio-module_active__WjGib",
    icon: "icon-tile-radio-module_icon__3u83s",
    content: "icon-tile-radio-module_content__43VfU",
    activeWithSecondaryAction: "icon-tile-radio-module_activeWithSecondaryAction__OyefW",
    iconContainer: "icon-tile-radio-module_iconContainer__RY2cC",
    label: "icon-tile-radio-module_label__nM2zt"
};
const IconTileRadio = ({icon: V, label: X, isActive: J, secondaryActionLabel: ne, testId: ue, onClick: ce, onMouseOver: me, onSecondaryActionClick: ge}) => {
    const Te = () => {
        ce()
    }
    ;
    return jsxRuntimeExports.jsxs("div", {
        className: styles$h$1.container,
        children: [jsxRuntimeExports.jsx("button", {
            type: BUTTON_TYPES$1.BUTTON,
            className: classNames(styles$h$1.button, J && styles$h$1.active, J && ge && ne && styles$h$1.activeWithSecondaryAction),
            onClick: Te,
            "aria-checked": J,
            onMouseOver: me,
            "data-testid": ue,
            role: "radio",
            children: jsxRuntimeExports.jsxs("div", {
                className: styles$h$1.content,
                children: [jsxRuntimeExports.jsx("div", {
                    className: styles$h$1.iconContainer,
                    children: jsxRuntimeExports.jsx(Icon, {
                        name: V,
                        size: ICON_SIZES.FILL,
                        className: styles$h$1.icon
                    })
                }), jsxRuntimeExports.jsx("div", {
                    className: styles$h$1.label,
                    children: X
                })]
            })
        }), ge && ne && J && jsxRuntimeExports.jsx(Button, {
            fillWidth: !0,
            onClick: ge,
            children: ne
        })]
    })
}
;
var styles$g$1 = {
    gallery: "image-gallery-module_gallery__WLL8N",
    imageWrapper: "image-gallery-module_imageWrapper__PMsxI",
    button: "image-gallery-module_button__d5vd0",
    selected: "image-gallery-module_selected__ODPU9",
    selectedIcon: "image-gallery-module_selectedIcon__bzKbA",
    selectableImage: "image-gallery-module_selectableImage__WQtRx",
    addNewButton: "image-gallery-module_addNewButton__tN3Ld"
};
const ImageGallery = ({images: V, picks: X, onChange: J, onAddNew: ne, addNewIconColor: ue}) => {
    const {colors: ce} = reactExports.useContext(ThemeContext)
      , me = ge => () => {
        J && J(ge)
    }
    ;
    return jsxRuntimeExports.jsxs("div", {
        className: styles$g$1.gallery,
        children: [V.map( ({id: ge, src: Te, alt: _e}, Se) => {
            const Ie = X == null ? void 0 : X.includes(ge ?? Te);
            return J ? jsxRuntimeExports.jsxs("button", {
                className: classNames(styles$g$1.button, Ie && styles$g$1.selected, styles$g$1.selectableImage),
                onClick: me(ge ?? Te),
                children: [jsxRuntimeExports.jsx("img", {
                    src: Te,
                    alt: _e
                }), Ie && jsxRuntimeExports.jsx("div", {
                    className: styles$g$1.selectedIcon,
                    children: jsxRuntimeExports.jsx(Checkbox, {
                        checked: !0,
                        positive: !0
                    })
                })]
            }, Se) : jsxRuntimeExports.jsx("div", {
                className: styles$g$1.imageWrapper,
                children: jsxRuntimeExports.jsx("img", {
                    src: Te,
                    alt: _e
                })
            })
        }
        ), ne ? jsxRuntimeExports.jsx("button", {
            className: classNames(styles$g$1.button, styles$g$1.selectableImage, styles$g$1.addNewButton),
            onClick: ne,
            children: jsxRuntimeExports.jsx(Icon, {
                name: ICON_NAMES.PLUS,
                color: ue || ce.primary
            })
        }) : null]
    })
}
  , IncrementMutator = ({value: V, min: X, max: J, labels: ne, title: ue, caption: ce, disabled: me, unavailable: ge, footer: Te, error: _e, step: Se, enforceStep: Ie, onChange: ye, onBlur: $e}) => jsxRuntimeExports.jsx(Mutator$1, {
    title: ue,
    caption: ce,
    isDisabled: me,
    error: _e,
    input: jsxRuntimeExports.jsx(Incrementor, {
        isDisabled: me,
        labels: ne,
        count: V,
        max: J,
        min: X,
        step: Se,
        enforceStep: Ie,
        onChange: ye,
        onBlur: $e,
        error: _e,
        unavailable: ge
    }),
    footer: Te
});
var styles$f$1 = {
    link: "link-module_link__vby5l"
};
const Link$1 = ({to: V, outsideLink: X, children: J, className: ne, onClick: ue}) => jsxRuntimeExports.jsx("a", {
    className: classNames((V || ue) && styles$f$1.link, ne),
    onClick: ue,
    href: V,
    ...X && {
        target: "_blank"
    },
    children: J
});
var styles$e$1 = {
    container: "media-radio-module_container__Elzdk",
    isActive: "media-radio-module_isActive__weSzg",
    tall: "media-radio-module_tall__HlTCG",
    short: "media-radio-module_short__q7ucy",
    flat: "media-radio-module_flat__WQDYH",
    contentWrapper: "media-radio-module_contentWrapper__ET7rW",
    content: "media-radio-module_content__CnTmh"
}, MEDIA_BUTTON_ASPECT_RATIO;
(function(V) {
    V.FLAT = "flat",
    V.SHORT = "short",
    V.TALL = "tall"
}
)(MEDIA_BUTTON_ASPECT_RATIO || (MEDIA_BUTTON_ASPECT_RATIO = {}));
const MediaRadio = ({fgImage: V, bgImage: X, aspectRatio: J=MEDIA_BUTTON_ASPECT_RATIO.TALL, text: ne, isActive: ue, color: ce, testId: me, onClick: ge, onMouseOver: Te, onMouseOut: _e}) => {
    const Se = reactExports.useContext(CurrentBreakpointContext)
      , {colors: Ie, breakpoints: ye} = reactExports.useContext(ThemeContext)
      , $e = getMobileFirstOption(J, Se, ye) ?? MEDIA_BUTTON_ASPECT_RATIO.TALL
      , Ne = getMobileFirstOption(X, Se, ye) ?? "";
    return jsxRuntimeExports.jsx("button", {
        className: classNames(styles$e$1.container, styles$e$1[$e], ue && styles$e$1.isActive),
        onClick: ge,
        role: "radio",
        "aria-checked": ue,
        onMouseOver: Te,
        onMouseOut: _e,
        "data-testid": me,
        type: BUTTON_TYPES$1.BUTTON,
        style: {
            "--bg-image": `url(${Ne})`,
            "--brand-color": `${ce ?? Ie.primary}`
        },
        children: jsxRuntimeExports.jsx("div", {
            className: styles$e$1.contentWrapper,
            children: V ? jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                children: [jsxRuntimeExports.jsx("img", {
                    className: styles$e$1.content,
                    src: V
                }), jsxRuntimeExports.jsx("span", {
                    className: "visuallyHidden",
                    children: ne
                })]
            }) : jsxRuntimeExports.jsx("span", {
                className: styles$e$1.content,
                children: ne
            })
        })
    })
}
;
var styles$d$1 = {
    container: "media-radio-group-module_container__r0wx3",
    iconVariant: "media-radio-group-module_iconVariant__0D6Uz"
}, MEDIA_RADIO_GROUP_VARIANT;
(function(V) {
    V.ICON = "icon",
    V.MEDIA = "media"
}
)(MEDIA_RADIO_GROUP_VARIANT || (MEDIA_RADIO_GROUP_VARIANT = {}));
const MediaRadioGroup = ({radios: V, name: X, variant: J=MEDIA_RADIO_GROUP_VARIANT.MEDIA, color: ne, activeValue: ue, className: ce, isDisabled: me, onChange: ge, onSecondaryActionClick: Te}) => {
    const {colors: _e} = reactExports.useContext(ThemeContext)
      , Se = reactExports.useId()
      , Ie = $e => () => {
        me || ge($e)
    }
      , ye = () => {
        Te && Te()
    }
    ;
    return jsxRuntimeExports.jsxs("div", {
        className: classNames(styles$d$1.container, J === MEDIA_RADIO_GROUP_VARIANT.ICON && styles$d$1.iconVariant, ce),
        "aria-labelledby": Se,
        role: "radiogroup",
        children: [jsxRuntimeExports.jsx("span", {
            className: "visuallyHidden",
            id: Se,
            children: X
        }), V.map( ($e, Ne) => "icon"in $e && J === MEDIA_RADIO_GROUP_VARIANT.ICON ? jsxRuntimeExports.jsx(IconTileRadio, {
            ...$e,
            testId: $e.testId,
            onClick: Ie($e.value),
            isActive: ue === $e.value,
            onSecondaryActionClick: ye
        }, Ne) : !("icon"in $e) && J === MEDIA_RADIO_GROUP_VARIANT.MEDIA ? jsxRuntimeExports.jsx(MediaRadio, {
            color: ne ?? _e.primary,
            ...$e,
            testId: $e.testId,
            onClick: Ie($e.value),
            isActive: ue === $e.value
        }, Ne) : null)]
    })
}
;
var styles$c$1 = {
    item: "menu-item-module_item__S1V0Y"
};
const MenuItem = ({children: V, onClick: X}) => jsxRuntimeExports.jsx("button", {
    onClick: X,
    type: "button",
    className: styles$c$1.item,
    children: V
});
var styles$b$1 = {
    list: "menu-item-list-module_list__Pvr-z"
};
const MenuItemList = ({items: V}) => jsxRuntimeExports.jsx(Well, {
    padding: WELL_PADDING_SIZE.SM,
    variant: WELL_VARIANT.SECONDARY,
    className: styles$b$1.list,
    children: V
});
var styles$a$1 = {
    inputs: "number-mutator-module_inputs__fLET6",
    error: "number-mutator-module_error__Mzwod",
    grow: "number-mutator-module_grow__9SsIY",
    textInput: "number-mutator-module_textInput__cgEKT"
};
const NumberMutator = ({title: V, options: X, precision: J, step: ne, value: ue, caption: ce, isDisabled: me, unavailable: ge, formatter: Te, error: _e, testId: Se, className: Ie, onChange: ye, onBlur: $e}) => {
    const [Ne,ve] = reactExports.useState(Array.isArray(ue) ? ue[0] === ue[1] : !0)
      , ke = J && precisionToStep(J)
      , xe = Array.isArray(X) ? X : [X]
      , we = Array.isArray(ue) ? ue : [ue]
      , [Fe,je] = reactExports.useState("")
      , [Xe,ze] = reactExports.useState("")
      , [qe,Ze] = reactExports.useState(!1);
    let et = !1;
    const it = nt => {
        if (Te != null && Te.format) {
            const ct = Number(nt);
            return isNaN(ct) || nt === void 0 || nt === "" ? nt : (Te == null ? void 0 : Te.format(ct)) ?? ""
        }
        return nt
    }
      , at = nt => {
        if (Te != null && Te.parse) {
            if (typeof nt == "string")
                if (nt !== "" && nt !== "-") {
                    const ct = Te.parse(nt);
                    return ct !== void 0 && !isNaN(+ct) ? {
                        value: +ct,
                        isSuccessful: !0
                    } : {
                        value: "",
                        isSuccessful: !1
                    }
                } else
                    return {
                        value: nt,
                        isSuccessful: !0
                    };
            else if (typeof nt == "number")
                return {
                    value: nt,
                    isSuccessful: !0
                }
        }
        return {
            value: nt,
            isSuccessful: !0
        }
    }
      , rt = nt => ct => {
        const {value: Et, isSuccessful: Ke} = at(ct);
        Ke && (nt === 0 ? ye && ye(Array.isArray(X) ? [Et, Ne ? Et : we[1]] : Et) : ye && ye([Ne ? Et : we[0], Et])),
        nt === 0 ? je(ct) : ze(ct)
    }
      , ft = nt => {
        ve(nt)
    }
      , St = nt => ct => {
        const {value: Et, isSuccessful: Ke} = at(ct)
          , {min: mt, max: lt} = xe[nt]
          , Qe = Ke && Te && (typeof Et == "number" || !isNaN(Number(Et)))
          , gt = Qe ? clamp(mt, lt, Number(Et)) : Et;
        Qe && gt !== Number(Et) && ye && rt(nt)(gt),
        nt === 0 ? (je(ct),
        Ze(!1),
        $e && $e(Array.isArray(X) ? [gt, Ne ? gt : we[1]] : Et)) : (ze(ct),
        Ze(!1),
        $e && $e([Ne ? gt : we[0], gt]))
    }
      , Ye = () => {
        Ze(!0),
        je(it(we[0])),
        ze(it(we[1]))
    }
      , We = xe.map( ({label: nt, max: ct, min: Et}, Ke) => {
        const mt = we[Ne ? 0 : Ke]
          , lt = qe ? mt : it(mt)
          , Qe = +mt
          , gt = !isNaN(Qe)
          , Nt = gt ? Qe : +mt
          , Gt = gt ? clamp(+Nt, Et, ct) : +mt
          , Ht = Nt <= ct && Nt >= Et && gt || !gt
          , Kt = Ke === 0 ? Fe : Xe;
        return et = !Ht,
        jsxRuntimeExports.jsxs("div", {
            className: classNames(styles$a$1.inputs, styles$a$1.grow),
            children: [jsxRuntimeExports.jsx(RangeInput, {
                className: styles$a$1.grow,
                label: nt,
                max: ct,
                min: Et,
                value: Gt,
                size: RANGE_INPUT_SIZE.SM,
                step: ne ?? ke,
                disabled: Ne && Ke === 1 || me,
                unavailable: ge,
                onChange: rt(Ke)
            }), jsxRuntimeExports.jsx(TextInput, {
                className: classNames(styles$a$1.textInput, !Ht && styles$a$1.error),
                type: Te ? TEXT_INPUT_TYPES.TEXT : TEXT_INPUT_TYPES.NUMBER,
                label: nt,
                max: ct,
                min: Et,
                precision: J,
                step: ne,
                disabled: Ne && Ke === 1 || me,
                textAlign: TEXT_ALIGNMENT_TYPES.CENTER,
                value: qe ? Kt : lt,
                unavailable: ge,
                onChange: rt(Ke),
                onBlur: St(Ke),
                onFocus: Ye
            })]
        }, Ke)
    }
    );
    return jsxRuntimeExports.jsx(Mutator$1, {
        title: V,
        caption: ce,
        onLink: ft,
        isDisabled: me,
        isLinked: Ne,
        testId: Se,
        input: We.length === 1 ? We[0] : We,
        className: Ie,
        error: _e || et
    })
}
;
var styles$9$1 = {
    container: "radio-module_container__vKw5g",
    disabled: "radio-module_disabled__3bEdQ",
    button: "radio-module_button__rVjEm",
    selected: "radio-module_selected__SjUcC",
    content: "radio-module_content__8HIyq"
};
const Radio = ({name: V, options: X, fillWidth: J=!1, disabled: ne=!1, value: ue, onChange: ce}) => {
    const me = reactExports.useId()
      , ge = Te => () => {
        ce && ce(Te)
    }
    ;
    return jsxRuntimeExports.jsxs("div", {
        className: classNames(styles$9$1.container, ne && styles$9$1.disabled),
        style: J ? {
            width: "100%"
        } : {},
        role: "radiogroup",
        "aria-labelledby": me,
        children: [jsxRuntimeExports.jsx("span", {
            className: "visuallyHidden",
            id: me,
            children: V
        }), X.map( ({label: Te, value: _e}) => jsxRuntimeExports.jsx("button", {
            type: BUTTON_TYPES$1.BUTTON,
            role: "radio",
            "aria-checked": `${ue}` == `${_e}`,
            onClick: ge(_e),
            value: `${_e}`,
            disabled: ne,
            className: classNames(styles$9$1.button, ue === _e && styles$9$1.selected),
            children: jsxRuntimeExports.jsx("span", {
                className: styles$9$1.content,
                children: Te
            })
        }, `${_e}`))]
    })
}
  , SelectMutator = ({title: V, options: X, value: J, caption: ne, isDisabled: ue, unavailable: ce, testId: me, className: ge, onChange: Te}) => {
    const [_e,Se] = reactExports.useState(Array.isArray(J) ? J[0] === J[1] : !0)
      , Ie = Array.isArray(X) ? X : [X]
      , ye = Array.isArray(J) ? J : [J]
      , $e = xe => {
        Te && Te([_e ? xe : ye[0], xe])
    }
      , Ne = xe => {
        Te && Te(Array.isArray(X) ? [xe, _e ? xe : ye[1]] : xe)
    }
      , ve = xe => {
        Se(xe)
    }
      , ke = Ie.map( ({items: xe, placeholder: we}, Fe) => {
        const je = ye == null ? void 0 : ye[_e ? 0 : Fe];
        return jsxRuntimeExports.jsx(Dropdown, {
            fillWidth: !0,
            placeholder: we,
            items: xe.map( ({label: Xe, value: ze}) => ({
                content: Xe,
                value: ze
            })),
            disabled: _e && Fe === 1 || ue,
            value: je,
            onChange: Fe === 1 ? $e : Ne,
            unavailable: ce
        }, Fe)
    }
    );
    return jsxRuntimeExports.jsx(Mutator$1, {
        title: V,
        isDisabled: ue,
        caption: ne,
        onLink: ve,
        isLinked: _e,
        input: ke.length === 1 ? ke[0] : ke,
        testId: me,
        className: ge
    })
}
;
var styles$8$1 = {
    tab: "tab-module_tab__KBO2-",
    active: "tab-module_active__lrSrz",
    disabled: "tab-module_disabled__IEp4b",
    activeIcon: "tab-module_activeIcon__GVQ1Q"
};
const Tab = ({active: V, disabled: X, children: J}) => jsxRuntimeExports.jsxs("div", {
    className: classNames(styles$8$1.tab, V && styles$8$1.active, X && styles$8$1.disabled),
    children: [J, V && jsxRuntimeExports.jsx(Icon, {
        className: styles$8$1.activeIcon,
        name: ICON_NAMES.TRIANGLE,
        size: ICON_SIZES.XS
    })]
});
var styles$7$1 = {
    tabBar: "tab-list-module_tabBar__hwnVo",
    hidden: "tab-list-module_hidden__uqTQ-",
    tabsContainer: "tab-list-module_tabsContainer__MF7MW",
    tabs: "tab-list-module_tabs__rzXLw",
    tab: "tab-list-module_tab__WjFZU",
    scrollButtonWrapper: "tab-list-module_scrollButtonWrapper__YSYUc"
};
const TabList = ({tabs: V, ariaId: X, activeTabIndex: J, scrollBeforeIcon: ne=ICON_NAMES.CHEVRON_LEFT, scrollAfterIcon: ue=ICON_NAMES.CHEVRON_RIGHT, onTabClick: ce}) => {
    const [me] = useOnWindowResize()
      , ge = reactExports.useRef(null)
      , Te = reactExports.useRef(null)
      , [_e,Se] = reactExports.useState(!1)
      , [Ie,ye] = reactExports.useState(!1)
      , [$e,Ne] = reactExports.useState(!1)
      , ve = Fe => () => {
        ce && ce(Fe)
    }
      , ke = () => {
        if (!ge.current)
            return;
        const {scrollLeft: Fe, clientWidth: je, scrollWidth: Xe} = ge.current
          , ze = Math.floor(Xe) - (Math.floor(je) + Math.floor(Fe))
          , qe = ze < 2 && ze > -2;
        ye(!!Fe),
        Ne(!qe)
    }
      , xe = Fe => () => {
        if (!Te.current || !ge.current)
            return;
        const {childNodes: je} = Te.current
          , {offsetLeft: Xe, scrollLeft: ze, clientWidth: qe} = ge.current
          , Ze = Array.from(je)
          , et = Ze.findIndex(rt => {
            const {offsetLeft: ft=0, clientWidth: St=0} = rt
              , Ye = ft - Xe;
            return Fe ? Ye < ze && Ye + St > ze : St + Ye - ze > qe
        }
        )
          , it = Fe ? 0 : Ze.length
          , at = Ze[et === -1 ? it : et];
        at && at.scrollIntoView({
            behavior: "smooth",
            block: "nearest",
            inline: Fe ? "end" : "start"
        })
    }
      , we = () => {
        ge.current && _e && ke()
    }
    ;
    return reactExports.useEffect( () => {
        if (ge.current) {
            const {clientWidth: Fe, scrollWidth: je} = ge.current;
            je > Fe ? (Se(!0),
            ke()) : Se(!1)
        }
    }
    , [me]),
    jsxRuntimeExports.jsxs("div", {
        className: classNames(styles$7$1.tabBar),
        role: "tablist",
        children: [_e && jsxRuntimeExports.jsx("div", {
            className: styles$7$1.scrollButtonWrapper,
            children: jsxRuntimeExports.jsx(IconButton, {
                className: classNames(!Ie && styles$7$1.hidden),
                transparent: !0,
                color: "var(--tmln-ui-tabs-tab-name-color)",
                hoverColor: "var(--tmln-ui-tabs-tab-name-color)",
                icon: ne,
                onClick: xe(!0)
            })
        }), jsxRuntimeExports.jsx("div", {
            className: styles$7$1.tabsContainer,
            onScroll: we,
            ref: ge,
            children: jsxRuntimeExports.jsx("div", {
                className: styles$7$1.tabs,
                ref: Te,
                children: V.map( (Fe, je) => {
                    const Xe = J === je;
                    return jsxRuntimeExports.jsx("button", {
                        className: classNames(styles$7$1.tab, Xe && styles$7$1.active),
                        role: "tab",
                        type: BUTTON_TYPES$1.BUTTON,
                        tabIndex: 0,
                        "aria-selected": Xe,
                        onClick: ve(je),
                        ...X && {
                            id: `${X}-tab-${je}`
                        },
                        ...X && {
                            "aria-controls": `${X}-panel-${je}`
                        },
                        children: Fe
                    }, `tab-${je}`)
                }
                )
            })
        }), _e && jsxRuntimeExports.jsx("div", {
            className: styles$7$1.scrollButtonWrapper,
            children: jsxRuntimeExports.jsx(IconButton, {
                className: classNames(!$e && styles$7$1.hidden),
                transparent: !0,
                color: "var(--tmln-ui-tabs-tab-name-color)",
                hoverColor: "var(--tmln-ui-tabs-tab-name-color)",
                icon: ue,
                onClick: xe(!1)
            })
        })]
    })
}
  , TextToClipboard = ({text: V, label: X, fillWidth: J}) => {
    const ne = () => {
        copyToClipboard(V)
    }
    ;
    return jsxRuntimeExports.jsx(TextInput, {
        label: X,
        fillWidth: J,
        value: V,
        action: {
            icon: ICON_NAMES.COPY,
            iconOnly: !0,
            onClick: ne,
            text: X
        },
        readOnly: !0
    })
}
;
var styles$6$1 = {
    accordion: "main-nav-module_accordion__KDuVv",
    active: "main-nav-module_active__x6iI7",
    header: "main-nav-module_header__WosH6",
    open: "main-nav-module_open__1xca-",
    disabled: "main-nav-module_disabled__Y9Yss",
    subLink: "main-nav-module_subLink__1v00R",
    iconContainer: "main-nav-module_iconContainer__pwNxe",
    iconActive: "main-nav-module_iconActive__QDqE2",
    icon: "main-nav-module_icon__4NFXn",
    iconDisabled: "main-nav-module_iconDisabled__aqGtZ",
    label: "main-nav-module_label__lMmLn",
    subItemHasIcon: "main-nav-module_subItemHasIcon__j4Jde",
    lastSubItem: "main-nav-module_lastSubItem__gvpeT",
    subLinkLabel: "main-nav-module_subLinkLabel__elC-U",
    listItem: "main-nav-module_listItem__h8t1D",
    lgSpacing: "main-nav-module_lgSpacing__OniPw",
    subItemIconContainer: "main-nav-module_subItemIconContainer__fUJE-",
    subItemIcon: "main-nav-module_subItemIcon__-HsP5",
    hasIconOrStep: "main-nav-module_hasIconOrStep__5rRfc",
    iconWrapper: "main-nav-module_iconWrapper__PHnyg",
    last: "main-nav-module_last__9D-fS",
    first: "main-nav-module_first__D2oiy"
}, MAIN_NAV_LIST_SPACING_SIZE;
(function(V) {
    V.MD = "md",
    V.LG = "lg"
}
)(MAIN_NAV_LIST_SPACING_SIZE || (MAIN_NAV_LIST_SPACING_SIZE = {}));
const MainNav = ({pathname: V, items: X}) => {
    var Se;
    const {colors: J} = reactExports.useContext(ThemeContext)
      , ne = Ie => {
        const ye = V.split("/")
          , $e = Ie.split("/");
        return $e[$e.length - 1] === ye[ye.length - 1]
    }
      , ue = (Se = X.find(Ie => {
        var ye;
        return ne(Ie.link) || ((ye = Ie.subItems) == null ? void 0 : ye.some( ({link: $e}) => ne($e)))
    }
    )) == null ? void 0 : Se.id;
    reactExports.useEffect( () => {
        ue && me(new Set([ue]))
    }
    , [ue]);
    const [ce,me] = reactExports.useState(new Set(ue && [ue]))
      , ge = (Ie, ye, $e, Ne) => ve => {
        ce.add(Ie),
        me(new Set([...ce])),
        ye && ve.preventDefault(),
        Ne($e)
    }
      , Te = Ie => {
        me(new Set([...Ie]))
    }
      , _e = (Ie, ye, $e) => Ne => {
        Ie ? Ne.preventDefault() : $e(ye)
    }
    ;
    return jsxRuntimeExports.jsx("div", {
        className: styles$6$1.container,
        children: jsxRuntimeExports.jsx(Accordion, {
            activeIds: ce,
            onChange: Te,
            iconColor: "var(--tmln-ui-main-nav-header-color)",
            className: styles$6$1.accordion,
            items: X.map( ({label: Ie, icon: ye, subItems: $e, id: Ne, link: ve, isDisabled: ke, onClick: xe, spacing: we}, Fe) => {
                var qe;
                const je = Ne === ue
                  , Xe = X.length === Fe + 1
                  , ze = ke ?? !!((qe = $e == null ? void 0 : $e[0]) != null && qe.isDisabled);
                return {
                    id: Ne,
                    header: jsxRuntimeExports.jsxs("a", {
                        className: classNames(styles$6$1.header, je && styles$6$1.active, ze && styles$6$1.disabled, ce.has(Ne) && styles$6$1.open),
                        "data-testid": Ne,
                        onClick: ge(Ne, ze, ve, xe),
                        title: Ie,
                        children: [jsxRuntimeExports.jsx("div", {
                            className: classNames(styles$6$1.iconWrapper, Fe === X.length - 1 && styles$6$1.last, Fe === 0 && styles$6$1.first),
                            children: jsxRuntimeExports.jsx("div", {
                                className: classNames(styles$6$1.iconContainer, ce.has(Ne) && styles$6$1.open, ze && styles$6$1.iconDisabled, je && styles$6$1.iconActive, (($e == null ? void 0 : $e[0].step) !== void 0 || ($e == null ? void 0 : $e[0].icon)) && styles$6$1.firstChildHasIcon, we === MAIN_NAV_LIST_SPACING_SIZE.LG && styles$6$1.lgSpacing),
                                children: jsxRuntimeExports.jsx(Icon, {
                                    name: ye,
                                    size: ICON_SIZES.XS,
                                    color: je ? J.black : void 0,
                                    className: styles$6$1.icon
                                })
                            })
                        }), jsxRuntimeExports.jsx("span", {
                            className: styles$6$1.label,
                            children: Ie
                        })]
                    }),
                    body: $e && jsxRuntimeExports.jsx(List, {
                        children: $e.map( (Ze, et) => jsxRuntimeExports.jsx("a", {
                            title: Ze.label,
                            "data-testid": Ze.testId,
                            className: classNames(styles$6$1.subLink, $e.length === et + 1 && Xe && styles$6$1.lastSubItem, $e.length === et + 1 && styles$6$1.lastSubItemInGroup, ne(Ze.link) && styles$6$1.active, Ze.isDisabled && styles$6$1.disabled, (Ze.step !== void 0 || Ze.icon) && styles$6$1.subItemHasIcon, we === MAIN_NAV_LIST_SPACING_SIZE.LG && styles$6$1.lgSpacing),
                            onClick: _e(!!Ze.isDisabled, Ze.link, Ze.onClick),
                            children: jsxRuntimeExports.jsxs(ListItem, {
                                className: classNames(styles$6$1.listItem, Ze.isDisabled && styles$6$1.disabled),
                                children: [jsxRuntimeExports.jsx("div", {
                                    className: classNames(styles$6$1.subItemIconContainer, !!(Ze.icon || Ze.step) && styles$6$1.hasIconOrStep),
                                    children: jsxRuntimeExports.jsxs("div", {
                                        className: styles$6$1.subItemIcon,
                                        children: [Ze.step !== void 0 && !Ze.icon && (typeof Ze.step == "number" ? Ze.step : et + 1), Ze.icon && jsxRuntimeExports.jsx(Icon, {
                                            name: Ze.icon,
                                            size: ICON_SIZES.FILL
                                        })]
                                    })
                                }), jsxRuntimeExports.jsx("div", {
                                    children: jsxRuntimeExports.jsx("div", {
                                        className: classNames(styles$6$1.subLinkLabel, styles$6$1.label),
                                        children: jsxRuntimeExports.jsxs(Space, {
                                            column: !0,
                                            align: SPACE_ALIGN.START,
                                            gapSize: SPACE_GAP_SIZE.NONE,
                                            children: [Ze.label, Ze.description && jsxRuntimeExports.jsx(Caption, {
                                                className: styles$6$1.caption,
                                                children: Ze.description
                                            })]
                                        })
                                    })
                                })]
                            })
                        }, Ze.label))
                    })
                }
            }
            )
        })
    })
}
;
var styles$5$1 = {
    trigger: "menu-module_trigger__ZAKIl",
    context: "menu-module_context__yRhak",
    open: "menu-module_open__C1YRA"
};
const Menu = ({children: V, label: X, ignoreContextClick: J=!1, isOpen: ne=!1, placement: ue=PLACEMENT.BOTTOM_LEFT, className: ce, onToggle: me}) => {
    const ge = reactExports.useRef(null)
      , Te = reactExports.useRef(null)
      , _e = reactExports.useRef(document.body)
      , Se = document.documentElement.dir === "rtl"
      , [Ie,ye] = useOnWindowResize(30)
      , $e = () => {
        if (Te.current && ge.current) {
            const {x: ve, y: ke} = computeRelativeCoordinates({
                target: ge.current,
                elementToPlace: Te.current,
                isRtl: Se,
                placement: ue,
                alignToEdge: !0
            });
            Te.current.style.left = `${ve}px`,
            Te.current.style.top = `${ke}px`
        }
    }
      , Ne = () => {
        me && me(!ne)
    }
    ;
    return reactExports.useEffect( () => {
        const ve = ke => {
            var we, Fe;
            const xe = ((we = Te == null ? void 0 : Te.current) == null ? void 0 : we.contains(ke.target)) && !J;
            !((Fe = ge == null ? void 0 : ge.current) != null && Fe.contains(ke.target)) && !xe && me && me(!1)
        }
        ;
        return ne ? document.addEventListener("click", ve, !0) : document.removeEventListener("click", ve, !0),
        () => {
            document.removeEventListener("click", ve, !0)
        }
    }
    , [ne]),
    reactExports.useEffect( () => {
        ne ? $e() : Te.current && (Te.current.style.left = "0",
        Te.current.style.top = "0")
    }
    , [Ie, ye, ne]),
    jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsx("button", {
            type: BUTTON_TYPES$1.BUTTON,
            ref: ge,
            className: classNames(styles$5$1.trigger, ce),
            onClick: Ne,
            children: X
        }), reactDomExports.createPortal(jsxRuntimeExports.jsx("div", {
            ref: Te,
            className: classNames(styles$5$1.context, ne && styles$5$1.open),
            children: V
        }), _e.current)]
    })
}
;
var styles$4$1 = {
    container: "sidebar-module_container__8b1ZT",
    sidebar: "sidebar-module_sidebar__ScAHa",
    collapsed: "sidebar-module_collapsed__URr7R",
    content: "sidebar-module_content__rwkd4",
    footer: "sidebar-module_footer__2RFxW",
    collapseBtn: "sidebar-module_collapseBtn__CfYdw"
};
const Sidebar = ({children: V, label: X, content: J, collapseLabel: ne, isCollapsed: ue, className: ce, hideOnMobile: me=!1, toggleCollapse: ge}) => {
    const {breakpoints: Te} = reactExports.useContext(ThemeContext)
      , _e = reactExports.useContext(CurrentBreakpointContext)
      , Se = getMobileFirstOption({
        xxs: !0,
        md: !1
    }, _e, Te) ?? !0;
    return jsxRuntimeExports.jsxs("div", {
        className: styles$4$1.container,
        children: [!Se || !me ? jsxRuntimeExports.jsxs("aside", {
            className: classNames(styles$4$1.sidebar, ue && styles$4$1.collapsed, ce),
            "aria-label": X,
            children: [jsxRuntimeExports.jsx("div", {
                className: styles$4$1.content,
                children: J
            }), jsxRuntimeExports.jsx("footer", {
                className: styles$4$1.footer,
                children: jsxRuntimeExports.jsxs("button", {
                    type: BUTTON_TYPES$1.BUTTON,
                    className: styles$4$1.collapseBtn,
                    onClick: ge,
                    children: [!ue && jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
                        children: ne
                    }), jsxRuntimeExports.jsx(Icon, {
                        size: ICON_SIZES.XS,
                        name: ue ? ICON_NAMES.CHEVRON_RIGHT : ICON_NAMES.CHEVRON_LEFT
                    })]
                })
            })]
        }) : null, V]
    })
}
;
var styles$2$1 = {
    tabPanel: "tab-panel-module_tabPanel__RFERC"
};
const TabPanel = ({instanceId: V, activeTabIndex: X, panels: J}) => jsxRuntimeExports.jsx("div", {
    className: styles$2$1.tabPanel,
    children: J.map( (ne, ue) => jsxRuntimeExports.jsx("div", {
        id: `${V}-panel-${ue}`,
        role: "tabpanel",
        tabIndex: 0,
        "aria-labelledby": `${V}-tab-${ue}`,
        hidden: X !== ue,
        children: ne
    }, `${V}-panel-${ue}`))
});
var styles$16 = {
    paragraph: "paragraph-module_paragraph__VVyCO",
    largeSize: "paragraph-module_largeSize__YfIIv"
}, PARAGRAPH_SIZE;
(function(V) {
    V.MD = "medium",
    V.LG = "large"
}
)(PARAGRAPH_SIZE || (PARAGRAPH_SIZE = {}));
const Paragraph = ({children: V, size: X=PARAGRAPH_SIZE.MD, className: J}) => jsxRuntimeExports.jsx("p", {
    className: classNames(styles$16.paragraph, styles$16[`${X}Size`], J),
    children: V
})
  , useDialog = (V, {onSubmit: X, onClose: J, onOpen: ne}={}) => {
    const {setIsOpen: ue, dialogRef: ce, setActiveId: me, state: ge, activeId: Te} = reactExports.useContext(DialogContext)
      , _e = () => {
        ue(!1, DIALOG_STATE.CLOSED)
    }
      , Se = () => {
        me && me(V),
        ue(!0, DIALOG_STATE.OPENED)
    }
    ;
    return reactExports.useEffect( () => {
        if (V === Te)
            switch (ge) {
            case DIALOG_STATE.OPENED:
                ne && ne();
                break;
            case DIALOG_STATE.CLOSED:
                J && J();
                break;
            case DIALOG_STATE.SUBMITTED:
                X && X()
            }
    }
    , [Te, V, ge]),
    {
        dialogRef: ce,
        open: Se,
        close: _e
    }
}
  , useOffCanvas = V => {
    const {setIsOpen: X, setActiveId: J} = reactExports.useContext(OffCanvasContext);
    return {
        open: ce => {
            X({
                newState: !0,
                id: V,
                isFluidWidth: ce
            }),
            J && J(V)
        }
        ,
        close: () => {
            X({
                newState: !1,
                id: V
            })
        }
    }
}
;
var Subscribable = class {
    constructor() {
        this.listeners = new Set,
        this.subscribe = this.subscribe.bind(this)
    }
    subscribe(V) {
        return this.listeners.add(V),
        this.onSubscribe(),
        () => {
            this.listeners.delete(V),
            this.onUnsubscribe()
        }
    }
    hasListeners() {
        return this.listeners.size > 0
    }
    onSubscribe() {}
    onUnsubscribe() {}
}
  , isServer = typeof window > "u" || "Deno"in globalThis;
function noop$6() {}
function functionalUpdate(V, X) {
    return typeof V == "function" ? V(X) : V
}
function isValidTimeout(V) {
    return typeof V == "number" && V >= 0 && V !== 1 / 0
}
function timeUntilStale(V, X) {
    return Math.max(V + (X || 0) - Date.now(), 0)
}
function resolveStaleTime(V, X) {
    return typeof V == "function" ? V(X) : V
}
function resolveEnabled(V, X) {
    return typeof V == "function" ? V(X) : V
}
function matchQuery(V, X) {
    const {type: J="all", exact: ne, fetchStatus: ue, predicate: ce, queryKey: me, stale: ge} = V;
    if (me) {
        if (ne) {
            if (X.queryHash !== hashQueryKeyByOptions(me, X.options))
                return !1
        } else if (!partialMatchKey(X.queryKey, me))
            return !1
    }
    if (J !== "all") {
        const Te = X.isActive();
        if (J === "active" && !Te || J === "inactive" && Te)
            return !1
    }
    return !(typeof ge == "boolean" && X.isStale() !== ge || ue && ue !== X.state.fetchStatus || ce && !ce(X))
}
function matchMutation(V, X) {
    const {exact: J, status: ne, predicate: ue, mutationKey: ce} = V;
    if (ce) {
        if (!X.options.mutationKey)
            return !1;
        if (J) {
            if (hashKey(X.options.mutationKey) !== hashKey(ce))
                return !1
        } else if (!partialMatchKey(X.options.mutationKey, ce))
            return !1
    }
    return !(ne && X.state.status !== ne || ue && !ue(X))
}
function hashQueryKeyByOptions(V, X) {
    return ((X == null ? void 0 : X.queryKeyHashFn) || hashKey)(V)
}
function hashKey(V) {
    return JSON.stringify(V, (X, J) => isPlainObject$2(J) ? Object.keys(J).sort().reduce( (ne, ue) => (ne[ue] = J[ue],
    ne), {}) : J)
}
function partialMatchKey(V, X) {
    return V === X ? !0 : typeof V != typeof X ? !1 : V && X && typeof V == "object" && typeof X == "object" ? !Object.keys(X).some(J => !partialMatchKey(V[J], X[J])) : !1
}
function replaceEqualDeep(V, X) {
    if (V === X)
        return V;
    const J = isPlainArray(V) && isPlainArray(X);
    if (J || isPlainObject$2(V) && isPlainObject$2(X)) {
        const ne = J ? V : Object.keys(V)
          , ue = ne.length
          , ce = J ? X : Object.keys(X)
          , me = ce.length
          , ge = J ? [] : {};
        let Te = 0;
        for (let _e = 0; _e < me; _e++) {
            const Se = J ? _e : ce[_e];
            (!J && ne.includes(Se) || J) && V[Se] === void 0 && X[Se] === void 0 ? (ge[Se] = void 0,
            Te++) : (ge[Se] = replaceEqualDeep(V[Se], X[Se]),
            ge[Se] === V[Se] && V[Se] !== void 0 && Te++)
        }
        return ue === me && Te === ue ? V : ge
    }
    return X
}
function shallowEqualObjects(V, X) {
    if (!X || Object.keys(V).length !== Object.keys(X).length)
        return !1;
    for (const J in V)
        if (V[J] !== X[J])
            return !1;
    return !0
}
function isPlainArray(V) {
    return Array.isArray(V) && V.length === Object.keys(V).length
}
function isPlainObject$2(V) {
    if (!hasObjectPrototype(V))
        return !1;
    const X = V.constructor;
    if (X === void 0)
        return !0;
    const J = X.prototype;
    return !(!hasObjectPrototype(J) || !J.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(V) !== Object.prototype)
}
function hasObjectPrototype(V) {
    return Object.prototype.toString.call(V) === "[object Object]"
}
function sleep(V) {
    return new Promise(X => {
        setTimeout(X, V)
    }
    )
}
function replaceData(V, X, J) {
    return typeof J.structuralSharing == "function" ? J.structuralSharing(V, X) : J.structuralSharing !== !1 ? replaceEqualDeep(V, X) : X
}
function addToEnd(V, X, J=0) {
    const ne = [...V, X];
    return J && ne.length > J ? ne.slice(1) : ne
}
function addToStart(V, X, J=0) {
    const ne = [X, ...V];
    return J && ne.length > J ? ne.slice(0, -1) : ne
}
var skipToken = Symbol();
function ensureQueryFn(V, X) {
    return !V.queryFn && (X != null && X.initialPromise) ? () => X.initialPromise : !V.queryFn || V.queryFn === skipToken ? () => Promise.reject(new Error(`Missing queryFn: '${V.queryHash}'`)) : V.queryFn
}
var mi, Co, Ea, FE, FocusManager = (FE = class extends Subscribable {
    constructor() {
        super();
        _n(this, mi);
        _n(this, Co);
        _n(this, Ea);
        hn(this, Ea, X => {
            if (!isServer && window.addEventListener) {
                const J = () => X();
                return window.addEventListener("visibilitychange", J, !1),
                () => {
                    window.removeEventListener("visibilitychange", J)
                }
            }
        }
        )
    }
    onSubscribe() {
        It(this, Co) || this.setEventListener(It(this, Ea))
    }
    onUnsubscribe() {
        var X;
        this.hasListeners() || ((X = It(this, Co)) == null || X.call(this),
        hn(this, Co, void 0))
    }
    setEventListener(X) {
        var J;
        hn(this, Ea, X),
        (J = It(this, Co)) == null || J.call(this),
        hn(this, Co, X(ne => {
            typeof ne == "boolean" ? this.setFocused(ne) : this.onFocus()
        }
        ))
    }
    setFocused(X) {
        It(this, mi) !== X && (hn(this, mi, X),
        this.onFocus())
    }
    onFocus() {
        const X = this.isFocused();
        this.listeners.forEach(J => {
            J(X)
        }
        )
    }
    isFocused() {
        var X;
        return typeof It(this, mi) == "boolean" ? It(this, mi) : ((X = globalThis.document) == null ? void 0 : X.visibilityState) !== "hidden"
    }
}
,
mi = new WeakMap,
Co = new WeakMap,
Ea = new WeakMap,
FE), focusManager = new FocusManager, Ta, vo, Aa, HE, OnlineManager = (HE = class extends Subscribable {
    constructor() {
        super();
        _n(this, Ta, !0);
        _n(this, vo);
        _n(this, Aa);
        hn(this, Aa, X => {
            if (!isServer && window.addEventListener) {
                const J = () => X(!0)
                  , ne = () => X(!1);
                return window.addEventListener("online", J, !1),
                window.addEventListener("offline", ne, !1),
                () => {
                    window.removeEventListener("online", J),
                    window.removeEventListener("offline", ne)
                }
            }
        }
        )
    }
    onSubscribe() {
        It(this, vo) || this.setEventListener(It(this, Aa))
    }
    onUnsubscribe() {
        var X;
        this.hasListeners() || ((X = It(this, vo)) == null || X.call(this),
        hn(this, vo, void 0))
    }
    setEventListener(X) {
        var J;
        hn(this, Aa, X),
        (J = It(this, vo)) == null || J.call(this),
        hn(this, vo, X(this.setOnline.bind(this)))
    }
    setOnline(X) {
        It(this, Ta) !== X && (hn(this, Ta, X),
        this.listeners.forEach(ne => {
            ne(X)
        }
        ))
    }
    isOnline() {
        return It(this, Ta)
    }
}
,
Ta = new WeakMap,
vo = new WeakMap,
Aa = new WeakMap,
HE), onlineManager = new OnlineManager;
function pendingThenable() {
    let V, X;
    const J = new Promise( (ue, ce) => {
        V = ue,
        X = ce
    }
    );
    J.status = "pending",
    J.catch( () => {}
    );
    function ne(ue) {
        Object.assign(J, ue),
        delete J.resolve,
        delete J.reject
    }
    return J.resolve = ue => {
        ne({
            status: "fulfilled",
            value: ue
        }),
        V(ue)
    }
    ,
    J.reject = ue => {
        ne({
            status: "rejected",
            reason: ue
        }),
        X(ue)
    }
    ,
    J
}
function defaultRetryDelay(V) {
    return Math.min(1e3 * 2 ** V, 3e4)
}
function canFetch(V) {
    return (V ?? "online") === "online" ? onlineManager.isOnline() : !0
}
var CancelledError = class extends Error {
    constructor(V) {
        super("CancelledError"),
        this.revert = V == null ? void 0 : V.revert,
        this.silent = V == null ? void 0 : V.silent
    }
}
;
function isCancelledError(V) {
    return V instanceof CancelledError
}
function createRetryer(V) {
    let X = !1, J = 0, ne = !1, ue;
    const ce = pendingThenable()
      , me = ve => {
        var ke;
        ne || (ye(new CancelledError(ve)),
        (ke = V.abort) == null || ke.call(V))
    }
      , ge = () => {
        X = !0
    }
      , Te = () => {
        X = !1
    }
      , _e = () => focusManager.isFocused() && (V.networkMode === "always" || onlineManager.isOnline()) && V.canRun()
      , Se = () => canFetch(V.networkMode) && V.canRun()
      , Ie = ve => {
        var ke;
        ne || (ne = !0,
        (ke = V.onSuccess) == null || ke.call(V, ve),
        ue == null || ue(),
        ce.resolve(ve))
    }
      , ye = ve => {
        var ke;
        ne || (ne = !0,
        (ke = V.onError) == null || ke.call(V, ve),
        ue == null || ue(),
        ce.reject(ve))
    }
      , $e = () => new Promise(ve => {
        var ke;
        ue = xe => {
            (ne || _e()) && ve(xe)
        }
        ,
        (ke = V.onPause) == null || ke.call(V)
    }
    ).then( () => {
        var ve;
        ue = void 0,
        ne || (ve = V.onContinue) == null || ve.call(V)
    }
    )
      , Ne = () => {
        if (ne)
            return;
        let ve;
        const ke = J === 0 ? V.initialPromise : void 0;
        try {
            ve = ke ?? V.fn()
        } catch (xe) {
            ve = Promise.reject(xe)
        }
        Promise.resolve(ve).then(Ie).catch(xe => {
            var ze;
            if (ne)
                return;
            const we = V.retry ?? (isServer ? 0 : 3)
              , Fe = V.retryDelay ?? defaultRetryDelay
              , je = typeof Fe == "function" ? Fe(J, xe) : Fe
              , Xe = we === !0 || typeof we == "number" && J < we || typeof we == "function" && we(J, xe);
            if (X || !Xe) {
                ye(xe);
                return
            }
            J++,
            (ze = V.onFail) == null || ze.call(V, J, xe),
            sleep(je).then( () => _e() ? void 0 : $e()).then( () => {
                X ? ye(xe) : Ne()
            }
            )
        }
        )
    }
    ;
    return {
        promise: ce,
        cancel: me,
        continue: () => (ue == null || ue(),
        ce),
        cancelRetry: ge,
        continueRetry: Te,
        canStart: Se,
        start: () => (Se() ? Ne() : $e().then(Ne),
        ce)
    }
}
function createNotifyManager() {
    let V = []
      , X = 0
      , J = ge => {
        ge()
    }
      , ne = ge => {
        ge()
    }
      , ue = ge => setTimeout(ge, 0);
    const ce = ge => {
        X ? V.push(ge) : ue( () => {
            J(ge)
        }
        )
    }
      , me = () => {
        const ge = V;
        V = [],
        ge.length && ue( () => {
            ne( () => {
                ge.forEach(Te => {
                    J(Te)
                }
                )
            }
            )
        }
        )
    }
    ;
    return {
        batch: ge => {
            let Te;
            X++;
            try {
                Te = ge()
            } finally {
                X--,
                X || me()
            }
            return Te
        }
        ,
        batchCalls: ge => (...Te) => {
            ce( () => {
                ge(...Te)
            }
            )
        }
        ,
        schedule: ce,
        setNotifyFunction: ge => {
            J = ge
        }
        ,
        setBatchNotifyFunction: ge => {
            ne = ge
        }
        ,
        setScheduler: ge => {
            ue = ge
        }
    }
}
var notifyManager = createNotifyManager(), fi, VE, Removable = (VE = class {
    constructor() {
        _n(this, fi)
    }
    destroy() {
        this.clearGcTimeout()
    }
    scheduleGc() {
        this.clearGcTimeout(),
        isValidTimeout(this.gcTime) && hn(this, fi, setTimeout( () => {
            this.optionalRemove()
        }
        , this.gcTime))
    }
    updateGcTime(V) {
        this.gcTime = Math.max(this.gcTime || 0, V ?? (isServer ? 1 / 0 : 5 * 60 * 1e3))
    }
    clearGcTimeout() {
        It(this, fi) && (clearTimeout(It(this, fi)),
        hn(this, fi, void 0))
    }
}
,
fi = new WeakMap,
VE), _a, Sa, es, Ar, Sl, gi, ps, no, GE, Query = (GE = class extends Removable {
    constructor(X) {
        super();
        _n(this, ps);
        _n(this, _a);
        _n(this, Sa);
        _n(this, es);
        _n(this, Ar);
        _n(this, Sl);
        _n(this, gi);
        hn(this, gi, !1),
        hn(this, Sl, X.defaultOptions),
        this.setOptions(X.options),
        this.observers = [],
        hn(this, es, X.cache),
        this.queryKey = X.queryKey,
        this.queryHash = X.queryHash,
        hn(this, _a, getDefaultState$1(this.options)),
        this.state = X.state ?? It(this, _a),
        this.scheduleGc()
    }
    get meta() {
        return this.options.meta
    }
    get promise() {
        var X;
        return (X = It(this, Ar)) == null ? void 0 : X.promise
    }
    setOptions(X) {
        this.options = {
            ...It(this, Sl),
            ...X
        },
        this.updateGcTime(this.options.gcTime)
    }
    optionalRemove() {
        !this.observers.length && this.state.fetchStatus === "idle" && It(this, es).remove(this)
    }
    setData(X, J) {
        const ne = replaceData(this.state.data, X, this.options);
        return Cn(this, ps, no).call(this, {
            data: ne,
            type: "success",
            dataUpdatedAt: J == null ? void 0 : J.updatedAt,
            manual: J == null ? void 0 : J.manual
        }),
        ne
    }
    setState(X, J) {
        Cn(this, ps, no).call(this, {
            type: "setState",
            state: X,
            setStateOptions: J
        })
    }
    cancel(X) {
        var ne, ue;
        const J = (ne = It(this, Ar)) == null ? void 0 : ne.promise;
        return (ue = It(this, Ar)) == null || ue.cancel(X),
        J ? J.then(noop$6).catch(noop$6) : Promise.resolve()
    }
    destroy() {
        super.destroy(),
        this.cancel({
            silent: !0
        })
    }
    reset() {
        this.destroy(),
        this.setState(It(this, _a))
    }
    isActive() {
        return this.observers.some(X => resolveEnabled(X.options.enabled, this) !== !1)
    }
    isDisabled() {
        return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === skipToken || this.state.dataUpdateCount + this.state.errorUpdateCount === 0
    }
    isStale() {
        return this.state.isInvalidated ? !0 : this.getObserversCount() > 0 ? this.observers.some(X => X.getCurrentResult().isStale) : this.state.data === void 0
    }
    isStaleByTime(X=0) {
        return this.state.isInvalidated || this.state.data === void 0 || !timeUntilStale(this.state.dataUpdatedAt, X)
    }
    onFocus() {
        var J;
        const X = this.observers.find(ne => ne.shouldFetchOnWindowFocus());
        X == null || X.refetch({
            cancelRefetch: !1
        }),
        (J = It(this, Ar)) == null || J.continue()
    }
    onOnline() {
        var J;
        const X = this.observers.find(ne => ne.shouldFetchOnReconnect());
        X == null || X.refetch({
            cancelRefetch: !1
        }),
        (J = It(this, Ar)) == null || J.continue()
    }
    addObserver(X) {
        this.observers.includes(X) || (this.observers.push(X),
        this.clearGcTimeout(),
        It(this, es).notify({
            type: "observerAdded",
            query: this,
            observer: X
        }))
    }
    removeObserver(X) {
        this.observers.includes(X) && (this.observers = this.observers.filter(J => J !== X),
        this.observers.length || (It(this, Ar) && (It(this, gi) ? It(this, Ar).cancel({
            revert: !0
        }) : It(this, Ar).cancelRetry()),
        this.scheduleGc()),
        It(this, es).notify({
            type: "observerRemoved",
            query: this,
            observer: X
        }))
    }
    getObserversCount() {
        return this.observers.length
    }
    invalidate() {
        this.state.isInvalidated || Cn(this, ps, no).call(this, {
            type: "invalidate"
        })
    }
    fetch(X, J) {
        var Te, _e, Se;
        if (this.state.fetchStatus !== "idle") {
            if (this.state.data !== void 0 && (J != null && J.cancelRefetch))
                this.cancel({
                    silent: !0
                });
            else if (It(this, Ar))
                return It(this, Ar).continueRetry(),
                It(this, Ar).promise
        }
        if (X && this.setOptions(X),
        !this.options.queryFn) {
            const Ie = this.observers.find(ye => ye.options.queryFn);
            Ie && this.setOptions(Ie.options)
        }
        const ne = new AbortController
          , ue = Ie => {
            Object.defineProperty(Ie, "signal", {
                enumerable: !0,
                get: () => (hn(this, gi, !0),
                ne.signal)
            })
        }
          , ce = () => {
            const Ie = ensureQueryFn(this.options, J)
              , ye = {
                queryKey: this.queryKey,
                meta: this.meta
            };
            return ue(ye),
            hn(this, gi, !1),
            this.options.persister ? this.options.persister(Ie, ye, this) : Ie(ye)
        }
          , me = {
            fetchOptions: J,
            options: this.options,
            queryKey: this.queryKey,
            state: this.state,
            fetchFn: ce
        };
        ue(me),
        (Te = this.options.behavior) == null || Te.onFetch(me, this),
        hn(this, Sa, this.state),
        (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((_e = me.fetchOptions) == null ? void 0 : _e.meta)) && Cn(this, ps, no).call(this, {
            type: "fetch",
            meta: (Se = me.fetchOptions) == null ? void 0 : Se.meta
        });
        const ge = Ie => {
            var ye, $e, Ne, ve;
            isCancelledError(Ie) && Ie.silent || Cn(this, ps, no).call(this, {
                type: "error",
                error: Ie
            }),
            isCancelledError(Ie) || (($e = (ye = It(this, es).config).onError) == null || $e.call(ye, Ie, this),
            (ve = (Ne = It(this, es).config).onSettled) == null || ve.call(Ne, this.state.data, Ie, this)),
            this.scheduleGc()
        }
        ;
        return hn(this, Ar, createRetryer({
            initialPromise: J == null ? void 0 : J.initialPromise,
            fn: me.fetchFn,
            abort: ne.abort.bind(ne),
            onSuccess: Ie => {
                var ye, $e, Ne, ve;
                if (Ie === void 0) {
                    ge(new Error(`${this.queryHash} data is undefined`));
                    return
                }
                try {
                    this.setData(Ie)
                } catch (ke) {
                    ge(ke);
                    return
                }
                ($e = (ye = It(this, es).config).onSuccess) == null || $e.call(ye, Ie, this),
                (ve = (Ne = It(this, es).config).onSettled) == null || ve.call(Ne, Ie, this.state.error, this),
                this.scheduleGc()
            }
            ,
            onError: ge,
            onFail: (Ie, ye) => {
                Cn(this, ps, no).call(this, {
                    type: "failed",
                    failureCount: Ie,
                    error: ye
                })
            }
            ,
            onPause: () => {
                Cn(this, ps, no).call(this, {
                    type: "pause"
                })
            }
            ,
            onContinue: () => {
                Cn(this, ps, no).call(this, {
                    type: "continue"
                })
            }
            ,
            retry: me.options.retry,
            retryDelay: me.options.retryDelay,
            networkMode: me.options.networkMode,
            canRun: () => !0
        })),
        It(this, Ar).start()
    }
}
,
_a = new WeakMap,
Sa = new WeakMap,
es = new WeakMap,
Ar = new WeakMap,
Sl = new WeakMap,
gi = new WeakMap,
ps = new WeakSet,
no = function(X) {
    const J = ne => {
        switch (X.type) {
        case "failed":
            return {
                ...ne,
                fetchFailureCount: X.failureCount,
                fetchFailureReason: X.error
            };
        case "pause":
            return {
                ...ne,
                fetchStatus: "paused"
            };
        case "continue":
            return {
                ...ne,
                fetchStatus: "fetching"
            };
        case "fetch":
            return {
                ...ne,
                ...fetchState(ne.data, this.options),
                fetchMeta: X.meta ?? null
            };
        case "success":
            return {
                ...ne,
                data: X.data,
                dataUpdateCount: ne.dataUpdateCount + 1,
                dataUpdatedAt: X.dataUpdatedAt ?? Date.now(),
                error: null,
                isInvalidated: !1,
                status: "success",
                ...!X.manual && {
                    fetchStatus: "idle",
                    fetchFailureCount: 0,
                    fetchFailureReason: null
                }
            };
        case "error":
            const ue = X.error;
            return isCancelledError(ue) && ue.revert && It(this, Sa) ? {
                ...It(this, Sa),
                fetchStatus: "idle"
            } : {
                ...ne,
                error: ue,
                errorUpdateCount: ne.errorUpdateCount + 1,
                errorUpdatedAt: Date.now(),
                fetchFailureCount: ne.fetchFailureCount + 1,
                fetchFailureReason: ue,
                fetchStatus: "idle",
                status: "error"
            };
        case "invalidate":
            return {
                ...ne,
                isInvalidated: !0
            };
        case "setState":
            return {
                ...ne,
                ...X.state
            }
        }
    }
    ;
    this.state = J(this.state),
    notifyManager.batch( () => {
        this.observers.forEach(ne => {
            ne.onQueryUpdate()
        }
        ),
        It(this, es).notify({
            query: this,
            type: "updated",
            action: X
        })
    }
    )
}
,
GE);
function fetchState(V, X) {
    return {
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchStatus: canFetch(X.networkMode) ? "fetching" : "paused",
        ...V === void 0 && {
            error: null,
            status: "pending"
        }
    }
}
function getDefaultState$1(V) {
    const X = typeof V.initialData == "function" ? V.initialData() : V.initialData
      , J = X !== void 0
      , ne = J ? typeof V.initialDataUpdatedAt == "function" ? V.initialDataUpdatedAt() : V.initialDataUpdatedAt : 0;
    return {
        data: X,
        dataUpdateCount: 0,
        dataUpdatedAt: J ? ne ?? Date.now() : 0,
        error: null,
        errorUpdateCount: 0,
        errorUpdatedAt: 0,
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchMeta: null,
        isInvalidated: !1,
        status: J ? "success" : "pending",
        fetchStatus: "idle"
    }
}
var ws, jE, QueryCache = (jE = class extends Subscribable {
    constructor(X={}) {
        super();
        _n(this, ws);
        this.config = X,
        hn(this, ws, new Map)
    }
    build(X, J, ne) {
        const ue = J.queryKey
          , ce = J.queryHash ?? hashQueryKeyByOptions(ue, J);
        let me = this.get(ce);
        return me || (me = new Query({
            cache: this,
            queryKey: ue,
            queryHash: ce,
            options: X.defaultQueryOptions(J),
            state: ne,
            defaultOptions: X.getQueryDefaults(ue)
        }),
        this.add(me)),
        me
    }
    add(X) {
        It(this, ws).has(X.queryHash) || (It(this, ws).set(X.queryHash, X),
        this.notify({
            type: "added",
            query: X
        }))
    }
    remove(X) {
        const J = It(this, ws).get(X.queryHash);
        J && (X.destroy(),
        J === X && It(this, ws).delete(X.queryHash),
        this.notify({
            type: "removed",
            query: X
        }))
    }
    clear() {
        notifyManager.batch( () => {
            this.getAll().forEach(X => {
                this.remove(X)
            }
            )
        }
        )
    }
    get(X) {
        return It(this, ws).get(X)
    }
    getAll() {
        return [...It(this, ws).values()]
    }
    find(X) {
        const J = {
            exact: !0,
            ...X
        };
        return this.getAll().find(ne => matchQuery(J, ne))
    }
    findAll(X={}) {
        const J = this.getAll();
        return Object.keys(X).length > 0 ? J.filter(ne => matchQuery(X, ne)) : J
    }
    notify(X) {
        notifyManager.batch( () => {
            this.listeners.forEach(J => {
                J(X)
            }
            )
        }
        )
    }
    onFocus() {
        notifyManager.batch( () => {
            this.getAll().forEach(X => {
                X.onFocus()
            }
            )
        }
        )
    }
    onOnline() {
        notifyManager.batch( () => {
            this.getAll().forEach(X => {
                X.onOnline()
            }
            )
        }
        )
    }
}
,
ws = new WeakMap,
jE), Bs, Or, Ei, Us, Oo, WE, Mutation = (WE = class extends Removable {
    constructor(X) {
        super();
        _n(this, Us);
        _n(this, Bs);
        _n(this, Or);
        _n(this, Ei);
        this.mutationId = X.mutationId,
        hn(this, Or, X.mutationCache),
        hn(this, Bs, []),
        this.state = X.state || getDefaultState(),
        this.setOptions(X.options),
        this.scheduleGc()
    }
    setOptions(X) {
        this.options = X,
        this.updateGcTime(this.options.gcTime)
    }
    get meta() {
        return this.options.meta
    }
    addObserver(X) {
        It(this, Bs).includes(X) || (It(this, Bs).push(X),
        this.clearGcTimeout(),
        It(this, Or).notify({
            type: "observerAdded",
            mutation: this,
            observer: X
        }))
    }
    removeObserver(X) {
        hn(this, Bs, It(this, Bs).filter(J => J !== X)),
        this.scheduleGc(),
        It(this, Or).notify({
            type: "observerRemoved",
            mutation: this,
            observer: X
        })
    }
    optionalRemove() {
        It(this, Bs).length || (this.state.status === "pending" ? this.scheduleGc() : It(this, Or).remove(this))
    }
    continue() {
        var X;
        return ((X = It(this, Ei)) == null ? void 0 : X.continue()) ?? this.execute(this.state.variables)
    }
    async execute(X) {
        var ue, ce, me, ge, Te, _e, Se, Ie, ye, $e, Ne, ve, ke, xe, we, Fe, je, Xe, ze, qe;
        hn(this, Ei, createRetryer({
            fn: () => this.options.mutationFn ? this.options.mutationFn(X) : Promise.reject(new Error("No mutationFn found")),
            onFail: (Ze, et) => {
                Cn(this, Us, Oo).call(this, {
                    type: "failed",
                    failureCount: Ze,
                    error: et
                })
            }
            ,
            onPause: () => {
                Cn(this, Us, Oo).call(this, {
                    type: "pause"
                })
            }
            ,
            onContinue: () => {
                Cn(this, Us, Oo).call(this, {
                    type: "continue"
                })
            }
            ,
            retry: this.options.retry ?? 0,
            retryDelay: this.options.retryDelay,
            networkMode: this.options.networkMode,
            canRun: () => It(this, Or).canRun(this)
        }));
        const J = this.state.status === "pending"
          , ne = !It(this, Ei).canStart();
        try {
            if (!J) {
                Cn(this, Us, Oo).call(this, {
                    type: "pending",
                    variables: X,
                    isPaused: ne
                }),
                await ((ce = (ue = It(this, Or).config).onMutate) == null ? void 0 : ce.call(ue, X, this));
                const et = await ((ge = (me = this.options).onMutate) == null ? void 0 : ge.call(me, X));
                et !== this.state.context && Cn(this, Us, Oo).call(this, {
                    type: "pending",
                    context: et,
                    variables: X,
                    isPaused: ne
                })
            }
            const Ze = await It(this, Ei).start();
            return await ((_e = (Te = It(this, Or).config).onSuccess) == null ? void 0 : _e.call(Te, Ze, X, this.state.context, this)),
            await ((Ie = (Se = this.options).onSuccess) == null ? void 0 : Ie.call(Se, Ze, X, this.state.context)),
            await (($e = (ye = It(this, Or).config).onSettled) == null ? void 0 : $e.call(ye, Ze, null, this.state.variables, this.state.context, this)),
            await ((ve = (Ne = this.options).onSettled) == null ? void 0 : ve.call(Ne, Ze, null, X, this.state.context)),
            Cn(this, Us, Oo).call(this, {
                type: "success",
                data: Ze
            }),
            Ze
        } catch (Ze) {
            try {
                throw await ((xe = (ke = It(this, Or).config).onError) == null ? void 0 : xe.call(ke, Ze, X, this.state.context, this)),
                await ((Fe = (we = this.options).onError) == null ? void 0 : Fe.call(we, Ze, X, this.state.context)),
                await ((Xe = (je = It(this, Or).config).onSettled) == null ? void 0 : Xe.call(je, void 0, Ze, this.state.variables, this.state.context, this)),
                await ((qe = (ze = this.options).onSettled) == null ? void 0 : qe.call(ze, void 0, Ze, X, this.state.context)),
                Ze
            } finally {
                Cn(this, Us, Oo).call(this, {
                    type: "error",
                    error: Ze
                })
            }
        } finally {
            It(this, Or).runNext(this)
        }
    }
}
,
Bs = new WeakMap,
Or = new WeakMap,
Ei = new WeakMap,
Us = new WeakSet,
Oo = function(X) {
    const J = ne => {
        switch (X.type) {
        case "failed":
            return {
                ...ne,
                failureCount: X.failureCount,
                failureReason: X.error
            };
        case "pause":
            return {
                ...ne,
                isPaused: !0
            };
        case "continue":
            return {
                ...ne,
                isPaused: !1
            };
        case "pending":
            return {
                ...ne,
                context: X.context,
                data: void 0,
                failureCount: 0,
                failureReason: null,
                error: null,
                isPaused: X.isPaused,
                status: "pending",
                variables: X.variables,
                submittedAt: Date.now()
            };
        case "success":
            return {
                ...ne,
                data: X.data,
                failureCount: 0,
                failureReason: null,
                error: null,
                status: "success",
                isPaused: !1
            };
        case "error":
            return {
                ...ne,
                data: void 0,
                error: X.error,
                failureCount: ne.failureCount + 1,
                failureReason: X.error,
                isPaused: !1,
                status: "error"
            }
        }
    }
    ;
    this.state = J(this.state),
    notifyManager.batch( () => {
        It(this, Bs).forEach(ne => {
            ne.onMutationUpdate(X)
        }
        ),
        It(this, Or).notify({
            mutation: this,
            type: "updated",
            action: X
        })
    }
    )
}
,
WE);
function getDefaultState() {
    return {
        context: void 0,
        data: void 0,
        error: null,
        failureCount: 0,
        failureReason: null,
        isPaused: !1,
        status: "idle",
        variables: void 0,
        submittedAt: 0
    }
}
var Xr, Il, YE, MutationCache = (YE = class extends Subscribable {
    constructor(X={}) {
        super();
        _n(this, Xr);
        _n(this, Il);
        this.config = X,
        hn(this, Xr, new Map),
        hn(this, Il, Date.now())
    }
    build(X, J, ne) {
        const ue = new Mutation({
            mutationCache: this,
            mutationId: ++Vc(this, Il)._,
            options: X.defaultMutationOptions(J),
            state: ne
        });
        return this.add(ue),
        ue
    }
    add(X) {
        const J = scopeFor(X)
          , ne = It(this, Xr).get(J) ?? [];
        ne.push(X),
        It(this, Xr).set(J, ne),
        this.notify({
            type: "added",
            mutation: X
        })
    }
    remove(X) {
        var ne;
        const J = scopeFor(X);
        if (It(this, Xr).has(J)) {
            const ue = (ne = It(this, Xr).get(J)) == null ? void 0 : ne.filter(ce => ce !== X);
            ue && (ue.length === 0 ? It(this, Xr).delete(J) : It(this, Xr).set(J, ue))
        }
        this.notify({
            type: "removed",
            mutation: X
        })
    }
    canRun(X) {
        var ne;
        const J = (ne = It(this, Xr).get(scopeFor(X))) == null ? void 0 : ne.find(ue => ue.state.status === "pending");
        return !J || J === X
    }
    runNext(X) {
        var ne;
        const J = (ne = It(this, Xr).get(scopeFor(X))) == null ? void 0 : ne.find(ue => ue !== X && ue.state.isPaused);
        return (J == null ? void 0 : J.continue()) ?? Promise.resolve()
    }
    clear() {
        notifyManager.batch( () => {
            this.getAll().forEach(X => {
                this.remove(X)
            }
            )
        }
        )
    }
    getAll() {
        return [...It(this, Xr).values()].flat()
    }
    find(X) {
        const J = {
            exact: !0,
            ...X
        };
        return this.getAll().find(ne => matchMutation(J, ne))
    }
    findAll(X={}) {
        return this.getAll().filter(J => matchMutation(X, J))
    }
    notify(X) {
        notifyManager.batch( () => {
            this.listeners.forEach(J => {
                J(X)
            }
            )
        }
        )
    }
    resumePausedMutations() {
        const X = this.getAll().filter(J => J.state.isPaused);
        return notifyManager.batch( () => Promise.all(X.map(J => J.continue().catch(noop$6))))
    }
}
,
Xr = new WeakMap,
Il = new WeakMap,
YE);
function scopeFor(V) {
    var X;
    return ((X = V.options.scope) == null ? void 0 : X.id) ?? String(V.mutationId)
}
function infiniteQueryBehavior(V) {
    return {
        onFetch: (X, J) => {
            var Se, Ie, ye, $e, Ne;
            const ne = X.options
              , ue = (ye = (Ie = (Se = X.fetchOptions) == null ? void 0 : Se.meta) == null ? void 0 : Ie.fetchMore) == null ? void 0 : ye.direction
              , ce = (($e = X.state.data) == null ? void 0 : $e.pages) || []
              , me = ((Ne = X.state.data) == null ? void 0 : Ne.pageParams) || [];
            let ge = {
                pages: [],
                pageParams: []
            }
              , Te = 0;
            const _e = async () => {
                let ve = !1;
                const ke = Fe => {
                    Object.defineProperty(Fe, "signal", {
                        enumerable: !0,
                        get: () => (X.signal.aborted ? ve = !0 : X.signal.addEventListener("abort", () => {
                            ve = !0
                        }
                        ),
                        X.signal)
                    })
                }
                  , xe = ensureQueryFn(X.options, X.fetchOptions)
                  , we = async (Fe, je, Xe) => {
                    if (ve)
                        return Promise.reject();
                    if (je == null && Fe.pages.length)
                        return Promise.resolve(Fe);
                    const ze = {
                        queryKey: X.queryKey,
                        pageParam: je,
                        direction: Xe ? "backward" : "forward",
                        meta: X.options.meta
                    };
                    ke(ze);
                    const qe = await xe(ze)
                      , {maxPages: Ze} = X.options
                      , et = Xe ? addToStart : addToEnd;
                    return {
                        pages: et(Fe.pages, qe, Ze),
                        pageParams: et(Fe.pageParams, je, Ze)
                    }
                }
                ;
                if (ue && ce.length) {
                    const Fe = ue === "backward"
                      , je = Fe ? getPreviousPageParam : getNextPageParam
                      , Xe = {
                        pages: ce,
                        pageParams: me
                    }
                      , ze = je(ne, Xe);
                    ge = await we(Xe, ze, Fe)
                } else {
                    const Fe = V ?? ce.length;
                    do {
                        const je = Te === 0 ? me[0] ?? ne.initialPageParam : getNextPageParam(ne, ge);
                        if (Te > 0 && je == null)
                            break;
                        ge = await we(ge, je),
                        Te++
                    } while (Te < Fe)
                }
                return ge
            }
            ;
            X.options.persister ? X.fetchFn = () => {
                var ve, ke;
                return (ke = (ve = X.options).persister) == null ? void 0 : ke.call(ve, _e, {
                    queryKey: X.queryKey,
                    meta: X.options.meta,
                    signal: X.signal
                }, J)
            }
            : X.fetchFn = _e
        }
    }
}
function getNextPageParam(V, {pages: X, pageParams: J}) {
    const ne = X.length - 1;
    return X.length > 0 ? V.getNextPageParam(X[ne], X, J[ne], J) : void 0
}
function getPreviousPageParam(V, {pages: X, pageParams: J}) {
    var ne;
    return X.length > 0 ? (ne = V.getPreviousPageParam) == null ? void 0 : ne.call(V, X[0], X, J[0], J) : void 0
}
var ir, xo, No, Ia, Ra, Lo, ya, ba, XE, QueryClient = (XE = class {
    constructor(V={}) {
        _n(this, ir);
        _n(this, xo);
        _n(this, No);
        _n(this, Ia);
        _n(this, Ra);
        _n(this, Lo);
        _n(this, ya);
        _n(this, ba);
        hn(this, ir, V.queryCache || new QueryCache),
        hn(this, xo, V.mutationCache || new MutationCache),
        hn(this, No, V.defaultOptions || {}),
        hn(this, Ia, new Map),
        hn(this, Ra, new Map),
        hn(this, Lo, 0)
    }
    mount() {
        Vc(this, Lo)._++,
        It(this, Lo) === 1 && (hn(this, ya, focusManager.subscribe(async V => {
            V && (await this.resumePausedMutations(),
            It(this, ir).onFocus())
        }
        )),
        hn(this, ba, onlineManager.subscribe(async V => {
            V && (await this.resumePausedMutations(),
            It(this, ir).onOnline())
        }
        )))
    }
    unmount() {
        var V, X;
        Vc(this, Lo)._--,
        It(this, Lo) === 0 && ((V = It(this, ya)) == null || V.call(this),
        hn(this, ya, void 0),
        (X = It(this, ba)) == null || X.call(this),
        hn(this, ba, void 0))
    }
    isFetching(V) {
        return It(this, ir).findAll({
            ...V,
            fetchStatus: "fetching"
        }).length
    }
    isMutating(V) {
        return It(this, xo).findAll({
            ...V,
            status: "pending"
        }).length
    }
    getQueryData(V) {
        var J;
        const X = this.defaultQueryOptions({
            queryKey: V
        });
        return (J = It(this, ir).get(X.queryHash)) == null ? void 0 : J.state.data
    }
    ensureQueryData(V) {
        const X = this.getQueryData(V.queryKey);
        if (X === void 0)
            return this.fetchQuery(V);
        {
            const J = this.defaultQueryOptions(V)
              , ne = It(this, ir).build(this, J);
            return V.revalidateIfStale && ne.isStaleByTime(resolveStaleTime(J.staleTime, ne)) && this.prefetchQuery(J),
            Promise.resolve(X)
        }
    }
    getQueriesData(V) {
        return It(this, ir).findAll(V).map( ({queryKey: X, state: J}) => {
            const ne = J.data;
            return [X, ne]
        }
        )
    }
    setQueryData(V, X, J) {
        const ne = this.defaultQueryOptions({
            queryKey: V
        })
          , ue = It(this, ir).get(ne.queryHash)
          , ce = ue == null ? void 0 : ue.state.data
          , me = functionalUpdate(X, ce);
        if (me !== void 0)
            return It(this, ir).build(this, ne).setData(me, {
                ...J,
                manual: !0
            })
    }
    setQueriesData(V, X, J) {
        return notifyManager.batch( () => It(this, ir).findAll(V).map( ({queryKey: ne}) => [ne, this.setQueryData(ne, X, J)]))
    }
    getQueryState(V) {
        var J;
        const X = this.defaultQueryOptions({
            queryKey: V
        });
        return (J = It(this, ir).get(X.queryHash)) == null ? void 0 : J.state
    }
    removeQueries(V) {
        const X = It(this, ir);
        notifyManager.batch( () => {
            X.findAll(V).forEach(J => {
                X.remove(J)
            }
            )
        }
        )
    }
    resetQueries(V, X) {
        const J = It(this, ir)
          , ne = {
            type: "active",
            ...V
        };
        return notifyManager.batch( () => (J.findAll(V).forEach(ue => {
            ue.reset()
        }
        ),
        this.refetchQueries(ne, X)))
    }
    cancelQueries(V={}, X={}) {
        const J = {
            revert: !0,
            ...X
        }
          , ne = notifyManager.batch( () => It(this, ir).findAll(V).map(ue => ue.cancel(J)));
        return Promise.all(ne).then(noop$6).catch(noop$6)
    }
    invalidateQueries(V={}, X={}) {
        return notifyManager.batch( () => {
            if (It(this, ir).findAll(V).forEach(ne => {
                ne.invalidate()
            }
            ),
            V.refetchType === "none")
                return Promise.resolve();
            const J = {
                ...V,
                type: V.refetchType ?? V.type ?? "active"
            };
            return this.refetchQueries(J, X)
        }
        )
    }
    refetchQueries(V={}, X) {
        const J = {
            ...X,
            cancelRefetch: (X == null ? void 0 : X.cancelRefetch) ?? !0
        }
          , ne = notifyManager.batch( () => It(this, ir).findAll(V).filter(ue => !ue.isDisabled()).map(ue => {
            let ce = ue.fetch(void 0, J);
            return J.throwOnError || (ce = ce.catch(noop$6)),
            ue.state.fetchStatus === "paused" ? Promise.resolve() : ce
        }
        ));
        return Promise.all(ne).then(noop$6)
    }
    fetchQuery(V) {
        const X = this.defaultQueryOptions(V);
        X.retry === void 0 && (X.retry = !1);
        const J = It(this, ir).build(this, X);
        return J.isStaleByTime(resolveStaleTime(X.staleTime, J)) ? J.fetch(X) : Promise.resolve(J.state.data)
    }
    prefetchQuery(V) {
        return this.fetchQuery(V).then(noop$6).catch(noop$6)
    }
    fetchInfiniteQuery(V) {
        return V.behavior = infiniteQueryBehavior(V.pages),
        this.fetchQuery(V)
    }
    prefetchInfiniteQuery(V) {
        return this.fetchInfiniteQuery(V).then(noop$6).catch(noop$6)
    }
    ensureInfiniteQueryData(V) {
        return V.behavior = infiniteQueryBehavior(V.pages),
        this.ensureQueryData(V)
    }
    resumePausedMutations() {
        return onlineManager.isOnline() ? It(this, xo).resumePausedMutations() : Promise.resolve()
    }
    getQueryCache() {
        return It(this, ir)
    }
    getMutationCache() {
        return It(this, xo)
    }
    getDefaultOptions() {
        return It(this, No)
    }
    setDefaultOptions(V) {
        hn(this, No, V)
    }
    setQueryDefaults(V, X) {
        It(this, Ia).set(hashKey(V), {
            queryKey: V,
            defaultOptions: X
        })
    }
    getQueryDefaults(V) {
        const X = [...It(this, Ia).values()];
        let J = {};
        return X.forEach(ne => {
            partialMatchKey(V, ne.queryKey) && (J = {
                ...J,
                ...ne.defaultOptions
            })
        }
        ),
        J
    }
    setMutationDefaults(V, X) {
        It(this, Ra).set(hashKey(V), {
            mutationKey: V,
            defaultOptions: X
        })
    }
    getMutationDefaults(V) {
        const X = [...It(this, Ra).values()];
        let J = {};
        return X.forEach(ne => {
            partialMatchKey(V, ne.mutationKey) && (J = {
                ...J,
                ...ne.defaultOptions
            })
        }
        ),
        J
    }
    defaultQueryOptions(V) {
        if (V._defaulted)
            return V;
        const X = {
            ...It(this, No).queries,
            ...this.getQueryDefaults(V.queryKey),
            ...V,
            _defaulted: !0
        };
        return X.queryHash || (X.queryHash = hashQueryKeyByOptions(X.queryKey, X)),
        X.refetchOnReconnect === void 0 && (X.refetchOnReconnect = X.networkMode !== "always"),
        X.throwOnError === void 0 && (X.throwOnError = !!X.suspense),
        !X.networkMode && X.persister && (X.networkMode = "offlineFirst"),
        X.enabled !== !0 && X.queryFn === skipToken && (X.enabled = !1),
        X
    }
    defaultMutationOptions(V) {
        return V != null && V._defaulted ? V : {
            ...It(this, No).mutations,
            ...(V == null ? void 0 : V.mutationKey) && this.getMutationDefaults(V.mutationKey),
            ...V,
            _defaulted: !0
        }
    }
    clear() {
        It(this, ir).clear(),
        It(this, xo).clear()
    }
}
,
ir = new WeakMap,
xo = new WeakMap,
No = new WeakMap,
Ia = new WeakMap,
Ra = new WeakMap,
Lo = new WeakMap,
ya = new WeakMap,
ba = new WeakMap,
XE), wr, Nn, Rl, Cr, Ti, $a, Po, Fs, yl, Oa, Ca, Ai, _i, Mo, va, Fn, _l, _p, Sp, Ip, Rp, yp, bp, $p, JE, zE, QueryObserver = (zE = class extends Subscribable {
    constructor(X, J) {
        super();
        _n(this, Fn);
        _n(this, wr);
        _n(this, Nn);
        _n(this, Rl);
        _n(this, Cr);
        _n(this, Ti);
        _n(this, $a);
        _n(this, Po);
        _n(this, Fs);
        _n(this, yl);
        _n(this, Oa);
        _n(this, Ca);
        _n(this, Ai);
        _n(this, _i);
        _n(this, Mo);
        _n(this, va, new Set);
        this.options = J,
        hn(this, wr, X),
        hn(this, Fs, null),
        hn(this, Po, pendingThenable()),
        this.options.experimental_prefetchInRender || It(this, Po).reject(new Error("experimental_prefetchInRender feature flag is not enabled")),
        this.bindMethods(),
        this.setOptions(J)
    }
    bindMethods() {
        this.refetch = this.refetch.bind(this)
    }
    onSubscribe() {
        this.listeners.size === 1 && (It(this, Nn).addObserver(this),
        shouldFetchOnMount(It(this, Nn), this.options) ? Cn(this, Fn, _l).call(this) : this.updateResult(),
        Cn(this, Fn, Rp).call(this))
    }
    onUnsubscribe() {
        this.hasListeners() || this.destroy()
    }
    shouldFetchOnReconnect() {
        return shouldFetchOn(It(this, Nn), this.options, this.options.refetchOnReconnect)
    }
    shouldFetchOnWindowFocus() {
        return shouldFetchOn(It(this, Nn), this.options, this.options.refetchOnWindowFocus)
    }
    destroy() {
        this.listeners = new Set,
        Cn(this, Fn, yp).call(this),
        Cn(this, Fn, bp).call(this),
        It(this, Nn).removeObserver(this)
    }
    setOptions(X, J) {
        const ne = this.options
          , ue = It(this, Nn);
        if (this.options = It(this, wr).defaultQueryOptions(X),
        this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof resolveEnabled(this.options.enabled, It(this, Nn)) != "boolean")
            throw new Error("Expected enabled to be a boolean or a callback that returns a boolean");
        Cn(this, Fn, $p).call(this),
        It(this, Nn).setOptions(this.options),
        ne._defaulted && !shallowEqualObjects(this.options, ne) && It(this, wr).getQueryCache().notify({
            type: "observerOptionsUpdated",
            query: It(this, Nn),
            observer: this
        });
        const ce = this.hasListeners();
        ce && shouldFetchOptionally(It(this, Nn), ue, this.options, ne) && Cn(this, Fn, _l).call(this),
        this.updateResult(J),
        ce && (It(this, Nn) !== ue || resolveEnabled(this.options.enabled, It(this, Nn)) !== resolveEnabled(ne.enabled, It(this, Nn)) || resolveStaleTime(this.options.staleTime, It(this, Nn)) !== resolveStaleTime(ne.staleTime, It(this, Nn))) && Cn(this, Fn, _p).call(this);
        const me = Cn(this, Fn, Sp).call(this);
        ce && (It(this, Nn) !== ue || resolveEnabled(this.options.enabled, It(this, Nn)) !== resolveEnabled(ne.enabled, It(this, Nn)) || me !== It(this, Mo)) && Cn(this, Fn, Ip).call(this, me)
    }
    getOptimisticResult(X) {
        const J = It(this, wr).getQueryCache().build(It(this, wr), X)
          , ne = this.createResult(J, X);
        return shouldAssignObserverCurrentProperties(this, ne) && (hn(this, Cr, ne),
        hn(this, $a, this.options),
        hn(this, Ti, It(this, Nn).state)),
        ne
    }
    getCurrentResult() {
        return It(this, Cr)
    }
    trackResult(X, J) {
        const ne = {};
        return Object.keys(X).forEach(ue => {
            Object.defineProperty(ne, ue, {
                configurable: !1,
                enumerable: !0,
                get: () => (this.trackProp(ue),
                J == null || J(ue),
                X[ue])
            })
        }
        ),
        ne
    }
    trackProp(X) {
        It(this, va).add(X)
    }
    getCurrentQuery() {
        return It(this, Nn)
    }
    refetch({...X}={}) {
        return this.fetch({
            ...X
        })
    }
    fetchOptimistic(X) {
        const J = It(this, wr).defaultQueryOptions(X)
          , ne = It(this, wr).getQueryCache().build(It(this, wr), J);
        return ne.fetch().then( () => this.createResult(ne, J))
    }
    fetch(X) {
        return Cn(this, Fn, _l).call(this, {
            ...X,
            cancelRefetch: X.cancelRefetch ?? !0
        }).then( () => (this.updateResult(),
        It(this, Cr)))
    }
    createResult(X, J) {
        var Ze;
        const ne = It(this, Nn)
          , ue = this.options
          , ce = It(this, Cr)
          , me = It(this, Ti)
          , ge = It(this, $a)
          , _e = X !== ne ? X.state : It(this, Rl)
          , {state: Se} = X;
        let Ie = {
            ...Se
        }, ye = !1, $e;
        if (J._optimisticResults) {
            const et = this.hasListeners()
              , it = !et && shouldFetchOnMount(X, J)
              , at = et && shouldFetchOptionally(X, ne, J, ue);
            (it || at) && (Ie = {
                ...Ie,
                ...fetchState(Se.data, X.options)
            }),
            J._optimisticResults === "isRestoring" && (Ie.fetchStatus = "idle")
        }
        let {error: Ne, errorUpdatedAt: ve, status: ke} = Ie;
        if (J.select && Ie.data !== void 0)
            if (ce && Ie.data === (me == null ? void 0 : me.data) && J.select === It(this, yl))
                $e = It(this, Oa);
            else
                try {
                    hn(this, yl, J.select),
                    $e = J.select(Ie.data),
                    $e = replaceData(ce == null ? void 0 : ce.data, $e, J),
                    hn(this, Oa, $e),
                    hn(this, Fs, null)
                } catch (et) {
                    hn(this, Fs, et)
                }
        else
            $e = Ie.data;
        if (J.placeholderData !== void 0 && $e === void 0 && ke === "pending") {
            let et;
            if (ce != null && ce.isPlaceholderData && J.placeholderData === (ge == null ? void 0 : ge.placeholderData))
                et = ce.data;
            else if (et = typeof J.placeholderData == "function" ? J.placeholderData((Ze = It(this, Ca)) == null ? void 0 : Ze.state.data, It(this, Ca)) : J.placeholderData,
            J.select && et !== void 0)
                try {
                    et = J.select(et),
                    hn(this, Fs, null)
                } catch (it) {
                    hn(this, Fs, it)
                }
            et !== void 0 && (ke = "success",
            $e = replaceData(ce == null ? void 0 : ce.data, et, J),
            ye = !0)
        }
        It(this, Fs) && (Ne = It(this, Fs),
        $e = It(this, Oa),
        ve = Date.now(),
        ke = "error");
        const xe = Ie.fetchStatus === "fetching"
          , we = ke === "pending"
          , Fe = ke === "error"
          , je = we && xe
          , Xe = $e !== void 0
          , qe = {
            status: ke,
            fetchStatus: Ie.fetchStatus,
            isPending: we,
            isSuccess: ke === "success",
            isError: Fe,
            isInitialLoading: je,
            isLoading: je,
            data: $e,
            dataUpdatedAt: Ie.dataUpdatedAt,
            error: Ne,
            errorUpdatedAt: ve,
            failureCount: Ie.fetchFailureCount,
            failureReason: Ie.fetchFailureReason,
            errorUpdateCount: Ie.errorUpdateCount,
            isFetched: Ie.dataUpdateCount > 0 || Ie.errorUpdateCount > 0,
            isFetchedAfterMount: Ie.dataUpdateCount > _e.dataUpdateCount || Ie.errorUpdateCount > _e.errorUpdateCount,
            isFetching: xe,
            isRefetching: xe && !we,
            isLoadingError: Fe && !Xe,
            isPaused: Ie.fetchStatus === "paused",
            isPlaceholderData: ye,
            isRefetchError: Fe && Xe,
            isStale: isStale(X, J),
            refetch: this.refetch,
            promise: It(this, Po)
        };
        if (this.options.experimental_prefetchInRender) {
            const et = rt => {
                qe.status === "error" ? rt.reject(qe.error) : qe.data !== void 0 && rt.resolve(qe.data)
            }
              , it = () => {
                const rt = hn(this, Po, qe.promise = pendingThenable());
                et(rt)
            }
              , at = It(this, Po);
            switch (at.status) {
            case "pending":
                X.queryHash === ne.queryHash && et(at);
                break;
            case "fulfilled":
                (qe.status === "error" || qe.data !== at.value) && it();
                break;
            case "rejected":
                (qe.status !== "error" || qe.error !== at.reason) && it();
                break
            }
        }
        return qe
    }
    updateResult(X) {
        const J = It(this, Cr)
          , ne = this.createResult(It(this, Nn), this.options);
        if (hn(this, Ti, It(this, Nn).state),
        hn(this, $a, this.options),
        It(this, Ti).data !== void 0 && hn(this, Ca, It(this, Nn)),
        shallowEqualObjects(ne, J))
            return;
        hn(this, Cr, ne);
        const ue = {}
          , ce = () => {
            if (!J)
                return !0;
            const {notifyOnChangeProps: me} = this.options
              , ge = typeof me == "function" ? me() : me;
            if (ge === "all" || !ge && !It(this, va).size)
                return !0;
            const Te = new Set(ge ?? It(this, va));
            return this.options.throwOnError && Te.add("error"),
            Object.keys(It(this, Cr)).some(_e => {
                const Se = _e;
                return It(this, Cr)[Se] !== J[Se] && Te.has(Se)
            }
            )
        }
        ;
        (X == null ? void 0 : X.listeners) !== !1 && ce() && (ue.listeners = !0),
        Cn(this, Fn, JE).call(this, {
            ...ue,
            ...X
        })
    }
    onQueryUpdate() {
        this.updateResult(),
        this.hasListeners() && Cn(this, Fn, Rp).call(this)
    }
}
,
wr = new WeakMap,
Nn = new WeakMap,
Rl = new WeakMap,
Cr = new WeakMap,
Ti = new WeakMap,
$a = new WeakMap,
Po = new WeakMap,
Fs = new WeakMap,
yl = new WeakMap,
Oa = new WeakMap,
Ca = new WeakMap,
Ai = new WeakMap,
_i = new WeakMap,
Mo = new WeakMap,
va = new WeakMap,
Fn = new WeakSet,
_l = function(X) {
    Cn(this, Fn, $p).call(this);
    let J = It(this, Nn).fetch(this.options, X);
    return X != null && X.throwOnError || (J = J.catch(noop$6)),
    J
}
,
_p = function() {
    Cn(this, Fn, yp).call(this);
    const X = resolveStaleTime(this.options.staleTime, It(this, Nn));
    if (isServer || It(this, Cr).isStale || !isValidTimeout(X))
        return;
    const ne = timeUntilStale(It(this, Cr).dataUpdatedAt, X) + 1;
    hn(this, Ai, setTimeout( () => {
        It(this, Cr).isStale || this.updateResult()
    }
    , ne))
}
,
Sp = function() {
    return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(It(this, Nn)) : this.options.refetchInterval) ?? !1
}
,
Ip = function(X) {
    Cn(this, Fn, bp).call(this),
    hn(this, Mo, X),
    !(isServer || resolveEnabled(this.options.enabled, It(this, Nn)) === !1 || !isValidTimeout(It(this, Mo)) || It(this, Mo) === 0) && hn(this, _i, setInterval( () => {
        (this.options.refetchIntervalInBackground || focusManager.isFocused()) && Cn(this, Fn, _l).call(this)
    }
    , It(this, Mo)))
}
,
Rp = function() {
    Cn(this, Fn, _p).call(this),
    Cn(this, Fn, Ip).call(this, Cn(this, Fn, Sp).call(this))
}
,
yp = function() {
    It(this, Ai) && (clearTimeout(It(this, Ai)),
    hn(this, Ai, void 0))
}
,
bp = function() {
    It(this, _i) && (clearInterval(It(this, _i)),
    hn(this, _i, void 0))
}
,
$p = function() {
    const X = It(this, wr).getQueryCache().build(It(this, wr), this.options);
    if (X === It(this, Nn))
        return;
    const J = It(this, Nn);
    hn(this, Nn, X),
    hn(this, Rl, X.state),
    this.hasListeners() && (J == null || J.removeObserver(this),
    X.addObserver(this))
}
,
JE = function(X) {
    notifyManager.batch( () => {
        X.listeners && this.listeners.forEach(J => {
            J(It(this, Cr))
        }
        ),
        It(this, wr).getQueryCache().notify({
            query: It(this, Nn),
            type: "observerResultsUpdated"
        })
    }
    )
}
,
zE);
function shouldLoadOnMount(V, X) {
    return resolveEnabled(X.enabled, V) !== !1 && V.state.data === void 0 && !(V.state.status === "error" && X.retryOnMount === !1)
}
function shouldFetchOnMount(V, X) {
    return shouldLoadOnMount(V, X) || V.state.data !== void 0 && shouldFetchOn(V, X, X.refetchOnMount)
}
function shouldFetchOn(V, X, J) {
    if (resolveEnabled(X.enabled, V) !== !1) {
        const ne = typeof J == "function" ? J(V) : J;
        return ne === "always" || ne !== !1 && isStale(V, X)
    }
    return !1
}
function shouldFetchOptionally(V, X, J, ne) {
    return (V !== X || resolveEnabled(ne.enabled, V) === !1) && (!J.suspense || V.state.status !== "error") && isStale(V, J)
}
function isStale(V, X) {
    return resolveEnabled(X.enabled, V) !== !1 && V.isStaleByTime(resolveStaleTime(X.staleTime, V))
}
function shouldAssignObserverCurrentProperties(V, X) {
    return !shallowEqualObjects(V.getCurrentResult(), X)
}
var ko, Do, Br, ro, so, Gc, Op, KE, MutationObserver$1 = (KE = class extends Subscribable {
    constructor(J, ne) {
        super();
        _n(this, so);
        _n(this, ko);
        _n(this, Do);
        _n(this, Br);
        _n(this, ro);
        hn(this, ko, J),
        this.setOptions(ne),
        this.bindMethods(),
        Cn(this, so, Gc).call(this)
    }
    bindMethods() {
        this.mutate = this.mutate.bind(this),
        this.reset = this.reset.bind(this)
    }
    setOptions(J) {
        var ue;
        const ne = this.options;
        this.options = It(this, ko).defaultMutationOptions(J),
        shallowEqualObjects(this.options, ne) || It(this, ko).getMutationCache().notify({
            type: "observerOptionsUpdated",
            mutation: It(this, Br),
            observer: this
        }),
        ne != null && ne.mutationKey && this.options.mutationKey && hashKey(ne.mutationKey) !== hashKey(this.options.mutationKey) ? this.reset() : ((ue = It(this, Br)) == null ? void 0 : ue.state.status) === "pending" && It(this, Br).setOptions(this.options)
    }
    onUnsubscribe() {
        var J;
        this.hasListeners() || (J = It(this, Br)) == null || J.removeObserver(this)
    }
    onMutationUpdate(J) {
        Cn(this, so, Gc).call(this),
        Cn(this, so, Op).call(this, J)
    }
    getCurrentResult() {
        return It(this, Do)
    }
    reset() {
        var J;
        (J = It(this, Br)) == null || J.removeObserver(this),
        hn(this, Br, void 0),
        Cn(this, so, Gc).call(this),
        Cn(this, so, Op).call(this)
    }
    mutate(J, ne) {
        var ue;
        return hn(this, ro, ne),
        (ue = It(this, Br)) == null || ue.removeObserver(this),
        hn(this, Br, It(this, ko).getMutationCache().build(It(this, ko), this.options)),
        It(this, Br).addObserver(this),
        It(this, Br).execute(J)
    }
}
,
ko = new WeakMap,
Do = new WeakMap,
Br = new WeakMap,
ro = new WeakMap,
so = new WeakSet,
Gc = function() {
    var ne;
    const J = ((ne = It(this, Br)) == null ? void 0 : ne.state) ?? getDefaultState();
    hn(this, Do, {
        ...J,
        isPending: J.status === "pending",
        isSuccess: J.status === "success",
        isError: J.status === "error",
        isIdle: J.status === "idle",
        mutate: this.mutate,
        reset: this.reset
    })
}
,
Op = function(J) {
    notifyManager.batch( () => {
        var ne, ue, ce, me, ge, Te, _e, Se;
        if (It(this, ro) && this.hasListeners()) {
            const Ie = It(this, Do).variables
              , ye = It(this, Do).context;
            (J == null ? void 0 : J.type) === "success" ? ((ue = (ne = It(this, ro)).onSuccess) == null || ue.call(ne, J.data, Ie, ye),
            (me = (ce = It(this, ro)).onSettled) == null || me.call(ce, J.data, null, Ie, ye)) : (J == null ? void 0 : J.type) === "error" && ((Te = (ge = It(this, ro)).onError) == null || Te.call(ge, J.error, Ie, ye),
            (Se = (_e = It(this, ro)).onSettled) == null || Se.call(_e, void 0, J.error, Ie, ye))
        }
        this.listeners.forEach(Ie => {
            Ie(It(this, Do))
        }
        )
    }
    )
}
,
KE);
function defaultTransformerFn(V) {
    return V
}
function dehydrateMutation(V) {
    return {
        mutationKey: V.options.mutationKey,
        state: V.state,
        ...V.options.scope && {
            scope: V.options.scope
        },
        ...V.meta && {
            meta: V.meta
        }
    }
}
function dehydrateQuery(V, X) {
    var J;
    return {
        state: {
            ...V.state,
            ...V.state.data !== void 0 && {
                data: X(V.state.data)
            }
        },
        queryKey: V.queryKey,
        queryHash: V.queryHash,
        ...V.state.status === "pending" && {
            promise: (J = V.promise) == null ? void 0 : J.then(X).catch(ne => Promise.reject(new Error("redacted")))
        },
        ...V.meta && {
            meta: V.meta
        }
    }
}
function defaultShouldDehydrateMutation(V) {
    return V.state.isPaused
}
function defaultShouldDehydrateQuery(V) {
    return V.state.status === "success"
}
function dehydrate(V, X={}) {
    var ge, Te, _e;
    const J = X.shouldDehydrateMutation ?? ((ge = V.getDefaultOptions().dehydrate) == null ? void 0 : ge.shouldDehydrateMutation) ?? defaultShouldDehydrateMutation
      , ne = V.getMutationCache().getAll().flatMap(Se => J(Se) ? [dehydrateMutation(Se)] : [])
      , ue = X.shouldDehydrateQuery ?? ((Te = V.getDefaultOptions().dehydrate) == null ? void 0 : Te.shouldDehydrateQuery) ?? defaultShouldDehydrateQuery
      , ce = X.serializeData ?? ((_e = V.getDefaultOptions().dehydrate) == null ? void 0 : _e.serializeData) ?? defaultTransformerFn
      , me = V.getQueryCache().getAll().flatMap(Se => ue(Se) ? [dehydrateQuery(Se, ce)] : []);
    return {
        mutations: ne,
        queries: me
    }
}
function hydrate(V, X, J) {
    var Te, _e;
    if (typeof X != "object" || X === null)
        return;
    const ne = V.getMutationCache()
      , ue = V.getQueryCache()
      , ce = ((Te = J == null ? void 0 : J.defaultOptions) == null ? void 0 : Te.deserializeData) ?? ((_e = V.getDefaultOptions().hydrate) == null ? void 0 : _e.deserializeData) ?? defaultTransformerFn
      , me = X.mutations || []
      , ge = X.queries || [];
    me.forEach( ({state: Se, ...Ie}) => {
        var ye, $e;
        ne.build(V, {
            ...(ye = V.getDefaultOptions().hydrate) == null ? void 0 : ye.mutations,
            ...($e = J == null ? void 0 : J.defaultOptions) == null ? void 0 : $e.mutations,
            ...Ie
        }, Se)
    }
    ),
    ge.forEach( ({queryKey: Se, state: Ie, queryHash: ye, meta: $e, promise: Ne}) => {
        var xe, we;
        let ve = ue.get(ye);
        const ke = Ie.data === void 0 ? Ie.data : ce(Ie.data);
        if (ve) {
            if (ve.state.dataUpdatedAt < Ie.dataUpdatedAt) {
                const {fetchStatus: Fe, ...je} = Ie;
                ve.setState({
                    ...je,
                    data: ke
                })
            }
        } else
            ve = ue.build(V, {
                ...(xe = V.getDefaultOptions().hydrate) == null ? void 0 : xe.queries,
                ...(we = J == null ? void 0 : J.defaultOptions) == null ? void 0 : we.queries,
                queryKey: Se,
                queryHash: ye,
                meta: $e
            }, {
                ...Ie,
                data: ke,
                fetchStatus: "idle"
            });
        if (Ne) {
            const Fe = Promise.resolve(Ne).then(ce);
            ve.fetch(void 0, {
                initialPromise: Fe
            })
        }
    }
    )
}
var QueryClientContext = reactExports.createContext(void 0)
  , useQueryClient = V => {
    const X = reactExports.useContext(QueryClientContext);
    if (!X)
        throw new Error("No QueryClient set, use QueryClientProvider to set one");
    return X
}
  , QueryClientProvider = ({client: V, children: X}) => (reactExports.useEffect( () => (V.mount(),
() => {
    V.unmount()
}
), [V]),
jsxRuntimeExports.jsx(QueryClientContext.Provider, {
    value: V,
    children: X
}))
  , IsRestoringContext = reactExports.createContext(!1)
  , useIsRestoring = () => reactExports.useContext(IsRestoringContext)
  , IsRestoringProvider = IsRestoringContext.Provider;
function createValue() {
    let V = !1;
    return {
        clearReset: () => {
            V = !1
        }
        ,
        reset: () => {
            V = !0
        }
        ,
        isReset: () => V
    }
}
var QueryErrorResetBoundaryContext = reactExports.createContext(createValue())
  , useQueryErrorResetBoundary = () => reactExports.useContext(QueryErrorResetBoundaryContext)
  , QueryErrorResetBoundary = ({children: V}) => {
    const [X] = reactExports.useState( () => createValue());
    return jsxRuntimeExports.jsx(QueryErrorResetBoundaryContext.Provider, {
        value: X,
        children: typeof V == "function" ? V(X) : V
    })
}
;
function shouldThrowError(V, X) {
    return typeof V == "function" ? V(...X) : !!V
}
function noop$5() {}
var ensurePreventErrorBoundaryRetry = (V, X) => {
    (V.suspense || V.throwOnError || V.experimental_prefetchInRender) && (X.isReset() || (V.retryOnMount = !1))
}
  , useClearResetErrorBoundary = V => {
    reactExports.useEffect( () => {
        V.clearReset()
    }
    , [V])
}
  , getHasError = ({result: V, errorResetBoundary: X, throwOnError: J, query: ne}) => V.isError && !X.isReset() && !V.isFetching && ne && shouldThrowError(J, [V.error, ne])
  , ensureSuspenseTimers = V => {
    V.suspense && (V.staleTime === void 0 && (V.staleTime = 1e3),
    typeof V.gcTime == "number" && (V.gcTime = Math.max(V.gcTime, 1e3)))
}
  , willFetch = (V, X) => V.isLoading && V.isFetching && !X
  , shouldSuspend = (V, X) => (V == null ? void 0 : V.suspense) && X.isPending
  , fetchOptimistic = (V, X, J) => X.fetchOptimistic(V).catch( () => {
    J.clearReset()
}
);
function useBaseQuery(V, X, J) {
    var Se, Ie, ye, $e, Ne;
    const ne = useQueryClient()
      , ue = useIsRestoring()
      , ce = useQueryErrorResetBoundary()
      , me = ne.defaultQueryOptions(V);
    (Ie = (Se = ne.getDefaultOptions().queries) == null ? void 0 : Se._experimental_beforeQuery) == null || Ie.call(Se, me),
    me._optimisticResults = ue ? "isRestoring" : "optimistic",
    ensureSuspenseTimers(me),
    ensurePreventErrorBoundaryRetry(me, ce),
    useClearResetErrorBoundary(ce);
    const ge = !ne.getQueryCache().get(me.queryHash)
      , [Te] = reactExports.useState( () => new X(ne,me))
      , _e = Te.getOptimisticResult(me);
    if (reactExports.useSyncExternalStore(reactExports.useCallback(ve => {
        const ke = ue ? () => {}
        : Te.subscribe(notifyManager.batchCalls(ve));
        return Te.updateResult(),
        ke
    }
    , [Te, ue]), () => Te.getCurrentResult(), () => Te.getCurrentResult()),
    reactExports.useEffect( () => {
        Te.setOptions(me, {
            listeners: !1
        })
    }
    , [me, Te]),
    shouldSuspend(me, _e))
        throw fetchOptimistic(me, Te, ce);
    if (getHasError({
        result: _e,
        errorResetBoundary: ce,
        throwOnError: me.throwOnError,
        query: ne.getQueryCache().get(me.queryHash)
    }))
        throw _e.error;
    if (($e = (ye = ne.getDefaultOptions().queries) == null ? void 0 : ye._experimental_afterQuery) == null || $e.call(ye, me, _e),
    me.experimental_prefetchInRender && !isServer && willFetch(_e, ue)) {
        const ve = ge ? fetchOptimistic(me, Te, ce) : (Ne = ne.getQueryCache().get(me.queryHash)) == null ? void 0 : Ne.promise;
        ve == null || ve.catch(noop$5).finally( () => {
            Te.updateResult()
        }
        )
    }
    return me.notifyOnChangeProps ? _e : Te.trackResult(_e)
}
function useQuery(V, X) {
    return useBaseQuery(V, QueryObserver)
}
function useMutation(V, X) {
    const J = useQueryClient()
      , [ne] = reactExports.useState( () => new MutationObserver$1(J,V));
    reactExports.useEffect( () => {
        ne.setOptions(V)
    }
    , [ne, V]);
    const ue = reactExports.useSyncExternalStore(reactExports.useCallback(me => ne.subscribe(notifyManager.batchCalls(me)), [ne]), () => ne.getCurrentResult(), () => ne.getCurrentResult())
      , ce = reactExports.useCallback( (me, ge) => {
        ne.mutate(me, ge).catch(noop$5)
    }
    , [ne]);
    if (ue.error && shouldThrowError(ne.options.throwOnError, [ue.error]))
        throw ue.error;
    return {
        ...ue,
        mutate: ce,
        mutateAsync: ue.mutate
    }
}
const isLoggerEnabled = localStorage.getItem(LOCAL_STORAGE_KEY.LOGGER) === "true"
  , loggerInstances = {};
let defaultLoggerLevel = 0
  , hue = 0;
function generateColor() {
    return hue += .618033988749895,
    hue = hue % 1,
    hue * 360
}
const scopeColorsMap = {};
let Logger$1 = class Ds {
    constructor(...X) {
        Tt(this, "context");
        Tt(this, "currentLevel", defaultLoggerLevel);
        Tt(this, "trace");
        Tt(this, "debug");
        Tt(this, "log");
        Tt(this, "info");
        Tt(this, "warn");
        Tt(this, "error");
        this.context = X,
        isLoggerEnabled ? (this.trace = this.currentLevel > 0 ? () => {}
        : createEmitter("trace", X),
        this.debug = this.currentLevel > 1 ? () => {}
        : createEmitter("debug", X),
        this.log = this.currentLevel > 2 ? () => {}
        : createEmitter("log", X),
        this.info = this.currentLevel > 3 ? () => {}
        : createEmitter("info", X),
        this.warn = this.currentLevel > 4 ? () => {}
        : createEmitter("warn", X),
        this.error = this.currentLevel > 5 ? () => {}
        : createEmitter("error", X)) : (this.trace = () => {}
        ,
        this.debug = () => {}
        ,
        this.log = () => {}
        ,
        this.info = () => {}
        ,
        this.warn = () => {}
        ,
        this.error = () => {}
        )
    }
    static get default() {
        return Ds.get()
    }
    static get(...X) {
        const J = X.join("_");
        return loggerInstances[J] || (loggerInstances[J] = new Ds(...X))
    }
    getLevel() {
        return this.currentLevel
    }
    setLevel(X) {
        this.currentLevel = X
    }
    static setGlobalLevel(X) {
        defaultLoggerLevel = X,
        Object.values(loggerInstances).forEach(J => {
            J.setLevel(X)
        }
        )
    }
    extend(...X) {
        const J = [...this.context, ...X];
        return Ds.get(...J)
    }
    static get trace() {
        return Ds.default.trace
    }
    static get debug() {
        return Ds.default.debug
    }
    static get log() {
        return Ds.default.log
    }
    static get info() {
        return Ds.default.info
    }
    static get warn() {
        return Ds.default.warn
    }
    static get error() {
        return Ds.default.error
    }
}
;
function createEmitter(V, X) {
    const J = [];
    if (X.length > 0) {
        const ne = "→";
        let ce = "%c" + X.join(":");
        ce += Array(Math.max(22 - ce.length, 2)).join(" ") + ne,
        scopeColorsMap[X[0]] || (scopeColorsMap[X[0]] = generateColor());
        const me = "color: hsl(" + scopeColorsMap[X[0]] + ",99%,40%); font-weight: bold";
        J.push(ce, me)
    }
    return getNativeConsole(V).bind(console, ...J)
}
function getNativeConsole(V) {
    switch (V) {
    case "trace":
        return console.trace;
    case "debug":
        return console.debug || console.log;
    case "log":
        return console.log;
    case "info":
        return console.info;
    case "warn":
        return console.warn;
    case "error":
        return console.error;
    default:
        throw Error("Unknown Logger emitter type: " + V)
    }
}
const armorImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAACXBIWXMAACxLAAAsSwGlPZapAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAVLSURBVHgB7d3tcVpHGIbhVSpwCS7BKsGVWCXEFdipIO4gTiVpISVQgjog+45hhmj0gfg4nN3numaYo9+C59YKCWgNAAAAAAAAAAAAAAAAAAAAWJu7tlLbrsEk7rq2Qr81IJYAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEW3MANg3msGkrteYAfG4iwPg27ddjeZXu2optt9uP/fJPv31sMJ5Nv32+u7vbtJVadQCKCDCoTVv5+MvqA1BEgME89tv92sdfhvgrwO4b6TkBRlDjX/1P/r0hTgB7TgKs3H78/7ZBDBWAIgKs1HDjL8MFoIgAKzPk+MuQ/wl48JzAcN9wpjPs+MuQJ4C9fhL40H6dBD41WN7Q4y9DB6CIADcy/PjL8AEoIsDCphh/mSIARQRYyDTjL9O8HLjfIY/9dt+//LvBdUw1/jLNCeBQPw387JcvDS5nuvGXKQNQRIALmnL8ZdoAFBHgAqYdf5n6LcH6nfbQLz8anGbq8Zfp3xOw33lf++V7g/eZfvxl6l8BDvVfB741IeA4EeMvMQEoIsARYsZfogJQRIBXRI2/xAWgiAAvuE8af4n8YJB+J//RBID/e0gbf4k8Aew5CbBT44/8F/LoABQRiBc7/hIfgCICsaLHXwRgp0fg9375s5EifvxFAA70CDz0y1+N2Rn/jgA8IQLTM/4DAvAMEZiW8T8hAC8QgekY/zME4BU9AvX+gvU+gx8aIzP+FwjAG0RgeMb/CgE4gggMy/jfIABHEoHhGP8RIl8MdIrdC0Xq8wg3jbUz/iM5AbyTTyZePeN/BwE4gQislvG/kwCcSARWx/hPIABnEIHVMP4TCcCZRODmjP8M/gpwpv7g2zR/HbiV78Z/HieAC3ESWNz33Xs7cgYBuCARWIzxX4gAXJgIXJ3xX5DnAC7s4DmBuLeYXoDxX5gTwJX0k0C9ZqBOAp8al2D8VyAAVyQCF2P8VyIAVyYCZzP+KxKABYjAyYz/yjwJuID+IH7st/v+pX9aOZ7xL8AJYGH9NPCzX740XmP8CxGAGxCBVxn/ggTgRkTgWca/MM8B3Eh/oD/0y4/GnvHfgADcUH/Af20+lbgYP7nq48m3ub41SLfNjIDxw942KwLGD09tMyJg/PCS7dwRMH54y3bOCBg/HGs7VwSMHwAAAAAAAAAAAAAAAAAAAOAI/wE5nWRua8vmRwAAAABJRU5ErkJggg=="
  , c4Img = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAACXBIWXMAACxLAAAsSwGlPZapAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAATLSURBVHgB7d3RbdtWGIbhn0Xu6xE0gr2BvEE6gdMROkFHaDeoO0GSCZwN4hE4QjZgjmFdxVRMkZJD6Xse4IAXNgxC5v9KlESpCgAAAAAAAAAAAAAAAAAAAIB4w2H+K07mtwJiCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMG6YrFhGLZt83edxmPXdX/VGWq3yz9tcz3yo21N1+/Wj/5tt8vnYpF3xTFs6rCDOsXT8G9rmc1u/ei+WMwpAAQTAAgmABBMACCYJwEvzO6Z9/d1Gp/O9RUJxgnA5bmq8WfNj/W3uSBOASCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMJ8ItNAwDJu2eajTvf2WcX1bt13X9cVsArCA4f/l+hKBRQRgJsO/Gn2JwGwCMIPhX52+RGAWATiQ4V+tvq2bFoFvxWReBThAG/6n6+E/luFfo01bD7v/ERN5BDDR7sB6uue/LtbssZ5PBzwSmEAAJjD8Z0cEJhKAVxj+syUCEwjATxj+sycCrxCAPQz/xRCBnxCAPVoAvpbhvxRPX7B6U7wgAHu0AAzFxWgBcKyP8D4ACCYAEEwAIJgAQDDfDXhaX+r5IhXm27S1LXhLw3HcFYu02/DDcATFKKcAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEe1ec0tUwDJtiid+Lk+mKUW1wh+JidE3xglMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABDMtQCn9aWtvtbhfVtXE3+3r+d9X4NNW9uCtzQcx12tRNuXhwP2+6FWou3Lh+EIilFOASCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAsK4YNTTFxeia4gWPACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTgP3+Ly7FfTGqK/YahuG+be6Kc3bfdd2fxSgBeEWLwEPbbItz9KkN/x/FXgLwihaAq7Z5isB1cU4e27ptAfhW7CUAE4jA2TH8EwnARCJwNgz/AQTgACKweob/QAJwIBFYLcM/gwDMIAKrY/hnEoCZRGA1DP8CArDALgJf29oUv0Lf1o3hn89bgRfYHXi39Xwg8rb6cs8PAAAAAAAAAAAAAAAAAAAAXKDv6votSyyA8U8AAAAASUVORK5CYII="
  , droneImg = "/bf6/11303125/assets/DRONE-BloJncsy.png"
  , m4Img = "/bf6/11303125/assets/M4SLAM-B8Micc4n.png"
  , motionGrenadeImg = "/bf6/11303125/assets/MOTION-SENSOR-GRENADE-BDCa0wwb.png"
  , supplyCrateImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAACXBIWXMAACxLAAAsSwGlPZapAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAWzSURBVHgB7d3RcdRWFIDhsxkKoIO4BJdgKgipIE4HdICpIHQAVBBSgaGCUILSgVOBcq9tmMkkgG3dI690vm9mRy/2g609/2hX0lUEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkGye55M532VQSt/nc74f48j9EEBZAgCFCQAUJgBQmABAYQIAhQkAFCYAUJgAQGECAIUJABT2JFY2z/Pztnl6j1+5z88+VL/f4DyoZI331fP2vvr7Hj9/dTgc3seKDrGi9s+4aJuXAXzNqxaBi1jJagEw/HBnq0VglQAYfri3VSKQHgDDDw+WHoHUALThf9E2vwXwUOctAu8iSVoAbr9VfxPAUmkRSAmA4YfhUiIwPACGH9IMj8DQABh+SDc0AsMCYPhhNcMiMCQAhh9WNyQCiwNg+OHRLI7AiADMATyKFoBFM+x2YChMAKAwAYDCBAAKG7Ei0Fnk6iu3ZK+S8qm9XgSVvG6v08h13l5THLHFAWhfQn6MRO0kw0nku8r+Ozgu7X11Ffk+tPfVX3HEfASAwgQAChMAKEwAoDABgMIEAAoTAChMAKAwAYDCBAAKEwAoTACgMAGAwhbfDTjPc/aCoE8j3+kKfwfH5STyvc6+6/BwOPwaC1gUFDbMoqDAgwkAFCYAUJgAQGECAIUJABQmAFCYAEBhAgCFCQAUJgBQmABAYSMeDspxmeLmQacZd6H1h7SucXcmKxGA/ZkOh8MfkWCe5/4U5bNgN3wEgMIEAAoTAChMAKAwAYDCBAAKEwAoTACgMAGAwgQAChMAKEwAoDABgMIEAAoTAChMAKAwAYDCBAAKEwAoTACgMAHgPlIWG+XxCMD+pC3bfTgcXrfNRbAbArA/p/M8v4kkLQKvQgR2QwD26bxF4CKSiMB+CMB+vRQBvucQC7U32Rwcs1dtWC8iSdv9b9vml+BRtH27aIYdAexf9pHAedu8CzZJAGoQAf6XANQhAvyHANQiAvyLANQjAnwhADWJANecBhyrXyr7KXI8v32NlH2K8KcYf2nyWXudB9eWngYUgLHO2v74GEmSzrmnRmC09j84a5vL4JrrAApJOrRO/TjAcROAjREBRhKADRIBRhGAjRIBRhCADRMBlhKAjRMBlhCAHRABHkoAduI2Ah9irB4B9/rvmADsy88x/krEtyKwXwKwI+0o4KptnoUIcEcCsDMiwH0IwA6JAHclADslAtyFAOyYCPA9ArBzIsC3CEABIsDXCEARyRE4CzZJAAq5jUC/WGiKsX5vETgNNkcAimkRmOLmSGCKcfq6f5cisD0CUJAI8JkAjDV6Bdw0IkBnVeDxphirf27vK/e+jwRt953EzSq7JzHWFDlOgi8sC17HedvXKQ/bSIwAyQSglmdtf3+IBCKwTZ4LUEva6bak7wQ4cgKwLalfsolAPQKwPSLAMAKwTSLAEAKwXSLAYgKwbSLAIgKwfSLAg7kOYD+ub/dtAzv6dt9rt9cJ/Bkbuty5AtcB8NkaRwIpceHxCMC+9Ai8DLgjAdgfh+jcmQBAYQIAhQkAFCYAUJgAQGECAIUJABQmAFCYAEBhAgCFCQAUJgBQmABAYQIAhQkAFCYAUJgAQGECAIUJABQmAPuTuSbgSbArnguwT1e3r9FOgqOy9LkAT2K5Kbwxjs3TsDpwBVMsNOIjgMdGwfqmuJm9RRZ/BOhuHxt1GY4EYA1T3DwGboqFhgSgEwFYxRSDhr8bFoBOBCDVFAOHvxsagE4EIMUUg4e/Gx6ATgRgqCkShr9LCUAnAjDEFEnD36UFoBMBWGSKxOHvUgPQiQA8yBTJw9+lB6ATAbiXKVYY/m6VAHQiAHcyxUrD360WgE4E4JumWHH4AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYB/+AQE7rc+l0ojWAAAAAElFTkSuQmCC"
  , supplyPouchImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAACXBIWXMAACxLAAAsSwGlPZapAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAhhSURBVHgB7d2BcRvHGYbhHxkXoA6MDqJ0IHUQV2CqgjAViK4gSQWiKsi4ArkEl3Ad2B2cdy1ghpJJESBwd7v7P88MBh5rhiIhfC/BI3CIAAAAAAAAAAAAAAAAAAAAAOBk8zzfzP37MWjWLmhSGc5NufoQY7jZ7XYfg+YIQIMGG/+RCDRIABoz6PiPRKAxAtCQwcd/JAINEYBGJBn/kQg0QgAakGz8RyLQAAHYWNLxH4nAxgRgQ8nHfyQCGxKAjRj/F0RgIwKwAeN/lAhsQABWZvzfJAIrE4AVGf9JRGBFfwtWUcZ/F8Z/ivvDbcUKPAJYweEO/T44x0/lkcBdsCgBWJjxX0QEFiYAC1p4/PeHSwvelctSr/sXAfpTxz8vp7ljCeVzup+XcxfQi3KH3c/LafZA4rxsBL4Prs5vAfpyXx4Ov4tGlc/tplz5FV5HBKAfTY//SAT6IgB96GL8RyLQDwFo311P4z86ROAuIJv5egcBu3/+QP0a5utwEJA+zNcJwDBPHpqvEwEBWIAfAdp1H+NwPKBRAgCJCQAkJgCQmABAYgIAiQkAJCYAkJgAQGICAIk5JdgF5nnel6v/l8urR/54H5eZYiz7uMz0yP/7vVx+2O12U/AiAvBCh/F/isvv2FxmKpe3IvAyAvACxt+cKUTgRQTgTMbfrClE4GwCcAbjb94UInAWATiR8XdjChE4mQCcwPi7M4UInEQAnmH83ZpCBJ4lAN9g/N2bQgS+SQCeYPzDmEIEniQAjzD+4UwhAo8SgK8Y/7CmEIG/EIAHjH94U4jAF7wa8KCM/3UY/+j25fLp8G9NeATwpwfjfxVkUF9FWB8J/BrJpQ+A8aclApE8AMafXvoIpA2A8XOQOgIpA2D8fCVtBNIFwPh5QsoIpAqA8fOMdBFIEwDj50SpIpAiAMbPmdJEYPgAGD8vlCICQwfA+LnQ8BEYNgDGz5UMHYEhA2D8XNmwERguAMbPQoaMwFABMH4WNlwEhjkfQBn/TRg/y6r3rXo+gX/GIIZ4BHAY/4eA9dyURwIfo3PdB8D42VD3Eeg6AMZPA7qOQLcBMH4a0m0EugyA8dOgLiPQXQCMn4Z1F4GuAmD8dKCrCHQTAOOnI91EoIsAGD8d6iICzQfA+OlY8xFoOgBl/G/i89N7oVf1tQO/RKNafy3APqBv30fDvDkoJCYAkJgAQGICAIkJACT2XTCSqVxu4/Opq5ZQz4hzH866NAwBGMtUfuf8cyxonud6Prw3wRD8CACJCQAkJgCQmABAYgIAiQkAJCYAkJgAQGICAIkJACQmAJCYAEBiAgCJCQAkJgCQmABAYgIAiQkAJCYAkJgAQGICAIkJAOda6pTjbEAAONe/4/P7DzAAARjL63me97Gg3W43lau3IQJDEICx1Hfs+SQCnEoAxrMPEeBEAjCmfYgAJxCAce1DBHiGAIxtHyLANwjA+PYhAjxBAHLYhwjwCAHIYx8iwFcEIJd9iAAPCEA++xABDr4LLjHF8nfw/eFy7Y9ZI/D2MNRF1I9d/47yn+/j+l/D0T6W+9jDE4DLLDqg6vCd+lN0HIFy9S4WUj7/+vTn34IX8SPABZYe/4O/Y6mH0vtY4ceBJZXbx8uTLyAAHRABliIAnRABliAAHREBrk0AOiMCXJMAdEgEuBYB6JQIcA0C0DER4FIC0LmVIvA6GJIADEAEeCkBGMTCETiebVgEBiMAAxEBziUAgxEBziEAAxIBTiUAgxIBTiEAAxMBntN6AP4eXEQENtf0bdNsAMqd6r/l6ja4mAhs6rbcNnfRqF00qNxg9+Xqx2hcGVaTt99TFjy9WFXPzFNPL/ZrrKx8XXO0777cNoudGu2lmnsE0Mv4e3R4JPCPcllipB4JfNtNuW0+RGOaCoDxL+9wDr3644AIrK+5CDQTAONfjwhsqqkINBGAXsc/wNl0u49Ap/8GzURg84NYvvM/aSqXH5Y+qHY4r349MOg79vo2PzC4aQCM/1mrHFkXgU1tGoHNAmD8JxOB8W0WgU0CYPxnE4HxbRKB1QNg/C8mAuNbPQKrBsD4LyYC41s1AqsFwPivRgTGt1oE1gxAD8/X7oUIDG6t15k4H0CfVnmizcJPFqIBAtAvEeBiAtC3YwTexIJEYFwC0L9jBBY9wPogAlMwDAEYx/1KjwSmYBgCMJZ/BZxBAMbyKuAMAgCJCQAkJgCQmABAYgIAiQkAJCYAkJgAQGICAIkJACQmAJCYAEBiAgCJCQAkJgCQmABAYgIAiQkAJCYAkJgAQGICAIl5c9Dx3Mdy5+6vZx2+DRa31puDCgA0yLsDA4sTAEhszQBMAZxiipWsGQDvLAvPm+LzVlax2kHAqhwH3JerT+WyD+BrU7m8Lcf/pljJqgGoRAAeNcXK469WD0AlAvCFKTYYf7VJACoRgD9NsdH4q80CUIkAyU2x4firTQNQiQBJTbHx+KvNA1CJAMlM0cD4qyYCUIkASUzRyPirZgJQiQCDm6Kh8VdNBaASAQY1RWPjr5oLQCUCDGaKBsdfNRmASgQYxBSNjr9q9uXAhxvsp4C+3bU6/sr5ACAxAYDEBAASEwBITAAgMQGAxAQAEhMASEwAIDEBgMQEABITAEis9QD8FtC336NhTQdgt9v9XK7uAvp0d7gPN6vZ8wE8NM/z+xAC+lLH3/zL2bsIQCUCdKSL8VfdBKAqEbgtV/8JaNdtGf//ohNdBaAqEbgpVx8C2nNTxv8xOtJdACoRoEHdjb/qMgCVCNCQLsdfdRuASgRoQLfjr7oOQCUCbKjr8VfdB6ASATbQ/firIQJQiQArGmL81TABqESAFQwz/mqoAFQiwIKGGj8AAAAAAAAAAAAAAAAAAADQpj8AqkPsmtF63X0AAAAASUVORK5CYII="
  , arImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAEACAYAAADFkM5nAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAx6SURBVHgB7d39dVNHGgfglz37/5oKVlQQUgGigpAK4lQQUgGkAkgFmAqSVICoIKECbirAqeDuDBqvjfG3r+7M6D7POXNkSzbYsqT56Z2vCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAKHgRUNo7jQbp4Vj4dHjx4sAkAYH+lzv/5+LWPqT0OAHZGBYBqUie/Shcfr/iSp6oBtK5UsNapHZSrVLEArpJeON+MV/tUQgI0J3f8qb2+5LH7KgC4WOngr/MuoDE5mJahqqs8DwC+VF5Ab2od0Igbdv5ZDrgHAcCp8XYBQBWAJtyi8z/xIqBR/wpo31oVgEbkDn11i69fBwCnxttVAFQBqO4Oj9nsY0CjVADoRa4C2BuAmoRQ9ooAQE9+Cqgghc/DuF3pH4CL3LGcmq0CZjTefuKfIQC6oAJAb8yqZm63nfgHXbAVMFWM128DfJWHDx48OA7YsXs+TrO8LfCjgAb9O6A/r9IL8/vgJo5TB/T7+SvHL09g5HL3rTgdlPkDmTMCaIoKAFVM8M6Km7nwHaj7v5ohtZ8vCmUwN3MAAOazSu230cZWNEAAAJifyaxUZw4Akxu/Ph/9Ig5JmcfZMegvrg9qWgVUZg4Ak0qdzcvw7gauY3UA1akAMBmdP9zYZZUZ+tPt6g4VACZTdj1bBcCyDKm9TUHgZXSkywBwwzHmKVm/ew3LygA+L/F8HZ3oLgBULDMPYf3upQQAgM8bbz2MTnQVABoZY/4ltmGAL+VqzKsAWLZVCgF/Rwd6CwDGmAFoWTdnlXQTAJSYAWhd6vy76VftBAgA0+jqlFIBAACmIQAAwAIJAACwQAIAACyQAAAACyQA7EhXdywAizNER7o5DTBvrDCO4ya2ZwDUlLcCFka+lncCfBYAdKG344B/TO1d1NsN8CgFkR+Dr5SNmgQAYMmG6EhXASB1vkO6eFTO0X4S88qd//sAgIt1VR3u8jhg2lOOaP4UAMu17umNYm9DADSqoTka0IP8TvG6o8VXZy5XQQ/+iY6oADCZMg+g5hwN6MWQQvOjuKX0HPtvusjnzf8nthNvV+Xy4MznEUJDLd0cBZwJAEzuhnM0rBqYx2XvNN3/dd0pANzFNaFhVdrj4N56OgkwEwCowpyB2VzY0Theu7rZAsBNlMfDOrXvYhsGVsGt9RYA7ARIFXnOQLrYBFBdXmGVWl7p9H0JJuvUnofn6G0M0RkBgJryngpDwPI0vVwsz2RP7dfUnqZPcyDIz9WjsAnaVbq7b6wCoJrK+zoshRfsNv0VnSjP06PSfkzP1/xcPYxtlWAVnOjuuWYOACyQOQBVDak9LR1r19LjKM8XOAkES59I+HseQomOqAAA7NZxaX+V9muZA9O99Hv8/3cqoTJPIjyMZYYBQwAAfDbEtjP8sC8d/lVKRePXWG4YGKIzJgEC7Mb3ZTLd4uZhlFUFudLxbfo0t6Mw4bc5AgDA9I5LeXzx8v2QT1Etywvz5lPXbYHcqyE6IwAATM/qiwukEPBHmSiXw8BR7FdVoLu/uQAAwKzKEMFJVWBf9gMRAADgpsoOhCdBYBP96uokwMw+ALBAne0DcLJt9FA+Hsr1q3KZZ5nnsyXWl3z/+a+fQ1N7/ffkzEZDh9GXrk4CBBYqB4CxD6/G7cFRN/mdDsrXn/dnuf1Jam/GmQT3Mm4fo2/GTkSHVABggcY+KgCv0zuqn2/zDeM2LOTf63xoeHiyHC99Tb59FbvnHeEEymP1RbRdEcirPh5GZ8wBAFo03Lbzz0on//qCm/5z5uO5lqEtfWvcSZxMGIztyoGX0eaEwS5XfQgAQItext29veb2DzEPAWBCJQj8kj7MJxTmo4qHaMcQHRIAgNbkF/rrOvFLlS1pN1d8yVwb9KyDyZ3ZZXCflhBWIQAArZmig95ccdtc5dr1eMMJjNzNuSWEQ9QzRIcEAKA1m7i/L8r8FSfj/RTsXANBwBwAgAlM8WJ6fMnHc3uuCjCfikFAAABoxNlO9/yQwirmk3+OF8GsKgSBITokAACtmeId8zdnPj46d9t3Ma9cBVgHs5sxCKgAAExgiuVzJ//GRSsKnsX83hgKqGeGICAAAN04jnZftJ5N0Fnm78+/3+HZK9O/m9ePr2J+qzAUUN0Og0B3BwEBCzZevG9+K17FPaTv/zO1x+euezzWZ3OghqS/x2FqH8f7U90B+jK2HQLy2Pkq7uD896XPc1Xh01jfu6A54z2DQHTKYUCwcPnFL138EKfH6rZsKJdnhzCGc5fZ2XX/edJfjXH/y/ycytCvg+aU50Ieqlnd4tu6PfpZAAC+kl4I/1s+zCecnRykszp3eRCngeH8dWdv40s5uHxbtiymQbcMApv0t3waHRIAgJ26Q5iY2yrmr35022ksxbgdRsqVscO4OggcldMKAejRON2EsJt6HjQvB4HUXlzy2MjXraJTKgAARXkx/y3mO8o3DwX8FTRvPK0IrGM7jJP/bvlUwi73AMgEAIAzxu2Srj9jnv0ChtiGgG47EfplIyDgpMxp0l583iwmd8ZzjemuYltxgNmpAMDClY7/07mrh3J51XK7fP0/l3z9ce/vasftmv11zOOXdH+9DJiRAAALN24PqtnlBjVDubwqTLxtbVncDPfLeU/TfbAJAJhD6uh+Gutrcvgh/VzvxvnknQpXATMxBwBYRV0tDxf8EvPJIehNwEwEAKD2ATVDNKqU5Dcxn/VofwBmIgAAAsDV5qwCZC8MBTAHAQAWrIy91x5/b3ojnFIFGGI+hgKYhQAAy1b73X82RPvmrgIYCmDnBABYtm+iviEal6oARzH/z2kogJ0SAGDZWqgAfIg+vI55GQpgpwQAWLbaAaCnHQPfxulGRnPJQwHPAnZAAIBlqx0AujkJrwSVuasA2ZvROQ3sgAAAC5U6lRbK/72dF/BrzP8z587/RcDEBABYrhYCwCY6UrEK8Hzcnk0AkxEAYLlaWAHQzRDAGTWqAJkqAJMSAGC51lHfP9GZilUAewMwKccBw0Ll4+eirrwC4GF0qEzK+xTzy+HjUUcrJ2iYCgAsUCPjyT2W/z8rHfAm5mdCIJMRAGCZjP/f39zbA594bodApiAAwDKto74hOlYOCapRis9DJ0PAPQkAsEwtLAHsvQKQ/R7zq/F/sodMAoSFKeXjj1FZehfb/etPpfvykQoAU1ABgOXx7n8ipSM+ivm81vkzFQEAlue7qG+I/fE2dmuIbch4ljr/nwMm8u8AlsYWwBPKkwHTUMAmpplYmScV/lXaJl+mf//vgB0wBwAWpOIGNuetU8f2PvZE2VfhXdzOEKcd/eePdfbMSQCABSlny/8Wle3DBMDzyumK+b5dXXDzEOUdfWkf7OZHbYYAYFmeRH2b2EOpQ88d+6MUBA7T5Q9x+u7+vc4egKpS5/TnWN+rAKqzCgAWYtyuWTcBEPhMAIDlWEcbPgRQnQAAy9HC+P9gIxtogwAAy7GO+vZiB0DYBwIALMC4XaK2ivocZAONEABgGVoo/2fG/6ERAgAsw7Oobyhr5YEGCACw58ryv3XUp/OHhggAsP/W0Qbj/9AQAQD2XwvH/2Z7c/gP7AOHAcEeG9s5/S+fdPdtAM1QAYD9to42bAJoigAA+62V8r/xf2iMIQDYU6X8/zG1g6jrOJX/HwbQFBUA2F957X/tzj/z7h8aJADA/mql/L8JoDmGAGAPNTT7P3uYhgCOA2iKCgDsp8fRht91/tAmAQD2Uwtj/5nxf2iUAADs0h8BNEkAgP20ifqOlP+hXQIA7KHS8f4YdU/gOwqgWVYBwJ47cxzwDzHf1sBDCiGPAgCoL4eB1A5T+y21T+PuvAigaSoAsGCpo86bBeUdA9eprWI6j1IFYAgAoG0pDDxJ7VVqH8f7eRMAQH9SJ/44tZ9SezfeXitbEAMAdzWezht4d4PO/10AAPsldfAH4+WTCPPwQSs7EALXMAkQuLPU4T+J7bbD7236AwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABc639AzEC8Yt56lAAAAABJRU5ErkJggg=="
  , carbineImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAEACAYAAADFkM5nAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAzgSURBVHgB7d3rdRRHFgDgy579vxDBDhEsRMAQATgC5AgMESBHAESgcQS2I9AQATgCjSNAGfRWuVtGyEjqnkdXdc/3nVMeIQ2DNY+u27du34oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYw4OAAZqmeZhuXnZ/3Dx48GAdAMB8pcn/JI0vzbcu0ngZAEyKDAC9pEl+kW4+pfHwlru8SdmA9wEV6DJVy/j6fpWtAthGOqCeNfd7ElBYeh+efidTlZ13gQEAfaUD56ceAcB5QCE5S9XjffouAOiv6e9VwMi6yf+i53t0GUD8K2C/TgLGl7NPi573fREA9NMMswwYSdOu+Q9xEQD00wyjFoBRNG3qf7AALAFwEMtGFoBxvA0ADqcZThaAg2raxlRbCUAjIPrZ8qD5XPMVDqVp1/IXsYX0vnTs4+j9O+Bw3qWD9Ifgb2neWX3v+/lsNhgiN51axJbyEpXglGMnCqYXadP9uO3M0/NbxCaN0/SS/BJwhAQA9GKC2g8BQJV+SC/LbwFHRgBALyao/RAAVOlzelmeBhwZNQAwImv9VXoy4HXZ5P+oH2AOZADoxRkqfGMT7VUum4CJkgE4cs0/900H7rdI4yyN57EDn7+dbaJdwrkMBpMBOGLp4PM62k5qDj6whV36Cfj87U2e/D+kl+I0GEQAcKS6Nc+zAHbxY2wn9zH4KdinNykIeB/0JgA4UikA+BTtQQhgDjYpAHgc9CYA2FKBtbtN7HGtS1EfMDdaPA+jCHALBdfuLnNrXWtdAOxKADBQt3b+LsrIAcfb7uR9EwCwJemSgaydA9TJEsAwnqyBrJ0D1EkAMMy/AgA4OmoAAOYpXzG06W6nYtENRiAAAJifTUx0r4LuKqtShdZHxXrJQGoAgAl4POWNirYNAtQADOPJGkgAANRuDhNhOtSeR9tsrTcBwDCKAAGo0S/BQQkAhrPtJMDhbYKDUgQ4XN5t6jTKWsfuH46TAHa1iu2cBBRmvWSgbhOgvDZVqhvgOo0fdt0USC0D7G7bNef08fsSh91L5NG+Ng4rJT1Hy2iPtb2pARhGBmCg7kP1tNsT4FmMa53+fetiUIdNbO/QmcQXYQ2de4iWjtQIZyAwdyfbBuQjZBI3MdE+AFdkAA5PBuB41VDLALVY9bxfzgDmyXuV5pqPsaUtMomL7t+9uu1z/4v0+J/T7XuZQ75HtHSkKqhlgGpM6cwxfXbzZ/Y/0V4jfzXus0njdEqBgAzA4XmyjtyAM5CTgJma8sTRBfMv03gV9wcDm5hIICAAODxPFr24aoAZu0zzxqOYgS6gfxv3b6izicoDAQHA4WkEBBy732Im0vyXaxMeR1vfc9dlgIs0VmmSzXUCr4KjJAAAjtkmjZ9jZlIQkH+np3F/ceMiBAJHS7qEXiwB7M3qlu+fBGPZdGOdxoepN8y5T/roLqJdFjjpcfdNVLI0YAng8DxZ9KJvwH7cdoASYB1cnuTzFrO/z33Cv83UAgEBwOFZAqCv9wHT9TpPZsc6+We5KVAaP6Yvc43A6p67L6JdGjjvJmJmSABAXx/S+BwwTb8Hf7kWCCyjXQa5S77PuUBgnqRLGKTQHgiz0R14/8ESwGFJDd8uvfXy5/k0+jUUWqXx8xgthi0BHJ4nCyogADgsE8P9agsEBACHZwkAgDx5fkzjefRbGjiJdq+Bs664kAkSLUEFJpQByEV062irxC/j65a4D+PrZjV5LO/4+/nvjLoHhTPD4UpnBGQAgKPQTMOvTdt3vu/v9Po7j3HR/WzRtGePX5px/DfYSnrunjVtEWAfZ82eMgLpcZbNQAEwNU39fo0tNG2HuZv+e+3n58047Hq5o2bkQKARABycGgDgPps03sR2Vt/53uLa12P14Xflyo6u1Qj06SNwEmoEqicAAO5zusPabu4fcVfznT9iHDIAezKwodBJCASqJQAA7vMxttR13rvrLH+s5lLLYK92CAQEY5UQAAB3We+hsvvWAGLE1ry56HAZ7N0WgcCn9Frk8VO3zv93YWn+uvveafrjVnUnAJPS1Otd7Cg9xpMbj/mk0O++8+/C/ZqvV3iMLhhEBgC4yz7O0L95jHS2WGpPiZPGOvTBDcwIUJAAADi0xbWvv5n8m3HXg3Oq+SwYhUCgfgIA4C69G//0fIz1jZ+NXRCW15dfB6P5TiCwCaogAADuso8J+n/dbV4K+HDjZ69ifG+bAR0N2Y9rgUDuJXAaAgGAv1LhY7XE3cZOk2XTthDOfrrx/ZOmHBXmhTVtsWB+D1w0exIAU9N8v29+LXZaN2/a9rHPbnwvH/wvmrKWQRWaPQUCATBF6fj1tqnXabNlBf3Nv9e013lfNOVdNJYCqtLsGAgEg9g6ESrStFXx+Xr1RXxbPV+jTXd7GV8v9dvcuM3+vPZ1/v1+inq8T+vS2+5zwIHkQCDdvI2BnwHbAQ/jyYLKdWep/0njUXebLbrbh/G1yn7R42f80/M0b6yD6nSBQA6Ie2VqBADDeLLgiGwRTIxtEeNnPzZpPB2xLTEDNO0S0nn0eE8IAAAmrmn3nr9oxqNNcMWafkWjmjwBzEU6qK+a8bwMqpVfnzteu3wZ7SIAmIem3R3uUzMOk0jFuvfCba+b4G0L1kugMleT0B624Z2F7vm4iHHkvQqeqweoU/deyFeRXNWq/NVd0mdlOwIAqEw+o4lvq54vb4xsc+Nn2Z+3/WzqB8imXd89iXGsupa1MGsCAKjICGe7fYKJX2oLGEbOAmRv0nPwPgBgDE3bJa+0Z1Ghpm0pPBb1AMye3QChLv+L8v6IOv0c48lLMHkTI62CmS0BANRlEWVd1loA13XrW8d4ctvitwEzJQCAujyJsj5H3cbMAmR5l8ZlwAwJAKAupQOAqi9/K5AFyM4sBTBHAgCoRNPuBFh6oqk9A5CNnQVYhKUAZkgAAPVYRHnVBwCFsgCWApgdAQDUo4YrAKbSAW/sLEBmwyBmRQAA9Si9/p/VegngNwplAZ6kLIClAGZDJ0CoRJpccqe7RZSTLwF8FBPRpeTPY1w5Q/JU73nmQAYAKtBVmS+irCkUAP6tywJsYlz5dbLvPLMgAIA61JD+n1QA0ClRC7BUEMgcCACgDjUUAG5iYlIWYBVlChf1BmDyBABQh2WUN8UMQFZi175FtPvSw2QpAoQKVFAAmD2qdR+Au3Rn4vn5G/uMXEEgkyYDAIV1284uoqzNFCf/rPv/LpEFUBDIpAkAoLwaCgA3MW0fooxl18IZJkcAAOU9i/LWMWFdFqBUDcMkMycgAIDyXAK4H7/F+NZqAJgqAQCUt4zy/ozpy8sAY5+NrwImSgAABVXSUCa3AJ58BqBAMeAq/Zu/BEyUAADKqqEB0BzS/1cOnQXIj71K43UabwIm7N8BlPQyyptNAJCzACmrkrMAp7G7q8LCq5HX++ewVAJ/0QgICkqT1ZcYv4HNTS/TxPZ7zMSWjYE20U7yV7cme2ZPBgAK6a4fr6Gf/B8xI10W4Gm0WwUvvnOXTXSTfPf1x6k2QYJdCACgnBqu/7+c42Vs3e/0OAUCJ+n2VbQT/Tqc2QNQWpqczpvyfg3gKLkKAMqpoQHQOoCjJACAApr2+v8a1v/ndAkgMIAAAMp4ERVI6+EfAzhKAgAoQ/ofKEoAACNL6f9F1NH/X/ofjpgAAMa3jDqU2D0PqIQAAMZXxfp/zKwBEDCMAADGt4zy1rrfwXETAMCIKrr8bx3AURMAwLheRR3WARw1uwHCiFIGIO9St4iycv//RwEcNRkAGEmX/l9EeesAjp4AAMZTS/rf5X+AAABGtIw6aP8LCABgDDWl/x88eLAJ4OgJAGAc0v9AVVwFACOopPo/eywDAGQyAHBg3eY/iyjvs8kfuCIAgMNbRB1WAdARAMDhbaIOvwdARwAAh3fZjZJU/wPfEADAgXW77v0YZTvwrQLgGlcBwIi6gsBlGi/SeBnjeWT7XwCoQAoGHqbxIo2zNL40h3MWAECd0kT9rAsGLpr9ehYAQP3SpP0kjXdpfGp28ykAgOlJk/gijZM0zpvhamlBDABs61ow8GuPyf8iAID5ab4WEV7cmPzP03gYALdwGSDMRNMW++VJ/6NL/gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIA6/B80x3mnojdjcwAAAABJRU5ErkJggg=="
  , lmgImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAEACAYAAADFkM5nAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAuLSURBVHgB7d3tdRPHHgfgP/fk+yUVRFRwQwWICi6pIEoFgQowFQQqwFQAqcBKBZAKvKnAvhXozmSXEyGELFk7o13t85wzR9iSbbSSdn47rxEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPRgtVrNU/k1lfep3Ky+lr93lcrPAQCMT6rEH3YV/m9dpb6twt/lWhAAgIHrKvxFV+F/XPXnIqCCB0Gv0od3lm5uHzx4cBvA2cgVfrp5lsqTVOapzKKcp+kcsgxg+NLJ4dnGVcDHLgwAI5U/w90V/vWqrrcBDN+q7ffbJvcBzgIYnVVb+V+vTkMAoLh/BX14+Y3v5yZDH2QYp6so28wPJyUA9GO+474fAxiVdAW+CJU/Z04AKO9hAGNjOh5nTwAA+JqWO86eaYA9yCN2dt3/IAnOxqqdp/1raN2hrBfp1PE6oJDvAthbqvzfRzsXHErL0w8fphBwEVCALgDYU3flr/Knppcra4pQiKbpHugCmIb0Ml+HkeGcRpPKL1YHpE9aAGB/s4DTmKVytbJPAD1yZdoDLQDTcNfrDJV8SuWndFppAo6gYurBFAJA1weZVzXM06OMfq9orO8fgamoJpWL9NZ4F3BPAkAPzj0AdJW/ZVFPRABgh8tUXmkN4D6MAWAfea+DWQBDs4h2bICVCzmYFoAeTKAF4CY0+5+MFgD2dBlaAziAANCDCQQAJ/ITEgA4QJPKGysIsg8BoAcCACUJANxDk8pTrQHsIgD0QACgJAGAI1zGyLsFukHIi1SexHnPQsrTO1/XnNkhAPRAAKAkAYAevErlckxBIL195tEOQJ7HtOQQ8CIqqHZiyZtapJvnUXaf7dtUfo/2AN5GJQIAJQkA9KSJEawdMOGKf11+nV5FYVVOLCeYR56bUp7WCgECACUJAPSsiQEGARX/F27T6/P9QT9xD7UCQF5BbhEADEWTyptUPpyya0DFv12N4F8rANhFDWC4LqOdPvgpKlHx73ZOAUBTIMDw/T0SPZU/SrQKrI0F+zUsLraTAADAqSyjbRk4Kgx0lX4e/P0sXO3vTQAAYAiaaANBbiH4M9oZV836QOuuos8lz9X/obudh+7fexEAAGCCagQAuwECwAQJAAAwQQIAAEyQAAAAE1QrAFRblx8AuFutAHAZAMBg1JoGmOeGfox680GbVB7bDKgfpnEC1HU20wC7ivhptC0BJSvl/LsvomLlDwBjNOor06HQAgBAnywEBAAUoQWgky5yZ+nmbbTrV9ulCoCTqdEC8F3wufK/CptWADARugBaL0PlD8CE6AIIg9wAGBaDAAGAIgQAAJggAQAAJkgAAIAJEgBalg0GYFIEgNZlAMCEmAYYFgICYFhMA6wkHecm/tmtsAkAOHNaALhTaiG5Cfsj1Jb3pNg6NiUF1r/Wvz7VQlabVyjpv/HDHT/SBLCXGi0AAgB3Sif29+nmWVBLkz77j/Z98FACwF2suAn7EwAYBGMkqnucPvuf9n2wADAZs6hjFm2L349dmXW3VCQAMBhdCMibJi2CUpapvDik8s8EgGmoUSHskl6+J9EGgXlXdAsWJAAwSDv6epvYbRYjsNnH/tkefdzH+F/6u/daj0IAmIRP6XA/jgFJL2cOAzkU5O7BedArAYBRuesEf+ormHMlAEzCIh3udzFQ6aXNrQE5CPw3tA70QgBgVASAstLhXUR7gt08uc7jNJZbvnf5rYpKALi35+mYvokR6boLFtG+N2fBwQQARkUAKCcd2jwIcx7jkMcwPN3s0hAA9tZ0ZZnKm/t2DQ2FMHA/AgCjIgCUkQ7rRbQDMMfkIr3cr9a/ceYBYJnK62j76v8KtloLA7m7QDfBDgIAoyIAlJEO63WM78rpNr3c369/4473RxPtSpy59SBXoDdr982irSzy7Ty2r0mx7H7HPOoeqyba/vk/goOkt0Puzsqv5SL4igDAaHTTBK/veNijbtllDjDWK+ctKwV+63ls7TL4lvRr5tGuS7FumX7+aXf/83TzW5TXRLtmg91Ej7AxgNCCYx0BgFE4YKGgJtoTfRPs7cwDQBP3eE9sGRPxRYtDheWrm/Be7l13Lpmn8nNMfGqhzYAYi9w/PdvjcfkxbwP+cXHPSvTVxteblf1Biyndw2uVf//yMU3lsmvNeZTKL7F9tgk90ALA0Q68Qv2qb5jdzrgF4KA9DzZtXuWv/710X+4CeB7l6M6qaDXB5ci1AHCOjPzlsw9xnMsd9/0Z5SxV/nU53mUIAMCpHBsASlbyuzQBZ0AAAE7l2Aq8+ca/gT0IAMBJ9Dx9rtn4+t9RzizgDAgA9ME8aE5htvbvze6EkvvXz7tBaTBqAgB9OGTK1bH9vozX5t4Axw4I/c/av3/fuG8eZZnOyugJAPQhz9XdpxUgP+ZFMFWb75Fjr9I///wXawl0uybOoqx5N9WQepqYjiYqEAA4WnfyfbzHQx+bzjNpy42vn8RxcgvCF5sOdU3ztTZOet4tS0wd+eJhKt2Ni6hAAKAX+1TsKv/Je7fx9fMj+9I/bKn8ay8W87aHrgz2kF7r3NU4hRbEi1qbS1kJkN7YDbCMc1kJMNuys+HeGwF1Fe3DLX+n6TYAehmnWWgqLwusa6uSM14VMH8Wnj+ouLOkEzK9EQDKOLMAsIjzHECXQ8wyYESckOmNAFDGOQWALD2dy2h3ezsnTdgamJExBgCoLTfXn9t00FkqZgUwKgIAUFW+Sk7lp2inj5betremRTcWAUZBkyy90QVQxrl1AWyTnuIPaz/3V/SoGzyYlwaepfI6yq4SmLsATHdlFJyQ6Y0AUMYUAkAt3Qjyj1F2tkATxgMwAroAgMnorsxfR1mzMB6AEXBFRm+0AJShBaBfXZdAXo+g9JoBr9IhuAgYKC0AwKR0TfOlWwGyl5YKZshckdEbLQBlaAHoXzcW4DrKMyiQwdICAExOVyFfRnm5m+F9wAAJAMBUvYo6frR1MEMkAACTVLEVILN1MIMjAABT9i7qeWvrYIZEAAAmq9vBbxl1zMJ4AAZEAACmrtZYgGxuvwCGwrQsemMaYBmmAZaXDvFVuplHHaYGMghaAADqtgLkcQBvA05MAAAmr/JYgExXACenSZbe6AIoQxdAHd00vauoJ3cFPE2H6VPACWgBAIiTtALoCuCkBACAf9QcC5DlVQJfBpyAJll6owugDF0AdaXDnTcJmkVdj3UFUJsWAIAv1dgqeJO9AqhOAAD4Ul4e+Dbqqv33QAAAWJea4nNlvIw6mlTm6W/+FFCZAADwtTdR1jKVRar4H6XyR8AJGJRFbwwCLMMgwNMosDzwMpUPqbzrWhngpJyQ6Y0AUEY6rDfRzhkfk9v0cn8fI9bTwkDLrrxR6TM03wUwdJepjG3Z2A8xcnlhoBQCmjh8SmCu6C9T+aB5H5iE1R2Ce0mHbpbnpq/G4zqVWZyB9DwWBzzvq1R+TmVsrTUAx7nr7Bjc26oNAW9TuVkNV/6//bY6k8r/s/R8Xu54ztfd/Sp9YLruqBwEAEZr1bYEfFyr9HPQeRIwYgZl0Zu7KnmDAAGGwzoA9MkoZ4CREADo067NTJYBAJyfVTtQ7eYbg8NmAQCcpy4EXK1V/FcqfwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAU/s/rjAaFwsdHgsAAAAASUVORK5CYII="
  , marksmanImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAEACAYAAADFkM5nAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAvmSURBVHgB7d3tdRNJFgbgy575P7MRrCYCIIIxGTARwEQARGATARCBTQTMRoAmgmEioIkAiKC3yiqzQsjWd3d19/OcU0fClj+QZNWr27erIgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARqZt28/t6eTv/UucWPoZZ2m8v+N3uExjFgDAQpoYz9vTehcnVCb/bXxsOwgjADAIeVJsT1sFyC7TeJzGgziyMrFv61UAAAvt6asAyz6m8S6NJ+2BZfl2EV52+tkBPboXABVpF6XxPDn2USJv0pin8fbevXvzXb6wBIhdJvUm/Yxf13yfi3TxLI0v5fe5+b2a8rGvyx9P36MJ2IMAAFQnTYLn6eIi+tXEDmHgGAGgTP7nsbsvITCwIwEAqE7PVYB1mliEgTdpAv2w7gZ7BIC+rK08MD3/CoDKpAkqv3N9HfWYpfE0jb9L38CT1ql8DJwAANTqTSxK2LWZpXGVRg4Cl4IAQyUAAFWqsAqwztMoQSAWwQAGQw8AUK3SC/B3mFyPSQ8A11QAgGqVKsDLAI5OAACqlkLAVSw68IEjEgCAIVAFgCMTAIDqlYV4am8IhEHRBAgMQoWLAw2VJkCuqQAAg6AhEI5LAAAGI4WAfBhgHsDBBABgaP6IOlcIhEERAIBBKbvZaQiEA2kCBAYpb8oTVgjchyZArqkAAEOlCgAHEACAoXobwN4EAGCQymmBTQB7+SkAhquJ4fQBbDz23rbtebq4iN19WRrNyuXN+JTG5/Q7fAoIAQAYtlGtCpgm55cpBOSrz8OEzok5CwAYpDRRzmKxNPBQ6L6nKnoAgKF6F8DeBABgUPKmQGm8T1cfBLA3AQAYhDLxX8Si7H8WwEE0AQJVKcf2s9zgl9/l3y+XZwEcjQAAVGGATX0waA4BAMAECQAAMEECAABMkAAAABNkJUC+adv2LF3ktcjPgilYuzKdZrxBatKYp/EyPaZNwBYEAK6Vyf99MCUCwPg0aTwSAtiGAMC19KKfX/BnAQzd6xQAXgRsIABwvcJauvgcwBjYdIitaAIcoVzOz2ult1sKkz/A5FgJcGQcywdgGw4BjIxj+QDV+ZDG77U1ZwoAI+JYPkC15ikAPIqK6AEYl18CgBqdlTdp1RAAAKAbP0dFqmwCtCIdAJxWdT0AutgBGKN7SVSkxgCgix2A0aktAFTVA1AaJGYBAOPSRGVqawLUxQ7AGH2JyjgLAABOTwAAAPpXVQAoyyTOAwDGpYnK1FgBeBkAMC4OAWySqgDzdJH3sp4HAIxDdQGgypUAy6GAqjZNGIK2bWfp4mMAUBsVAACYIAEAACaoicoIACPiLAoAtlXdXgAcxmZKMHlNejPw6103KP1C99N4EItdV/OllVhPa5Yel09REQFghMof92XYThmmaGMAWEcoOLl/p8elqj4AAQBnD8C47BUA1kmvDb+li6dlcIDadgLM9ACgdwBYK702/JXGH7FYm+V1VNjINhDVnQGQCQDcsALj9OR3ij+IxYs9w3X0ySa/SUjjRaks5EAwD3YhAFAvKzDCaHyIE0qvFVdp5IXa8uvFVVQ6uVWmiQrpAWCjLXoEjnbMkf7pCRm8X8thvU6U58tZGudpzIJ15iU0VUUFAGAc5mmcdTn5Z+XwwFV5E3AWi6oA32uiQgIAwDBdpfE4Fu+68ylmj3LTXvRI0+Ct9AAAcBTP80Sbxn/z4jLVnV+uaXCVAADA4dLE+iYGQtPgtSYqJAAADEsTA1SqArka8DAWVYEmpkMFgMGabfj8L6UTGOBOE20aFAAYnjSx5/XAN20ulNcLf59ua91wYGsTahr8GhWyDgB3SpN6Ph98tuXNL9IfsxUFB26i6wA0sXiXtvxOLQfaWdS3Ic6o191Iz7+n6eJJjGszs+p2AswEAG5V3tF/3uFLLAg0AhMKAE0sNrn5564u+g0L3cxjcTz7vNxmFqf3Jf2+/46RK/d7vl/zqY6Dri7WuBFQJgBwqz0mAgFgBCYSAJo0Hu5y+twt98t3k3G6TQ7MXUxW1W0teypjWGmw1gCgBwCYmjxxPtp1Ar1l18zcAPufpX//Gd2YxUSMoGmwiUoJAMDUvD5gudxNPS4n3YhnyW8xQQNtGqy2UiMAAFPzNvZUds286wW9q0avBzFhA1tpUABgEmwLSu3m9w7fLOfqjs91VQF47LTbhQGsNCgAMDy3HPO8S1cvfrCveRzun5V/93GOd578J10FWFXxSoNNVEoAYJNtz+tvdrgt9KWJwzVL17/02I1/HvygwqZBFQCGqRzzfLjhZjdd1U3AtKxWvWbRnbN0GOB5cKtKmgYFAAZt0xP4i8l/VPRy3O3+0vUPd3yuC+f24dis56ZBAQAYhlLSnsc4HeO4+Wzp+uq2vI+jW7kX4DLYWg9Ng01USgAA1hnrdq3HmKBvQsTFcuUrvRM/i37Wr8+HAroOHoPXYdNglRsBZQIA8IMyseV3SVcxLrMyUR/0PdJ4vrzxVSnD9/lO/NJpgfvpoGlwl/1UOmUvADbaYm14ewCMWHn883K3v8T3O+TdXI+Vj9WuiQOaVtP98SR97dulf8/Sxbvo/7S8vMLhi+Bg5TF9FouK0SwOUOs+AJkAwEYCALsoa+PnDXJ+jvVBYfl6X6Ghif+XfJe3AV7+2NeVz327fhMeSun9VdSzNv+jcuYOR3Lg9sRV79woALCRAMCplfL1LBahIeL2oLAaKPheEzvucsh29tye+EN6LDadRt0bAYCNBABqVEJDDgyz8qF8ue4wxTFDQ7N0vdZDHg4FnNCO2xP/mR6L3wOGKj/h27uNfe942EsOKWn8lsZl262z4OTS/fw0v/7d8ThMctdGRqQVAOBgeVJO43PbjY+tswI60/4YBPL1JwFD1woAcBTpb+VB2513QafaRcVnMMFLDwAbtXoAiG/H3POkctMN35RPfVr62PWwNPTt2sX6/a+iGy/TY3ERsIYAwEYCANkWz4NVq0Ghie+DwtfVz02le71UzWbRDacGstZPAXAaO3ffp4kxX9yEhuVz85tyfSzVhtdldOFdul8fqsqwSgWAjVQAyPaoAHRlcM+/cjgl35ddHS+elw1w4Bt7AQB0rBzq6KoCkOUzEM4DlggAAP3IWwl32fNw0VofgCUCAEAPeqgCZJdDOk2N0xIAAPrTdRVgFoslbEEAAOhLT1WA5w4FkAkAAP3qugqQORSAAADQp56qALM0ngWTJgAA9O9NdO+irO3ARAkAAD0rVYCr6N5lMFkCAEAdXkb3zsrmREyQAABQgbJW/5/RvXMNgdMkAADUo49egDz5WxtgggQAgEqUbXvn0T1rA0yQAABQlz56ATJVgIkRAAAq0mMVQEPgxAgAAPXpoxkw0xA4IQIAQH3eRvfLA2cm/wkRAAAqUxYG+hDdm5efzQQIAAB16qMZ8CqYDAEAoEI9NAM26We+DSZDAACoVxdVgFzyz02Hj4JJ+SngcI4ZwgnkKkDbtrkX4EEcTxOLykL+vn+ln9FHrwEVEADYKK9Rnl6E5unq2S038QIyAVs8DziNvDzwvrv2fVgZ/2jyA3aSlwlt1/toT/HpuON50KePMXLp/3i+4T74nMb7NF6l8SSNY1YMgKlLLyqz8iJz84LzrjX5T87K86AGow8AWfp/Pmi///u7TONZa7JnT/cCYE/tYtW4+7FYQCZPRLOV0YUPqaz9MICdCADAyZR3pz/H+nBwrFXnrlIA+COAnQgAQC+OVD1o0niUGxQD2IkAAFRpQ/Ugm6fxwuQPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP36H6iPgXjNb1ZzAAAAAElFTkSuQmCC"
  , knifeImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAEACAYAAADFkM5nAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAaSSURBVHgB7d3vedNWFAfgkz79nmxQdQLSCXAmIBs0TNAyAWSCwgSEDdoJCBOQToCZgDCBew+6KqqbOCbEia37vs9zkBQ72PG/89OVLEUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArLBaLg1IvSn1a9D7U5YMAAKapNvyrvA0AYHpKkz9erHYYwIP5IQA246Zh/v0AHowAAAANEgAAoEECAAA0SAAAgAYJAADQIAEAABokAABAgwQAAGiQAAAADRIAAKBBAgAANEgAAIAGCQAA0CABAAAaJAAAQIMEAABokAAAAA0SAACgQT8GTMxisejK5Empw1JdsCkXe3t7zwLYSQIAO2+p4R+XOggAVhIA2Dml4Wejf1xqVkvD301deS7/LqMIl8F3K49lvg/u+r1w6fmZLgGArVY/1LLhz6Jv+jmv4U/DWf5TnuNsMFnzpWnWx2G+NKKLaEx9/ce4CZefzaIf8crLulqbaP7D7Z2XydNyH+bBpAgAbJX6gZfD+I+ib/qHwdQNzatbdaVsfKUJvRstP4/+NXK5VOljnc7r9N4DxGiN/HKpgQ+v8f34+rePq6tXHaYnpd6M/usMwr/H/ZmVel/u91GLIWzKBAAe1Gg4f1jL7wLW00X/mlnHeamjYaHuN/JhdPl8xe/mZc/Gza/8/h/RN/Gr7tPK246+yb+O3ZL3Of/mo2AyBADuTf3QnUW/dn8YhvPZHt0Nl+0v/ezGEYsJMho3MQIAGzHadj8M5Wdp9rC7vH8nRgDguy01e0P5ADtAAOCb1GY/K/VTaPYAO0sA4FpL2+xz3pH1ACZCAGBo9Nnch7X6odHb5gcwUQJAI2qTH2+rH4byN3YAEQC2lwAwMfV79V18PTZ+i19XAuAGAsDE1IOVXJQgkNO3ofkDcIUfgknK43aX+rnM5ulaLwMARgSAiSsh4GWZ/BL1xCsAkASABtTRgKdlNmseADRPAGhICQFn0Y8GvAgAmiYANCZPS1rqtMzm/gFnAUCTBIBG2SwA0DYBoHG5WaB+W0AQAGiIAMAXggBAWwQA/qPuKHgUggDApAkA/E/dP8CIADB2EUyKQwGzUh0ROFssFidl+mv0JxCCKTgfzc9vuO7y0TTfLS0vn1RrvDyVI3G+DCZFAGAtoyCQJxj6rdRxOIsgDyub8OU19bnUp7xSee1+XP7FHOWKflPXrQzvh7iFvO3yPprVxSEodHW5G/1sm07kdVHu95tgUvYCbqF8gOWHU4YAowLtOi9N4domWkeNXsfN5tE37fF0mM/mnY38cx7DIhjO+Pk4+nCQNQ4Ldx3K8zHPNf9XHv/pMQLArdQPg7PoRwW66IPASTj7IOs7Lq+jv4JvMpzx86rLajDfjzty1egJ0yEA8N3qcGoeXfC0rp08iX504DDgetYo71gN5h5X1iIAcKdGayendWRgFn0gyKl9BnZDPn/rNBF7hcMOEwDYmDoycFYrhydzu+VsVGyXbPpPy/P2ZwCTJwBwb0pjyb22s3JzwRAIcjPBLPp9B2wyeDi5o9epHb2gHQIAD2YUCF7lct2B6VH0QaCr0yybDjZnXuqkPhdAQwQAtkZd+xxCwb9GwaCLr8HgYLTM7Vjrh4YJAGy964LBoAaELvqvP111YJXxdLB85LapWbU3+Jfvdlvrh7YJAOy8GhDskQ7wDZwMCAAaJAAAQIMEAABokAAAAA0SAACgQQIAADRIAACABgkAANAgAQAAGiQAAECDBAAAaJAAAAANEgAAAIC7kadpLvVhcbX3AQBMU2n0XanXoyCQ0+cZDgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADW8A+yBb5tRzebUwAAAABJRU5ErkJggg=="
  , pistolImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAEACAYAAADFkM5nAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAArpSURBVHgB7d3xdRPHFgfgq3fy/zMVZKkgTgURFUAqsFNBSAU2FSSpIKKCJBVYVIBfBV4qgA72zaJ1YkC2VtLKaPd+3zlzloCQ7Rzs+e2dO7MRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPQyC9hD0zTzcjkrY97j5XUZizLezGazOmBi7nw/nJZxsuHldfh+AMao/LC7bHZzU0YVMCG+H4AUyg+sl81+bso4CZiA8m/5vNnPje8HYBS6H1j7+jlgAgb6frgIeET/CdhSs1rnrGJ/84CRK98P7Xp/Ffs7DXhEAgBf07yx9sn4DVW6twTAoxIA+JraH3g3JQRcBgCPSgDgGFw0OqEBHtU3AVtoVp3KL2J4VRlvy/tfB4zLUKX70/Lv/yq2twhnCbADBwHRW3eH3v6AqgI4JnUZP5YQIEDTmwBAL92d/9sw+cOxqsv4voSADwE96AGgr7bsXwVwrKoynK1BbwIAfZ0FcOwO0Z/DRGkC5KOuxH/7EJN1HFICx89ZAvQmAHB7ktmfocQPkIYAkNydzn53DgCJ6AHgjzD5A6QjACTWrfvPA4B0BIDc3PkDJCUAAEBCAgAAJCQAAEBCAgAAJCQAAEBCAgAAJCQAAEBCAgAAJCQAAEBCAgAAJCQAAEBCAgAAJCQAAEBCAkBuHwKAlASAxGazWRsAlgFAOgIAv4RKAEA6AkBypQpwXS7PyqgDgDRmAZ2mac7L5bsyTtb88Yt7fh84HnUJ9U8DehAA6KWEg5tyqQI4ZgIAvVkCAICEBACA6ahKte6qjF/LqAIeYAmAXiwBwCidlyWB1wFrqAAATNeihPd5wBoCAMC0XQSsIQAATNtpwBoCAMC0Ob+DtQQAAEhIAACAhAQAAEhIAACAhAQAAEhIAKCv6wDG6EPAGgIAfS0DGKO/AtbwLAB6aZqm3Uv8NjwPAMakvfv/fjab1QGfUQGgl/IDpP1B8qyMOoAxqMt4ZvLnPioAbK1UA56XyzycMPaYqlgd6er/eU7L2C58tz07r7vgDmsJADAiJXydx+rhLlWQxWWZyF8FDEwAgJEpIaAql6sQArJ4qozPIQgAMEJdU2YbAoZ80tsyVh3jdey2dWwRu4eSy+7v33oSq6/tLFbLTVl9KJP/kwCAW20loIybZj/vy7joAsW+n8+82d3PB/46x+om4EDsAoCR6srCP8XulrHaIvZqiGax8h7LcvktdnPywPvWZTwtv3wdwGAEABixbtJdxvbaxrJDbBFrm9UO0nlePtfzcCIlDEYAgPH7Pbbz8lBd5V0lYdcqQB8/Rq6jbW375GAEABi/aovXtnf+2waGbR3s/buKxSEDxrE5aQboz4B1BAAYv+96vm75GPvJuyrAMg7n78ilCjgAAQDGr29JfJ+GwW0d7AE0JWC0fQDLyKNvwIOtCAAwfn0CwOKRD5PZ9i69ju1kagasAg5AAIDxe9fjNY96lGwXNrZp1tu2se9N5DHkYU/wDwEAxm/T5Hn9lY6Srbd4bZ8Qc1emCoAAwEEIADB+mybDZXwd20zS9RavjWRn41d2AnAIAgCMXI/JcBnH7XrHkwjryOOHgIEJADAN9QN/duwH59Sxm0wHAs0DBiYAwDQsH/izOo7brlsGMwUAfQAMTgCAaTjGpriq5+sydfTvaq4PgKEJADAN/4vj0+eudZmsoW8fqgAMSgCAaWgrAEdTEi93q1X0e5DNIujrecCABACYgK6L/r5lgK9x5zjv8Zq6fN6vg75eBAxIAIDpuK+Z7msEgJ97vOYy9pNtTbw9D+DbgIEIADAd991Nz+MRlUlqHptDxxB3/xmb4lQBGMwsgMkok+9VrJ/wn+x42M4un8NNbN4B8HTf5r/ycZrIp22afBYwABUAmJbf7vn9PiX5vZU5+TI2T/6XA0z+WbfE2Q4IwHplgnjffOn9oSeO8v7nzWYXMYB2maHJ6yxgACoAMD3rqgDt5H+wKkCZlF6Wyx8bXtbe+Q/1WOIq8poHAHyuTMYnzf1VgCoG1H2sPzbcsbYfd9DmtfJ+fzZ5vQ8AWKe5vxx/0wy0FFDe52WzPmjc9WtzgKWHHh936uYBAOuUSeLqnsnjbbPnpFz+fvXA5NROzhfNwNWGOx+7T6/B1P0asCfbAGGimtUE/DbW75dvTw38cZ9u/PL+5+Vy1r1/HasnEl6X9zzYw326r6nd6lhFbu05Ck8DANZpHr5bvmlGVEpuVlWHm4Zb84A92AUAE1buEhdx/5G7VRlXzaqJr4oj1k127vw/9UMAwEOa1Zr8JkcXBJrVfv+rhnWuAvagBwCSaFaH8Fz2eGnbH9A+WOhNqSAs45E0q8bEKlZ3tu2zBNqtg069e9ijHfHM9AgAkEizOrBn2w7yZRm3jxt+1/2676RzEp9O4v+983u3o7pzZTsvSwD4PWAHAgAk0+iknxIPB2JnmgAhmXbrX7eF7DJW2/cYr9PGw4HYkQoAJNZVA56X0S4NVMEYPXvMXg2mQwUAEuuqAb93FYG26W4RqgJj8zxgByoAwBdKZaDtwm/Hd3F8TXqfNxZm96EEuCcBWxIAgNHp1r3bcHLejewsA7A1SwDA6LR739tnDpTxU/nPdvmijtycCsjWBABg1LoHGrVb4erI60XAliwBAJPQ/Pu8gKyqEobeBfSkAgBMQrcGvoi8VAHYigoAMBnduQY3kZNTAdmKAABMSveUvHnk5OFA9GYJAJiaV5GXQ4HoTQAAJqXrBch6FzwP6EkAAKbot8hJIyC9CQDAFL2JnE667ZCwkQAATE63DFBHTvoA6EUAAKZqETlZBqAXAQCYqqzLAFVZBvg2YAMBAJik5LsBzgM2EACAKVtETvOADQQAYMr+jpzmZRngJOABAgAwZdeRdxngLOABAgAwWd25+NeRk90APEgAAKbur8jp1DIADxEAgKl7HTm1k/9pwD0EAGDSumWAZeTkVEDuJQAAGSwjp/OAewgAQAYeDgSfEQCAyUt+KuAPAWsIAEAWi8hpHrCGAABk4VRAuEMAAFJIvgzgVEC+IAAAmWQ9FMipgHxBAAAyybobwKmAfEEAADJpKwAZlwHayd9uAD4hAABpeDgQ/EsAALLRBwDFLAAS6dbC30dOz7rdEKACAOTi4UCwIgAAGVkGID1LAEA6ZRmgKpebyKkqVZB3QXoqAEA6ZQKsy6WOnFQB+EgAALJaRE4CAB8JAEBWWU8F9HAgPhIAgJSSPxzIbgAEACC1ReRkGQABAEjt78jJMgACAJBX4mWAdvI/DVITAIDssh4KpA8gOQEAyC7rboDzILVvAiC3tgLQREJtH0D3bAQAAAAAAAAAAAAAAAAAAI7HLAD4qGmai5j2ATm/zGazrCcf8hkBAKBTAsC8XK5imuoy+T8N6DgKGKAz8YcDXQbcIQAAfOqnmJ727v91wB0CAMAd3Rr5ZUzLZcBn9AAArNE1BF7G+Fn7Zy0VAIA1yqT5KlbLAXWM22XAGioAAA8olYCqXOZlnJVRxbh8KEHm+wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdvd/aRi5RlOta9AAAAAASUVORK5CYII="
  , smgImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAEACAYAAADFkM5nAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAmzSURBVHgB7d3/edRGHgfgr+/h/0AFt1QAVBBTwXEVxKkAqACugpAKIBWEqyCmApwKrFRgpwLdDCvDntm1vVqNLGne93nm0WJrbWN5dz6anxEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAYrVt+zSVz+03+fHTAACWKVX0q1Qu2u2Og9lI1+thKi/ydcuPA4ijALZKFcX7dDjZ8enLVJ4dHR01waTlIJcOn1PZrPjz9Wu6cpbKX1eP0zW9DADqda3pf5s/gsnL16ndz0V37X9P5ZcuQABQiztWFsfBpLWHOxcCWKJ/BHCIH4OlW6XyPmBhjAGAHfKt3x1Oa1Kf8eNgsu54HW9zma7zo4AF0QIAh1npBqiCmQMsjgAAh9MNAMyOLgDYYY+mY90AEzZQF0Cka+z9kkXRAgCH0w0AzI4AAMP4VwDMiCYt2GGopmMWo0nlt9QT8DZgAQQA2EEAYId3KQS8Dpg5AQB2EAC4wfMUAk4DZswYAID9vQmYOS0AsIMWAG5iWiBzpwUAACokAABAhQQAAKiQAAAAFXoQMENt265iIEdHR00AVEYAYFZSxf8q1lOwBtue1WB/oEamsTAbqaI+SYf3ARNgGiBzZwwAc/JTADAICZbZsDAPU6IFgLnTArBQua88lYt2es5TcSfP7LV1OG+9XhdLgl2gdh595SfpBuq3fZ6Q340CuA+v0+v1XbAoAsAC5dSeDqsAGEaTAsDjYFEEgAVypwwMzZiH5TEGAAAqJAAAQIUEAACokAAAABUSAACgQgLAMp0FANxAAFimX2P68kJAewmYkKOZSD/qzwFbCAALlF7zH2L9om9ieppUXh3tuQog0JsWQbZyV8VstG17kQ4PAyagu7uevPS6ya+ZizjQXP6/3J0WAObEnQzsKdXblzHN1kDumQDAnPwngD6EZ74jADAb6U7mNB3ehrsZ2FcTcI0+HdjBmANuMqc+8fS3/DIdDtrO1xiA5dECALvZ/5yl+CvgGgEAdkg3PHnMgRDAdXlQ3UnMizEAfEeTDtyim0b15NqHczB4GtORK6UP3XGb/H94kcpq95f48vyme/y0O5/17ySXXIl+TMHwU8zQoV1augCWxwWFHtKbaa4gP8c05Irp3+n9ubntxPRz5595V3A53qzc0rkn6fA+luuyK2fdselKfpybzC/S72MxTee3XPtbCQDL44JCT+kN9U2sZyXcp1x5Pe/met8q/czH6fDHjk+vrld46fzzuLnVYIquKvYmvlXozbWP/X3X39lSpGuZw9xJ9CQALM+DAHrJYwTSm2puJr+vroAm1nf++1Rku/qCL3fc7X5M5VVMg4r9ME3ABgEADpP3XLivroC3d2n235QrxxRacgV5vS94VzD4M8aXx1c0oWIfmpkA/B8BAA6QKqWzVKE+Sw9/6D405uDA/0Y/2wLAxx3njj56PP1OXwcljH4tmTYBAA6UQ8DV4xQGTmOcANAccEe8bST4rjDhrns5moAN1gGAYY3VZN5rOlc3pfH6c093dSXs28XAdNkUiOsEABjWWM2sD7vKfF/bWiemMsiP8nQD8JUAAMNqYjwvY3/fLWiU7gzvY6Af96MJ6AgAMKDCzax5gOHpxr9f7dMK0J27ebef7wZtsVyXJqAjAMDwTqOMXGHnaYdXA/Nyhf5mj+e/jW+L+uQw8dzUuuqYCshXAgAMr4kyVt2gvJ83PpZbAd7e7elfgslJKo/yVLu7VP7pa6+CJTEGAKCUvIZ+W8YvN3yP34eurHOXQSof2pEFRaVf8UXbQ7A4WgBgeKXusr7296e79w/p8Dy+tTa8SOU8vU+/b9fr/e+lXVf2q1RepPIylbxfQN4H4KdgaZqAsBkQDK5dD7a7iOGdpYr/2bXvtYr1OICTbefH7oV8Vjse3zubzpTV9twUyHVZHhcUCmjL7KKXV/97HNu/3yrWQeB44O+7ueHOcYxARVNWbuGJ9SDQvbguy2MpYCgj332vYli5if7htsF7m4MD0zl5sZ8fuu+/6k7ZtgLgpqud9rKme3y2bYdA/cGz93dACABQShNlrOKWMQYbexN8CvjeaUAYBAilNFHGk4DDWPuBLwQAKKPUgitjbTXMQtkUiCsCAJRRaiqgAMAQLAiEAAAlFNxGVwBgCE1QPQEAymlieHnBnn8GHMYOkAgAUFCpZtbjgMPoAkAAgIJKjbY+DjhME1RPAIBytAAwSd1MANMBKycAQDmlVlxbdfsNwCGaoGoCAJRTsp/1x4DD7PP32QSLIwBAOU2UcxxwmF/3OHfvzYOYPgEACim84tpxwAG6PSOex80tAU0qr9K5+4QFZsL2jlBQ6qv/HOUW73m0bWfA0krvBmjbWRiHFgAoyzgAYJIEACirZAA4DoCeBAAoq9SugJl9AYDeBAAoq2QLgAAA9CYAQEHdroClBurljYGEAKAXAQDKKzlS/0kA9CAAQHmnUc4qAHoQAKC8JspZBUAPAgCUV3ImgE2BgF4EACiv5EwAAQDoRQCA8poAiGkRAKCwwpsCAfQiAMA4SnYDAOxNAIBxNFHG6LsBAssgAMA4/owymgDoQQCAcZTqAmgCoAcBAMbRRBnGFgC9HAUwirZtz+Owlftyf/9prCv9XD51MwwA9vYggLHkSnt1x3Mv41tFn8tpquxLrigIVEYAgPHkivzFDZ87DZU9MBJdADCS1AWQl+393P3zNLpm/FQaTfkAAAAAwPB0AQC9pC6NNgaUukG8H8GIrAMAABUSAACgQgIAAFRIAACACgkAAFAhAQAAKiQAAECFBAAAqJAAAAAVEgAAoEICAABUSAAAgAoJAABQIQEAACokAABAhQQAAKiQAAAAFRIAAKBCAgAAVEgAAIAKCQAAUCEBAAAqJAAAQIUEAACokAAAABUSAACgQgIAAFRIAACACgkAAFAhAQAAKiQAAECFBAAAqJAAAAAVEgAAoEICAABUSAAAgAoJAABQIQEAACokAABAhQQAoK/LGM6QXwu4AwEA6OtdDOdjAADT17btw1TO28Od568VAMA8dCHgfSoX7f7yc96o/AEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIA+/gcVhEj18jeanAAAAABJRU5ErkJggg=="
  , sniperImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAEACAYAAADFkM5nAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAmDSURBVHgB7d39cdtGGgfg15n8n7gCIxVE6kDuwFfB2RVcXEHkChxXYF0F9lVgXQWWKwhTgXgV6HaP0ImGKBH8WAjAPs/MDiV+aCQRxP7wYncRAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMDI3NzdNal9Su77Z7FN+TgAA89B2/g91/OuuhQAAmIn26L6vLwH8z7MAmLDcq+/w9OWzZ8+eByAAwBS0peuPqZ2k9nPsZ5naVdsWqX3LX6cOcRkTtmMAiPT32u9BCAAwem3n/zX27/i3mXQwEABgPz4IMHL5HHe6eRXDm0QwEABgPz4IMHK7dnADGFUwEABgPz4IMHIjDAAPuQ0G2YfUz36OAUwxABxpTMcm+X/+Nv2Ji4AtBAAYuQkFgHWDjbafWgAYaEzHqRDANgIAjNxEAwBP6zIFgJcBjxAAYOQEAPZgvQO2EgBg5AQA9mGwI9v8EABAdQQAAKiQAAAAFRIAAKBCAgAAVEgAAIAKCQAAUCEBAAAqJAAAzM8gF2Ji2qwUBSM314sBbfu7xraS3bF+XxcDYixUAIBjWcTqcsD56PNNsFHbMZ+mdhHHlTv+y9D505MKAIxcOmK8jnJHi/vIHc1V2xbt7bfU6Sx3+SG1VgBgLH4MYOxyB3sWw8sd+iI6nX3q5/4KYPIkVhi5gc4ZL2Lgjl4FAJ6WDRYmoA0B71N7Ffsb1RG9AABPywYLPAkBAJ6WWQAAUCGJFThYe4riY2onMa4ZC2OTp0i+NU2PMRAAgIMMMEhxbizUwyg4BQAcKg9O1Pn3l/9XHwOemAoAcJCJLlX81LYulQylFQ8Azg0C7OwitXdOE1BS0QDg3CDA3owVoKjSAeBTHLZwCUDVrC9AKaUDgHODAAcQACjFLAAAqJAAAAAVEgAAoEICAABUqHQAWAYAMDqlA8BVAACjYyEggBEzDZBSilYA2hWsTmN1CUwAYCQkS2bLQlTMgQoApZgFAAAVkiyZLRUAKnfVtuJXFXTV16PIs+YW7e1Fes/+GYUJAMyWAAD/l0PAeRSSPmp5sPdJcEw5vL1M71ux6fROATBn1qGAld9TJ/1bFJB+bu74df7Hl/+n/4iCBADmzDoUcCeHgBLl+SYo5SwKEgCYszehCgC3cudf4ojy16CUopUVAYDZsg4F3PM6js+gv3KK/m8NAqQqbQn0p/bbZu2hZu32PB632PB6mIqjDghMn6lP6eZVUETJdSAEAOjYNnug+4HsESp+jrsk/3OndR9vAsq7iCNND0zb/59huy1GAIAB7RoACv4eL9ovn8ddwNglQDQbHodbi1hVu/69bxBI2+h5uvk9KEYAgAGNJQCUsCVUZM3a05tH7hMq5uUitX+ldtln3nnajs5i1fGfBUUJADCgOQeAEnqOq+je5xTIeOXps4v29q+1+3N4bGJ1vl/4G4gAAAMSAJ6ecRWwIgDAQNo1zf/c8rRfSq+tThlHGlfRxIAe6gDakJTn9Z8HsyUAwADazj+vab6tvJnPkZ4KAXV6ZNR7XnOi77iKs879y7XXfWdbB9Au8fs+mCUBAAaQdqT5amavez49D5Z6GVTnke3ked8Lt2yYO5+v/vamfey7U1B9OoD0ki9hQN4slQwAVgKEO693eO5JUKuHLtP69+jvrPP95zjMu4AdqQBAa9fLBxsMWK+0qVzH/XL9IlanhpZbXpuP/D+tvy695pe1x3euALSvUwWYIRUAgHH5Y8N9TfRbFKdbKTiP4zi0ikBlHMFASwXgONoj0WwZd4Pbul//Z8P9957X95z60NoR+Hkw4KYBow+OBdiwct4f6blvO8/ZtwKQf5frYFZK7md+DIDjOosjWesLHwoTjz22MWik/ellHCh38Ol3y1WA8w0P5/Ehl907N3T+Fxs6/1dx2O90GU4D0JMjGGg9cF73QSoAm+1aSRnasd639og7TxttOg8tosdYgL4/b5ffN/2MPB3wt2A2jAGAYVzt8NyLoGptB/9mw0NNal/7Hs3njr9dW39TmNjVt4CeHMFAy0JAx1FLBeDWrpWjXe1YAWhi+0qWTIgKAAyg7dBPezxV58+6knPwdx3ZP8pBk4yTCgB0uBjQYWqrAGTpT34dqwF+TRzPXpWm0hUJhqUCADBiaR99kW7y0tB5TMBlHGbZ/ox9K02qAPTiSAY6VAAOU2MFYEw2XGeACVMBAKCvy4AeBACAeTEVkF4EAIAZaVc63GVNCyolAADMz4eALQQAgJlpZyWcBzzCaGboMAvgMGYBjE96S16km+ep/RSrNQJyax75mpEoub3akUGHAHAYAWD62gsTNbEKDE3cBYST+D4wUJgAAAMSAA4jANRhLSS8iLuQcBsQToKjEABgQALAYQQAsva0QxObw4HqQU8CAAxIADjM2Nei9/49vU71YD0YNGEMwncEABiQAHCY9O/7km7OYqS8f+OXtqEcBrqnFm6/rooAAAMSAA7TXpP+a4y0CuD9m7a1cHASFZxWEABgQALA4doQ8D5GeFEa7988tacVfo27asF6QJgsAQAGJAAc1wOjxdfboDto719dph4MBAAYkAAwrIEDwuf09v0tqN5EgsFV2l5PoxA7MugQAMbliAFhmdppevsWAQ9YCwa3YwvWA8LQztP2+i4KsSODDgFgWnoEhOwqtTc6fw7RDkDMqyOuh4ImysxOWKT2suQ2a0cGHQIAsIsC6xrkalXu/Ite1tmODDoEAOCY1ioHTdw/fXV7my1Su0jtQ9rNLKMwOzLoEACAGvwQAEB1BAAAqJAAAAAVEgAAoEICAABUSAAAgAoJAABQIQEAACokAABAhQQAAKiQAAAAFRIAAKBCAgAAVEgAgPuKX4YT4KkJAHDf1SOPfQ4AYH5ubm6a1K5v7sv3NQEAzFMbAj6tdfxfdP4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMCY/RdgZtpvSwcYNwAAAABJRU5ErkJggg=="
  , shotgunImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAEACAYAAADFkM5nAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAj8SURBVHgB7d3/ddNYFgDg6z37/zIVjKeChQrwVDBQAdkKFiogVMBQAaGCZSpIpoKECiIqCFPB2/eQgm3hMHZiyZL8fec8nDgOOZEc3av7fkUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMSUppkdvb3C5zu0lL5ePz5mvzAICWWTBKObCf5ofXW778zWw2Ow04Qvlv5SQ/PN3ipV9yu8p/Kx8CYKjSjgKOUFMd29X7ABiqtKOAI5Pf9ifp/n4LmLh/BMA0PSSIPwuYOAkAMFWPAriTBAAAjpAEAACO0D8DRirVaxyUEduPQ7mX/XrWjJ0tU2irgAmyDsBI7TqyP1/EJnWu869fgv55CPx0q8rtef7zuQqYGAnABk1weRvuLIHaWW6vciLwJWAiJAAtOfiX6T//C4B1pQrwXJcAUyEBaMkJwHV+mAfA96rcfh1iEtCMiVnk9nPzVKlWfGoeK9UL2iQALbv2rQNHp8rtyVACaqr3OngRdfD/ka+JQPN4Fd8nCFVwVCQALRIAYAslaF407c9DDBJcGau0iP2pWu1zLJMGVYSJkQC0SACAe6iivqv+GHVCUEWH8mXqZdTBv2+3VYTV9jlUEUZJAtAiAQB4kCp+3NWgijAQEoCWHP8vo57+B8D+GYswEBKAFtMAAQ6uipWxB7He1XClirAfEoANVpaYXQQAQ3RbPajCgMV7kQCMUE5QFlEvg7u1CS4FbKwG8CO3XQyvLOW8md0AAZiiR1FXcS/z/cJp8B0JAABT97qpnLJCAgDAMXgdrDEGYADsaw/QuS+z2eyn4BsJwABYewCge1MbDP1QDsaB5eBf7vhvAoBOSQDWGQNweEr+AN2rgjUSAACOgYWBWiQAABwDCUCLBODwvCkBulcFayQAB9asVy0JgOE7C8asCtZIAIbhTQBDVuX2Krf5SvtptiLqZWdf5vYxBJshsh9AiykRA5FSKqtUlYuHWQEwPD/turtcM8X3adRrfCzCQl+Htsjn8M/gGwkAo2Q3wN7sHPi2Mbbzt6/54/nXLklAabeJgQXA+tPJe3nMJACMkgSgH10tnHKsCUBbUyX4d6xXCebBvlkGeAMJAKMkAehHjwlAuTP7PbeLqPvP/yp3a02AnOf2r6iD48v4PkC+bL52Et3p7e6x2RukJAWLWFYJdB08zEU+f78GayQAjJIEoB89JgBP8o/aapDWhr0zTvL3fmiShevoJljO88/4HAfS6jpYhCrBrs7y+ftPsMYsAMZKX950nG0b/BuvWp8vyj/NHfpFdOOgffXl+OT2NYjl9kt+qrQS0C6CbZgBsIEEgLH6PehaXxfNs11enAPgRawngKsfX0Q3FjEg+RhUTUJQytqlb/tZ1MexCjaRAGwgAWCs3oWLXdfOoh+fYnerQb9a+birMv1gR+uXykduf6xUBxYhGWi7z3ts8iQAjFJT7n0S9YVOd8B+Vbmd5mP8Lnpwj/n181jvA1+9u+vqvbBoxhgMXpnrvpIM3FYGjvlv5IvpfwADkdbtFFjz609Wvve69bVF6s7rGKlyjJvjdp6Oz3mwkQoAcGjz2M1qID5tfa3Lu/TTVFcfRqfpJrgdM1AqA2XqZBXHQf//HSQAwKE93faFOQCfxDJhKHO7P7Re8lt0632MXDOA8F1rvMCUVQHAMNy3RJuWJez3aUPXQX7uOnXvZUxMqWykuovgOk3P1gkmAB3bcJF+tsP3Prrj+dPUj5s00q6AbZSAmeoEayqsoggwFPmifNm6SD8oqKb1gYF9mPzAsrSsClym8boM7mQpYKB3qR5Rf9p6uorlQj5V81imb/218vnXx9KP3fw/j5r/57/Rv5MNYxAmKdVLEZdjvIhxLUP8MZ+j58FGEgCgd03gLndn8xivkpz8cmxzzFM9EPNFDGx1xDuU9SzeBBuZBQD0rgmaZUpaFeNVkpjRzwrYVWs64VkM+xyaAvgDEgDgIJoyfgkkH2O8nqUJzgrYRjOdcHXFwSGex4Pt4DgGugCASUvLrXTLuIN57N/XZalvxyUcs1QP5FxEd8d6J11tZw3AiKR6VPtN6sZlMt1sTTr8dEIzAP6GLgDgKDR36F1tI10qDG+Db243JYp6u+Ly2Hd/fBUAUKR6U5yuqgDFUY4H2FaqqzDvUz8rDo528yYAOlACQ+pOSS4eB38rdb87Ydf7QgAwJqn7KsB1Mh5ga6muCrxO+68K2AMAgHWp2ypAYTzAPaT9DhyUhAGwLnVfBSgWwb2kPexDEACwSeq+CnCd3IU+WD6Gj9PuAwevAwA2Sf1UAXQF7FHafuCgNQAAuFsJ0Kl7i2Cv0nI64V2Obo8GAHbQBJKuuRvtSHP+zlvHu3w+DwD4kdTPcrUWCOpQqmcPlGYNhh3YKAE4ak3Q6Pou3YZBDI69AICjloNyWaP+IrpVZgMYEAgAQ5KrAIvUj0UAAMORul2X/pb56QyGLgCA2pvo3td17wMGwCBAgEYOzjdR99d36Wo2mz0JODAVAICli+jeWcAASAAAlt5F9/4IAGBYOh4MqP8fAIYo7X9KYNnStuw58DRgQAwCBGjJwfo8Pyxid1et9mk2m30JGCAJAEBLqjeTKUnA/I6XlKDeDvRXAQCMW1puOXuT23Xz8Yvcfg4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACG6f84Tx+J+0u3UwAAAABJRU5ErkJggg=="
  , apcImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAACXBIWXMAACxLAAAsSwGlPZapAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAXaSURBVHgB7d3hcdRWFIbhczMUQAmkA3eQdQWhgywVJFRgpwLSAaYDOsB0QAlLB3SgXMPuhCEGtN6xravveWY0+oGGWVidd7hIlqoAAAAAAAAAAAAAAAAAAACApWnF0aZp2vbd62JJtq21N8VRfikglgBAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABuJvfi6XZFEcTgCNN03TVd8+Lpdn278bPZxzJDwMdYT/8fxRLdtVae1HMIgAzGf6hiMBMAjCD4R+SCMwgAD9h+IcmAj8hAD9g+FdBBH5AAL7D8K+KCHyHANzC8K+SCNxCAL5h+FdNBL4hAF8x/BFE4CvuBNzrw39Rhj/Bdv9dUwLwtWdFimfFZwIAwQQAggkABBMACOYy4B14N+AieTfgHfgXAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwZ7UYKZp2tRpPrXWPhR8o59bZ333tE7Qz63rGshwAeje1Wmu+3Ze8H+v+rap0wz1kB1LAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGAjPhWYu/mnb29nHrvp22WxegKQ40Nr7f2cA6dp+rWIYAkAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMFGvBNwW6f5VHC7v/t2VUGGC0Br7U3BPejn1nWFsQSAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYV4PtTdP0Z989n3n4s2Jp/urf4Xbmse9ba5eFAHzlrL68FJMxnR1x7K74zBIAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgDrs223ezP3N+jHXt32G/RfelGsigCsy/aYQT/WTRhKBFZFANbjXof/QATWRQDW4UGG/0AE1kMAxvegw38gAusgAGN7lOE/EIHxCcC4HnX4D0RgbAIwpkUM/4EIjEsAxrOo4T8QgTEJwFgWOfwHIjAeARjHoof/QATGIgBjeDvC8B/sI3BVLJ4AjOFTwT0QAAgmABBMACCYAEAwAYBgT4qDm8ts1zOP3fRtWyzJVc3//j4WnwnAXr92fT332Gmabh6PtS2W5HqkeyWWwhIAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAIzhaY1nxM8cRwDG8HyapssaxP6zPi8Wb7jnAfST612d5kNr7WWN56L/2W+eW3BZC7Yf/osaUP/sr/rurE7Qv5/zGsiIDwTZVK5FR2Dk4d+7Gf5NBbEEGM/FEpcDKxj+SAIwpkVFwPCPSwDGtYgIGP6xCcDYHjUChn98AjC+R4mA4V8HAViHB42A4V8PAViPB4mA4V8XLwZZl8/3CdSXt+Tch20Z/lURgPW5KEPKTJYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAgo34WPDrOs2HgtvFnRvDBaC1dl5wD/q59bLCWAJAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBsxAeC3ItpmjZ992zm4b8VS7Pp32GbeeyutXZd1Ny/sNXrJ8/rvtsWCa56AF4UlgCQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEMytwP/5WPPfO/i0b2fFkuz22xzeD7nnVuA7mKZp23eviyXZttbeFEexBIBgAgDBBACCCQAEcxVgXLu+XdYyXNb8h6mwIAIwpl3fzvv/eu9qAfpVkfd9965EYDiWAOPZ1YKG/8b+s5zX/OvwLIQAjGVXCxv+AxEYkwCMY1cLHf4DERiPAIxhVwsf/gMRAAAAAAAAAAAAAAAAAAAAADjNvxDmH5duSoIKAAAAAElFTkSuQmCC"
  , airImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAACXBIWXMAACxLAAAsSwGlPZapAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAj4SURBVHgB7d37kWPVEQfgHhf/e4jAcgSQgeUIvI5gIAJwBAwRQAbYEYAjYB0BdgQ7GXgzkI92dF0LNSx63Mc53d9XpRqKndqdh/qn7j7SVQQAAAAAAAAAAAAAAAAAAAAA3TgcDp+22z4o63dBZQ/t9qcA6mmP/m+OtwBqObX/k31QkhGgrof3/tsYAJWc2v+JMQCq+EX7bwwozAhQ08ML/88YABX8ov03BkAVv9L+GwOKMgLU8/CBPzMGQGa/0v4bAyC732j/jQEFGQFqeTjjc4wBkNFvtP/GAMjqzPbfGFCMEaCOc9r/iTEAMjmz/TcGQDYXtv/GgEKMADVc0v5PjAGQwYXtvzEAsriy/TcGFGEEyO+LuJ4xIDkBkN+ncb1XQWp3QWrHPj5u8/Hd3d3bICUdQGIzzfC7IC0BkNsncTt7gMQEQG77uN0tOwQ6JwBy28Xt9kFaloBJtfn/vn34b8zDIjApHUBec7buxoCkBEBecywAl/i76IgAyGsf89EBJCUA8trFfPZBSpaACc28AJxYBCakA8hpiZbdGJCQAMhpiWfvWQQmJAByWuLReh+kIwByMgJwFkvAZBZaAE4sApPRAeSzj+V4ZWAyAiCfJZd1+yAVAZDPPpazC1KxA0im7QCO8/99LONt2wF8HKShA0ikFf8uliv+o/v2b/whSEMA5LLGUd0+SEMA5LLGlt7zARIRALmsUZwCIBFLwEQWXgBOLAIT0QEkcXwPwFi++I8sAhMRAHnsYj37IAUBkMeaT9O1B0hCAOSxZlEKgCQsAZNYaQE4sQhMQgeQwIoLwMn96d9kcAIghy2K0SXCEhAAOWxRjDqABARADlsU4z4YniVgAm0eP8T6jpcG+6NLhI1NBzC4Vvv72MZx6bgLhiYAxrflMs41AgcnAMa35TLOInBwAmB8AoCrWQIObOH3ADiX9woYmA5gbD08AusCBiYAxtbDs/E8I3BgAmBs+9ieDmBgAmBsu9jePhiWJeCgOlkATiwCB6UDGNc++vGXYEgCYFw9Fd0+GJIRYFArXwHot3hh0KB0AANqxf8q+in+o+PX4jRgQAJgTD3O3A/BcIwAA+qs/Z8YAwakAxhMh+3/xBgwIAEwnp6P3IwBgzECDKbT9n9iDBiMDmAgHbf/E2PAYATAWEZ4xp0xYCBGgIF03v5PjAED0QEMYoD2f2IMGIgAGMdIL7gxBgzCCDCIQdr/iTFgEDqAAQzU/k+MAYMQAGMY8fX2xoABGAEGMFj7PzEGDEAH0LkB2/+JMWAAAqB/I19uyxjQOSNA5wZt/yfGgM7pADo2cPs/MQZ0TgD0LcPVdo0BHTMCdGzw9n9iDOiYDqBTCdr/iTGgYwKgX5nebMMY0CkjQKdaB/Am+njvvzm8bSPAx0F3dAAdasW/jzzFf3R/+p7ojADoU8aW2fsHdsgI0KFk7f/EGNAhHUBnErb/E2NAhwRAfzJvzI0BnTECdCZp+z8xBnRGB9CRxO3/xBjQGQHQiVYYx2fMfRH5fXH6XumAEaADrSB27cP3Uecps/9ut7+2ceAp2JQA2Nip+H+M3K3/S57a7c9CYFtGgA2d5uGfol7xH+3a7cf2M/BCoQ0JgI20O/6X8fzIX3ke3rXbT6efBRsQABtod/jH9uGbYPLN6WfCyuwAVtbu6H8PL4/9Nd+2ncDfgtUIgJWcjr6OLb+Z98OcEKxIAKyg8Kb/Wk/hhGAVdgALO225Ff9lduGEYBUCYEHtDvxZKP5r7cIJweIEwEJOW+3vovYx3xycECzIDmAB7Q77bdR4Xv+anBAsQADM6LTpPz6nfx8s4XU8nxB4j4GZCICZ2PSv5imcEMzGDmAGNv2r2oUTgtkIgBvZ9G9iF88h8Cq4iQC4gU3/pt7tW5wQ3MYO4Eo2/V35uu0EHoOLCYALnTb9x0d97Wdffmi3z50QXEYAXKDgpbtG8xROCC4iAM502jofi38X9OwphMDZLAHPcNo22/SPYRfPryEwop1h+A6g/aK/u+DT/9EeGV5f8PnTpbtcvWdMFy8HT9dpPPuCLe3v/zwG9lGM77MLPvf1BZ87HfN9FYzqq/Y7jAtDYBeX3aeGDgAjwAuOm/7TpbsU//iOIfC9NyN5mQD4hfee0++6fXkc9wE/nX63vEcAvOe94nfMl88unp8+vAv+TwCcFH+Tjip28dwJ7IN3BEB4k45i3l2d2aXGnpUPAG/SUZZLjUWOY8CrnLbCxxf0WPbVdTwh+H3lS42V7ABs+nnPl+3+UPaEoFwA2PTzgndXdKoYAtUC4PiLtunnJbt4fmD4JArJ8FqAQ8BG2v5g6BpyDAiFCQAoTABAYQIAChMAUJgAgMIEABQmAKAwAQCFCQAoTABAYQIAChMAUJgAgMIEABQmAKAwAQCFCQAoTABAYQIAChMAUJgAgMIEABQmAKAwAQCFCQAoTABAYR9FLa/b7SnG86rd7mMsb9vthxjPrt32wRgOl3mIAbWv+81hPG9iQO3r/uySbzIGZwSAwgQAFCYAoDABAIVlOAXYX/C5/wn4sNdR6BRg+AC4u7v7V8BM2v3pKcY8Kr6KEQAKEwBQmACAwgQAFCYAoDABAIUJAChMAEBhAgAKEwBQmADo3OFweIznq9SMZnf62oFrHAvoML7HAC5zyFH8k8cAznPIVfyTxwA+7JCz+CePAbzskLv4J48B/NyhRvFPHgN4dqhV/JPHgOoONYt/8hhs6i7YzKkAvoravr67u3sMNiEANqL4f0YIbEQAbEDxv0gIbEAArEzxf5AQWJkAWJHiP4sQWJEAWIniv4gQWIkAWIHiv4oQWIEAWJjiv4kQWJgAWJDin4UQWJAAWIjin5UQWIgAWIDiX4QQWIAAmJniX5QQmJkAmJHiX4UQmJEAmIniX5UQmIkAmIHi34QQmIEAuJHi35QQuJEAuIHi74IQuIEAuJLi74oQuJIAuILi75IQuIIAuFAr/lftw/dBj161EPhncDZvDnq5+6BXfjcXEgBQmACAwgQAFCYAoDABAIUJAChMAEBhAgAKEwBQmAAAAAAAAAAAAAAAAAAAAAAAgI78D4ZZc0lVglz9AAAAAElFTkSuQmCC"
  , ifvImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAACXBIWXMAACxLAAAsSwGlPZapAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAdASURBVHgB7d3hdRPZGcfhVzkUQAcxFYR0gCtIUgFsBbupAKeCbAdAB3SA04FTAUoHdDC5E6Qczq5tjKyZez3/5zlHRx/MBzTS+7uvjJGrAAAAAAAAAAAAAAAAAAAAAAYwTdO7aV1vix/SrtnVtK5PFWhXYdoTfdHuPte6vrTbi91u96X4rsNzNA/kRa3rsj1H1xXkD5Wnx2n8vN1+Lh7qVa0//LO4TS1qA+h0+h/ZAh6oPU/zc3RRfURtAWkbQM/C2wIeoA3/m+o3/LOoLSBmA+h8+h/ZAr6j8+l/FLMFJG0AI5TdFnCPAU7/o5gtIGIDGOT0P7IF3GGQ0/8oYgtI2QBGKrot4BYDnf5HEVvA5jeAwU7/I1vAbwx2+h9tfgtI2ABGLLkt4BsDnv5Hr2vjEjaAqcY0n/43xexlfY3icNoGsOkZEQC4x9YDkPijwMCBAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACPaseAr2u93uRT0hg37EF79hA4BgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJjPAwgxTdNFPfz/58+fP7AvNk8Acrxut6sH/tn5z/2j2DxvASCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGDPilHs2+36jq99qafnY7s9v+Nrr9rtouhOAMawb7fL3W63r41oj+Xvd31tmqaLdvepRKA7bwH629fGhv97Do/1sr4+djoSgL72FTb8RyIwBgHoZ1+hw38kAv0JQB/7Ch/+IxHoSwDWN39H3/B/43At/lZP8187njQBWJfhv0O7Jjf1dRMQgRUJwHqOw39T3EoE1icA6zD8DyQC6xKA5Rn+HyQC6xGAZRn+E4nAOgRgOYb/kURgeQKwDMN/JiKwLAE4P8N/ZiKwHAE4L8O/EBFYhgCcj+FfmAic3642bmpqHX9eavjbQ/hru/tLPc7Lw+0hbg63x/jQrsd1LaBdj1f19fMEFtcew6ZnRADO4017nXyoBbS//jy084v9eT0ti25E7bq8aXfvamFbD4C3AI9n+G83/50/HR7D2bVr/r7d/VQ8igA8juG/nwgMTgBO94vhfxARGJjvAZzuor34/lNntrHh/9Zi3xM4fMjo51qA7wGwmg0P/2zRTYDTCMAgNj78RyIwGAEYQMjwH4nAQASgs7DhPxKBQQhAR6HDfyQCAxCATr759ViJw390jMBF0YUA9HNR2cN/NF+DPxZdCAAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEE4BOdrvddbv7ULxv1+JfRRcC0FF74b9pdx8r18d2DX4quhGA/uYBuKk882M2/J0JQGftBPzS7i4rKwLzY708PHY6EoABhEXA8A9EAAYREgHDPxgBGMjGI2D4ByQAp7uqBWw0AksP/1VxEgE43Ztpmt7VAjYWgUWHvz0H79vd6+IkAvA4InA/wz84AXg8Ebid4X8CdrVx7YUy1TreL/VTbe0hPG93f6qn5d9bGP72GDY9IwJwXotFgK/WPvm3HgBvAc5rfjvwz2IR7dr+Wtb+sxKA8/ulvVCvirM6XNOfC37E1M9VcRbztZw6KZ62qa+r4lGmjsM/q43zFmBZbycRONnh2r0tFiMAyxOBExj+dQjAOkTgBxj+9QjAekTgAQz/ugRgXSJwD8O/PgFYnwjcwvD3IQB9iMA3DH8/AtCPCJTh700A+oqOgOHvTwD6i4yA4R+DAIwhKgKGfxw+DwDu4fMAgM0SAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwZ4VvXxpt5ti9rLdnhec2zRN76Yx+T33B+1avJ3G9K42LuETgV61u081lv1ut3tR/E97jubT/3ONtwW8aM/TvjZs898DaE/gdbu7rrFcFf/XnqP57dCvNZb3Wx/+2eY3gNlgW4DT/xYDbgGbP/1nEf8KMNgWcFX8zmBbQMTpP4vYAGaDbAFO/3sMtAVEnP6zmJ8DGGQLuCruNMgWEHP6z2I2gFnnLcDp/wADbAExp/8s6icBO28BV8V3dd4Cok7/WdQGMOu0Bezb7TLtxXWqjltA1Ok/i/u/AJ22gLiT5TE6bQGeIwAAAAAAAAAAAAAAAAAAAGAI/wUDXkf8bDghYQAAAABJRU5ErkJggg=="
  , atImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAACXBIWXMAACxLAAAsSwGlPZapAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAZXSURBVHgB7d3tbRzXGYbhl4H/hx1kSkgHoSqwUkE2HdgdUBXYqUB0BUkqkFxB1EG2AycVTM5AuzCDIBJE7Xyc81wXMFj9IimA7z3n7MwOqwAAAAAAAAAAAAAAAAAAAADYzDzPp3klxRB+U0AsAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJwNj+UCuZ5/mh6J4AjO11refbAo6pnaFfz+v6peieFcC41j5D39sG9E8AxrXm8v/KNqBzAjCgZfnfXu5rfaeiawIwpq3OzLYBnROAMW2x/L+yDeiYAAxmw+X/1anolgCMZ+szsm1AxwRgPFsu/69sAzolAAPZYfl/dSq6JABj2etMbBvQKQEYyx7L/yvbgA4JwCB2XP5fnYruCMA49j4D2wZ0SADGsefy/8o2oDMCMI49l/91oJ+BLyAAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAj2TfFf5nme2ssP7biv7Xx/d3f3ob7OuR1T7et90RUBeOYy/O9q+0H6bX29N+14W/s5t4j9VHTFFuBix+G/iTZ8T/VxFbCXx6I7AlD9D/8zb2ofzv6dig/AQMO/5yrgsehSdABGGv5ntl4FOPt3LDYAgw7/HquAx6JbkQEYdfif2WoV4OzfubgABAz/lquAx6JrUQFIGP5n1l4FOPsPICYAYcO/xSrgsehe0gogZvif+bFW4uw/hqQATJXn3wWf4E5ACCYAEEwAIJgAQLC7CtEuA85Ft9pVh5jf1S1ZAUAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggkABBMACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAHpwLlYhABzduR2vilUIAEd2bseru7u7c7EKAeCozmX4VycAHNG5DP8mBICjOZfh34wAcDSPhn87AgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYHcVYm6KHpzLnYCbsQLgaKZ2vGu9norVCQBHNJUIbEIAOKqpRGB1AsCRTSUCqxIAjm4qEViNANCDqURgFS4DHsOHdvyrbu++Hb+vcZzLJcKbEoBjeGi/1D/XjbX/8qm9vK2xnEsEbsYWgN5MZTtwMwJAj6YSgZsQAHo1lQh8NQGgZ1OJwFf5puBlTnVb39XLrlhM9TEC3hh8AQHgRdqw/VQ31Ab47+3lXYnApmwBOIQ2uMt9EMsfAf1QLzOV7cAXEwAOQwS2JwAcighsSwA4HBHYjgBwSDeMwHL8Mv/qH+34azv+VAgAx3WjCDzUxw9FXS1XGV6346lF4J/t+K6CCQCHdoMIfMrUjh8uq4KpAgkAh7dyBBbLqiDyPQMBoAsbRGCq8T46/VlJdwI+1XGt8TCQ4SwRWO72q5ffMfg5D8t7Au37/FjQu+WBIPNKakft299f9u1rWK4Y3FcIWwC6s/J2YBn+mEuEAkCXLhH4Y63joUIIAD2bah0jPUj1kwSAnk21jqlCCAAEEwD4XzGXZQWAnr2vdax1s9HhCADdujz+a42z9fsKIQD0bo279m76vMMjEwB695e67SrgKenBogJA1y43BL2p2zjf8Gt1QQDo3uXDO7dYtn+f9lhxAWAIbXBP9fIILKuIU/saf6swAsAwLhF4rC+zXPJ7des/dAK7mwf9OPDntB9vasfb+eMz//6fd7MHg/rTYIznso//8/LvNuTLB3t+V78+GHRZ7v98efMwngAwtDboyxI/5s6+L+U9AAgmABBMACCYAEAwAYBgAgDBBACCCQAEEwAIJgAQTAAgmABAMAGAYAIAwQQAggnA2L6tlXiaDhxYG9CneX0iAEez0fCLABzNxsMvAnAUOw2/CMDedh7+KxHojKsA4zjC8D0UXREACCYAEEwAIJgAQDABgGACAMEEAIIJAAQTAAgmAAAAAAAAAAAAAAAAAAAAAABwIP8BAzSktE+nlnQAAAAASUVORK5CYII=";
function varint64read() {
    let V = 0
      , X = 0;
    for (let ne = 0; ne < 28; ne += 7) {
        let ue = this.buf[this.pos++];
        if (V |= (ue & 127) << ne,
        !(ue & 128))
            return this.assertBounds(),
            [V, X]
    }
    let J = this.buf[this.pos++];
    if (V |= (J & 15) << 28,
    X = (J & 112) >> 4,
    !(J & 128))
        return this.assertBounds(),
        [V, X];
    for (let ne = 3; ne <= 31; ne += 7) {
        let ue = this.buf[this.pos++];
        if (X |= (ue & 127) << ne,
        !(ue & 128))
            return this.assertBounds(),
            [V, X]
    }
    throw new Error("invalid varint")
}
function varint64write(V, X, J) {
    for (let ce = 0; ce < 28; ce = ce + 7) {
        const me = V >>> ce
          , ge = !(!(me >>> 7) && X == 0)
          , Te = (ge ? me | 128 : me) & 255;
        if (J.push(Te),
        !ge)
            return
    }
    const ne = V >>> 28 & 15 | (X & 7) << 4
      , ue = !!(X >> 3);
    if (J.push((ue ? ne | 128 : ne) & 255),
    !!ue) {
        for (let ce = 3; ce < 31; ce = ce + 7) {
            const me = X >>> ce
              , ge = !!(me >>> 7)
              , Te = (ge ? me | 128 : me) & 255;
            if (J.push(Te),
            !ge)
                return
        }
        J.push(X >>> 31 & 1)
    }
}
const TWO_PWR_32_DBL = 4294967296;
function int64FromString(V) {
    const X = V[0] === "-";
    X && (V = V.slice(1));
    const J = 1e6;
    let ne = 0
      , ue = 0;
    function ce(me, ge) {
        const Te = Number(V.slice(me, ge));
        ue *= J,
        ne = ne * J + Te,
        ne >= TWO_PWR_32_DBL && (ue = ue + (ne / TWO_PWR_32_DBL | 0),
        ne = ne % TWO_PWR_32_DBL)
    }
    return ce(-24, -18),
    ce(-18, -12),
    ce(-12, -6),
    ce(-6),
    X ? negate(ne, ue) : newBits(ne, ue)
}
function int64ToString(V, X) {
    let J = newBits(V, X);
    const ne = J.hi & 2147483648;
    ne && (J = negate(J.lo, J.hi));
    const ue = uInt64ToString(J.lo, J.hi);
    return ne ? "-" + ue : ue
}
function uInt64ToString(V, X) {
    if ({lo: V, hi: X} = toUnsigned(V, X),
    X <= 2097151)
        return String(TWO_PWR_32_DBL * X + V);
    const J = V & 16777215
      , ne = (V >>> 24 | X << 8) & 16777215
      , ue = X >> 16 & 65535;
    let ce = J + ne * 6777216 + ue * 6710656
      , me = ne + ue * 8147497
      , ge = ue * 2;
    const Te = 1e7;
    return ce >= Te && (me += Math.floor(ce / Te),
    ce %= Te),
    me >= Te && (ge += Math.floor(me / Te),
    me %= Te),
    ge.toString() + decimalFrom1e7WithLeadingZeros(me) + decimalFrom1e7WithLeadingZeros(ce)
}
function toUnsigned(V, X) {
    return {
        lo: V >>> 0,
        hi: X >>> 0
    }
}
function newBits(V, X) {
    return {
        lo: V | 0,
        hi: X | 0
    }
}
function negate(V, X) {
    return X = ~X,
    V ? V = ~V + 1 : X += 1,
    newBits(V, X)
}
const decimalFrom1e7WithLeadingZeros = V => {
    const X = String(V);
    return "0000000".slice(X.length) + X
}
;
function varint32write(V, X) {
    if (V >= 0) {
        for (; V > 127; )
            X.push(V & 127 | 128),
            V = V >>> 7;
        X.push(V)
    } else {
        for (let J = 0; J < 9; J++)
            X.push(V & 127 | 128),
            V = V >> 7;
        X.push(1)
    }
}
function varint32read() {
    let V = this.buf[this.pos++]
      , X = V & 127;
    if (!(V & 128))
        return this.assertBounds(),
        X;
    if (V = this.buf[this.pos++],
    X |= (V & 127) << 7,
    !(V & 128))
        return this.assertBounds(),
        X;
    if (V = this.buf[this.pos++],
    X |= (V & 127) << 14,
    !(V & 128))
        return this.assertBounds(),
        X;
    if (V = this.buf[this.pos++],
    X |= (V & 127) << 21,
    !(V & 128))
        return this.assertBounds(),
        X;
    V = this.buf[this.pos++],
    X |= (V & 15) << 28;
    for (let J = 5; V & 128 && J < 10; J++)
        V = this.buf[this.pos++];
    if (V & 128)
        throw new Error("invalid varint");
    return this.assertBounds(),
    X >>> 0
}
var define_process_env_default = {};
const protoInt64 = makeInt64Support();
function makeInt64Support() {
    const V = new DataView(new ArrayBuffer(8));
    if (typeof BigInt == "function" && typeof V.getBigInt64 == "function" && typeof V.getBigUint64 == "function" && typeof V.setBigInt64 == "function" && typeof V.setBigUint64 == "function" && (typeof process != "object" || typeof define_process_env_default != "object" || define_process_env_default.BUF_BIGINT_DISABLE !== "1")) {
        const J = BigInt("-9223372036854775808")
          , ne = BigInt("9223372036854775807")
          , ue = BigInt("0")
          , ce = BigInt("18446744073709551615");
        return {
            zero: BigInt(0),
            supported: !0,
            parse(me) {
                const ge = typeof me == "bigint" ? me : BigInt(me);
                if (ge > ne || ge < J)
                    throw new Error(`invalid int64: ${me}`);
                return ge
            },
            uParse(me) {
                const ge = typeof me == "bigint" ? me : BigInt(me);
                if (ge > ce || ge < ue)
                    throw new Error(`invalid uint64: ${me}`);
                return ge
            },
            enc(me) {
                return V.setBigInt64(0, this.parse(me), !0),
                {
                    lo: V.getInt32(0, !0),
                    hi: V.getInt32(4, !0)
                }
            },
            uEnc(me) {
                return V.setBigInt64(0, this.uParse(me), !0),
                {
                    lo: V.getInt32(0, !0),
                    hi: V.getInt32(4, !0)
                }
            },
            dec(me, ge) {
                return V.setInt32(0, me, !0),
                V.setInt32(4, ge, !0),
                V.getBigInt64(0, !0)
            },
            uDec(me, ge) {
                return V.setInt32(0, me, !0),
                V.setInt32(4, ge, !0),
                V.getBigUint64(0, !0)
            }
        }
    }
    return {
        zero: "0",
        supported: !1,
        parse(J) {
            return typeof J != "string" && (J = J.toString()),
            assertInt64String(J),
            J
        },
        uParse(J) {
            return typeof J != "string" && (J = J.toString()),
            assertUInt64String(J),
            J
        },
        enc(J) {
            return typeof J != "string" && (J = J.toString()),
            assertInt64String(J),
            int64FromString(J)
        },
        uEnc(J) {
            return typeof J != "string" && (J = J.toString()),
            assertUInt64String(J),
            int64FromString(J)
        },
        dec(J, ne) {
            return int64ToString(J, ne)
        },
        uDec(J, ne) {
            return uInt64ToString(J, ne)
        }
    }
}
function assertInt64String(V) {
    if (!/^-?[0-9]+$/.test(V))
        throw new Error("invalid int64: " + V)
}
function assertUInt64String(V) {
    if (!/^[0-9]+$/.test(V))
        throw new Error("invalid uint64: " + V)
}
const symbol = Symbol.for("@bufbuild/protobuf/text-encoding");
function getTextEncoding() {
    if (globalThis[symbol] == null) {
        const V = new globalThis.TextEncoder
          , X = new globalThis.TextDecoder;
        globalThis[symbol] = {
            encodeUtf8(J) {
                return V.encode(J)
            },
            decodeUtf8(J) {
                return X.decode(J)
            },
            checkUtf8(J) {
                try {
                    return encodeURIComponent(J),
                    !0
                } catch {
                    return !1
                }
            }
        }
    }
    return globalThis[symbol]
}
var WireType;
(function(V) {
    V[V.Varint = 0] = "Varint",
    V[V.Bit64 = 1] = "Bit64",
    V[V.LengthDelimited = 2] = "LengthDelimited",
    V[V.StartGroup = 3] = "StartGroup",
    V[V.EndGroup = 4] = "EndGroup",
    V[V.Bit32 = 5] = "Bit32"
}
)(WireType || (WireType = {}));
const FLOAT32_MAX = 34028234663852886e22
  , FLOAT32_MIN = -34028234663852886e22
  , UINT32_MAX = 4294967295
  , INT32_MAX = 2147483647
  , INT32_MIN = -2147483648;
class BinaryWriter {
    constructor(X=getTextEncoding().encodeUtf8) {
        this.encodeUtf8 = X,
        this.stack = [],
        this.chunks = [],
        this.buf = []
    }
    finish() {
        this.buf.length && (this.chunks.push(new Uint8Array(this.buf)),
        this.buf = []);
        let X = 0;
        for (let ue = 0; ue < this.chunks.length; ue++)
            X += this.chunks[ue].length;
        let J = new Uint8Array(X)
          , ne = 0;
        for (let ue = 0; ue < this.chunks.length; ue++)
            J.set(this.chunks[ue], ne),
            ne += this.chunks[ue].length;
        return this.chunks = [],
        J
    }
    fork() {
        return this.stack.push({
            chunks: this.chunks,
            buf: this.buf
        }),
        this.chunks = [],
        this.buf = [],
        this
    }
    join() {
        let X = this.finish()
          , J = this.stack.pop();
        if (!J)
            throw new Error("invalid state, fork stack empty");
        return this.chunks = J.chunks,
        this.buf = J.buf,
        this.uint32(X.byteLength),
        this.raw(X)
    }
    tag(X, J) {
        return this.uint32((X << 3 | J) >>> 0)
    }
    raw(X) {
        return this.buf.length && (this.chunks.push(new Uint8Array(this.buf)),
        this.buf = []),
        this.chunks.push(X),
        this
    }
    uint32(X) {
        for (assertUInt32(X); X > 127; )
            this.buf.push(X & 127 | 128),
            X = X >>> 7;
        return this.buf.push(X),
        this
    }
    int32(X) {
        return assertInt32(X),
        varint32write(X, this.buf),
        this
    }
    bool(X) {
        return this.buf.push(X ? 1 : 0),
        this
    }
    bytes(X) {
        return this.uint32(X.byteLength),
        this.raw(X)
    }
    string(X) {
        let J = this.encodeUtf8(X);
        return this.uint32(J.byteLength),
        this.raw(J)
    }
    float(X) {
        assertFloat32(X);
        let J = new Uint8Array(4);
        return new DataView(J.buffer).setFloat32(0, X, !0),
        this.raw(J)
    }
    double(X) {
        let J = new Uint8Array(8);
        return new DataView(J.buffer).setFloat64(0, X, !0),
        this.raw(J)
    }
    fixed32(X) {
        assertUInt32(X);
        let J = new Uint8Array(4);
        return new DataView(J.buffer).setUint32(0, X, !0),
        this.raw(J)
    }
    sfixed32(X) {
        assertInt32(X);
        let J = new Uint8Array(4);
        return new DataView(J.buffer).setInt32(0, X, !0),
        this.raw(J)
    }
    sint32(X) {
        return assertInt32(X),
        X = (X << 1 ^ X >> 31) >>> 0,
        varint32write(X, this.buf),
        this
    }
    sfixed64(X) {
        let J = new Uint8Array(8)
          , ne = new DataView(J.buffer)
          , ue = protoInt64.enc(X);
        return ne.setInt32(0, ue.lo, !0),
        ne.setInt32(4, ue.hi, !0),
        this.raw(J)
    }
    fixed64(X) {
        let J = new Uint8Array(8)
          , ne = new DataView(J.buffer)
          , ue = protoInt64.uEnc(X);
        return ne.setInt32(0, ue.lo, !0),
        ne.setInt32(4, ue.hi, !0),
        this.raw(J)
    }
    int64(X) {
        let J = protoInt64.enc(X);
        return varint64write(J.lo, J.hi, this.buf),
        this
    }
    sint64(X) {
        let J = protoInt64.enc(X)
          , ne = J.hi >> 31
          , ue = J.lo << 1 ^ ne
          , ce = (J.hi << 1 | J.lo >>> 31) ^ ne;
        return varint64write(ue, ce, this.buf),
        this
    }
    uint64(X) {
        let J = protoInt64.uEnc(X);
        return varint64write(J.lo, J.hi, this.buf),
        this
    }
}
class BinaryReader {
    constructor(X, J=getTextEncoding().decodeUtf8) {
        this.decodeUtf8 = J,
        this.varint64 = varint64read,
        this.uint32 = varint32read,
        this.buf = X,
        this.len = X.length,
        this.pos = 0,
        this.view = new DataView(X.buffer,X.byteOffset,X.byteLength)
    }
    tag() {
        let X = this.uint32()
          , J = X >>> 3
          , ne = X & 7;
        if (J <= 0 || ne < 0 || ne > 5)
            throw new Error("illegal tag: field no " + J + " wire type " + ne);
        return [J, ne]
    }
    skip(X, J) {
        let ne = this.pos;
        switch (X) {
        case WireType.Varint:
            for (; this.buf[this.pos++] & 128; )
                ;
            break;
        case WireType.Bit64:
            this.pos += 4;
        case WireType.Bit32:
            this.pos += 4;
            break;
        case WireType.LengthDelimited:
            let ue = this.uint32();
            this.pos += ue;
            break;
        case WireType.StartGroup:
            for (; ; ) {
                const [ce,me] = this.tag();
                if (me === WireType.EndGroup) {
                    if (J !== void 0 && ce !== J)
                        throw new Error("invalid end group tag");
                    break
                }
                this.skip(me, ce)
            }
            break;
        default:
            throw new Error("cant skip wire type " + X)
        }
        return this.assertBounds(),
        this.buf.subarray(ne, this.pos)
    }
    assertBounds() {
        if (this.pos > this.len)
            throw new RangeError("premature EOF")
    }
    int32() {
        return this.uint32() | 0
    }
    sint32() {
        let X = this.uint32();
        return X >>> 1 ^ -(X & 1)
    }
    int64() {
        return protoInt64.dec(...this.varint64())
    }
    uint64() {
        return protoInt64.uDec(...this.varint64())
    }
    sint64() {
        let[X,J] = this.varint64()
          , ne = -(X & 1);
        return X = (X >>> 1 | (J & 1) << 31) ^ ne,
        J = J >>> 1 ^ ne,
        protoInt64.dec(X, J)
    }
    bool() {
        let[X,J] = this.varint64();
        return X !== 0 || J !== 0
    }
    fixed32() {
        return this.view.getUint32((this.pos += 4) - 4, !0)
    }
    sfixed32() {
        return this.view.getInt32((this.pos += 4) - 4, !0)
    }
    fixed64() {
        return protoInt64.uDec(this.sfixed32(), this.sfixed32())
    }
    sfixed64() {
        return protoInt64.dec(this.sfixed32(), this.sfixed32())
    }
    float() {
        return this.view.getFloat32((this.pos += 4) - 4, !0)
    }
    double() {
        return this.view.getFloat64((this.pos += 8) - 8, !0)
    }
    bytes() {
        let X = this.uint32()
          , J = this.pos;
        return this.pos += X,
        this.assertBounds(),
        this.buf.subarray(J, J + X)
    }
    string() {
        return this.decodeUtf8(this.bytes())
    }
}
function assertInt32(V) {
    if (typeof V == "string")
        V = Number(V);
    else if (typeof V != "number")
        throw new Error("invalid int32: " + typeof V);
    if (!Number.isInteger(V) || V > INT32_MAX || V < INT32_MIN)
        throw new Error("invalid int32: " + V)
}
function assertUInt32(V) {
    if (typeof V == "string")
        V = Number(V);
    else if (typeof V != "number")
        throw new Error("invalid uint32: " + typeof V);
    if (!Number.isInteger(V) || V > UINT32_MAX || V < 0)
        throw new Error("invalid uint32: " + V)
}
function assertFloat32(V) {
    if (typeof V == "string") {
        const X = V;
        if (V = Number(V),
        isNaN(V) && X !== "NaN")
            throw new Error("invalid float32: " + X)
    } else if (typeof V != "number")
        throw new Error("invalid float32: " + typeof V);
    if (Number.isFinite(V) && (V > FLOAT32_MAX || V < FLOAT32_MIN))
        throw new Error("invalid float32: " + V)
}
function createBaseInt32Value() {
    return {
        value: 0
    }
}
const Int32Value = {
    encode(V, X=new BinaryWriter) {
        return V.value !== 0 && X.uint32(8).int32(V.value),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseInt32Value();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 8)
                        break;
                    ue.value = J.int32();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            value: isSet$g(V.value) ? globalThis.Number(V.value) : 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.value !== 0 && (X.value = Math.round(V.value)),
        X
    },
    create(V) {
        return Int32Value.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseInt32Value();
        return X.value = V.value ?? 0,
        X
    }
};
function createBaseStringValue() {
    return {
        value: ""
    }
}
const StringValue = {
    encode(V, X=new BinaryWriter) {
        return V.value !== "" && X.uint32(10).string(V.value),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseStringValue();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.value = J.string();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            value: isSet$g(V.value) ? globalThis.String(V.value) : ""
        }
    },
    toJSON(V) {
        const X = {};
        return V.value !== "" && (X.value = V.value),
        X
    },
    create(V) {
        return StringValue.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseStringValue();
        return X.value = V.value ?? "",
        X
    }
};
function createBaseBytesValue() {
    return {
        value: new Uint8Array(0)
    }
}
const BytesValue = {
    encode(V, X=new BinaryWriter) {
        return V.value.length !== 0 && X.uint32(10).bytes(V.value),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseBytesValue();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.value = J.bytes();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            value: isSet$g(V.value) ? bytesFromBase64$2(V.value) : new Uint8Array(0)
        }
    },
    toJSON(V) {
        const X = {};
        return V.value.length !== 0 && (X.value = base64FromBytes$2(V.value)),
        X
    },
    create(V) {
        return BytesValue.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseBytesValue();
        return X.value = V.value ?? new Uint8Array(0),
        X
    }
};
function bytesFromBase64$2(V) {
    if (globalThis.Buffer)
        return Uint8Array.from(globalThis.Buffer.from(V, "base64"));
    {
        const X = globalThis.atob(V)
          , J = new Uint8Array(X.length);
        for (let ne = 0; ne < X.length; ++ne)
            J[ne] = X.charCodeAt(ne);
        return J
    }
}
function base64FromBytes$2(V) {
    if (globalThis.Buffer)
        return globalThis.Buffer.from(V).toString("base64");
    {
        const X = [];
        return V.forEach(J => {
            X.push(globalThis.String.fromCharCode(J))
        }
        ),
        globalThis.btoa(X.join(""))
    }
}
function isSet$g(V) {
    return V != null
}
var Platform = (V => (V[V.UNKNOWN = 0] = "UNKNOWN",
V[V.PC = 1] = "PC",
V[V.PS4 = 2] = "PS4",
V[V.XBOXONE = 3] = "XBOXONE",
V[V.PS5 = 4] = "PS5",
V[V.XBSX = 5] = "XBSX",
V[V.COMMON = 6] = "COMMON",
V[V.STEAM = 7] = "STEAM",
V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED",
V))(Platform || {});
function platformFromJSON(V) {
    switch (V) {
    case 0:
    case "UNKNOWN":
        return 0;
    case 1:
    case "PC":
        return 1;
    case 2:
    case "PS4":
        return 2;
    case 3:
    case "XBOXONE":
        return 3;
    case 4:
    case "PS5":
        return 4;
    case 5:
    case "XBSX":
        return 5;
    case 6:
    case "COMMON":
        return 6;
    case 7:
    case "STEAM":
        return 7;
    case -1:
    case "UNRECOGNIZED":
    default:
        return -1
    }
}
function platformToJSON(V) {
    switch (V) {
    case 0:
        return "UNKNOWN";
    case 1:
        return "PC";
    case 2:
        return "PS4";
    case 3:
        return "XBOXONE";
    case 4:
        return "PS5";
    case 5:
        return "XBSX";
    case 6:
        return "COMMON";
    case 7:
        return "STEAM";
    case -1:
    default:
        return "UNRECOGNIZED"
    }
}
function createBasePlayer() {
    return {
        nucleusId: 0,
        personaId: 0,
        platform: 0
    }
}
const Player = {
    encode(V, X=new BinaryWriter) {
        return V.nucleusId !== 0 && X.uint32(8).uint64(V.nucleusId),
        V.personaId !== 0 && X.uint32(16).uint64(V.personaId),
        V.platform !== 0 && X.uint32(24).int32(V.platform),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBasePlayer();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 8)
                        break;
                    ue.nucleusId = longToNumber$2(J.uint64());
                    continue
                }
            case 2:
                {
                    if (ce !== 16)
                        break;
                    ue.personaId = longToNumber$2(J.uint64());
                    continue
                }
            case 3:
                {
                    if (ce !== 24)
                        break;
                    ue.platform = J.int32();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            nucleusId: isSet$f(V.nucleusId) ? globalThis.Number(V.nucleusId) : 0,
            personaId: isSet$f(V.personaId) ? globalThis.Number(V.personaId) : 0,
            platform: isSet$f(V.platform) ? platformFromJSON(V.platform) : 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.nucleusId !== 0 && (X.nucleusId = Math.round(V.nucleusId)),
        V.personaId !== 0 && (X.personaId = Math.round(V.personaId)),
        V.platform !== 0 && (X.platform = platformToJSON(V.platform)),
        X
    },
    create(V) {
        return Player.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBasePlayer();
        return X.nucleusId = V.nucleusId ?? 0,
        X.personaId = V.personaId ?? 0,
        X.platform = V.platform ?? 0,
        X
    }
};
function longToNumber$2(V) {
    const X = globalThis.Number(V.toString());
    if (X > globalThis.Number.MAX_SAFE_INTEGER)
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    if (X < globalThis.Number.MIN_SAFE_INTEGER)
        throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
    return X
}
function isSet$f(V) {
    return V != null
}
function mutatorBehaviourFromJSON(V) {
    switch (V) {
    case 0:
    case "OVERRIDE":
        return 0;
    case 1:
    case "MULTIPLIER":
        return 1;
    case 2:
    case "PERCENTAGE":
        return 2;
    case -1:
    case "UNRECOGNIZED":
    default:
        return -1
    }
}
function mutatorBehaviourToJSON(V) {
    switch (V) {
    case 0:
        return "OVERRIDE";
    case 1:
        return "MULTIPLIER";
    case 2:
        return "PERCENTAGE";
    case -1:
    default:
        return "UNRECOGNIZED"
    }
}
var TeamBalancingMethod = (V => (V[V.UNSPECIFIED = 0] = "UNSPECIFIED",
V[V.EVEN_NUMBERS = 1] = "EVEN_NUMBERS",
V[V.EVEN_PERCENTAGE = 2] = "EVEN_PERCENTAGE",
V[V.FILL_IN_TEAM_ORDER = 3] = "FILL_IN_TEAM_ORDER",
V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED",
V))(TeamBalancingMethod || {});
function teamBalancingMethodFromJSON(V) {
    switch (V) {
    case 0:
    case "UNSPECIFIED":
        return 0;
    case 1:
    case "EVEN_NUMBERS":
        return 1;
    case 2:
    case "EVEN_PERCENTAGE":
        return 2;
    case 3:
    case "FILL_IN_TEAM_ORDER":
        return 3;
    case -1:
    case "UNRECOGNIZED":
    default:
        return -1
    }
}
function teamBalancingMethodToJSON(V) {
    switch (V) {
    case 0:
        return "UNSPECIFIED";
    case 1:
        return "EVEN_NUMBERS";
    case 2:
        return "EVEN_PERCENTAGE";
    case 3:
        return "FILL_IN_TEAM_ORDER";
    case -1:
    default:
        return "UNRECOGNIZED"
    }
}
var InternalCapacityType = (V => (V[V.AI_BACKFILL = 0] = "AI_BACKFILL",
V[V.AI_STATIC = 1] = "AI_STATIC",
V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED",
V))(InternalCapacityType || {});
function internalCapacityTypeFromJSON(V) {
    switch (V) {
    case 0:
    case "AI_BACKFILL":
        return 0;
    case 1:
    case "AI_STATIC":
        return 1;
    case -1:
    case "UNRECOGNIZED":
    default:
        return -1
    }
}
function internalCapacityTypeToJSON(V) {
    switch (V) {
    case 0:
        return "AI_BACKFILL";
    case 1:
        return "AI_STATIC";
    case -1:
    default:
        return "UNRECOGNIZED"
    }
}
function createBaseMutatorBoolean$1() {
    return {
        value: !1
    }
}
const MutatorBoolean$1 = {
    encode(V, X=new BinaryWriter) {
        return V.value !== !1 && X.uint32(8).bool(V.value),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseMutatorBoolean$1();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 8)
                        break;
                    ue.value = J.bool();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            value: isSet$e(V.value) ? globalThis.Boolean(V.value) : !1
        }
    },
    toJSON(V) {
        const X = {};
        return V.value !== !1 && (X.value = V.value),
        X
    },
    create(V) {
        return MutatorBoolean$1.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseMutatorBoolean$1();
        return X.value = V.value ?? !1,
        X
    }
};
function createBaseMutatorInt$1() {
    return {
        value: 0,
        behaviour: 0
    }
}
const MutatorInt$1 = {
    encode(V, X=new BinaryWriter) {
        return V.value !== 0 && X.uint32(8).int32(V.value),
        V.behaviour !== 0 && X.uint32(16).int32(V.behaviour),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseMutatorInt$1();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 8)
                        break;
                    ue.value = J.int32();
                    continue
                }
            case 2:
                {
                    if (ce !== 16)
                        break;
                    ue.behaviour = J.int32();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            value: isSet$e(V.value) ? globalThis.Number(V.value) : 0,
            behaviour: isSet$e(V.behaviour) ? mutatorBehaviourFromJSON(V.behaviour) : 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.value !== 0 && (X.value = Math.round(V.value)),
        V.behaviour !== 0 && (X.behaviour = mutatorBehaviourToJSON(V.behaviour)),
        X
    },
    create(V) {
        return MutatorInt$1.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseMutatorInt$1();
        return X.value = V.value ?? 0,
        X.behaviour = V.behaviour ?? 0,
        X
    }
};
function createBaseMutatorFloat$1() {
    return {
        value: 0,
        behaviour: 0
    }
}
const MutatorFloat$1 = {
    encode(V, X=new BinaryWriter) {
        return V.value !== 0 && X.uint32(13).float(V.value),
        V.behaviour !== 0 && X.uint32(16).int32(V.behaviour),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseMutatorFloat$1();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 13)
                        break;
                    ue.value = J.float();
                    continue
                }
            case 2:
                {
                    if (ce !== 16)
                        break;
                    ue.behaviour = J.int32();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            value: isSet$e(V.value) ? globalThis.Number(V.value) : 0,
            behaviour: isSet$e(V.behaviour) ? mutatorBehaviourFromJSON(V.behaviour) : 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.value !== 0 && (X.value = V.value),
        V.behaviour !== 0 && (X.behaviour = mutatorBehaviourToJSON(V.behaviour)),
        X
    },
    create(V) {
        return MutatorFloat$1.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseMutatorFloat$1();
        return X.value = V.value ?? 0,
        X.behaviour = V.behaviour ?? 0,
        X
    }
};
function createBaseMutatorSparseBooleanEntry$1() {
    return {
        index: 0,
        value: !1
    }
}
const MutatorSparseBooleanEntry$1 = {
    encode(V, X=new BinaryWriter) {
        return V.index !== 0 && X.uint32(8).uint32(V.index),
        V.value !== !1 && X.uint32(16).bool(V.value),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseMutatorSparseBooleanEntry$1();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 8)
                        break;
                    ue.index = J.uint32();
                    continue
                }
            case 2:
                {
                    if (ce !== 16)
                        break;
                    ue.value = J.bool();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            index: isSet$e(V.index) ? globalThis.Number(V.index) : 0,
            value: isSet$e(V.value) ? globalThis.Boolean(V.value) : !1
        }
    },
    toJSON(V) {
        const X = {};
        return V.index !== 0 && (X.index = Math.round(V.index)),
        V.value !== !1 && (X.value = V.value),
        X
    },
    create(V) {
        return MutatorSparseBooleanEntry$1.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseMutatorSparseBooleanEntry$1();
        return X.index = V.index ?? 0,
        X.value = V.value ?? !1,
        X
    }
};
function createBaseMutatorSparseIntEntry$1() {
    return {
        index: 0,
        value: 0
    }
}
const MutatorSparseIntEntry$1 = {
    encode(V, X=new BinaryWriter) {
        return V.index !== 0 && X.uint32(8).uint32(V.index),
        V.value !== 0 && X.uint32(16).int32(V.value),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseMutatorSparseIntEntry$1();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 8)
                        break;
                    ue.index = J.uint32();
                    continue
                }
            case 2:
                {
                    if (ce !== 16)
                        break;
                    ue.value = J.int32();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            index: isSet$e(V.index) ? globalThis.Number(V.index) : 0,
            value: isSet$e(V.value) ? globalThis.Number(V.value) : 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.index !== 0 && (X.index = Math.round(V.index)),
        V.value !== 0 && (X.value = Math.round(V.value)),
        X
    },
    create(V) {
        return MutatorSparseIntEntry$1.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseMutatorSparseIntEntry$1();
        return X.index = V.index ?? 0,
        X.value = V.value ?? 0,
        X
    }
};
function createBaseMutatorSparseFloatEntry$1() {
    return {
        index: 0,
        value: 0
    }
}
const MutatorSparseFloatEntry$1 = {
    encode(V, X=new BinaryWriter) {
        return V.index !== 0 && X.uint32(8).uint32(V.index),
        V.value !== 0 && X.uint32(21).float(V.value),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseMutatorSparseFloatEntry$1();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 8)
                        break;
                    ue.index = J.uint32();
                    continue
                }
            case 2:
                {
                    if (ce !== 21)
                        break;
                    ue.value = J.float();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            index: isSet$e(V.index) ? globalThis.Number(V.index) : 0,
            value: isSet$e(V.value) ? globalThis.Number(V.value) : 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.index !== 0 && (X.index = Math.round(V.index)),
        V.value !== 0 && (X.value = V.value),
        X
    },
    create(V) {
        return MutatorSparseFloatEntry$1.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseMutatorSparseFloatEntry$1();
        return X.index = V.index ?? 0,
        X.value = V.value ?? 0,
        X
    }
};
function createBaseMutatorSparseBoolean$1() {
    return {
        defaultValue: !1,
        size: 0,
        sparseValues: []
    }
}
const MutatorSparseBoolean$1 = {
    encode(V, X=new BinaryWriter) {
        V.defaultValue !== !1 && X.uint32(8).bool(V.defaultValue),
        V.size !== 0 && X.uint32(16).uint32(V.size);
        for (const J of V.sparseValues)
            MutatorSparseBooleanEntry$1.encode(J, X.uint32(26).fork()).join();
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseMutatorSparseBoolean$1();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 8)
                        break;
                    ue.defaultValue = J.bool();
                    continue
                }
            case 2:
                {
                    if (ce !== 16)
                        break;
                    ue.size = J.uint32();
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.sparseValues.push(MutatorSparseBooleanEntry$1.decode(J, J.uint32()));
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            defaultValue: isSet$e(V.defaultValue) ? globalThis.Boolean(V.defaultValue) : !1,
            size: isSet$e(V.size) ? globalThis.Number(V.size) : 0,
            sparseValues: globalThis.Array.isArray(V == null ? void 0 : V.sparseValues) ? V.sparseValues.map(X => MutatorSparseBooleanEntry$1.fromJSON(X)) : []
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return V.defaultValue !== !1 && (X.defaultValue = V.defaultValue),
        V.size !== 0 && (X.size = Math.round(V.size)),
        (J = V.sparseValues) != null && J.length && (X.sparseValues = V.sparseValues.map(ne => MutatorSparseBooleanEntry$1.toJSON(ne))),
        X
    },
    create(V) {
        return MutatorSparseBoolean$1.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseMutatorSparseBoolean$1();
        return X.defaultValue = V.defaultValue ?? !1,
        X.size = V.size ?? 0,
        X.sparseValues = ((J = V.sparseValues) == null ? void 0 : J.map(ne => MutatorSparseBooleanEntry$1.fromPartial(ne))) || [],
        X
    }
};
function createBaseMutatorSparseInt$1() {
    return {
        defaultValue: 0,
        size: 0,
        sparseValues: []
    }
}
const MutatorSparseInt$1 = {
    encode(V, X=new BinaryWriter) {
        V.defaultValue !== 0 && X.uint32(8).int32(V.defaultValue),
        V.size !== 0 && X.uint32(16).uint32(V.size);
        for (const J of V.sparseValues)
            MutatorSparseIntEntry$1.encode(J, X.uint32(26).fork()).join();
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseMutatorSparseInt$1();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 8)
                        break;
                    ue.defaultValue = J.int32();
                    continue
                }
            case 2:
                {
                    if (ce !== 16)
                        break;
                    ue.size = J.uint32();
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.sparseValues.push(MutatorSparseIntEntry$1.decode(J, J.uint32()));
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            defaultValue: isSet$e(V.defaultValue) ? globalThis.Number(V.defaultValue) : 0,
            size: isSet$e(V.size) ? globalThis.Number(V.size) : 0,
            sparseValues: globalThis.Array.isArray(V == null ? void 0 : V.sparseValues) ? V.sparseValues.map(X => MutatorSparseIntEntry$1.fromJSON(X)) : []
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return V.defaultValue !== 0 && (X.defaultValue = Math.round(V.defaultValue)),
        V.size !== 0 && (X.size = Math.round(V.size)),
        (J = V.sparseValues) != null && J.length && (X.sparseValues = V.sparseValues.map(ne => MutatorSparseIntEntry$1.toJSON(ne))),
        X
    },
    create(V) {
        return MutatorSparseInt$1.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseMutatorSparseInt$1();
        return X.defaultValue = V.defaultValue ?? 0,
        X.size = V.size ?? 0,
        X.sparseValues = ((J = V.sparseValues) == null ? void 0 : J.map(ne => MutatorSparseIntEntry$1.fromPartial(ne))) || [],
        X
    }
};
function createBaseMutatorSparseFloat$1() {
    return {
        defaultValue: 0,
        size: 0,
        sparseValues: []
    }
}
const MutatorSparseFloat$1 = {
    encode(V, X=new BinaryWriter) {
        V.defaultValue !== 0 && X.uint32(13).float(V.defaultValue),
        V.size !== 0 && X.uint32(16).uint32(V.size);
        for (const J of V.sparseValues)
            MutatorSparseFloatEntry$1.encode(J, X.uint32(26).fork()).join();
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseMutatorSparseFloat$1();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 13)
                        break;
                    ue.defaultValue = J.float();
                    continue
                }
            case 2:
                {
                    if (ce !== 16)
                        break;
                    ue.size = J.uint32();
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.sparseValues.push(MutatorSparseFloatEntry$1.decode(J, J.uint32()));
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            defaultValue: isSet$e(V.defaultValue) ? globalThis.Number(V.defaultValue) : 0,
            size: isSet$e(V.size) ? globalThis.Number(V.size) : 0,
            sparseValues: globalThis.Array.isArray(V == null ? void 0 : V.sparseValues) ? V.sparseValues.map(X => MutatorSparseFloatEntry$1.fromJSON(X)) : []
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return V.defaultValue !== 0 && (X.defaultValue = V.defaultValue),
        V.size !== 0 && (X.size = Math.round(V.size)),
        (J = V.sparseValues) != null && J.length && (X.sparseValues = V.sparseValues.map(ne => MutatorSparseFloatEntry$1.toJSON(ne))),
        X
    },
    create(V) {
        return MutatorSparseFloat$1.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseMutatorSparseFloat$1();
        return X.defaultValue = V.defaultValue ?? 0,
        X.size = V.size ?? 0,
        X.sparseValues = ((J = V.sparseValues) == null ? void 0 : J.map(ne => MutatorSparseFloatEntry$1.fromPartial(ne))) || [],
        X
    }
};
function createBaseMutatorString$1() {
    return {
        value: ""
    }
}
const MutatorString$1 = {
    encode(V, X=new BinaryWriter) {
        return V.value !== "" && X.uint32(10).string(V.value),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseMutatorString$1();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.value = J.string();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            value: isSet$e(V.value) ? globalThis.String(V.value) : ""
        }
    },
    toJSON(V) {
        const X = {};
        return V.value !== "" && (X.value = V.value),
        X
    },
    create(V) {
        return MutatorString$1.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseMutatorString$1();
        return X.value = V.value ?? "",
        X
    }
};
function createBaseMutatorKind() {
    return {
        mutatorBoolean: void 0,
        mutatorString: void 0,
        mutatorFloat: void 0,
        mutatorInt: void 0,
        mutatorSparseBoolean: void 0,
        mutatorSparseInt: void 0,
        mutatorSparseFloat: void 0
    }
}
const MutatorKind = {
    encode(V, X=new BinaryWriter) {
        return V.mutatorBoolean !== void 0 && MutatorBoolean$1.encode(V.mutatorBoolean, X.uint32(10).fork()).join(),
        V.mutatorString !== void 0 && MutatorString$1.encode(V.mutatorString, X.uint32(34).fork()).join(),
        V.mutatorFloat !== void 0 && MutatorFloat$1.encode(V.mutatorFloat, X.uint32(42).fork()).join(),
        V.mutatorInt !== void 0 && MutatorInt$1.encode(V.mutatorInt, X.uint32(50).fork()).join(),
        V.mutatorSparseBoolean !== void 0 && MutatorSparseBoolean$1.encode(V.mutatorSparseBoolean, X.uint32(58).fork()).join(),
        V.mutatorSparseInt !== void 0 && MutatorSparseInt$1.encode(V.mutatorSparseInt, X.uint32(66).fork()).join(),
        V.mutatorSparseFloat !== void 0 && MutatorSparseFloat$1.encode(V.mutatorSparseFloat, X.uint32(74).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseMutatorKind();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.mutatorBoolean = MutatorBoolean$1.decode(J, J.uint32());
                    continue
                }
            case 4:
                {
                    if (ce !== 34)
                        break;
                    ue.mutatorString = MutatorString$1.decode(J, J.uint32());
                    continue
                }
            case 5:
                {
                    if (ce !== 42)
                        break;
                    ue.mutatorFloat = MutatorFloat$1.decode(J, J.uint32());
                    continue
                }
            case 6:
                {
                    if (ce !== 50)
                        break;
                    ue.mutatorInt = MutatorInt$1.decode(J, J.uint32());
                    continue
                }
            case 7:
                {
                    if (ce !== 58)
                        break;
                    ue.mutatorSparseBoolean = MutatorSparseBoolean$1.decode(J, J.uint32());
                    continue
                }
            case 8:
                {
                    if (ce !== 66)
                        break;
                    ue.mutatorSparseInt = MutatorSparseInt$1.decode(J, J.uint32());
                    continue
                }
            case 9:
                {
                    if (ce !== 74)
                        break;
                    ue.mutatorSparseFloat = MutatorSparseFloat$1.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            mutatorBoolean: isSet$e(V.mutatorBoolean) ? MutatorBoolean$1.fromJSON(V.mutatorBoolean) : void 0,
            mutatorString: isSet$e(V.mutatorString) ? MutatorString$1.fromJSON(V.mutatorString) : void 0,
            mutatorFloat: isSet$e(V.mutatorFloat) ? MutatorFloat$1.fromJSON(V.mutatorFloat) : void 0,
            mutatorInt: isSet$e(V.mutatorInt) ? MutatorInt$1.fromJSON(V.mutatorInt) : void 0,
            mutatorSparseBoolean: isSet$e(V.mutatorSparseBoolean) ? MutatorSparseBoolean$1.fromJSON(V.mutatorSparseBoolean) : void 0,
            mutatorSparseInt: isSet$e(V.mutatorSparseInt) ? MutatorSparseInt$1.fromJSON(V.mutatorSparseInt) : void 0,
            mutatorSparseFloat: isSet$e(V.mutatorSparseFloat) ? MutatorSparseFloat$1.fromJSON(V.mutatorSparseFloat) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.mutatorBoolean !== void 0 && (X.mutatorBoolean = MutatorBoolean$1.toJSON(V.mutatorBoolean)),
        V.mutatorString !== void 0 && (X.mutatorString = MutatorString$1.toJSON(V.mutatorString)),
        V.mutatorFloat !== void 0 && (X.mutatorFloat = MutatorFloat$1.toJSON(V.mutatorFloat)),
        V.mutatorInt !== void 0 && (X.mutatorInt = MutatorInt$1.toJSON(V.mutatorInt)),
        V.mutatorSparseBoolean !== void 0 && (X.mutatorSparseBoolean = MutatorSparseBoolean$1.toJSON(V.mutatorSparseBoolean)),
        V.mutatorSparseInt !== void 0 && (X.mutatorSparseInt = MutatorSparseInt$1.toJSON(V.mutatorSparseInt)),
        V.mutatorSparseFloat !== void 0 && (X.mutatorSparseFloat = MutatorSparseFloat$1.toJSON(V.mutatorSparseFloat)),
        X
    },
    create(V) {
        return MutatorKind.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseMutatorKind();
        return X.mutatorBoolean = V.mutatorBoolean !== void 0 && V.mutatorBoolean !== null ? MutatorBoolean$1.fromPartial(V.mutatorBoolean) : void 0,
        X.mutatorString = V.mutatorString !== void 0 && V.mutatorString !== null ? MutatorString$1.fromPartial(V.mutatorString) : void 0,
        X.mutatorFloat = V.mutatorFloat !== void 0 && V.mutatorFloat !== null ? MutatorFloat$1.fromPartial(V.mutatorFloat) : void 0,
        X.mutatorInt = V.mutatorInt !== void 0 && V.mutatorInt !== null ? MutatorInt$1.fromPartial(V.mutatorInt) : void 0,
        X.mutatorSparseBoolean = V.mutatorSparseBoolean !== void 0 && V.mutatorSparseBoolean !== null ? MutatorSparseBoolean$1.fromPartial(V.mutatorSparseBoolean) : void 0,
        X.mutatorSparseInt = V.mutatorSparseInt !== void 0 && V.mutatorSparseInt !== null ? MutatorSparseInt$1.fromPartial(V.mutatorSparseInt) : void 0,
        X.mutatorSparseFloat = V.mutatorSparseFloat !== void 0 && V.mutatorSparseFloat !== null ? MutatorSparseFloat$1.fromPartial(V.mutatorSparseFloat) : void 0,
        X
    }
};
function createBaseMutator() {
    return {
        name: "",
        category: "",
        kind: void 0,
        id: ""
    }
}
const Mutator = {
    encode(V, X=new BinaryWriter) {
        return V.name !== "" && X.uint32(10).string(V.name),
        V.category !== "" && X.uint32(18).string(V.category),
        V.kind !== void 0 && MutatorKind.encode(V.kind, X.uint32(26).fork()).join(),
        V.id !== "" && X.uint32(34).string(V.id),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseMutator();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.name = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.category = J.string();
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.kind = MutatorKind.decode(J, J.uint32());
                    continue
                }
            case 4:
                {
                    if (ce !== 34)
                        break;
                    ue.id = J.string();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            name: isSet$e(V.name) ? globalThis.String(V.name) : "",
            category: isSet$e(V.category) ? globalThis.String(V.category) : "",
            kind: isSet$e(V.kind) ? MutatorKind.fromJSON(V.kind) : void 0,
            id: isSet$e(V.id) ? globalThis.String(V.id) : ""
        }
    },
    toJSON(V) {
        const X = {};
        return V.name !== "" && (X.name = V.name),
        V.category !== "" && (X.category = V.category),
        V.kind !== void 0 && (X.kind = MutatorKind.toJSON(V.kind)),
        V.id !== "" && (X.id = V.id),
        X
    },
    create(V) {
        return Mutator.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseMutator();
        return X.name = V.name ?? "",
        X.category = V.category ?? "",
        X.kind = V.kind !== void 0 && V.kind !== null ? MutatorKind.fromPartial(V.kind) : void 0,
        X.id = V.id ?? "",
        X
    }
};
function createBaseAssetCategoryTagBooleanOverride() {
    return {
        assetCategoryTags: [],
        value: !1
    }
}
const AssetCategoryTagBooleanOverride = {
    encode(V, X=new BinaryWriter) {
        for (const J of V.assetCategoryTags)
            X.uint32(10).string(J);
        return V.value !== !1 && X.uint32(16).bool(V.value),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseAssetCategoryTagBooleanOverride();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.assetCategoryTags.push(J.string());
                    continue
                }
            case 2:
                {
                    if (ce !== 16)
                        break;
                    ue.value = J.bool();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            assetCategoryTags: globalThis.Array.isArray(V == null ? void 0 : V.assetCategoryTags) ? V.assetCategoryTags.map(X => globalThis.String(X)) : [],
            value: isSet$e(V.value) ? globalThis.Boolean(V.value) : !1
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return (J = V.assetCategoryTags) != null && J.length && (X.assetCategoryTags = V.assetCategoryTags),
        V.value !== !1 && (X.value = V.value),
        X
    },
    create(V) {
        return AssetCategoryTagBooleanOverride.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseAssetCategoryTagBooleanOverride();
        return X.assetCategoryTags = ((J = V.assetCategoryTags) == null ? void 0 : J.map(ne => ne)) || [],
        X.value = V.value ?? !1,
        X
    }
};
function createBaseAssetCategoryTagBooleanTeamOverride() {
    return {
        assetCategoryTags: [],
        value: !1,
        teamId: 0
    }
}
const AssetCategoryTagBooleanTeamOverride = {
    encode(V, X=new BinaryWriter) {
        for (const J of V.assetCategoryTags)
            X.uint32(10).string(J);
        return V.value !== !1 && X.uint32(16).bool(V.value),
        V.teamId !== 0 && X.uint32(24).uint32(V.teamId),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseAssetCategoryTagBooleanTeamOverride();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.assetCategoryTags.push(J.string());
                    continue
                }
            case 2:
                {
                    if (ce !== 16)
                        break;
                    ue.value = J.bool();
                    continue
                }
            case 3:
                {
                    if (ce !== 24)
                        break;
                    ue.teamId = J.uint32();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            assetCategoryTags: globalThis.Array.isArray(V == null ? void 0 : V.assetCategoryTags) ? V.assetCategoryTags.map(X => globalThis.String(X)) : [],
            value: isSet$e(V.value) ? globalThis.Boolean(V.value) : !1,
            teamId: isSet$e(V.teamId) ? globalThis.Number(V.teamId) : 0
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return (J = V.assetCategoryTags) != null && J.length && (X.assetCategoryTags = V.assetCategoryTags),
        V.value !== !1 && (X.value = V.value),
        V.teamId !== 0 && (X.teamId = Math.round(V.teamId)),
        X
    },
    create(V) {
        return AssetCategoryTagBooleanTeamOverride.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseAssetCategoryTagBooleanTeamOverride();
        return X.assetCategoryTags = ((J = V.assetCategoryTags) == null ? void 0 : J.map(ne => ne)) || [],
        X.value = V.value ?? !1,
        X.teamId = V.teamId ?? 0,
        X
    }
};
function createBaseAssetCategoryBoolean() {
    return {
        defaultValue: !1,
        overrides: void 0,
        teamOverrides: []
    }
}
const AssetCategoryBoolean = {
    encode(V, X=new BinaryWriter) {
        V.defaultValue !== !1 && X.uint32(8).bool(V.defaultValue),
        V.overrides !== void 0 && AssetCategoryTagBooleanOverride.encode(V.overrides, X.uint32(18).fork()).join();
        for (const J of V.teamOverrides)
            AssetCategoryTagBooleanTeamOverride.encode(J, X.uint32(26).fork()).join();
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseAssetCategoryBoolean();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 8)
                        break;
                    ue.defaultValue = J.bool();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.overrides = AssetCategoryTagBooleanOverride.decode(J, J.uint32());
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.teamOverrides.push(AssetCategoryTagBooleanTeamOverride.decode(J, J.uint32()));
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            defaultValue: isSet$e(V.defaultValue) ? globalThis.Boolean(V.defaultValue) : !1,
            overrides: isSet$e(V.overrides) ? AssetCategoryTagBooleanOverride.fromJSON(V.overrides) : void 0,
            teamOverrides: globalThis.Array.isArray(V == null ? void 0 : V.teamOverrides) ? V.teamOverrides.map(X => AssetCategoryTagBooleanTeamOverride.fromJSON(X)) : []
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return V.defaultValue !== !1 && (X.defaultValue = V.defaultValue),
        V.overrides !== void 0 && (X.overrides = AssetCategoryTagBooleanOverride.toJSON(V.overrides)),
        (J = V.teamOverrides) != null && J.length && (X.teamOverrides = V.teamOverrides.map(ne => AssetCategoryTagBooleanTeamOverride.toJSON(ne))),
        X
    },
    create(V) {
        return AssetCategoryBoolean.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseAssetCategoryBoolean();
        return X.defaultValue = V.defaultValue ?? !1,
        X.overrides = V.overrides !== void 0 && V.overrides !== null ? AssetCategoryTagBooleanOverride.fromPartial(V.overrides) : void 0,
        X.teamOverrides = ((J = V.teamOverrides) == null ? void 0 : J.map(ne => AssetCategoryTagBooleanTeamOverride.fromPartial(ne))) || [],
        X
    }
};
function createBaseAssetCategory() {
    return {
        tagId: "",
        boolean: void 0
    }
}
const AssetCategory = {
    encode(V, X=new BinaryWriter) {
        return V.tagId !== "" && X.uint32(10).string(V.tagId),
        V.boolean !== void 0 && AssetCategoryBoolean.encode(V.boolean, X.uint32(18).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseAssetCategory();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.tagId = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.boolean = AssetCategoryBoolean.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            tagId: isSet$e(V.tagId) ? globalThis.String(V.tagId) : "",
            boolean: isSet$e(V.boolean) ? AssetCategoryBoolean.fromJSON(V.boolean) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.tagId !== "" && (X.tagId = V.tagId),
        V.boolean !== void 0 && (X.boolean = AssetCategoryBoolean.toJSON(V.boolean)),
        X
    },
    create(V) {
        return AssetCategory.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseAssetCategory();
        return X.tagId = V.tagId ?? "",
        X.boolean = V.boolean !== void 0 && V.boolean !== null ? AssetCategoryBoolean.fromPartial(V.boolean) : void 0,
        X
    }
};
function createBaseTeamStructure() {
    return {
        teamId: 0,
        capacity: 0
    }
}
const TeamStructure = {
    encode(V, X=new BinaryWriter) {
        return V.teamId !== 0 && X.uint32(8).int32(V.teamId),
        V.capacity !== 0 && X.uint32(16).int32(V.capacity),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseTeamStructure();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 8)
                        break;
                    ue.teamId = J.int32();
                    continue
                }
            case 2:
                {
                    if (ce !== 16)
                        break;
                    ue.capacity = J.int32();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            teamId: isSet$e(V.teamId) ? globalThis.Number(V.teamId) : 0,
            capacity: isSet$e(V.capacity) ? globalThis.Number(V.capacity) : 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.teamId !== 0 && (X.teamId = Math.round(V.teamId)),
        V.capacity !== 0 && (X.capacity = Math.round(V.capacity)),
        X
    },
    create(V) {
        return TeamStructure.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseTeamStructure();
        return X.teamId = V.teamId ?? 0,
        X.capacity = V.capacity ?? 0,
        X
    }
};
function createBaseInternalTeamStructure() {
    return {
        teamId: 0,
        capacity: 0,
        capacityType: 0
    }
}
const InternalTeamStructure = {
    encode(V, X=new BinaryWriter) {
        return V.teamId !== 0 && X.uint32(8).int32(V.teamId),
        V.capacity !== 0 && X.uint32(16).int32(V.capacity),
        V.capacityType !== 0 && X.uint32(24).int32(V.capacityType),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseInternalTeamStructure();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 8)
                        break;
                    ue.teamId = J.int32();
                    continue
                }
            case 2:
                {
                    if (ce !== 16)
                        break;
                    ue.capacity = J.int32();
                    continue
                }
            case 3:
                {
                    if (ce !== 24)
                        break;
                    ue.capacityType = J.int32();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            teamId: isSet$e(V.teamId) ? globalThis.Number(V.teamId) : 0,
            capacity: isSet$e(V.capacity) ? globalThis.Number(V.capacity) : 0,
            capacityType: isSet$e(V.capacityType) ? internalCapacityTypeFromJSON(V.capacityType) : 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.teamId !== 0 && (X.teamId = Math.round(V.teamId)),
        V.capacity !== 0 && (X.capacity = Math.round(V.capacity)),
        V.capacityType !== 0 && (X.capacityType = internalCapacityTypeToJSON(V.capacityType)),
        X
    },
    create(V) {
        return InternalTeamStructure.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseInternalTeamStructure();
        return X.teamId = V.teamId ?? 0,
        X.capacity = V.capacity ?? 0,
        X.capacityType = V.capacityType ?? 0,
        X
    }
};
function createBaseTeamComposition() {
    return {
        teams: [],
        internalTeams: [],
        balancingMethod: 0
    }
}
const TeamComposition = {
    encode(V, X=new BinaryWriter) {
        for (const J of V.teams)
            TeamStructure.encode(J, X.uint32(10).fork()).join();
        for (const J of V.internalTeams)
            InternalTeamStructure.encode(J, X.uint32(18).fork()).join();
        return V.balancingMethod !== 0 && X.uint32(24).int32(V.balancingMethod),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseTeamComposition();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.teams.push(TeamStructure.decode(J, J.uint32()));
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.internalTeams.push(InternalTeamStructure.decode(J, J.uint32()));
                    continue
                }
            case 3:
                {
                    if (ce !== 24)
                        break;
                    ue.balancingMethod = J.int32();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            teams: globalThis.Array.isArray(V == null ? void 0 : V.teams) ? V.teams.map(X => TeamStructure.fromJSON(X)) : [],
            internalTeams: globalThis.Array.isArray(V == null ? void 0 : V.internalTeams) ? V.internalTeams.map(X => InternalTeamStructure.fromJSON(X)) : [],
            balancingMethod: isSet$e(V.balancingMethod) ? teamBalancingMethodFromJSON(V.balancingMethod) : 0
        }
    },
    toJSON(V) {
        var J, ne;
        const X = {};
        return (J = V.teams) != null && J.length && (X.teams = V.teams.map(ue => TeamStructure.toJSON(ue))),
        (ne = V.internalTeams) != null && ne.length && (X.internalTeams = V.internalTeams.map(ue => InternalTeamStructure.toJSON(ue))),
        V.balancingMethod !== 0 && (X.balancingMethod = teamBalancingMethodToJSON(V.balancingMethod)),
        X
    },
    create(V) {
        return TeamComposition.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J, ne;
        const X = createBaseTeamComposition();
        return X.teams = ((J = V.teams) == null ? void 0 : J.map(ue => TeamStructure.fromPartial(ue))) || [],
        X.internalTeams = ((ne = V.internalTeams) == null ? void 0 : ne.map(ue => InternalTeamStructure.fromPartial(ue))) || [],
        X.balancingMethod = V.balancingMethod ?? 0,
        X
    }
};
function isSet$e(V) {
    return V != null
}
function createBaseDuration() {
    return {
        seconds: 0,
        nanos: 0
    }
}
const Duration = {
    encode(V, X=new BinaryWriter) {
        return V.seconds !== 0 && X.uint32(8).int64(V.seconds),
        V.nanos !== 0 && X.uint32(16).int32(V.nanos),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseDuration();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 8)
                        break;
                    ue.seconds = longToNumber$1(J.int64());
                    continue
                }
            case 2:
                {
                    if (ce !== 16)
                        break;
                    ue.nanos = J.int32();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            seconds: isSet$d(V.seconds) ? globalThis.Number(V.seconds) : 0,
            nanos: isSet$d(V.nanos) ? globalThis.Number(V.nanos) : 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.seconds !== 0 && (X.seconds = Math.round(V.seconds)),
        V.nanos !== 0 && (X.nanos = Math.round(V.nanos)),
        X
    },
    create(V) {
        return Duration.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseDuration();
        return X.seconds = V.seconds ?? 0,
        X.nanos = V.nanos ?? 0,
        X
    }
};
function longToNumber$1(V) {
    const X = globalThis.Number(V.toString());
    if (X > globalThis.Number.MAX_SAFE_INTEGER)
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    if (X < globalThis.Number.MIN_SAFE_INTEGER)
        throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
    return X
}
function isSet$d(V) {
    return V != null
}
function createBaseEmpty() {
    return {}
}
const Empty = {
    encode(V, X=new BinaryWriter) {
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseEmpty();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {}
    },
    toJSON(V) {
        return {}
    },
    create(V) {
        return Empty.fromPartial(V ?? {})
    },
    fromPartial(V) {
        return createBaseEmpty()
    }
};
function createBaseTimestamp() {
    return {
        seconds: 0,
        nanos: 0
    }
}
const Timestamp = {
    encode(V, X=new BinaryWriter) {
        return V.seconds !== 0 && X.uint32(8).int64(V.seconds),
        V.nanos !== 0 && X.uint32(16).int32(V.nanos),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseTimestamp();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 8)
                        break;
                    ue.seconds = longToNumber(J.int64());
                    continue
                }
            case 2:
                {
                    if (ce !== 16)
                        break;
                    ue.nanos = J.int32();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            seconds: isSet$c(V.seconds) ? globalThis.Number(V.seconds) : 0,
            nanos: isSet$c(V.nanos) ? globalThis.Number(V.nanos) : 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.seconds !== 0 && (X.seconds = Math.round(V.seconds)),
        V.nanos !== 0 && (X.nanos = Math.round(V.nanos)),
        X
    },
    create(V) {
        return Timestamp.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseTimestamp();
        return X.seconds = V.seconds ?? 0,
        X.nanos = V.nanos ?? 0,
        X
    }
};
function longToNumber(V) {
    const X = globalThis.Number(V.toString());
    if (X > globalThis.Number.MAX_SAFE_INTEGER)
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    if (X < globalThis.Number.MIN_SAFE_INTEGER)
        throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
    return X
}
function isSet$c(V) {
    return V != null
}
function createBaseResourceLocation() {
    return {
        ref: void 0,
        url: void 0
    }
}
const ResourceLocation = {
    encode(V, X=new BinaryWriter) {
        return V.ref !== void 0 && X.uint32(10).string(V.ref),
        V.url !== void 0 && X.uint32(18).string(V.url),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseResourceLocation();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.ref = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.url = J.string();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            ref: isSet$b(V.ref) ? globalThis.String(V.ref) : void 0,
            url: isSet$b(V.url) ? globalThis.String(V.url) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.ref !== void 0 && (X.ref = V.ref),
        V.url !== void 0 && (X.url = V.url),
        X
    },
    create(V) {
        return ResourceLocation.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseResourceLocation();
        return X.ref = V.ref ?? void 0,
        X.url = V.url ?? void 0,
        X
    }
};
function isSet$b(V) {
    return V != null
}
function attachmentCompileStatusFromJSON(V) {
    switch (V) {
    case 0:
    case "ATTACHMENT_COMPILE_STATUS_UNSPECIFIED":
        return 0;
    case 1:
    case "ATTACHMENT_COMPILE_STATUS_OK":
        return 1;
    case 2:
    case "ATTACHMENT_COMPILE_STATUS_ERROR":
        return 2;
    case 3:
    case "ATTACHMENT_COMPILE_STATUS_INCOMPATIBLE_VERSION":
        return 3;
    case -1:
    case "UNRECOGNIZED":
    default:
        return -1
    }
}
function attachmentCompileStatusToJSON(V) {
    switch (V) {
    case 0:
        return "ATTACHMENT_COMPILE_STATUS_UNSPECIFIED";
    case 1:
        return "ATTACHMENT_COMPILE_STATUS_OK";
    case 2:
        return "ATTACHMENT_COMPILE_STATUS_ERROR";
    case 3:
        return "ATTACHMENT_COMPILE_STATUS_INCOMPATIBLE_VERSION";
    case -1:
    default:
        return "UNRECOGNIZED"
    }
}
var AttachmentType = (V => (V[V.ATTACHMENT_TYPE_UNSPECIFIED = 0] = "ATTACHMENT_TYPE_UNSPECIFIED",
V[V.ATTACHMENT_TYPE_SPATIAL = 1] = "ATTACHMENT_TYPE_SPATIAL",
V[V.ATTACHMENT_TYPE_SCRIPT = 2] = "ATTACHMENT_TYPE_SCRIPT",
V[V.ATTACHMENT_TYPE_SCRIPT_DATA = 3] = "ATTACHMENT_TYPE_SCRIPT_DATA",
V[V.ATTACHMENT_TYPE_STRINGS = 4] = "ATTACHMENT_TYPE_STRINGS",
V[V.ATTACHMENT_TYPE_MP_DATA = 5] = "ATTACHMENT_TYPE_MP_DATA",
V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED",
V))(AttachmentType || {});
function attachmentTypeFromJSON(V) {
    switch (V) {
    case 0:
    case "ATTACHMENT_TYPE_UNSPECIFIED":
        return 0;
    case 1:
    case "ATTACHMENT_TYPE_SPATIAL":
        return 1;
    case 2:
    case "ATTACHMENT_TYPE_SCRIPT":
        return 2;
    case 3:
    case "ATTACHMENT_TYPE_SCRIPT_DATA":
        return 3;
    case 4:
    case "ATTACHMENT_TYPE_STRINGS":
        return 4;
    case 5:
    case "ATTACHMENT_TYPE_MP_DATA":
        return 5;
    case -1:
    case "UNRECOGNIZED":
    default:
        return -1
    }
}
function attachmentTypeToJSON(V) {
    switch (V) {
    case 0:
        return "ATTACHMENT_TYPE_UNSPECIFIED";
    case 1:
        return "ATTACHMENT_TYPE_SPATIAL";
    case 2:
        return "ATTACHMENT_TYPE_SCRIPT";
    case 3:
        return "ATTACHMENT_TYPE_SCRIPT_DATA";
    case 4:
        return "ATTACHMENT_TYPE_STRINGS";
    case 5:
        return "ATTACHMENT_TYPE_MP_DATA";
    case -1:
    default:
        return "UNRECOGNIZED"
    }
}
var ProcessingStatus = (V => (V[V.PROCESSING_STATUS_UNSPECIFIED = 0] = "PROCESSING_STATUS_UNSPECIFIED",
V[V.PROCESSING_STATUS_PENDING = 1] = "PROCESSING_STATUS_PENDING",
V[V.PROCESSING_STATUS_PROCESSED = 2] = "PROCESSING_STATUS_PROCESSED",
V[V.PROCESSING_STATUS_NEEDS_RECOMPILE = 3] = "PROCESSING_STATUS_NEEDS_RECOMPILE",
V[V.PROCESSING_STATUS_ERROR = 4] = "PROCESSING_STATUS_ERROR",
V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED",
V))(ProcessingStatus || {});
function processingStatusFromJSON(V) {
    switch (V) {
    case 0:
    case "PROCESSING_STATUS_UNSPECIFIED":
        return 0;
    case 1:
    case "PROCESSING_STATUS_PENDING":
        return 1;
    case 2:
    case "PROCESSING_STATUS_PROCESSED":
        return 2;
    case 3:
    case "PROCESSING_STATUS_NEEDS_RECOMPILE":
        return 3;
    case 4:
    case "PROCESSING_STATUS_ERROR":
        return 4;
    case -1:
    case "UNRECOGNIZED":
    default:
        return -1
    }
}
function processingStatusToJSON(V) {
    switch (V) {
    case 0:
        return "PROCESSING_STATUS_UNSPECIFIED";
    case 1:
        return "PROCESSING_STATUS_PENDING";
    case 2:
        return "PROCESSING_STATUS_PROCESSED";
    case 3:
        return "PROCESSING_STATUS_NEEDS_RECOMPILE";
    case 4:
        return "PROCESSING_STATUS_ERROR";
    case -1:
    default:
        return "UNRECOGNIZED"
    }
}
function gameServerJoinabilitySettingValueFromJSON(V) {
    switch (V) {
    case 0:
    case "GAME_SERVER_JOINABILITY_SETTING_VALUE_UNSPECIFIED":
        return 0;
    case 1:
    case "GAME_SERVER_JOINABILITY_SETTING_VALUE_ALLOWED":
        return 1;
    case 2:
    case "GAME_SERVER_JOINABILITY_SETTING_VALUE_DISALLOWED":
        return 2;
    case -1:
    case "UNRECOGNIZED":
    default:
        return -1
    }
}
function gameServerJoinabilitySettingValueToJSON(V) {
    switch (V) {
    case 0:
        return "GAME_SERVER_JOINABILITY_SETTING_VALUE_UNSPECIFIED";
    case 1:
        return "GAME_SERVER_JOINABILITY_SETTING_VALUE_ALLOWED";
    case 2:
        return "GAME_SERVER_JOINABILITY_SETTING_VALUE_DISALLOWED";
    case -1:
    default:
        return "UNRECOGNIZED"
    }
}
var RotationBehavior = (V => (V[V.ROTATION_BEHAVIOR_LOOP = 0] = "ROTATION_BEHAVIOR_LOOP",
V[V.ROTATION_BEHAVIOR_EORMM = 1] = "ROTATION_BEHAVIOR_EORMM",
V[V.ROTATION_BEHAVIOR_ONE_MAP = 2] = "ROTATION_BEHAVIOR_ONE_MAP",
V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED",
V))(RotationBehavior || {});
function rotationBehaviorFromJSON(V) {
    switch (V) {
    case 0:
    case "ROTATION_BEHAVIOR_LOOP":
        return 0;
    case 1:
    case "ROTATION_BEHAVIOR_EORMM":
        return 1;
    case 2:
    case "ROTATION_BEHAVIOR_ONE_MAP":
        return 2;
    case -1:
    case "UNRECOGNIZED":
    default:
        return -1
    }
}
function rotationBehaviorToJSON(V) {
    switch (V) {
    case 0:
        return "ROTATION_BEHAVIOR_LOOP";
    case 1:
        return "ROTATION_BEHAVIOR_EORMM";
    case 2:
        return "ROTATION_BEHAVIOR_ONE_MAP";
    case -1:
    default:
        return "UNRECOGNIZED"
    }
}
function blazeGameSettingValueFromJSON(V) {
    switch (V) {
    case 0:
    case "BLAZE_GAME_SETTING_VALUE_UNSPECIFIED":
        return 0;
    case 1:
    case "BLAZE_GAME_SETTING_VALUE_ALLOWED":
        return 1;
    case 2:
    case "BLAZE_GAME_SETTING_VALUE_DISALLOWED":
        return 2;
    case -1:
    case "UNRECOGNIZED":
    default:
        return -1
    }
}
function blazeGameSettingValueToJSON(V) {
    switch (V) {
    case 0:
        return "BLAZE_GAME_SETTING_VALUE_UNSPECIFIED";
    case 1:
        return "BLAZE_GAME_SETTING_VALUE_ALLOWED";
    case 2:
        return "BLAZE_GAME_SETTING_VALUE_DISALLOWED";
    case -1:
    default:
        return "UNRECOGNIZED"
    }
}
var PublishStateType = (V => (V[V.PUBLISH_STATE_TYPE_INVALID = 0] = "PUBLISH_STATE_TYPE_INVALID",
V[V.PUBLISH_STATE_TYPE_DRAFT = 1] = "PUBLISH_STATE_TYPE_DRAFT",
V[V.PUBLISH_STATE_TYPE_PUBLISHED = 2] = "PUBLISH_STATE_TYPE_PUBLISHED",
V[V.PUBLISH_STATE_TYPE_ARCHIVED = 3] = "PUBLISH_STATE_TYPE_ARCHIVED",
V[V.PUBLISH_STATE_TYPE_ERROR = 4] = "PUBLISH_STATE_TYPE_ERROR",
V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED",
V))(PublishStateType || {});
function publishStateTypeFromJSON(V) {
    switch (V) {
    case 0:
    case "PUBLISH_STATE_TYPE_INVALID":
        return 0;
    case 1:
    case "PUBLISH_STATE_TYPE_DRAFT":
        return 1;
    case 2:
    case "PUBLISH_STATE_TYPE_PUBLISHED":
        return 2;
    case 3:
    case "PUBLISH_STATE_TYPE_ARCHIVED":
        return 3;
    case 4:
    case "PUBLISH_STATE_TYPE_ERROR":
        return 4;
    case -1:
    case "UNRECOGNIZED":
    default:
        return -1
    }
}
function publishStateTypeToJSON(V) {
    switch (V) {
    case 0:
        return "PUBLISH_STATE_TYPE_INVALID";
    case 1:
        return "PUBLISH_STATE_TYPE_DRAFT";
    case 2:
        return "PUBLISH_STATE_TYPE_PUBLISHED";
    case 3:
        return "PUBLISH_STATE_TYPE_ARCHIVED";
    case 4:
        return "PUBLISH_STATE_TYPE_ERROR";
    case -1:
    default:
        return "UNRECOGNIZED"
    }
}
var ModerationStateType = (V => (V[V.MODERATION_STATE_TYPE_UNDEFINED = 0] = "MODERATION_STATE_TYPE_UNDEFINED",
V[V.MODERATION_STATE_TYPE_IN_REVIEW = 1] = "MODERATION_STATE_TYPE_IN_REVIEW",
V[V.MODERATION_STATE_TYPE_APPROVED = 2] = "MODERATION_STATE_TYPE_APPROVED",
V[V.MODERATION_STATE_TYPE_DENIED = 3] = "MODERATION_STATE_TYPE_DENIED",
V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED",
V))(ModerationStateType || {});
function moderationStateTypeFromJSON(V) {
    switch (V) {
    case 0:
    case "MODERATION_STATE_TYPE_UNDEFINED":
        return 0;
    case 1:
    case "MODERATION_STATE_TYPE_IN_REVIEW":
        return 1;
    case 2:
    case "MODERATION_STATE_TYPE_APPROVED":
        return 2;
    case 3:
    case "MODERATION_STATE_TYPE_DENIED":
        return 3;
    case -1:
    case "UNRECOGNIZED":
    default:
        return -1
    }
}
function moderationStateTypeToJSON(V) {
    switch (V) {
    case 0:
        return "MODERATION_STATE_TYPE_UNDEFINED";
    case 1:
        return "MODERATION_STATE_TYPE_IN_REVIEW";
    case 2:
        return "MODERATION_STATE_TYPE_APPROVED";
    case 3:
        return "MODERATION_STATE_TYPE_DENIED";
    case -1:
    default:
        return "UNRECOGNIZED"
    }
}
function createBasePlayElement() {
    return {
        id: "",
        designId: "",
        creator: void 0,
        name: "",
        description: void 0,
        created: void 0,
        updated: void 0,
        playElementSettings: void 0,
        publishStateType: 0,
        likes: void 0,
        publishAt: void 0,
        thumbnailUrl: void 0,
        moderationState: 0,
        shortCode: void 0
    }
}
const PlayElement = {
    encode(V, X=new BinaryWriter) {
        return V.id !== "" && X.uint32(10).string(V.id),
        V.designId !== "" && X.uint32(18).string(V.designId),
        V.creator !== void 0 && Creator.encode(V.creator, X.uint32(26).fork()).join(),
        V.name !== "" && X.uint32(34).string(V.name),
        V.description !== void 0 && StringValue.encode({
            value: V.description
        }, X.uint32(42).fork()).join(),
        V.created !== void 0 && Timestamp.encode(toTimestamp$3(V.created), X.uint32(50).fork()).join(),
        V.updated !== void 0 && Timestamp.encode(toTimestamp$3(V.updated), X.uint32(58).fork()).join(),
        V.playElementSettings !== void 0 && PlayElementSettings.encode(V.playElementSettings, X.uint32(66).fork()).join(),
        V.publishStateType !== 0 && X.uint32(72).int32(V.publishStateType),
        V.likes !== void 0 && Int32Value.encode({
            value: V.likes
        }, X.uint32(82).fork()).join(),
        V.publishAt !== void 0 && Timestamp.encode(toTimestamp$3(V.publishAt), X.uint32(90).fork()).join(),
        V.thumbnailUrl !== void 0 && StringValue.encode({
            value: V.thumbnailUrl
        }, X.uint32(98).fork()).join(),
        V.moderationState !== 0 && X.uint32(104).int32(V.moderationState),
        V.shortCode !== void 0 && StringValue.encode({
            value: V.shortCode
        }, X.uint32(114).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBasePlayElement();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.id = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.designId = J.string();
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.creator = Creator.decode(J, J.uint32());
                    continue
                }
            case 4:
                {
                    if (ce !== 34)
                        break;
                    ue.name = J.string();
                    continue
                }
            case 5:
                {
                    if (ce !== 42)
                        break;
                    ue.description = StringValue.decode(J, J.uint32()).value;
                    continue
                }
            case 6:
                {
                    if (ce !== 50)
                        break;
                    ue.created = fromTimestamp$3(Timestamp.decode(J, J.uint32()));
                    continue
                }
            case 7:
                {
                    if (ce !== 58)
                        break;
                    ue.updated = fromTimestamp$3(Timestamp.decode(J, J.uint32()));
                    continue
                }
            case 8:
                {
                    if (ce !== 66)
                        break;
                    ue.playElementSettings = PlayElementSettings.decode(J, J.uint32());
                    continue
                }
            case 9:
                {
                    if (ce !== 72)
                        break;
                    ue.publishStateType = J.int32();
                    continue
                }
            case 10:
                {
                    if (ce !== 82)
                        break;
                    ue.likes = Int32Value.decode(J, J.uint32()).value;
                    continue
                }
            case 11:
                {
                    if (ce !== 90)
                        break;
                    ue.publishAt = fromTimestamp$3(Timestamp.decode(J, J.uint32()));
                    continue
                }
            case 12:
                {
                    if (ce !== 98)
                        break;
                    ue.thumbnailUrl = StringValue.decode(J, J.uint32()).value;
                    continue
                }
            case 13:
                {
                    if (ce !== 104)
                        break;
                    ue.moderationState = J.int32();
                    continue
                }
            case 14:
                {
                    if (ce !== 114)
                        break;
                    ue.shortCode = StringValue.decode(J, J.uint32()).value;
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            id: isSet$a(V.id) ? globalThis.String(V.id) : "",
            designId: isSet$a(V.designId) ? globalThis.String(V.designId) : "",
            creator: isSet$a(V.creator) ? Creator.fromJSON(V.creator) : void 0,
            name: isSet$a(V.name) ? globalThis.String(V.name) : "",
            description: isSet$a(V.description) ? String(V.description) : void 0,
            created: isSet$a(V.created) ? fromJsonTimestamp$3(V.created) : void 0,
            updated: isSet$a(V.updated) ? fromJsonTimestamp$3(V.updated) : void 0,
            playElementSettings: isSet$a(V.playElementSettings) ? PlayElementSettings.fromJSON(V.playElementSettings) : void 0,
            publishStateType: isSet$a(V.publishStateType) ? publishStateTypeFromJSON(V.publishStateType) : 0,
            likes: isSet$a(V.likes) ? Number(V.likes) : void 0,
            publishAt: isSet$a(V.publishAt) ? fromJsonTimestamp$3(V.publishAt) : void 0,
            thumbnailUrl: isSet$a(V.thumbnailUrl) ? String(V.thumbnailUrl) : void 0,
            moderationState: isSet$a(V.moderationState) ? moderationStateTypeFromJSON(V.moderationState) : 0,
            shortCode: isSet$a(V.shortCode) ? String(V.shortCode) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.id !== "" && (X.id = V.id),
        V.designId !== "" && (X.designId = V.designId),
        V.creator !== void 0 && (X.creator = Creator.toJSON(V.creator)),
        V.name !== "" && (X.name = V.name),
        V.description !== void 0 && (X.description = V.description),
        V.created !== void 0 && (X.created = V.created.toISOString()),
        V.updated !== void 0 && (X.updated = V.updated.toISOString()),
        V.playElementSettings !== void 0 && (X.playElementSettings = PlayElementSettings.toJSON(V.playElementSettings)),
        V.publishStateType !== 0 && (X.publishStateType = publishStateTypeToJSON(V.publishStateType)),
        V.likes !== void 0 && (X.likes = V.likes),
        V.publishAt !== void 0 && (X.publishAt = V.publishAt.toISOString()),
        V.thumbnailUrl !== void 0 && (X.thumbnailUrl = V.thumbnailUrl),
        V.moderationState !== 0 && (X.moderationState = moderationStateTypeToJSON(V.moderationState)),
        V.shortCode !== void 0 && (X.shortCode = V.shortCode),
        X
    },
    create(V) {
        return PlayElement.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBasePlayElement();
        return X.id = V.id ?? "",
        X.designId = V.designId ?? "",
        X.creator = V.creator !== void 0 && V.creator !== null ? Creator.fromPartial(V.creator) : void 0,
        X.name = V.name ?? "",
        X.description = V.description ?? void 0,
        X.created = V.created ?? void 0,
        X.updated = V.updated ?? void 0,
        X.playElementSettings = V.playElementSettings !== void 0 && V.playElementSettings !== null ? PlayElementSettings.fromPartial(V.playElementSettings) : void 0,
        X.publishStateType = V.publishStateType ?? 0,
        X.likes = V.likes ?? void 0,
        X.publishAt = V.publishAt ?? void 0,
        X.thumbnailUrl = V.thumbnailUrl ?? void 0,
        X.moderationState = V.moderationState ?? 0,
        X.shortCode = V.shortCode ?? void 0,
        X
    }
};
function createBasePlayElementDesign() {
    return {
        designId: "",
        designName: "",
        created: void 0,
        designMetadata: void 0,
        mapRotation: void 0,
        mutators: [],
        assetCategories: [],
        licenseRequirements: [],
        modRules: void 0,
        tags: [],
        blazeSettings: void 0,
        modLevelDataId: void 0,
        attachments: [],
        groupLicenses: [],
        attachmentCompileStatus: 0,
        serverHostLicenseRequirements: []
    }
}
const PlayElementDesign = {
    encode(V, X=new BinaryWriter) {
        V.designId !== "" && X.uint32(10).string(V.designId),
        V.designName !== "" && X.uint32(18).string(V.designName),
        V.created !== void 0 && Timestamp.encode(toTimestamp$3(V.created), X.uint32(34).fork()).join(),
        V.designMetadata !== void 0 && DesignMetadata.encode(V.designMetadata, X.uint32(42).fork()).join(),
        V.mapRotation !== void 0 && MapRotation.encode(V.mapRotation, X.uint32(50).fork()).join();
        for (const J of V.mutators)
            Mutator.encode(J, X.uint32(58).fork()).join();
        for (const J of V.assetCategories)
            AssetCategory.encode(J, X.uint32(66).fork()).join();
        for (const J of V.licenseRequirements)
            X.uint32(74).string(J);
        V.modRules !== void 0 && ModRules.encode(V.modRules, X.uint32(82).fork()).join();
        for (const J of V.tags)
            Tag.encode(J, X.uint32(98).fork()).join();
        V.blazeSettings !== void 0 && BlazePlayElementDesignSettings.encode(V.blazeSettings, X.uint32(106).fork()).join(),
        V.modLevelDataId !== void 0 && StringValue.encode({
            value: V.modLevelDataId
        }, X.uint32(114).fork()).join();
        for (const J of V.attachments)
            Attachment.encode(J, X.uint32(122).fork()).join();
        for (const J of V.groupLicenses)
            X.uint32(130).string(J);
        V.attachmentCompileStatus !== 0 && X.uint32(136).int32(V.attachmentCompileStatus);
        for (const J of V.serverHostLicenseRequirements)
            X.uint32(146).string(J);
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBasePlayElementDesign();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.designId = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.designName = J.string();
                    continue
                }
            case 4:
                {
                    if (ce !== 34)
                        break;
                    ue.created = fromTimestamp$3(Timestamp.decode(J, J.uint32()));
                    continue
                }
            case 5:
                {
                    if (ce !== 42)
                        break;
                    ue.designMetadata = DesignMetadata.decode(J, J.uint32());
                    continue
                }
            case 6:
                {
                    if (ce !== 50)
                        break;
                    ue.mapRotation = MapRotation.decode(J, J.uint32());
                    continue
                }
            case 7:
                {
                    if (ce !== 58)
                        break;
                    ue.mutators.push(Mutator.decode(J, J.uint32()));
                    continue
                }
            case 8:
                {
                    if (ce !== 66)
                        break;
                    ue.assetCategories.push(AssetCategory.decode(J, J.uint32()));
                    continue
                }
            case 9:
                {
                    if (ce !== 74)
                        break;
                    ue.licenseRequirements.push(J.string());
                    continue
                }
            case 10:
                {
                    if (ce !== 82)
                        break;
                    ue.modRules = ModRules.decode(J, J.uint32());
                    continue
                }
            case 12:
                {
                    if (ce !== 98)
                        break;
                    ue.tags.push(Tag.decode(J, J.uint32()));
                    continue
                }
            case 13:
                {
                    if (ce !== 106)
                        break;
                    ue.blazeSettings = BlazePlayElementDesignSettings.decode(J, J.uint32());
                    continue
                }
            case 14:
                {
                    if (ce !== 114)
                        break;
                    ue.modLevelDataId = StringValue.decode(J, J.uint32()).value;
                    continue
                }
            case 15:
                {
                    if (ce !== 122)
                        break;
                    ue.attachments.push(Attachment.decode(J, J.uint32()));
                    continue
                }
            case 16:
                {
                    if (ce !== 130)
                        break;
                    ue.groupLicenses.push(J.string());
                    continue
                }
            case 17:
                {
                    if (ce !== 136)
                        break;
                    ue.attachmentCompileStatus = J.int32();
                    continue
                }
            case 18:
                {
                    if (ce !== 146)
                        break;
                    ue.serverHostLicenseRequirements.push(J.string());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            designId: isSet$a(V.designId) ? globalThis.String(V.designId) : "",
            designName: isSet$a(V.designName) ? globalThis.String(V.designName) : "",
            created: isSet$a(V.created) ? fromJsonTimestamp$3(V.created) : void 0,
            designMetadata: isSet$a(V.designMetadata) ? DesignMetadata.fromJSON(V.designMetadata) : void 0,
            mapRotation: isSet$a(V.mapRotation) ? MapRotation.fromJSON(V.mapRotation) : void 0,
            mutators: globalThis.Array.isArray(V == null ? void 0 : V.mutators) ? V.mutators.map(X => Mutator.fromJSON(X)) : [],
            assetCategories: globalThis.Array.isArray(V == null ? void 0 : V.assetCategories) ? V.assetCategories.map(X => AssetCategory.fromJSON(X)) : [],
            licenseRequirements: globalThis.Array.isArray(V == null ? void 0 : V.licenseRequirements) ? V.licenseRequirements.map(X => globalThis.String(X)) : [],
            modRules: isSet$a(V.modRules) ? ModRules.fromJSON(V.modRules) : void 0,
            tags: globalThis.Array.isArray(V == null ? void 0 : V.tags) ? V.tags.map(X => Tag.fromJSON(X)) : [],
            blazeSettings: isSet$a(V.blazeSettings) ? BlazePlayElementDesignSettings.fromJSON(V.blazeSettings) : void 0,
            modLevelDataId: isSet$a(V.modLevelDataId) ? String(V.modLevelDataId) : void 0,
            attachments: globalThis.Array.isArray(V == null ? void 0 : V.attachments) ? V.attachments.map(X => Attachment.fromJSON(X)) : [],
            groupLicenses: globalThis.Array.isArray(V == null ? void 0 : V.groupLicenses) ? V.groupLicenses.map(X => globalThis.String(X)) : [],
            attachmentCompileStatus: isSet$a(V.attachmentCompileStatus) ? attachmentCompileStatusFromJSON(V.attachmentCompileStatus) : 0,
            serverHostLicenseRequirements: globalThis.Array.isArray(V == null ? void 0 : V.serverHostLicenseRequirements) ? V.serverHostLicenseRequirements.map(X => globalThis.String(X)) : []
        }
    },
    toJSON(V) {
        var J, ne, ue, ce, me, ge, Te;
        const X = {};
        return V.designId !== "" && (X.designId = V.designId),
        V.designName !== "" && (X.designName = V.designName),
        V.created !== void 0 && (X.created = V.created.toISOString()),
        V.designMetadata !== void 0 && (X.designMetadata = DesignMetadata.toJSON(V.designMetadata)),
        V.mapRotation !== void 0 && (X.mapRotation = MapRotation.toJSON(V.mapRotation)),
        (J = V.mutators) != null && J.length && (X.mutators = V.mutators.map(_e => Mutator.toJSON(_e))),
        (ne = V.assetCategories) != null && ne.length && (X.assetCategories = V.assetCategories.map(_e => AssetCategory.toJSON(_e))),
        (ue = V.licenseRequirements) != null && ue.length && (X.licenseRequirements = V.licenseRequirements),
        V.modRules !== void 0 && (X.modRules = ModRules.toJSON(V.modRules)),
        (ce = V.tags) != null && ce.length && (X.tags = V.tags.map(_e => Tag.toJSON(_e))),
        V.blazeSettings !== void 0 && (X.blazeSettings = BlazePlayElementDesignSettings.toJSON(V.blazeSettings)),
        V.modLevelDataId !== void 0 && (X.modLevelDataId = V.modLevelDataId),
        (me = V.attachments) != null && me.length && (X.attachments = V.attachments.map(_e => Attachment.toJSON(_e))),
        (ge = V.groupLicenses) != null && ge.length && (X.groupLicenses = V.groupLicenses),
        V.attachmentCompileStatus !== 0 && (X.attachmentCompileStatus = attachmentCompileStatusToJSON(V.attachmentCompileStatus)),
        (Te = V.serverHostLicenseRequirements) != null && Te.length && (X.serverHostLicenseRequirements = V.serverHostLicenseRequirements),
        X
    },
    create(V) {
        return PlayElementDesign.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J, ne, ue, ce, me, ge, Te;
        const X = createBasePlayElementDesign();
        return X.designId = V.designId ?? "",
        X.designName = V.designName ?? "",
        X.created = V.created ?? void 0,
        X.designMetadata = V.designMetadata !== void 0 && V.designMetadata !== null ? DesignMetadata.fromPartial(V.designMetadata) : void 0,
        X.mapRotation = V.mapRotation !== void 0 && V.mapRotation !== null ? MapRotation.fromPartial(V.mapRotation) : void 0,
        X.mutators = ((J = V.mutators) == null ? void 0 : J.map(_e => Mutator.fromPartial(_e))) || [],
        X.assetCategories = ((ne = V.assetCategories) == null ? void 0 : ne.map(_e => AssetCategory.fromPartial(_e))) || [],
        X.licenseRequirements = ((ue = V.licenseRequirements) == null ? void 0 : ue.map(_e => _e)) || [],
        X.modRules = V.modRules !== void 0 && V.modRules !== null ? ModRules.fromPartial(V.modRules) : void 0,
        X.tags = ((ce = V.tags) == null ? void 0 : ce.map(_e => Tag.fromPartial(_e))) || [],
        X.blazeSettings = V.blazeSettings !== void 0 && V.blazeSettings !== null ? BlazePlayElementDesignSettings.fromPartial(V.blazeSettings) : void 0,
        X.modLevelDataId = V.modLevelDataId ?? void 0,
        X.attachments = ((me = V.attachments) == null ? void 0 : me.map(_e => Attachment.fromPartial(_e))) || [],
        X.groupLicenses = ((ge = V.groupLicenses) == null ? void 0 : ge.map(_e => _e)) || [],
        X.attachmentCompileStatus = V.attachmentCompileStatus ?? 0,
        X.serverHostLicenseRequirements = ((Te = V.serverHostLicenseRequirements) == null ? void 0 : Te.map(_e => _e)) || [],
        X
    }
};
function createBaseAttachmentData() {
    return {
        original: new Uint8Array(0),
        compiled: void 0
    }
}
const AttachmentData = {
    encode(V, X=new BinaryWriter) {
        return V.original.length !== 0 && X.uint32(10).bytes(V.original),
        V.compiled !== void 0 && BytesValue.encode({
            value: V.compiled
        }, X.uint32(18).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseAttachmentData();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.original = J.bytes();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.compiled = BytesValue.decode(J, J.uint32()).value;
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            original: isSet$a(V.original) ? bytesFromBase64$1(V.original) : new Uint8Array(0),
            compiled: isSet$a(V.compiled) ? new Uint8Array(V.compiled) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.original.length !== 0 && (X.original = base64FromBytes$1(V.original)),
        V.compiled !== void 0 && (X.compiled = V.compiled),
        X
    },
    create(V) {
        return AttachmentData.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseAttachmentData();
        return X.original = V.original ?? new Uint8Array(0),
        X.compiled = V.compiled ?? void 0,
        X
    }
};
function createBaseAttachment() {
    return {
        id: "",
        version: "",
        filename: void 0,
        isProcessable: !1,
        processingStatus: 0,
        attachmentData: void 0,
        attachmentType: 0,
        metadata: void 0,
        errors: []
    }
}
const Attachment = {
    encode(V, X=new BinaryWriter) {
        V.id !== "" && X.uint32(10).string(V.id),
        V.version !== "" && X.uint32(18).string(V.version),
        V.filename !== void 0 && StringValue.encode({
            value: V.filename
        }, X.uint32(26).fork()).join(),
        V.isProcessable !== !1 && X.uint32(32).bool(V.isProcessable),
        V.processingStatus !== 0 && X.uint32(40).int32(V.processingStatus),
        V.attachmentData !== void 0 && AttachmentData.encode(V.attachmentData, X.uint32(50).fork()).join(),
        V.attachmentType !== 0 && X.uint32(56).int32(V.attachmentType),
        V.metadata !== void 0 && StringValue.encode({
            value: V.metadata
        }, X.uint32(66).fork()).join();
        for (const J of V.errors)
            X.uint32(74).string(J);
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseAttachment();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.id = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.version = J.string();
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.filename = StringValue.decode(J, J.uint32()).value;
                    continue
                }
            case 4:
                {
                    if (ce !== 32)
                        break;
                    ue.isProcessable = J.bool();
                    continue
                }
            case 5:
                {
                    if (ce !== 40)
                        break;
                    ue.processingStatus = J.int32();
                    continue
                }
            case 6:
                {
                    if (ce !== 50)
                        break;
                    ue.attachmentData = AttachmentData.decode(J, J.uint32());
                    continue
                }
            case 7:
                {
                    if (ce !== 56)
                        break;
                    ue.attachmentType = J.int32();
                    continue
                }
            case 8:
                {
                    if (ce !== 66)
                        break;
                    ue.metadata = StringValue.decode(J, J.uint32()).value;
                    continue
                }
            case 9:
                {
                    if (ce !== 74)
                        break;
                    ue.errors.push(J.string());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            id: isSet$a(V.id) ? globalThis.String(V.id) : "",
            version: isSet$a(V.version) ? globalThis.String(V.version) : "",
            filename: isSet$a(V.filename) ? String(V.filename) : void 0,
            isProcessable: isSet$a(V.isProcessable) ? globalThis.Boolean(V.isProcessable) : !1,
            processingStatus: isSet$a(V.processingStatus) ? processingStatusFromJSON(V.processingStatus) : 0,
            attachmentData: isSet$a(V.attachmentData) ? AttachmentData.fromJSON(V.attachmentData) : void 0,
            attachmentType: isSet$a(V.attachmentType) ? attachmentTypeFromJSON(V.attachmentType) : 0,
            metadata: isSet$a(V.metadata) ? String(V.metadata) : void 0,
            errors: globalThis.Array.isArray(V == null ? void 0 : V.errors) ? V.errors.map(X => globalThis.String(X)) : []
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return V.id !== "" && (X.id = V.id),
        V.version !== "" && (X.version = V.version),
        V.filename !== void 0 && (X.filename = V.filename),
        V.isProcessable !== !1 && (X.isProcessable = V.isProcessable),
        V.processingStatus !== 0 && (X.processingStatus = processingStatusToJSON(V.processingStatus)),
        V.attachmentData !== void 0 && (X.attachmentData = AttachmentData.toJSON(V.attachmentData)),
        V.attachmentType !== 0 && (X.attachmentType = attachmentTypeToJSON(V.attachmentType)),
        V.metadata !== void 0 && (X.metadata = V.metadata),
        (J = V.errors) != null && J.length && (X.errors = V.errors),
        X
    },
    create(V) {
        return Attachment.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseAttachment();
        return X.id = V.id ?? "",
        X.version = V.version ?? "",
        X.filename = V.filename ?? void 0,
        X.isProcessable = V.isProcessable ?? !1,
        X.processingStatus = V.processingStatus ?? 0,
        X.attachmentData = V.attachmentData !== void 0 && V.attachmentData !== null ? AttachmentData.fromPartial(V.attachmentData) : void 0,
        X.attachmentType = V.attachmentType ?? 0,
        X.metadata = V.metadata ?? void 0,
        X.errors = ((J = V.errors) == null ? void 0 : J.map(ne => ne)) || [],
        X
    }
};
function createBaseBlazePlayElementDesignSettings() {
    return {
        openGroupReservations: 0
    }
}
const BlazePlayElementDesignSettings = {
    encode(V, X=new BinaryWriter) {
        return V.openGroupReservations !== 0 && X.uint32(8).int32(V.openGroupReservations),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseBlazePlayElementDesignSettings();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 8)
                        break;
                    ue.openGroupReservations = J.int32();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            openGroupReservations: isSet$a(V.openGroupReservations) ? blazeGameSettingValueFromJSON(V.openGroupReservations) : 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.openGroupReservations !== 0 && (X.openGroupReservations = blazeGameSettingValueToJSON(V.openGroupReservations)),
        X
    },
    create(V) {
        return BlazePlayElementDesignSettings.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseBlazePlayElementDesignSettings();
        return X.openGroupReservations = V.openGroupReservations ?? 0,
        X
    }
};
function createBaseGameServerJoinabilitySettings() {
    return {
        matchmakingInProgress: 0
    }
}
const GameServerJoinabilitySettings = {
    encode(V, X=new BinaryWriter) {
        return V.matchmakingInProgress !== 0 && X.uint32(8).int32(V.matchmakingInProgress),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseGameServerJoinabilitySettings();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 8)
                        break;
                    ue.matchmakingInProgress = J.int32();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            matchmakingInProgress: isSet$a(V.matchmakingInProgress) ? gameServerJoinabilitySettingValueFromJSON(V.matchmakingInProgress) : 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.matchmakingInProgress !== 0 && (X.matchmakingInProgress = gameServerJoinabilitySettingValueToJSON(V.matchmakingInProgress)),
        X
    },
    create(V) {
        return GameServerJoinabilitySettings.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseGameServerJoinabilitySettings();
        return X.matchmakingInProgress = V.matchmakingInProgress ?? 0,
        X
    }
};
function createBaseCreator() {
    return {
        internalCreator: void 0,
        playerCreator: void 0,
        externalCreator: void 0,
        trustedCreator: void 0
    }
}
const Creator = {
    encode(V, X=new BinaryWriter) {
        return V.internalCreator !== void 0 && InternalCreator.encode(V.internalCreator, X.uint32(10).fork()).join(),
        V.playerCreator !== void 0 && PlayerCreator.encode(V.playerCreator, X.uint32(18).fork()).join(),
        V.externalCreator !== void 0 && ExternalCreator.encode(V.externalCreator, X.uint32(26).fork()).join(),
        V.trustedCreator !== void 0 && PlayerCreator.encode(V.trustedCreator, X.uint32(34).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseCreator();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.internalCreator = InternalCreator.decode(J, J.uint32());
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.playerCreator = PlayerCreator.decode(J, J.uint32());
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.externalCreator = ExternalCreator.decode(J, J.uint32());
                    continue
                }
            case 4:
                {
                    if (ce !== 34)
                        break;
                    ue.trustedCreator = PlayerCreator.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            internalCreator: isSet$a(V.internalCreator) ? InternalCreator.fromJSON(V.internalCreator) : void 0,
            playerCreator: isSet$a(V.playerCreator) ? PlayerCreator.fromJSON(V.playerCreator) : void 0,
            externalCreator: isSet$a(V.externalCreator) ? ExternalCreator.fromJSON(V.externalCreator) : void 0,
            trustedCreator: isSet$a(V.trustedCreator) ? PlayerCreator.fromJSON(V.trustedCreator) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.internalCreator !== void 0 && (X.internalCreator = InternalCreator.toJSON(V.internalCreator)),
        V.playerCreator !== void 0 && (X.playerCreator = PlayerCreator.toJSON(V.playerCreator)),
        V.externalCreator !== void 0 && (X.externalCreator = ExternalCreator.toJSON(V.externalCreator)),
        V.trustedCreator !== void 0 && (X.trustedCreator = PlayerCreator.toJSON(V.trustedCreator)),
        X
    },
    create(V) {
        return Creator.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseCreator();
        return X.internalCreator = V.internalCreator !== void 0 && V.internalCreator !== null ? InternalCreator.fromPartial(V.internalCreator) : void 0,
        X.playerCreator = V.playerCreator !== void 0 && V.playerCreator !== null ? PlayerCreator.fromPartial(V.playerCreator) : void 0,
        X.externalCreator = V.externalCreator !== void 0 && V.externalCreator !== null ? ExternalCreator.fromPartial(V.externalCreator) : void 0,
        X.trustedCreator = V.trustedCreator !== void 0 && V.trustedCreator !== null ? PlayerCreator.fromPartial(V.trustedCreator) : void 0,
        X
    }
};
function createBaseInternalCreator() {
    return {}
}
const InternalCreator = {
    encode(V, X=new BinaryWriter) {
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseInternalCreator();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {}
    },
    toJSON(V) {
        return {}
    },
    create(V) {
        return InternalCreator.fromPartial(V ?? {})
    },
    fromPartial(V) {
        return createBaseInternalCreator()
    }
};
function createBasePlayerCreator() {
    return {
        player: void 0
    }
}
const PlayerCreator = {
    encode(V, X=new BinaryWriter) {
        return V.player !== void 0 && Player.encode(V.player, X.uint32(10).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBasePlayerCreator();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.player = Player.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            player: isSet$a(V.player) ? Player.fromJSON(V.player) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.player !== void 0 && (X.player = Player.toJSON(V.player)),
        X
    },
    create(V) {
        return PlayerCreator.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBasePlayerCreator();
        return X.player = V.player !== void 0 && V.player !== null ? Player.fromPartial(V.player) : void 0,
        X
    }
};
function createBaseExternalCreator() {
    return {}
}
const ExternalCreator = {
    encode(V, X=new BinaryWriter) {
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseExternalCreator();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {}
    },
    toJSON(V) {
        return {}
    },
    create(V) {
        return ExternalCreator.fromPartial(V ?? {})
    },
    fromPartial(V) {
        return createBaseExternalCreator()
    }
};
function createBaseTag() {
    return {
        tagId: "",
        priority: 0,
        metadata: void 0
    }
}
const Tag = {
    encode(V, X=new BinaryWriter) {
        return V.tagId !== "" && X.uint32(10).string(V.tagId),
        V.priority !== 0 && X.uint32(16).int32(V.priority),
        V.metadata !== void 0 && Metadata.encode(V.metadata, X.uint32(26).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseTag();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.tagId = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 16)
                        break;
                    ue.priority = J.int32();
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.metadata = Metadata.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            tagId: isSet$a(V.tagId) ? globalThis.String(V.tagId) : "",
            priority: isSet$a(V.priority) ? globalThis.Number(V.priority) : 0,
            metadata: isSet$a(V.metadata) ? Metadata.fromJSON(V.metadata) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.tagId !== "" && (X.tagId = V.tagId),
        V.priority !== 0 && (X.priority = Math.round(V.priority)),
        V.metadata !== void 0 && (X.metadata = Metadata.toJSON(V.metadata)),
        X
    },
    create(V) {
        return Tag.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseTag();
        return X.tagId = V.tagId ?? "",
        X.priority = V.priority ?? 0,
        X.metadata = V.metadata !== void 0 && V.metadata !== null ? Metadata.fromPartial(V.metadata) : void 0,
        X
    }
};
function createBaseMapEntry() {
    return {
        levelName: "",
        levelLocation: "",
        rounds: 0,
        allowedSpectators: 0,
        teamComposition: void 0,
        blazeGameSettings: void 0,
        mutators: [],
        gameServerJoinabilitySettings: void 0
    }
}
const MapEntry = {
    encode(V, X=new BinaryWriter) {
        V.levelName !== "" && X.uint32(10).string(V.levelName),
        V.levelLocation !== "" && X.uint32(18).string(V.levelLocation),
        V.rounds !== 0 && X.uint32(24).int32(V.rounds),
        V.allowedSpectators !== 0 && X.uint32(32).int32(V.allowedSpectators),
        V.teamComposition !== void 0 && TeamComposition.encode(V.teamComposition, X.uint32(42).fork()).join(),
        V.blazeGameSettings !== void 0 && BlazeGameSettings.encode(V.blazeGameSettings, X.uint32(50).fork()).join();
        for (const J of V.mutators)
            Mutator.encode(J, X.uint32(58).fork()).join();
        return V.gameServerJoinabilitySettings !== void 0 && GameServerJoinabilitySettings.encode(V.gameServerJoinabilitySettings, X.uint32(66).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseMapEntry();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.levelName = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.levelLocation = J.string();
                    continue
                }
            case 3:
                {
                    if (ce !== 24)
                        break;
                    ue.rounds = J.int32();
                    continue
                }
            case 4:
                {
                    if (ce !== 32)
                        break;
                    ue.allowedSpectators = J.int32();
                    continue
                }
            case 5:
                {
                    if (ce !== 42)
                        break;
                    ue.teamComposition = TeamComposition.decode(J, J.uint32());
                    continue
                }
            case 6:
                {
                    if (ce !== 50)
                        break;
                    ue.blazeGameSettings = BlazeGameSettings.decode(J, J.uint32());
                    continue
                }
            case 7:
                {
                    if (ce !== 58)
                        break;
                    ue.mutators.push(Mutator.decode(J, J.uint32()));
                    continue
                }
            case 8:
                {
                    if (ce !== 66)
                        break;
                    ue.gameServerJoinabilitySettings = GameServerJoinabilitySettings.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            levelName: isSet$a(V.levelName) ? globalThis.String(V.levelName) : "",
            levelLocation: isSet$a(V.levelLocation) ? globalThis.String(V.levelLocation) : "",
            rounds: isSet$a(V.rounds) ? globalThis.Number(V.rounds) : 0,
            allowedSpectators: isSet$a(V.allowedSpectators) ? globalThis.Number(V.allowedSpectators) : 0,
            teamComposition: isSet$a(V.teamComposition) ? TeamComposition.fromJSON(V.teamComposition) : void 0,
            blazeGameSettings: isSet$a(V.blazeGameSettings) ? BlazeGameSettings.fromJSON(V.blazeGameSettings) : void 0,
            mutators: globalThis.Array.isArray(V == null ? void 0 : V.mutators) ? V.mutators.map(X => Mutator.fromJSON(X)) : [],
            gameServerJoinabilitySettings: isSet$a(V.gameServerJoinabilitySettings) ? GameServerJoinabilitySettings.fromJSON(V.gameServerJoinabilitySettings) : void 0
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return V.levelName !== "" && (X.levelName = V.levelName),
        V.levelLocation !== "" && (X.levelLocation = V.levelLocation),
        V.rounds !== 0 && (X.rounds = Math.round(V.rounds)),
        V.allowedSpectators !== 0 && (X.allowedSpectators = Math.round(V.allowedSpectators)),
        V.teamComposition !== void 0 && (X.teamComposition = TeamComposition.toJSON(V.teamComposition)),
        V.blazeGameSettings !== void 0 && (X.blazeGameSettings = BlazeGameSettings.toJSON(V.blazeGameSettings)),
        (J = V.mutators) != null && J.length && (X.mutators = V.mutators.map(ne => Mutator.toJSON(ne))),
        V.gameServerJoinabilitySettings !== void 0 && (X.gameServerJoinabilitySettings = GameServerJoinabilitySettings.toJSON(V.gameServerJoinabilitySettings)),
        X
    },
    create(V) {
        return MapEntry.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseMapEntry();
        return X.levelName = V.levelName ?? "",
        X.levelLocation = V.levelLocation ?? "",
        X.rounds = V.rounds ?? 0,
        X.allowedSpectators = V.allowedSpectators ?? 0,
        X.teamComposition = V.teamComposition !== void 0 && V.teamComposition !== null ? TeamComposition.fromPartial(V.teamComposition) : void 0,
        X.blazeGameSettings = V.blazeGameSettings !== void 0 && V.blazeGameSettings !== null ? BlazeGameSettings.fromPartial(V.blazeGameSettings) : void 0,
        X.mutators = ((J = V.mutators) == null ? void 0 : J.map(ne => Mutator.fromPartial(ne))) || [],
        X.gameServerJoinabilitySettings = V.gameServerJoinabilitySettings !== void 0 && V.gameServerJoinabilitySettings !== null ? GameServerJoinabilitySettings.fromPartial(V.gameServerJoinabilitySettings) : void 0,
        X
    }
};
function createBaseMapRotation() {
    return {
        maps: [],
        attributes: void 0
    }
}
const MapRotation = {
    encode(V, X=new BinaryWriter) {
        for (const J of V.maps)
            MapEntry.encode(J, X.uint32(10).fork()).join();
        return V.attributes !== void 0 && MapRotationAttributes.encode(V.attributes, X.uint32(18).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseMapRotation();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.maps.push(MapEntry.decode(J, J.uint32()));
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.attributes = MapRotationAttributes.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            maps: globalThis.Array.isArray(V == null ? void 0 : V.maps) ? V.maps.map(X => MapEntry.fromJSON(X)) : [],
            attributes: isSet$a(V.attributes) ? MapRotationAttributes.fromJSON(V.attributes) : void 0
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return (J = V.maps) != null && J.length && (X.maps = V.maps.map(ne => MapEntry.toJSON(ne))),
        V.attributes !== void 0 && (X.attributes = MapRotationAttributes.toJSON(V.attributes)),
        X
    },
    create(V) {
        return MapRotation.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseMapRotation();
        return X.maps = ((J = V.maps) == null ? void 0 : J.map(ne => MapEntry.fromPartial(ne))) || [],
        X.attributes = V.attributes !== void 0 && V.attributes !== null ? MapRotationAttributes.fromPartial(V.attributes) : void 0,
        X
    }
};
function createBaseMapRotationAttributes() {
    return {
        rotationBehavior: 0
    }
}
const MapRotationAttributes = {
    encode(V, X=new BinaryWriter) {
        return V.rotationBehavior !== 0 && X.uint32(8).int32(V.rotationBehavior),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseMapRotationAttributes();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 8)
                        break;
                    ue.rotationBehavior = J.int32();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            rotationBehavior: isSet$a(V.rotationBehavior) ? rotationBehaviorFromJSON(V.rotationBehavior) : 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.rotationBehavior !== 0 && (X.rotationBehavior = rotationBehaviorToJSON(V.rotationBehavior)),
        X
    },
    create(V) {
        return MapRotationAttributes.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseMapRotationAttributes();
        return X.rotationBehavior = V.rotationBehavior ?? 0,
        X
    }
};
function createBaseDesignMetadata() {
    return {
        progressionMode: void 0,
        firstPartyMetadata: []
    }
}
const DesignMetadata = {
    encode(V, X=new BinaryWriter) {
        V.progressionMode !== void 0 && StringValue.encode({
            value: V.progressionMode
        }, X.uint32(10).fork()).join();
        for (const J of V.firstPartyMetadata)
            FirstPartyMetadata.encode(J, X.uint32(18).fork()).join();
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseDesignMetadata();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.progressionMode = StringValue.decode(J, J.uint32()).value;
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.firstPartyMetadata.push(FirstPartyMetadata.decode(J, J.uint32()));
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            progressionMode: isSet$a(V.progressionMode) ? String(V.progressionMode) : void 0,
            firstPartyMetadata: globalThis.Array.isArray(V == null ? void 0 : V.firstPartyMetadata) ? V.firstPartyMetadata.map(X => FirstPartyMetadata.fromJSON(X)) : []
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return V.progressionMode !== void 0 && (X.progressionMode = V.progressionMode),
        (J = V.firstPartyMetadata) != null && J.length && (X.firstPartyMetadata = V.firstPartyMetadata.map(ne => FirstPartyMetadata.toJSON(ne))),
        X
    },
    create(V) {
        return DesignMetadata.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseDesignMetadata();
        return X.progressionMode = V.progressionMode ?? void 0,
        X.firstPartyMetadata = ((J = V.firstPartyMetadata) == null ? void 0 : J.map(ne => FirstPartyMetadata.fromPartial(ne))) || [],
        X
    }
};
function createBaseFirstPartyMetadata() {
    return {
        psnMetadata: void 0
    }
}
const FirstPartyMetadata = {
    encode(V, X=new BinaryWriter) {
        return V.psnMetadata !== void 0 && PSNMetadata.encode(V.psnMetadata, X.uint32(10).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseFirstPartyMetadata();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.psnMetadata = PSNMetadata.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            psnMetadata: isSet$a(V.psnMetadata) ? PSNMetadata.fromJSON(V.psnMetadata) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.psnMetadata !== void 0 && (X.psnMetadata = PSNMetadata.toJSON(V.psnMetadata)),
        X
    },
    create(V) {
        return FirstPartyMetadata.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseFirstPartyMetadata();
        return X.psnMetadata = V.psnMetadata !== void 0 && V.psnMetadata !== null ? PSNMetadata.fromPartial(V.psnMetadata) : void 0,
        X
    }
};
function createBasePSNMetadata() {
    return {
        activityId: ""
    }
}
const PSNMetadata = {
    encode(V, X=new BinaryWriter) {
        return V.activityId !== "" && X.uint32(10).string(V.activityId),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBasePSNMetadata();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.activityId = J.string();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            activityId: isSet$a(V.activityId) ? globalThis.String(V.activityId) : ""
        }
    },
    toJSON(V) {
        const X = {};
        return V.activityId !== "" && (X.activityId = V.activityId),
        X
    },
    create(V) {
        return PSNMetadata.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBasePSNMetadata();
        return X.activityId = V.activityId ?? "",
        X
    }
};
function createBaseBlazeGameSettings() {
    return {
        joinInProgress: 0,
        openToJoinByPlayer: 0,
        openToInvites: 0
    }
}
const BlazeGameSettings = {
    encode(V, X=new BinaryWriter) {
        return V.joinInProgress !== 0 && X.uint32(8).int32(V.joinInProgress),
        V.openToJoinByPlayer !== 0 && X.uint32(16).int32(V.openToJoinByPlayer),
        V.openToInvites !== 0 && X.uint32(24).int32(V.openToInvites),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseBlazeGameSettings();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 8)
                        break;
                    ue.joinInProgress = J.int32();
                    continue
                }
            case 2:
                {
                    if (ce !== 16)
                        break;
                    ue.openToJoinByPlayer = J.int32();
                    continue
                }
            case 3:
                {
                    if (ce !== 24)
                        break;
                    ue.openToInvites = J.int32();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            joinInProgress: isSet$a(V.joinInProgress) ? blazeGameSettingValueFromJSON(V.joinInProgress) : 0,
            openToJoinByPlayer: isSet$a(V.openToJoinByPlayer) ? blazeGameSettingValueFromJSON(V.openToJoinByPlayer) : 0,
            openToInvites: isSet$a(V.openToInvites) ? blazeGameSettingValueFromJSON(V.openToInvites) : 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.joinInProgress !== 0 && (X.joinInProgress = blazeGameSettingValueToJSON(V.joinInProgress)),
        V.openToJoinByPlayer !== 0 && (X.openToJoinByPlayer = blazeGameSettingValueToJSON(V.openToJoinByPlayer)),
        V.openToInvites !== 0 && (X.openToInvites = blazeGameSettingValueToJSON(V.openToInvites)),
        X
    },
    create(V) {
        return BlazeGameSettings.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseBlazeGameSettings();
        return X.joinInProgress = V.joinInProgress ?? 0,
        X.openToJoinByPlayer = V.openToJoinByPlayer ?? 0,
        X.openToInvites = V.openToInvites ?? 0,
        X
    }
};
function createBaseModRules() {
    return {
        compatibleRules: void 0,
        incompatibleRules: void 0,
        errorRules: void 0
    }
}
const ModRules = {
    encode(V, X=new BinaryWriter) {
        return V.compatibleRules !== void 0 && CompatibleModRules.encode(V.compatibleRules, X.uint32(10).fork()).join(),
        V.incompatibleRules !== void 0 && IncompatibleModRules.encode(V.incompatibleRules, X.uint32(18).fork()).join(),
        V.errorRules !== void 0 && ErrorModRules.encode(V.errorRules, X.uint32(26).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseModRules();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.compatibleRules = CompatibleModRules.decode(J, J.uint32());
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.incompatibleRules = IncompatibleModRules.decode(J, J.uint32());
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.errorRules = ErrorModRules.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            compatibleRules: isSet$a(V.compatibleRules) ? CompatibleModRules.fromJSON(V.compatibleRules) : void 0,
            incompatibleRules: isSet$a(V.incompatibleRules) ? IncompatibleModRules.fromJSON(V.incompatibleRules) : void 0,
            errorRules: isSet$a(V.errorRules) ? ErrorModRules.fromJSON(V.errorRules) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.compatibleRules !== void 0 && (X.compatibleRules = CompatibleModRules.toJSON(V.compatibleRules)),
        V.incompatibleRules !== void 0 && (X.incompatibleRules = IncompatibleModRules.toJSON(V.incompatibleRules)),
        V.errorRules !== void 0 && (X.errorRules = ErrorModRules.toJSON(V.errorRules)),
        X
    },
    create(V) {
        return ModRules.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseModRules();
        return X.compatibleRules = V.compatibleRules !== void 0 && V.compatibleRules !== null ? CompatibleModRules.fromPartial(V.compatibleRules) : void 0,
        X.incompatibleRules = V.incompatibleRules !== void 0 && V.incompatibleRules !== null ? IncompatibleModRules.fromPartial(V.incompatibleRules) : void 0,
        X.errorRules = V.errorRules !== void 0 && V.errorRules !== null ? ErrorModRules.fromPartial(V.errorRules) : void 0,
        X
    }
};
function createBaseUncompressed() {
    return {
        compiledModRules: new Uint8Array(0),
        rulesVersion: 0
    }
}
const Uncompressed = {
    encode(V, X=new BinaryWriter) {
        return V.compiledModRules.length !== 0 && X.uint32(10).bytes(V.compiledModRules),
        V.rulesVersion !== 0 && X.uint32(16).int32(V.rulesVersion),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseUncompressed();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.compiledModRules = J.bytes();
                    continue
                }
            case 2:
                {
                    if (ce !== 16)
                        break;
                    ue.rulesVersion = J.int32();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            compiledModRules: isSet$a(V.compiledModRules) ? bytesFromBase64$1(V.compiledModRules) : new Uint8Array(0),
            rulesVersion: isSet$a(V.rulesVersion) ? globalThis.Number(V.rulesVersion) : 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.compiledModRules.length !== 0 && (X.compiledModRules = base64FromBytes$1(V.compiledModRules)),
        V.rulesVersion !== 0 && (X.rulesVersion = Math.round(V.rulesVersion)),
        X
    },
    create(V) {
        return Uncompressed.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseUncompressed();
        return X.compiledModRules = V.compiledModRules ?? new Uint8Array(0),
        X.rulesVersion = V.rulesVersion ?? 0,
        X
    }
};
function createBaseCompressed() {
    return {
        compiledModRules: new Uint8Array(0),
        rulesVersion: 0,
        inflatedSize: 0
    }
}
const Compressed = {
    encode(V, X=new BinaryWriter) {
        return V.compiledModRules.length !== 0 && X.uint32(10).bytes(V.compiledModRules),
        V.rulesVersion !== 0 && X.uint32(16).int32(V.rulesVersion),
        V.inflatedSize !== 0 && X.uint32(24).int32(V.inflatedSize),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseCompressed();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.compiledModRules = J.bytes();
                    continue
                }
            case 2:
                {
                    if (ce !== 16)
                        break;
                    ue.rulesVersion = J.int32();
                    continue
                }
            case 3:
                {
                    if (ce !== 24)
                        break;
                    ue.inflatedSize = J.int32();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            compiledModRules: isSet$a(V.compiledModRules) ? bytesFromBase64$1(V.compiledModRules) : new Uint8Array(0),
            rulesVersion: isSet$a(V.rulesVersion) ? globalThis.Number(V.rulesVersion) : 0,
            inflatedSize: isSet$a(V.inflatedSize) ? globalThis.Number(V.inflatedSize) : 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.compiledModRules.length !== 0 && (X.compiledModRules = base64FromBytes$1(V.compiledModRules)),
        V.rulesVersion !== 0 && (X.rulesVersion = Math.round(V.rulesVersion)),
        V.inflatedSize !== 0 && (X.inflatedSize = Math.round(V.inflatedSize)),
        X
    },
    create(V) {
        return Compressed.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseCompressed();
        return X.compiledModRules = V.compiledModRules ?? new Uint8Array(0),
        X.rulesVersion = V.rulesVersion ?? 0,
        X.inflatedSize = V.inflatedSize ?? 0,
        X
    }
};
function createBaseCompiledRules() {
    return {
        uncompressed: void 0,
        compressed: void 0
    }
}
const CompiledRules = {
    encode(V, X=new BinaryWriter) {
        return V.uncompressed !== void 0 && Uncompressed.encode(V.uncompressed, X.uint32(10).fork()).join(),
        V.compressed !== void 0 && Compressed.encode(V.compressed, X.uint32(18).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseCompiledRules();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.uncompressed = Uncompressed.decode(J, J.uint32());
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.compressed = Compressed.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            uncompressed: isSet$a(V.uncompressed) ? Uncompressed.fromJSON(V.uncompressed) : void 0,
            compressed: isSet$a(V.compressed) ? Compressed.fromJSON(V.compressed) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.uncompressed !== void 0 && (X.uncompressed = Uncompressed.toJSON(V.uncompressed)),
        V.compressed !== void 0 && (X.compressed = Compressed.toJSON(V.compressed)),
        X
    },
    create(V) {
        return CompiledRules.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseCompiledRules();
        return X.uncompressed = V.uncompressed !== void 0 && V.uncompressed !== null ? Uncompressed.fromPartial(V.uncompressed) : void 0,
        X.compressed = V.compressed !== void 0 && V.compressed !== null ? Compressed.fromPartial(V.compressed) : void 0,
        X
    }
};
function createBaseCompatibleModRules() {
    return {
        original: new Uint8Array(0),
        rulesVersion: 0,
        compiled: void 0
    }
}
const CompatibleModRules = {
    encode(V, X=new BinaryWriter) {
        return V.original.length !== 0 && X.uint32(10).bytes(V.original),
        V.rulesVersion !== 0 && X.uint32(16).int32(V.rulesVersion),
        V.compiled !== void 0 && CompiledRules.encode(V.compiled, X.uint32(26).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseCompatibleModRules();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.original = J.bytes();
                    continue
                }
            case 2:
                {
                    if (ce !== 16)
                        break;
                    ue.rulesVersion = J.int32();
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.compiled = CompiledRules.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            original: isSet$a(V.original) ? bytesFromBase64$1(V.original) : new Uint8Array(0),
            rulesVersion: isSet$a(V.rulesVersion) ? globalThis.Number(V.rulesVersion) : 0,
            compiled: isSet$a(V.compiled) ? CompiledRules.fromJSON(V.compiled) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.original.length !== 0 && (X.original = base64FromBytes$1(V.original)),
        V.rulesVersion !== 0 && (X.rulesVersion = Math.round(V.rulesVersion)),
        V.compiled !== void 0 && (X.compiled = CompiledRules.toJSON(V.compiled)),
        X
    },
    create(V) {
        return CompatibleModRules.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseCompatibleModRules();
        return X.original = V.original ?? new Uint8Array(0),
        X.rulesVersion = V.rulesVersion ?? 0,
        X.compiled = V.compiled !== void 0 && V.compiled !== null ? CompiledRules.fromPartial(V.compiled) : void 0,
        X
    }
};
function createBaseIncompatibleModRules() {
    return {
        original: new Uint8Array(0),
        rulesVersion: 0,
        blueprintRulesVersion: 0
    }
}
const IncompatibleModRules = {
    encode(V, X=new BinaryWriter) {
        return V.original.length !== 0 && X.uint32(10).bytes(V.original),
        V.rulesVersion !== 0 && X.uint32(16).int32(V.rulesVersion),
        V.blueprintRulesVersion !== 0 && X.uint32(24).int32(V.blueprintRulesVersion),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseIncompatibleModRules();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.original = J.bytes();
                    continue
                }
            case 2:
                {
                    if (ce !== 16)
                        break;
                    ue.rulesVersion = J.int32();
                    continue
                }
            case 3:
                {
                    if (ce !== 24)
                        break;
                    ue.blueprintRulesVersion = J.int32();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            original: isSet$a(V.original) ? bytesFromBase64$1(V.original) : new Uint8Array(0),
            rulesVersion: isSet$a(V.rulesVersion) ? globalThis.Number(V.rulesVersion) : 0,
            blueprintRulesVersion: isSet$a(V.blueprintRulesVersion) ? globalThis.Number(V.blueprintRulesVersion) : 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.original.length !== 0 && (X.original = base64FromBytes$1(V.original)),
        V.rulesVersion !== 0 && (X.rulesVersion = Math.round(V.rulesVersion)),
        V.blueprintRulesVersion !== 0 && (X.blueprintRulesVersion = Math.round(V.blueprintRulesVersion)),
        X
    },
    create(V) {
        return IncompatibleModRules.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseIncompatibleModRules();
        return X.original = V.original ?? new Uint8Array(0),
        X.rulesVersion = V.rulesVersion ?? 0,
        X.blueprintRulesVersion = V.blueprintRulesVersion ?? 0,
        X
    }
};
function createBaseErrorModRules() {
    return {
        original: new Uint8Array(0),
        errorMessage: void 0
    }
}
const ErrorModRules = {
    encode(V, X=new BinaryWriter) {
        return V.original.length !== 0 && X.uint32(10).bytes(V.original),
        V.errorMessage !== void 0 && StringValue.encode({
            value: V.errorMessage
        }, X.uint32(18).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseErrorModRules();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.original = J.bytes();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.errorMessage = StringValue.decode(J, J.uint32()).value;
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            original: isSet$a(V.original) ? bytesFromBase64$1(V.original) : new Uint8Array(0),
            errorMessage: isSet$a(V.errorMessage) ? String(V.errorMessage) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.original.length !== 0 && (X.original = base64FromBytes$1(V.original)),
        V.errorMessage !== void 0 && (X.errorMessage = V.errorMessage),
        X
    },
    create(V) {
        return ErrorModRules.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseErrorModRules();
        return X.original = V.original ?? new Uint8Array(0),
        X.errorMessage = V.errorMessage ?? void 0,
        X
    }
};
function createBasePlayElementSettings() {
    return {
        secret: void 0,
        messages: [],
        allowCopies: !1
    }
}
const PlayElementSettings = {
    encode(V, X=new BinaryWriter) {
        V.secret !== void 0 && StringValue.encode({
            value: V.secret
        }, X.uint32(10).fork()).join();
        for (const J of V.messages)
            GameServerMessage.encode(J, X.uint32(18).fork()).join();
        return V.allowCopies !== !1 && X.uint32(24).bool(V.allowCopies),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBasePlayElementSettings();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.secret = StringValue.decode(J, J.uint32()).value;
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.messages.push(GameServerMessage.decode(J, J.uint32()));
                    continue
                }
            case 3:
                {
                    if (ce !== 24)
                        break;
                    ue.allowCopies = J.bool();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            secret: isSet$a(V.secret) ? String(V.secret) : void 0,
            messages: globalThis.Array.isArray(V == null ? void 0 : V.messages) ? V.messages.map(X => GameServerMessage.fromJSON(X)) : [],
            allowCopies: isSet$a(V.allowCopies) ? globalThis.Boolean(V.allowCopies) : !1
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return V.secret !== void 0 && (X.secret = V.secret),
        (J = V.messages) != null && J.length && (X.messages = V.messages.map(ne => GameServerMessage.toJSON(ne))),
        V.allowCopies !== !1 && (X.allowCopies = V.allowCopies),
        X
    },
    create(V) {
        return PlayElementSettings.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBasePlayElementSettings();
        return X.secret = V.secret ?? void 0,
        X.messages = ((J = V.messages) == null ? void 0 : J.map(ne => GameServerMessage.fromPartial(ne))) || [],
        X.allowCopies = V.allowCopies ?? !1,
        X
    }
};
function createBaseGameServerMessage() {
    return {
        kind: "",
        text: ""
    }
}
const GameServerMessage = {
    encode(V, X=new BinaryWriter) {
        return V.kind !== "" && X.uint32(10).string(V.kind),
        V.text !== "" && X.uint32(18).string(V.text),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseGameServerMessage();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.kind = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.text = J.string();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            kind: isSet$a(V.kind) ? globalThis.String(V.kind) : "",
            text: isSet$a(V.text) ? globalThis.String(V.text) : ""
        }
    },
    toJSON(V) {
        const X = {};
        return V.kind !== "" && (X.kind = V.kind),
        V.text !== "" && (X.text = V.text),
        X
    },
    create(V) {
        return GameServerMessage.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseGameServerMessage();
        return X.kind = V.kind ?? "",
        X.text = V.text ?? "",
        X
    }
};
function createBaseBlueprint() {
    return {
        blueprintId: void 0,
        name: "",
        availableGameData: void 0,
        availableTags: void 0,
        availableThumbnailUrls: [],
        availableProgressionModeTags: void 0
    }
}
const Blueprint = {
    encode(V, X=new BinaryWriter) {
        V.blueprintId !== void 0 && BlueprintId.encode(V.blueprintId, X.uint32(10).fork()).join(),
        V.name !== "" && X.uint32(18).string(V.name),
        V.availableGameData !== void 0 && AvailableGameData.encode(V.availableGameData, X.uint32(26).fork()).join(),
        V.availableTags !== void 0 && AvailableTags.encode(V.availableTags, X.uint32(34).fork()).join();
        for (const J of V.availableThumbnailUrls)
            X.uint32(42).string(J);
        return V.availableProgressionModeTags !== void 0 && AvailableTags.encode(V.availableProgressionModeTags, X.uint32(50).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseBlueprint();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.blueprintId = BlueprintId.decode(J, J.uint32());
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.name = J.string();
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.availableGameData = AvailableGameData.decode(J, J.uint32());
                    continue
                }
            case 4:
                {
                    if (ce !== 34)
                        break;
                    ue.availableTags = AvailableTags.decode(J, J.uint32());
                    continue
                }
            case 5:
                {
                    if (ce !== 42)
                        break;
                    ue.availableThumbnailUrls.push(J.string());
                    continue
                }
            case 6:
                {
                    if (ce !== 50)
                        break;
                    ue.availableProgressionModeTags = AvailableTags.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            blueprintId: isSet$a(V.blueprintId) ? BlueprintId.fromJSON(V.blueprintId) : void 0,
            name: isSet$a(V.name) ? globalThis.String(V.name) : "",
            availableGameData: isSet$a(V.availableGameData) ? AvailableGameData.fromJSON(V.availableGameData) : void 0,
            availableTags: isSet$a(V.availableTags) ? AvailableTags.fromJSON(V.availableTags) : void 0,
            availableThumbnailUrls: globalThis.Array.isArray(V == null ? void 0 : V.availableThumbnailUrls) ? V.availableThumbnailUrls.map(X => globalThis.String(X)) : [],
            availableProgressionModeTags: isSet$a(V.availableProgressionModeTags) ? AvailableTags.fromJSON(V.availableProgressionModeTags) : void 0
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return V.blueprintId !== void 0 && (X.blueprintId = BlueprintId.toJSON(V.blueprintId)),
        V.name !== "" && (X.name = V.name),
        V.availableGameData !== void 0 && (X.availableGameData = AvailableGameData.toJSON(V.availableGameData)),
        V.availableTags !== void 0 && (X.availableTags = AvailableTags.toJSON(V.availableTags)),
        (J = V.availableThumbnailUrls) != null && J.length && (X.availableThumbnailUrls = V.availableThumbnailUrls),
        V.availableProgressionModeTags !== void 0 && (X.availableProgressionModeTags = AvailableTags.toJSON(V.availableProgressionModeTags)),
        X
    },
    create(V) {
        return Blueprint.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseBlueprint();
        return X.blueprintId = V.blueprintId !== void 0 && V.blueprintId !== null ? BlueprintId.fromPartial(V.blueprintId) : void 0,
        X.name = V.name ?? "",
        X.availableGameData = V.availableGameData !== void 0 && V.availableGameData !== null ? AvailableGameData.fromPartial(V.availableGameData) : void 0,
        X.availableTags = V.availableTags !== void 0 && V.availableTags !== null ? AvailableTags.fromPartial(V.availableTags) : void 0,
        X.availableThumbnailUrls = ((J = V.availableThumbnailUrls) == null ? void 0 : J.map(ne => ne)) || [],
        X.availableProgressionModeTags = V.availableProgressionModeTags !== void 0 && V.availableProgressionModeTags !== null ? AvailableTags.fromPartial(V.availableProgressionModeTags) : void 0,
        X
    }
};
function createBaseBlueprintId() {
    return {
        id: "",
        version: ""
    }
}
const BlueprintId = {
    encode(V, X=new BinaryWriter) {
        return V.id !== "" && X.uint32(10).string(V.id),
        V.version !== "" && X.uint32(18).string(V.version),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseBlueprintId();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.id = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.version = J.string();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            id: isSet$a(V.id) ? globalThis.String(V.id) : "",
            version: isSet$a(V.version) ? globalThis.String(V.version) : ""
        }
    },
    toJSON(V) {
        const X = {};
        return V.id !== "" && (X.id = V.id),
        V.version !== "" && (X.version = V.version),
        X
    },
    create(V) {
        return BlueprintId.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseBlueprintId();
        return X.id = V.id ?? "",
        X.version = V.version ?? "",
        X
    }
};
function createBaseAvailableGameData() {
    return {
        mutators: [],
        maps: [],
        modRules: void 0,
        assetCategories: void 0,
        spatialAssetInfo: void 0
    }
}
const AvailableGameData = {
    encode(V, X=new BinaryWriter) {
        for (const J of V.mutators)
            AvailableMutator.encode(J, X.uint32(10).fork()).join();
        for (const J of V.maps)
            AvailableMapEntry.encode(J, X.uint32(18).fork()).join();
        return V.modRules !== void 0 && ModRulesDefinition.encode(V.modRules, X.uint32(26).fork()).join(),
        V.assetCategories !== void 0 && AvailableAssetCategories.encode(V.assetCategories, X.uint32(34).fork()).join(),
        V.spatialAssetInfo !== void 0 && AssetInfo.encode(V.spatialAssetInfo, X.uint32(42).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseAvailableGameData();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.mutators.push(AvailableMutator.decode(J, J.uint32()));
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.maps.push(AvailableMapEntry.decode(J, J.uint32()));
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.modRules = ModRulesDefinition.decode(J, J.uint32());
                    continue
                }
            case 4:
                {
                    if (ce !== 34)
                        break;
                    ue.assetCategories = AvailableAssetCategories.decode(J, J.uint32());
                    continue
                }
            case 5:
                {
                    if (ce !== 42)
                        break;
                    ue.spatialAssetInfo = AssetInfo.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            mutators: globalThis.Array.isArray(V == null ? void 0 : V.mutators) ? V.mutators.map(X => AvailableMutator.fromJSON(X)) : [],
            maps: globalThis.Array.isArray(V == null ? void 0 : V.maps) ? V.maps.map(X => AvailableMapEntry.fromJSON(X)) : [],
            modRules: isSet$a(V.modRules) ? ModRulesDefinition.fromJSON(V.modRules) : void 0,
            assetCategories: isSet$a(V.assetCategories) ? AvailableAssetCategories.fromJSON(V.assetCategories) : void 0,
            spatialAssetInfo: isSet$a(V.spatialAssetInfo) ? AssetInfo.fromJSON(V.spatialAssetInfo) : void 0
        }
    },
    toJSON(V) {
        var J, ne;
        const X = {};
        return (J = V.mutators) != null && J.length && (X.mutators = V.mutators.map(ue => AvailableMutator.toJSON(ue))),
        (ne = V.maps) != null && ne.length && (X.maps = V.maps.map(ue => AvailableMapEntry.toJSON(ue))),
        V.modRules !== void 0 && (X.modRules = ModRulesDefinition.toJSON(V.modRules)),
        V.assetCategories !== void 0 && (X.assetCategories = AvailableAssetCategories.toJSON(V.assetCategories)),
        V.spatialAssetInfo !== void 0 && (X.spatialAssetInfo = AssetInfo.toJSON(V.spatialAssetInfo)),
        X
    },
    create(V) {
        return AvailableGameData.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J, ne;
        const X = createBaseAvailableGameData();
        return X.mutators = ((J = V.mutators) == null ? void 0 : J.map(ue => AvailableMutator.fromPartial(ue))) || [],
        X.maps = ((ne = V.maps) == null ? void 0 : ne.map(ue => AvailableMapEntry.fromPartial(ue))) || [],
        X.modRules = V.modRules !== void 0 && V.modRules !== null ? ModRulesDefinition.fromPartial(V.modRules) : void 0,
        X.assetCategories = V.assetCategories !== void 0 && V.assetCategories !== null ? AvailableAssetCategories.fromPartial(V.assetCategories) : void 0,
        X.spatialAssetInfo = V.spatialAssetInfo !== void 0 && V.spatialAssetInfo !== null ? AssetInfo.fromPartial(V.spatialAssetInfo) : void 0,
        X
    }
};
function createBaseAvailableTag() {
    return {
        id: "",
        metadata: void 0,
        category: void 0
    }
}
const AvailableTag = {
    encode(V, X=new BinaryWriter) {
        return V.id !== "" && X.uint32(10).string(V.id),
        V.metadata !== void 0 && Metadata.encode(V.metadata, X.uint32(18).fork()).join(),
        V.category !== void 0 && StringValue.encode({
            value: V.category
        }, X.uint32(26).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseAvailableTag();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.id = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.metadata = Metadata.decode(J, J.uint32());
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.category = StringValue.decode(J, J.uint32()).value;
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            id: isSet$a(V.id) ? globalThis.String(V.id) : "",
            metadata: isSet$a(V.metadata) ? Metadata.fromJSON(V.metadata) : void 0,
            category: isSet$a(V.category) ? String(V.category) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.id !== "" && (X.id = V.id),
        V.metadata !== void 0 && (X.metadata = Metadata.toJSON(V.metadata)),
        V.category !== void 0 && (X.category = V.category),
        X
    },
    create(V) {
        return AvailableTag.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseAvailableTag();
        return X.id = V.id ?? "",
        X.metadata = V.metadata !== void 0 && V.metadata !== null ? Metadata.fromPartial(V.metadata) : void 0,
        X.category = V.category ?? void 0,
        X
    }
};
function createBaseAvailableTags() {
    return {
        tags: []
    }
}
const AvailableTags = {
    encode(V, X=new BinaryWriter) {
        for (const J of V.tags)
            AvailableTag.encode(J, X.uint32(10).fork()).join();
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseAvailableTags();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.tags.push(AvailableTag.decode(J, J.uint32()));
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            tags: globalThis.Array.isArray(V == null ? void 0 : V.tags) ? V.tags.map(X => AvailableTag.fromJSON(X)) : []
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return (J = V.tags) != null && J.length && (X.tags = V.tags.map(ne => AvailableTag.toJSON(ne))),
        X
    },
    create(V) {
        return AvailableTags.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseAvailableTags();
        return X.tags = ((J = V.tags) == null ? void 0 : J.map(ne => AvailableTag.fromPartial(ne))) || [],
        X
    }
};
function createBaseAvailableAssetCategories() {
    return {
        rootTags: [],
        tags: []
    }
}
const AvailableAssetCategories = {
    encode(V, X=new BinaryWriter) {
        for (const J of V.rootTags)
            AvailableAssetCategoryTag.encode(J, X.uint32(10).fork()).join();
        for (const J of V.tags)
            AvailableAssetCategoryTag.encode(J, X.uint32(18).fork()).join();
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseAvailableAssetCategories();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.rootTags.push(AvailableAssetCategoryTag.decode(J, J.uint32()));
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.tags.push(AvailableAssetCategoryTag.decode(J, J.uint32()));
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            rootTags: globalThis.Array.isArray(V == null ? void 0 : V.rootTags) ? V.rootTags.map(X => AvailableAssetCategoryTag.fromJSON(X)) : [],
            tags: globalThis.Array.isArray(V == null ? void 0 : V.tags) ? V.tags.map(X => AvailableAssetCategoryTag.fromJSON(X)) : []
        }
    },
    toJSON(V) {
        var J, ne;
        const X = {};
        return (J = V.rootTags) != null && J.length && (X.rootTags = V.rootTags.map(ue => AvailableAssetCategoryTag.toJSON(ue))),
        (ne = V.tags) != null && ne.length && (X.tags = V.tags.map(ue => AvailableAssetCategoryTag.toJSON(ue))),
        X
    },
    create(V) {
        return AvailableAssetCategories.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J, ne;
        const X = createBaseAvailableAssetCategories();
        return X.rootTags = ((J = V.rootTags) == null ? void 0 : J.map(ue => AvailableAssetCategoryTag.fromPartial(ue))) || [],
        X.tags = ((ne = V.tags) == null ? void 0 : ne.map(ue => AvailableAssetCategoryTag.fromPartial(ue))) || [],
        X
    }
};
function createBaseAvailableAssetCategoryTag() {
    return {
        tagId: "",
        name: "",
        childrenTags: [],
        metadata: void 0
    }
}
const AvailableAssetCategoryTag = {
    encode(V, X=new BinaryWriter) {
        V.tagId !== "" && X.uint32(10).string(V.tagId),
        V.name !== "" && X.uint32(18).string(V.name);
        for (const J of V.childrenTags)
            X.uint32(26).string(J);
        return V.metadata !== void 0 && Metadata.encode(V.metadata, X.uint32(34).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseAvailableAssetCategoryTag();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.tagId = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.name = J.string();
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.childrenTags.push(J.string());
                    continue
                }
            case 4:
                {
                    if (ce !== 34)
                        break;
                    ue.metadata = Metadata.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            tagId: isSet$a(V.tagId) ? globalThis.String(V.tagId) : "",
            name: isSet$a(V.name) ? globalThis.String(V.name) : "",
            childrenTags: globalThis.Array.isArray(V == null ? void 0 : V.childrenTags) ? V.childrenTags.map(X => globalThis.String(X)) : [],
            metadata: isSet$a(V.metadata) ? Metadata.fromJSON(V.metadata) : void 0
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return V.tagId !== "" && (X.tagId = V.tagId),
        V.name !== "" && (X.name = V.name),
        (J = V.childrenTags) != null && J.length && (X.childrenTags = V.childrenTags),
        V.metadata !== void 0 && (X.metadata = Metadata.toJSON(V.metadata)),
        X
    },
    create(V) {
        return AvailableAssetCategoryTag.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseAvailableAssetCategoryTag();
        return X.tagId = V.tagId ?? "",
        X.name = V.name ?? "",
        X.childrenTags = ((J = V.childrenTags) == null ? void 0 : J.map(ne => ne)) || [],
        X.metadata = V.metadata !== void 0 && V.metadata !== null ? Metadata.fromPartial(V.metadata) : void 0,
        X
    }
};
function createBaseAvailableMutator() {
    return {
        name: "",
        category: "",
        kind: void 0,
        metadata: void 0,
        id: ""
    }
}
const AvailableMutator = {
    encode(V, X=new BinaryWriter) {
        return V.name !== "" && X.uint32(10).string(V.name),
        V.category !== "" && X.uint32(18).string(V.category),
        V.kind !== void 0 && AvailableMutatorKind.encode(V.kind, X.uint32(26).fork()).join(),
        V.metadata !== void 0 && Metadata.encode(V.metadata, X.uint32(34).fork()).join(),
        V.id !== "" && X.uint32(42).string(V.id),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseAvailableMutator();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.name = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.category = J.string();
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.kind = AvailableMutatorKind.decode(J, J.uint32());
                    continue
                }
            case 4:
                {
                    if (ce !== 34)
                        break;
                    ue.metadata = Metadata.decode(J, J.uint32());
                    continue
                }
            case 5:
                {
                    if (ce !== 42)
                        break;
                    ue.id = J.string();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            name: isSet$a(V.name) ? globalThis.String(V.name) : "",
            category: isSet$a(V.category) ? globalThis.String(V.category) : "",
            kind: isSet$a(V.kind) ? AvailableMutatorKind.fromJSON(V.kind) : void 0,
            metadata: isSet$a(V.metadata) ? Metadata.fromJSON(V.metadata) : void 0,
            id: isSet$a(V.id) ? globalThis.String(V.id) : ""
        }
    },
    toJSON(V) {
        const X = {};
        return V.name !== "" && (X.name = V.name),
        V.category !== "" && (X.category = V.category),
        V.kind !== void 0 && (X.kind = AvailableMutatorKind.toJSON(V.kind)),
        V.metadata !== void 0 && (X.metadata = Metadata.toJSON(V.metadata)),
        V.id !== "" && (X.id = V.id),
        X
    },
    create(V) {
        return AvailableMutator.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseAvailableMutator();
        return X.name = V.name ?? "",
        X.category = V.category ?? "",
        X.kind = V.kind !== void 0 && V.kind !== null ? AvailableMutatorKind.fromPartial(V.kind) : void 0,
        X.metadata = V.metadata !== void 0 && V.metadata !== null ? Metadata.fromPartial(V.metadata) : void 0,
        X.id = V.id ?? "",
        X
    }
};
function createBaseAvailableMapEntry() {
    return {
        levelName: "",
        levelLocation: "",
        gameSize: void 0,
        rounds: void 0,
        allowedSpectators: void 0,
        metadata: void 0,
        allowedTeamsRange: void 0
    }
}
const AvailableMapEntry = {
    encode(V, X=new BinaryWriter) {
        return V.levelName !== "" && X.uint32(10).string(V.levelName),
        V.levelLocation !== "" && X.uint32(18).string(V.levelLocation),
        V.gameSize !== void 0 && AvailableIntValue.encode(V.gameSize, X.uint32(26).fork()).join(),
        V.rounds !== void 0 && AvailableIntValue.encode(V.rounds, X.uint32(34).fork()).join(),
        V.allowedSpectators !== void 0 && AvailableIntValue.encode(V.allowedSpectators, X.uint32(42).fork()).join(),
        V.metadata !== void 0 && Metadata.encode(V.metadata, X.uint32(50).fork()).join(),
        V.allowedTeamsRange !== void 0 && AvailableIntValue.encode(V.allowedTeamsRange, X.uint32(58).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseAvailableMapEntry();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.levelName = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.levelLocation = J.string();
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.gameSize = AvailableIntValue.decode(J, J.uint32());
                    continue
                }
            case 4:
                {
                    if (ce !== 34)
                        break;
                    ue.rounds = AvailableIntValue.decode(J, J.uint32());
                    continue
                }
            case 5:
                {
                    if (ce !== 42)
                        break;
                    ue.allowedSpectators = AvailableIntValue.decode(J, J.uint32());
                    continue
                }
            case 6:
                {
                    if (ce !== 50)
                        break;
                    ue.metadata = Metadata.decode(J, J.uint32());
                    continue
                }
            case 7:
                {
                    if (ce !== 58)
                        break;
                    ue.allowedTeamsRange = AvailableIntValue.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            levelName: isSet$a(V.levelName) ? globalThis.String(V.levelName) : "",
            levelLocation: isSet$a(V.levelLocation) ? globalThis.String(V.levelLocation) : "",
            gameSize: isSet$a(V.gameSize) ? AvailableIntValue.fromJSON(V.gameSize) : void 0,
            rounds: isSet$a(V.rounds) ? AvailableIntValue.fromJSON(V.rounds) : void 0,
            allowedSpectators: isSet$a(V.allowedSpectators) ? AvailableIntValue.fromJSON(V.allowedSpectators) : void 0,
            metadata: isSet$a(V.metadata) ? Metadata.fromJSON(V.metadata) : void 0,
            allowedTeamsRange: isSet$a(V.allowedTeamsRange) ? AvailableIntValue.fromJSON(V.allowedTeamsRange) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.levelName !== "" && (X.levelName = V.levelName),
        V.levelLocation !== "" && (X.levelLocation = V.levelLocation),
        V.gameSize !== void 0 && (X.gameSize = AvailableIntValue.toJSON(V.gameSize)),
        V.rounds !== void 0 && (X.rounds = AvailableIntValue.toJSON(V.rounds)),
        V.allowedSpectators !== void 0 && (X.allowedSpectators = AvailableIntValue.toJSON(V.allowedSpectators)),
        V.metadata !== void 0 && (X.metadata = Metadata.toJSON(V.metadata)),
        V.allowedTeamsRange !== void 0 && (X.allowedTeamsRange = AvailableIntValue.toJSON(V.allowedTeamsRange)),
        X
    },
    create(V) {
        return AvailableMapEntry.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseAvailableMapEntry();
        return X.levelName = V.levelName ?? "",
        X.levelLocation = V.levelLocation ?? "",
        X.gameSize = V.gameSize !== void 0 && V.gameSize !== null ? AvailableIntValue.fromPartial(V.gameSize) : void 0,
        X.rounds = V.rounds !== void 0 && V.rounds !== null ? AvailableIntValue.fromPartial(V.rounds) : void 0,
        X.allowedSpectators = V.allowedSpectators !== void 0 && V.allowedSpectators !== null ? AvailableIntValue.fromPartial(V.allowedSpectators) : void 0,
        X.metadata = V.metadata !== void 0 && V.metadata !== null ? Metadata.fromPartial(V.metadata) : void 0,
        X.allowedTeamsRange = V.allowedTeamsRange !== void 0 && V.allowedTeamsRange !== null ? AvailableIntValue.fromPartial(V.allowedTeamsRange) : void 0,
        X
    }
};
function createBaseAvailableMutatorKind() {
    return {
        mutatorBoolean: void 0,
        mutatorString: void 0,
        mutatorFloatValues: void 0,
        mutatorIntValues: void 0,
        mutatorSparseBoolean: void 0,
        mutatorSparseIntValues: void 0,
        mutatorSparseFloatValues: void 0
    }
}
const AvailableMutatorKind = {
    encode(V, X=new BinaryWriter) {
        return V.mutatorBoolean !== void 0 && MutatorBoolean.encode(V.mutatorBoolean, X.uint32(10).fork()).join(),
        V.mutatorString !== void 0 && MutatorString.encode(V.mutatorString, X.uint32(34).fork()).join(),
        V.mutatorFloatValues !== void 0 && AvailableMutatorFloatValues.encode(V.mutatorFloatValues, X.uint32(58).fork()).join(),
        V.mutatorIntValues !== void 0 && AvailableMutatorIntValues.encode(V.mutatorIntValues, X.uint32(66).fork()).join(),
        V.mutatorSparseBoolean !== void 0 && MutatorSparseBoolean.encode(V.mutatorSparseBoolean, X.uint32(74).fork()).join(),
        V.mutatorSparseIntValues !== void 0 && AvailableMutatorSparseIntValues.encode(V.mutatorSparseIntValues, X.uint32(82).fork()).join(),
        V.mutatorSparseFloatValues !== void 0 && AvailableMutatorSparseFloatValues.encode(V.mutatorSparseFloatValues, X.uint32(90).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseAvailableMutatorKind();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.mutatorBoolean = MutatorBoolean.decode(J, J.uint32());
                    continue
                }
            case 4:
                {
                    if (ce !== 34)
                        break;
                    ue.mutatorString = MutatorString.decode(J, J.uint32());
                    continue
                }
            case 7:
                {
                    if (ce !== 58)
                        break;
                    ue.mutatorFloatValues = AvailableMutatorFloatValues.decode(J, J.uint32());
                    continue
                }
            case 8:
                {
                    if (ce !== 66)
                        break;
                    ue.mutatorIntValues = AvailableMutatorIntValues.decode(J, J.uint32());
                    continue
                }
            case 9:
                {
                    if (ce !== 74)
                        break;
                    ue.mutatorSparseBoolean = MutatorSparseBoolean.decode(J, J.uint32());
                    continue
                }
            case 10:
                {
                    if (ce !== 82)
                        break;
                    ue.mutatorSparseIntValues = AvailableMutatorSparseIntValues.decode(J, J.uint32());
                    continue
                }
            case 11:
                {
                    if (ce !== 90)
                        break;
                    ue.mutatorSparseFloatValues = AvailableMutatorSparseFloatValues.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            mutatorBoolean: isSet$a(V.mutatorBoolean) ? MutatorBoolean.fromJSON(V.mutatorBoolean) : void 0,
            mutatorString: isSet$a(V.mutatorString) ? MutatorString.fromJSON(V.mutatorString) : void 0,
            mutatorFloatValues: isSet$a(V.mutatorFloatValues) ? AvailableMutatorFloatValues.fromJSON(V.mutatorFloatValues) : void 0,
            mutatorIntValues: isSet$a(V.mutatorIntValues) ? AvailableMutatorIntValues.fromJSON(V.mutatorIntValues) : void 0,
            mutatorSparseBoolean: isSet$a(V.mutatorSparseBoolean) ? MutatorSparseBoolean.fromJSON(V.mutatorSparseBoolean) : void 0,
            mutatorSparseIntValues: isSet$a(V.mutatorSparseIntValues) ? AvailableMutatorSparseIntValues.fromJSON(V.mutatorSparseIntValues) : void 0,
            mutatorSparseFloatValues: isSet$a(V.mutatorSparseFloatValues) ? AvailableMutatorSparseFloatValues.fromJSON(V.mutatorSparseFloatValues) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.mutatorBoolean !== void 0 && (X.mutatorBoolean = MutatorBoolean.toJSON(V.mutatorBoolean)),
        V.mutatorString !== void 0 && (X.mutatorString = MutatorString.toJSON(V.mutatorString)),
        V.mutatorFloatValues !== void 0 && (X.mutatorFloatValues = AvailableMutatorFloatValues.toJSON(V.mutatorFloatValues)),
        V.mutatorIntValues !== void 0 && (X.mutatorIntValues = AvailableMutatorIntValues.toJSON(V.mutatorIntValues)),
        V.mutatorSparseBoolean !== void 0 && (X.mutatorSparseBoolean = MutatorSparseBoolean.toJSON(V.mutatorSparseBoolean)),
        V.mutatorSparseIntValues !== void 0 && (X.mutatorSparseIntValues = AvailableMutatorSparseIntValues.toJSON(V.mutatorSparseIntValues)),
        V.mutatorSparseFloatValues !== void 0 && (X.mutatorSparseFloatValues = AvailableMutatorSparseFloatValues.toJSON(V.mutatorSparseFloatValues)),
        X
    },
    create(V) {
        return AvailableMutatorKind.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseAvailableMutatorKind();
        return X.mutatorBoolean = V.mutatorBoolean !== void 0 && V.mutatorBoolean !== null ? MutatorBoolean.fromPartial(V.mutatorBoolean) : void 0,
        X.mutatorString = V.mutatorString !== void 0 && V.mutatorString !== null ? MutatorString.fromPartial(V.mutatorString) : void 0,
        X.mutatorFloatValues = V.mutatorFloatValues !== void 0 && V.mutatorFloatValues !== null ? AvailableMutatorFloatValues.fromPartial(V.mutatorFloatValues) : void 0,
        X.mutatorIntValues = V.mutatorIntValues !== void 0 && V.mutatorIntValues !== null ? AvailableMutatorIntValues.fromPartial(V.mutatorIntValues) : void 0,
        X.mutatorSparseBoolean = V.mutatorSparseBoolean !== void 0 && V.mutatorSparseBoolean !== null ? MutatorSparseBoolean.fromPartial(V.mutatorSparseBoolean) : void 0,
        X.mutatorSparseIntValues = V.mutatorSparseIntValues !== void 0 && V.mutatorSparseIntValues !== null ? AvailableMutatorSparseIntValues.fromPartial(V.mutatorSparseIntValues) : void 0,
        X.mutatorSparseFloatValues = V.mutatorSparseFloatValues !== void 0 && V.mutatorSparseFloatValues !== null ? AvailableMutatorSparseFloatValues.fromPartial(V.mutatorSparseFloatValues) : void 0,
        X
    }
};
function createBaseMutatorSparseInt() {
    return {
        defaultValue: 0,
        size: 0,
        sparseValues: []
    }
}
const MutatorSparseInt = {
    encode(V, X=new BinaryWriter) {
        V.defaultValue !== 0 && X.uint32(8).int32(V.defaultValue),
        V.size !== 0 && X.uint32(16).uint32(V.size);
        for (const J of V.sparseValues)
            MutatorSparseIntEntry.encode(J, X.uint32(26).fork()).join();
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseMutatorSparseInt();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 8)
                        break;
                    ue.defaultValue = J.int32();
                    continue
                }
            case 2:
                {
                    if (ce !== 16)
                        break;
                    ue.size = J.uint32();
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.sparseValues.push(MutatorSparseIntEntry.decode(J, J.uint32()));
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            defaultValue: isSet$a(V.defaultValue) ? globalThis.Number(V.defaultValue) : 0,
            size: isSet$a(V.size) ? globalThis.Number(V.size) : 0,
            sparseValues: globalThis.Array.isArray(V == null ? void 0 : V.sparseValues) ? V.sparseValues.map(X => MutatorSparseIntEntry.fromJSON(X)) : []
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return V.defaultValue !== 0 && (X.defaultValue = Math.round(V.defaultValue)),
        V.size !== 0 && (X.size = Math.round(V.size)),
        (J = V.sparseValues) != null && J.length && (X.sparseValues = V.sparseValues.map(ne => MutatorSparseIntEntry.toJSON(ne))),
        X
    },
    create(V) {
        return MutatorSparseInt.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseMutatorSparseInt();
        return X.defaultValue = V.defaultValue ?? 0,
        X.size = V.size ?? 0,
        X.sparseValues = ((J = V.sparseValues) == null ? void 0 : J.map(ne => MutatorSparseIntEntry.fromPartial(ne))) || [],
        X
    }
};
function createBaseMutatorSparseFloat() {
    return {
        defaultValue: 0,
        size: 0,
        sparseValues: []
    }
}
const MutatorSparseFloat = {
    encode(V, X=new BinaryWriter) {
        V.defaultValue !== 0 && X.uint32(13).float(V.defaultValue),
        V.size !== 0 && X.uint32(16).uint32(V.size);
        for (const J of V.sparseValues)
            MutatorSparseFloatEntry.encode(J, X.uint32(26).fork()).join();
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseMutatorSparseFloat();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 13)
                        break;
                    ue.defaultValue = J.float();
                    continue
                }
            case 2:
                {
                    if (ce !== 16)
                        break;
                    ue.size = J.uint32();
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.sparseValues.push(MutatorSparseFloatEntry.decode(J, J.uint32()));
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            defaultValue: isSet$a(V.defaultValue) ? globalThis.Number(V.defaultValue) : 0,
            size: isSet$a(V.size) ? globalThis.Number(V.size) : 0,
            sparseValues: globalThis.Array.isArray(V == null ? void 0 : V.sparseValues) ? V.sparseValues.map(X => MutatorSparseFloatEntry.fromJSON(X)) : []
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return V.defaultValue !== 0 && (X.defaultValue = V.defaultValue),
        V.size !== 0 && (X.size = Math.round(V.size)),
        (J = V.sparseValues) != null && J.length && (X.sparseValues = V.sparseValues.map(ne => MutatorSparseFloatEntry.toJSON(ne))),
        X
    },
    create(V) {
        return MutatorSparseFloat.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseMutatorSparseFloat();
        return X.defaultValue = V.defaultValue ?? 0,
        X.size = V.size ?? 0,
        X.sparseValues = ((J = V.sparseValues) == null ? void 0 : J.map(ne => MutatorSparseFloatEntry.fromPartial(ne))) || [],
        X
    }
};
function createBaseAvailableMutatorSparseIntValues() {
    return {
        mutator: void 0,
        availableValues: void 0
    }
}
const AvailableMutatorSparseIntValues = {
    encode(V, X=new BinaryWriter) {
        return V.mutator !== void 0 && MutatorSparseInt.encode(V.mutator, X.uint32(10).fork()).join(),
        V.availableValues !== void 0 && AvailableIntValues.encode(V.availableValues, X.uint32(18).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseAvailableMutatorSparseIntValues();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.mutator = MutatorSparseInt.decode(J, J.uint32());
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.availableValues = AvailableIntValues.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            mutator: isSet$a(V.mutator) ? MutatorSparseInt.fromJSON(V.mutator) : void 0,
            availableValues: isSet$a(V.availableValues) ? AvailableIntValues.fromJSON(V.availableValues) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.mutator !== void 0 && (X.mutator = MutatorSparseInt.toJSON(V.mutator)),
        V.availableValues !== void 0 && (X.availableValues = AvailableIntValues.toJSON(V.availableValues)),
        X
    },
    create(V) {
        return AvailableMutatorSparseIntValues.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseAvailableMutatorSparseIntValues();
        return X.mutator = V.mutator !== void 0 && V.mutator !== null ? MutatorSparseInt.fromPartial(V.mutator) : void 0,
        X.availableValues = V.availableValues !== void 0 && V.availableValues !== null ? AvailableIntValues.fromPartial(V.availableValues) : void 0,
        X
    }
};
function createBaseAvailableMutatorSparseFloatValues() {
    return {
        mutator: void 0,
        availableValues: void 0
    }
}
const AvailableMutatorSparseFloatValues = {
    encode(V, X=new BinaryWriter) {
        return V.mutator !== void 0 && MutatorSparseFloat.encode(V.mutator, X.uint32(10).fork()).join(),
        V.availableValues !== void 0 && AvailableFloatValues.encode(V.availableValues, X.uint32(18).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseAvailableMutatorSparseFloatValues();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.mutator = MutatorSparseFloat.decode(J, J.uint32());
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.availableValues = AvailableFloatValues.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            mutator: isSet$a(V.mutator) ? MutatorSparseFloat.fromJSON(V.mutator) : void 0,
            availableValues: isSet$a(V.availableValues) ? AvailableFloatValues.fromJSON(V.availableValues) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.mutator !== void 0 && (X.mutator = MutatorSparseFloat.toJSON(V.mutator)),
        V.availableValues !== void 0 && (X.availableValues = AvailableFloatValues.toJSON(V.availableValues)),
        X
    },
    create(V) {
        return AvailableMutatorSparseFloatValues.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseAvailableMutatorSparseFloatValues();
        return X.mutator = V.mutator !== void 0 && V.mutator !== null ? MutatorSparseFloat.fromPartial(V.mutator) : void 0,
        X.availableValues = V.availableValues !== void 0 && V.availableValues !== null ? AvailableFloatValues.fromPartial(V.availableValues) : void 0,
        X
    }
};
function createBaseMutatorSparseIntEntry() {
    return {
        index: 0,
        value: 0
    }
}
const MutatorSparseIntEntry = {
    encode(V, X=new BinaryWriter) {
        return V.index !== 0 && X.uint32(8).uint32(V.index),
        V.value !== 0 && X.uint32(16).int32(V.value),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseMutatorSparseIntEntry();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 8)
                        break;
                    ue.index = J.uint32();
                    continue
                }
            case 2:
                {
                    if (ce !== 16)
                        break;
                    ue.value = J.int32();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            index: isSet$a(V.index) ? globalThis.Number(V.index) : 0,
            value: isSet$a(V.value) ? globalThis.Number(V.value) : 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.index !== 0 && (X.index = Math.round(V.index)),
        V.value !== 0 && (X.value = Math.round(V.value)),
        X
    },
    create(V) {
        return MutatorSparseIntEntry.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseMutatorSparseIntEntry();
        return X.index = V.index ?? 0,
        X.value = V.value ?? 0,
        X
    }
};
function createBaseMutatorSparseFloatEntry() {
    return {
        index: 0,
        value: 0
    }
}
const MutatorSparseFloatEntry = {
    encode(V, X=new BinaryWriter) {
        return V.index !== 0 && X.uint32(8).uint32(V.index),
        V.value !== 0 && X.uint32(21).float(V.value),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseMutatorSparseFloatEntry();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 8)
                        break;
                    ue.index = J.uint32();
                    continue
                }
            case 2:
                {
                    if (ce !== 21)
                        break;
                    ue.value = J.float();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            index: isSet$a(V.index) ? globalThis.Number(V.index) : 0,
            value: isSet$a(V.value) ? globalThis.Number(V.value) : 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.index !== 0 && (X.index = Math.round(V.index)),
        V.value !== 0 && (X.value = V.value),
        X
    },
    create(V) {
        return MutatorSparseFloatEntry.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseMutatorSparseFloatEntry();
        return X.index = V.index ?? 0,
        X.value = V.value ?? 0,
        X
    }
};
function createBaseAvailableMutatorIntValues() {
    return {
        mutator: void 0,
        availableValues: void 0
    }
}
const AvailableMutatorIntValues = {
    encode(V, X=new BinaryWriter) {
        return V.mutator !== void 0 && MutatorInt.encode(V.mutator, X.uint32(10).fork()).join(),
        V.availableValues !== void 0 && AvailableIntValues.encode(V.availableValues, X.uint32(18).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseAvailableMutatorIntValues();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.mutator = MutatorInt.decode(J, J.uint32());
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.availableValues = AvailableIntValues.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            mutator: isSet$a(V.mutator) ? MutatorInt.fromJSON(V.mutator) : void 0,
            availableValues: isSet$a(V.availableValues) ? AvailableIntValues.fromJSON(V.availableValues) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.mutator !== void 0 && (X.mutator = MutatorInt.toJSON(V.mutator)),
        V.availableValues !== void 0 && (X.availableValues = AvailableIntValues.toJSON(V.availableValues)),
        X
    },
    create(V) {
        return AvailableMutatorIntValues.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseAvailableMutatorIntValues();
        return X.mutator = V.mutator !== void 0 && V.mutator !== null ? MutatorInt.fromPartial(V.mutator) : void 0,
        X.availableValues = V.availableValues !== void 0 && V.availableValues !== null ? AvailableIntValues.fromPartial(V.availableValues) : void 0,
        X
    }
};
function createBaseMutatorInt() {
    return {
        value: 0
    }
}
const MutatorInt = {
    encode(V, X=new BinaryWriter) {
        return V.value !== 0 && X.uint32(8).int32(V.value),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseMutatorInt();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 8)
                        break;
                    ue.value = J.int32();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            value: isSet$a(V.value) ? globalThis.Number(V.value) : 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.value !== 0 && (X.value = Math.round(V.value)),
        X
    },
    create(V) {
        return MutatorInt.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseMutatorInt();
        return X.value = V.value ?? 0,
        X
    }
};
function createBaseAvailableMutatorFloatValues() {
    return {
        mutator: void 0,
        availableValues: void 0
    }
}
const AvailableMutatorFloatValues = {
    encode(V, X=new BinaryWriter) {
        return V.mutator !== void 0 && MutatorFloat.encode(V.mutator, X.uint32(10).fork()).join(),
        V.availableValues !== void 0 && AvailableFloatValues.encode(V.availableValues, X.uint32(18).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseAvailableMutatorFloatValues();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.mutator = MutatorFloat.decode(J, J.uint32());
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.availableValues = AvailableFloatValues.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            mutator: isSet$a(V.mutator) ? MutatorFloat.fromJSON(V.mutator) : void 0,
            availableValues: isSet$a(V.availableValues) ? AvailableFloatValues.fromJSON(V.availableValues) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.mutator !== void 0 && (X.mutator = MutatorFloat.toJSON(V.mutator)),
        V.availableValues !== void 0 && (X.availableValues = AvailableFloatValues.toJSON(V.availableValues)),
        X
    },
    create(V) {
        return AvailableMutatorFloatValues.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseAvailableMutatorFloatValues();
        return X.mutator = V.mutator !== void 0 && V.mutator !== null ? MutatorFloat.fromPartial(V.mutator) : void 0,
        X.availableValues = V.availableValues !== void 0 && V.availableValues !== null ? AvailableFloatValues.fromPartial(V.availableValues) : void 0,
        X
    }
};
function createBaseMutatorFloat() {
    return {
        value: 0
    }
}
const MutatorFloat = {
    encode(V, X=new BinaryWriter) {
        return V.value !== 0 && X.uint32(13).float(V.value),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseMutatorFloat();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 13)
                        break;
                    ue.value = J.float();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            value: isSet$a(V.value) ? globalThis.Number(V.value) : 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.value !== 0 && (X.value = V.value),
        X
    },
    create(V) {
        return MutatorFloat.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseMutatorFloat();
        return X.value = V.value ?? 0,
        X
    }
};
function createBaseMutatorBoolean() {
    return {
        value: !1
    }
}
const MutatorBoolean = {
    encode(V, X=new BinaryWriter) {
        return V.value !== !1 && X.uint32(8).bool(V.value),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseMutatorBoolean();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 8)
                        break;
                    ue.value = J.bool();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            value: isSet$a(V.value) ? globalThis.Boolean(V.value) : !1
        }
    },
    toJSON(V) {
        const X = {};
        return V.value !== !1 && (X.value = V.value),
        X
    },
    create(V) {
        return MutatorBoolean.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseMutatorBoolean();
        return X.value = V.value ?? !1,
        X
    }
};
function createBaseMutatorString() {
    return {
        value: ""
    }
}
const MutatorString = {
    encode(V, X=new BinaryWriter) {
        return V.value !== "" && X.uint32(10).string(V.value),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseMutatorString();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.value = J.string();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            value: isSet$a(V.value) ? globalThis.String(V.value) : ""
        }
    },
    toJSON(V) {
        const X = {};
        return V.value !== "" && (X.value = V.value),
        X
    },
    create(V) {
        return MutatorString.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseMutatorString();
        return X.value = V.value ?? "",
        X
    }
};
function createBaseMutatorSparseBoolean() {
    return {
        defaultValue: !1,
        size: 0,
        sparseValues: []
    }
}
const MutatorSparseBoolean = {
    encode(V, X=new BinaryWriter) {
        V.defaultValue !== !1 && X.uint32(8).bool(V.defaultValue),
        V.size !== 0 && X.uint32(16).uint32(V.size);
        for (const J of V.sparseValues)
            MutatorSparseBooleanEntry.encode(J, X.uint32(26).fork()).join();
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseMutatorSparseBoolean();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 8)
                        break;
                    ue.defaultValue = J.bool();
                    continue
                }
            case 2:
                {
                    if (ce !== 16)
                        break;
                    ue.size = J.uint32();
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.sparseValues.push(MutatorSparseBooleanEntry.decode(J, J.uint32()));
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            defaultValue: isSet$a(V.defaultValue) ? globalThis.Boolean(V.defaultValue) : !1,
            size: isSet$a(V.size) ? globalThis.Number(V.size) : 0,
            sparseValues: globalThis.Array.isArray(V == null ? void 0 : V.sparseValues) ? V.sparseValues.map(X => MutatorSparseBooleanEntry.fromJSON(X)) : []
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return V.defaultValue !== !1 && (X.defaultValue = V.defaultValue),
        V.size !== 0 && (X.size = Math.round(V.size)),
        (J = V.sparseValues) != null && J.length && (X.sparseValues = V.sparseValues.map(ne => MutatorSparseBooleanEntry.toJSON(ne))),
        X
    },
    create(V) {
        return MutatorSparseBoolean.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseMutatorSparseBoolean();
        return X.defaultValue = V.defaultValue ?? !1,
        X.size = V.size ?? 0,
        X.sparseValues = ((J = V.sparseValues) == null ? void 0 : J.map(ne => MutatorSparseBooleanEntry.fromPartial(ne))) || [],
        X
    }
};
function createBaseMutatorSparseBooleanEntry() {
    return {
        index: 0,
        value: !1
    }
}
const MutatorSparseBooleanEntry = {
    encode(V, X=new BinaryWriter) {
        return V.index !== 0 && X.uint32(8).uint32(V.index),
        V.value !== !1 && X.uint32(16).bool(V.value),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseMutatorSparseBooleanEntry();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 8)
                        break;
                    ue.index = J.uint32();
                    continue
                }
            case 2:
                {
                    if (ce !== 16)
                        break;
                    ue.value = J.bool();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            index: isSet$a(V.index) ? globalThis.Number(V.index) : 0,
            value: isSet$a(V.value) ? globalThis.Boolean(V.value) : !1
        }
    },
    toJSON(V) {
        const X = {};
        return V.index !== 0 && (X.index = Math.round(V.index)),
        V.value !== !1 && (X.value = V.value),
        X
    },
    create(V) {
        return MutatorSparseBooleanEntry.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseMutatorSparseBooleanEntry();
        return X.index = V.index ?? 0,
        X.value = V.value ?? !1,
        X
    }
};
function createBaseAvailableIntValue() {
    return {
        defaultValue: 0,
        availableValues: void 0
    }
}
const AvailableIntValue = {
    encode(V, X=new BinaryWriter) {
        return V.defaultValue !== 0 && X.uint32(8).int32(V.defaultValue),
        V.availableValues !== void 0 && AvailableIntValues.encode(V.availableValues, X.uint32(18).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseAvailableIntValue();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 8)
                        break;
                    ue.defaultValue = J.int32();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.availableValues = AvailableIntValues.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            defaultValue: isSet$a(V.defaultValue) ? globalThis.Number(V.defaultValue) : 0,
            availableValues: isSet$a(V.availableValues) ? AvailableIntValues.fromJSON(V.availableValues) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.defaultValue !== 0 && (X.defaultValue = Math.round(V.defaultValue)),
        V.availableValues !== void 0 && (X.availableValues = AvailableIntValues.toJSON(V.availableValues)),
        X
    },
    create(V) {
        return AvailableIntValue.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseAvailableIntValue();
        return X.defaultValue = V.defaultValue ?? 0,
        X.availableValues = V.availableValues !== void 0 && V.availableValues !== null ? AvailableIntValues.fromPartial(V.availableValues) : void 0,
        X
    }
};
function createBaseAvailableIntValues() {
    return {
        range: void 0,
        sparseValues: void 0
    }
}
const AvailableIntValues = {
    encode(V, X=new BinaryWriter) {
        return V.range !== void 0 && IntRange.encode(V.range, X.uint32(10).fork()).join(),
        V.sparseValues !== void 0 && SparseIntValues.encode(V.sparseValues, X.uint32(18).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseAvailableIntValues();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.range = IntRange.decode(J, J.uint32());
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.sparseValues = SparseIntValues.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            range: isSet$a(V.range) ? IntRange.fromJSON(V.range) : void 0,
            sparseValues: isSet$a(V.sparseValues) ? SparseIntValues.fromJSON(V.sparseValues) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.range !== void 0 && (X.range = IntRange.toJSON(V.range)),
        V.sparseValues !== void 0 && (X.sparseValues = SparseIntValues.toJSON(V.sparseValues)),
        X
    },
    create(V) {
        return AvailableIntValues.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseAvailableIntValues();
        return X.range = V.range !== void 0 && V.range !== null ? IntRange.fromPartial(V.range) : void 0,
        X.sparseValues = V.sparseValues !== void 0 && V.sparseValues !== null ? SparseIntValues.fromPartial(V.sparseValues) : void 0,
        X
    }
};
function createBaseAvailableFloatValues() {
    return {
        range: void 0,
        sparseValues: void 0
    }
}
const AvailableFloatValues = {
    encode(V, X=new BinaryWriter) {
        return V.range !== void 0 && FloatRange.encode(V.range, X.uint32(10).fork()).join(),
        V.sparseValues !== void 0 && SparseFloatValues.encode(V.sparseValues, X.uint32(18).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseAvailableFloatValues();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.range = FloatRange.decode(J, J.uint32());
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.sparseValues = SparseFloatValues.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            range: isSet$a(V.range) ? FloatRange.fromJSON(V.range) : void 0,
            sparseValues: isSet$a(V.sparseValues) ? SparseFloatValues.fromJSON(V.sparseValues) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.range !== void 0 && (X.range = FloatRange.toJSON(V.range)),
        V.sparseValues !== void 0 && (X.sparseValues = SparseFloatValues.toJSON(V.sparseValues)),
        X
    },
    create(V) {
        return AvailableFloatValues.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseAvailableFloatValues();
        return X.range = V.range !== void 0 && V.range !== null ? FloatRange.fromPartial(V.range) : void 0,
        X.sparseValues = V.sparseValues !== void 0 && V.sparseValues !== null ? SparseFloatValues.fromPartial(V.sparseValues) : void 0,
        X
    }
};
function createBaseIntRange() {
    return {
        minValue: 0,
        maxValue: 0
    }
}
const IntRange = {
    encode(V, X=new BinaryWriter) {
        return V.minValue !== 0 && X.uint32(8).int32(V.minValue),
        V.maxValue !== 0 && X.uint32(16).int32(V.maxValue),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseIntRange();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 8)
                        break;
                    ue.minValue = J.int32();
                    continue
                }
            case 2:
                {
                    if (ce !== 16)
                        break;
                    ue.maxValue = J.int32();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            minValue: isSet$a(V.minValue) ? globalThis.Number(V.minValue) : 0,
            maxValue: isSet$a(V.maxValue) ? globalThis.Number(V.maxValue) : 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.minValue !== 0 && (X.minValue = Math.round(V.minValue)),
        V.maxValue !== 0 && (X.maxValue = Math.round(V.maxValue)),
        X
    },
    create(V) {
        return IntRange.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseIntRange();
        return X.minValue = V.minValue ?? 0,
        X.maxValue = V.maxValue ?? 0,
        X
    }
};
function createBaseFloatRange() {
    return {
        minValue: 0,
        maxValue: 0
    }
}
const FloatRange = {
    encode(V, X=new BinaryWriter) {
        return V.minValue !== 0 && X.uint32(13).float(V.minValue),
        V.maxValue !== 0 && X.uint32(21).float(V.maxValue),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseFloatRange();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 13)
                        break;
                    ue.minValue = J.float();
                    continue
                }
            case 2:
                {
                    if (ce !== 21)
                        break;
                    ue.maxValue = J.float();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            minValue: isSet$a(V.minValue) ? globalThis.Number(V.minValue) : 0,
            maxValue: isSet$a(V.maxValue) ? globalThis.Number(V.maxValue) : 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.minValue !== 0 && (X.minValue = V.minValue),
        V.maxValue !== 0 && (X.maxValue = V.maxValue),
        X
    },
    create(V) {
        return FloatRange.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseFloatRange();
        return X.minValue = V.minValue ?? 0,
        X.maxValue = V.maxValue ?? 0,
        X
    }
};
function createBaseSparseIntValues() {
    return {
        values: []
    }
}
const SparseIntValues = {
    encode(V, X=new BinaryWriter) {
        X.uint32(10).fork();
        for (const J of V.values)
            X.int32(J);
        return X.join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseSparseIntValues();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce === 8) {
                        ue.values.push(J.int32());
                        continue
                    }
                    if (ce === 10) {
                        const me = J.uint32() + J.pos;
                        for (; J.pos < me; )
                            ue.values.push(J.int32());
                        continue
                    }
                    break
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            values: globalThis.Array.isArray(V == null ? void 0 : V.values) ? V.values.map(X => globalThis.Number(X)) : []
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return (J = V.values) != null && J.length && (X.values = V.values.map(ne => Math.round(ne))),
        X
    },
    create(V) {
        return SparseIntValues.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseSparseIntValues();
        return X.values = ((J = V.values) == null ? void 0 : J.map(ne => ne)) || [],
        X
    }
};
function createBaseSparseFloatValues() {
    return {
        values: []
    }
}
const SparseFloatValues = {
    encode(V, X=new BinaryWriter) {
        X.uint32(10).fork();
        for (const J of V.values)
            X.float(J);
        return X.join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseSparseFloatValues();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce === 13) {
                        ue.values.push(J.float());
                        continue
                    }
                    if (ce === 10) {
                        const me = J.uint32() + J.pos;
                        for (; J.pos < me; )
                            ue.values.push(J.float());
                        continue
                    }
                    break
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            values: globalThis.Array.isArray(V == null ? void 0 : V.values) ? V.values.map(X => globalThis.Number(X)) : []
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return (J = V.values) != null && J.length && (X.values = V.values),
        X
    },
    create(V) {
        return SparseFloatValues.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseSparseFloatValues();
        return X.values = ((J = V.values) == null ? void 0 : J.map(ne => ne)) || [],
        X
    }
};
function createBaseMetadata() {
    return {
        translations: [],
        resources: []
    }
}
const Metadata = {
    encode(V, X=new BinaryWriter) {
        for (const J of V.translations)
            TranslationMetadata.encode(J, X.uint32(10).fork()).join();
        for (const J of V.resources)
            Resource.encode(J, X.uint32(18).fork()).join();
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseMetadata();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.translations.push(TranslationMetadata.decode(J, J.uint32()));
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.resources.push(Resource.decode(J, J.uint32()));
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            translations: globalThis.Array.isArray(V == null ? void 0 : V.translations) ? V.translations.map(X => TranslationMetadata.fromJSON(X)) : [],
            resources: globalThis.Array.isArray(V == null ? void 0 : V.resources) ? V.resources.map(X => Resource.fromJSON(X)) : []
        }
    },
    toJSON(V) {
        var J, ne;
        const X = {};
        return (J = V.translations) != null && J.length && (X.translations = V.translations.map(ue => TranslationMetadata.toJSON(ue))),
        (ne = V.resources) != null && ne.length && (X.resources = V.resources.map(ue => Resource.toJSON(ue))),
        X
    },
    create(V) {
        return Metadata.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J, ne;
        const X = createBaseMetadata();
        return X.translations = ((J = V.translations) == null ? void 0 : J.map(ue => TranslationMetadata.fromPartial(ue))) || [],
        X.resources = ((ne = V.resources) == null ? void 0 : ne.map(ue => Resource.fromPartial(ue))) || [],
        X
    }
};
function createBaseTranslationMetadata() {
    return {
        kind: "",
        translationId: ""
    }
}
const TranslationMetadata = {
    encode(V, X=new BinaryWriter) {
        return V.kind !== "" && X.uint32(10).string(V.kind),
        V.translationId !== "" && X.uint32(18).string(V.translationId),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseTranslationMetadata();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.kind = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.translationId = J.string();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            kind: isSet$a(V.kind) ? globalThis.String(V.kind) : "",
            translationId: isSet$a(V.translationId) ? globalThis.String(V.translationId) : ""
        }
    },
    toJSON(V) {
        const X = {};
        return V.kind !== "" && (X.kind = V.kind),
        V.translationId !== "" && (X.translationId = V.translationId),
        X
    },
    create(V) {
        return TranslationMetadata.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseTranslationMetadata();
        return X.kind = V.kind ?? "",
        X.translationId = V.translationId ?? "",
        X
    }
};
function createBaseResource() {
    return {
        location: void 0,
        kind: ""
    }
}
const Resource = {
    encode(V, X=new BinaryWriter) {
        return V.location !== void 0 && ResourceLocation.encode(V.location, X.uint32(10).fork()).join(),
        V.kind !== "" && X.uint32(18).string(V.kind),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseResource();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.location = ResourceLocation.decode(J, J.uint32());
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.kind = J.string();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            location: isSet$a(V.location) ? ResourceLocation.fromJSON(V.location) : void 0,
            kind: isSet$a(V.kind) ? globalThis.String(V.kind) : ""
        }
    },
    toJSON(V) {
        const X = {};
        return V.location !== void 0 && (X.location = ResourceLocation.toJSON(V.location)),
        V.kind !== "" && (X.kind = V.kind),
        X
    },
    create(V) {
        return Resource.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseResource();
        return X.location = V.location !== void 0 && V.location !== null ? ResourceLocation.fromPartial(V.location) : void 0,
        X.kind = V.kind ?? "",
        X
    }
};
function createBaseModRulesDefinition() {
    return {
        rulesVersion: 0,
        modBuilder: new Uint8Array(0)
    }
}
const ModRulesDefinition = {
    encode(V, X=new BinaryWriter) {
        return V.rulesVersion !== 0 && X.uint32(8).int32(V.rulesVersion),
        V.modBuilder.length !== 0 && X.uint32(18).bytes(V.modBuilder),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseModRulesDefinition();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 8)
                        break;
                    ue.rulesVersion = J.int32();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.modBuilder = J.bytes();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            rulesVersion: isSet$a(V.rulesVersion) ? globalThis.Number(V.rulesVersion) : 0,
            modBuilder: isSet$a(V.modBuilder) ? bytesFromBase64$1(V.modBuilder) : new Uint8Array(0)
        }
    },
    toJSON(V) {
        const X = {};
        return V.rulesVersion !== 0 && (X.rulesVersion = Math.round(V.rulesVersion)),
        V.modBuilder.length !== 0 && (X.modBuilder = base64FromBytes$1(V.modBuilder)),
        X
    },
    create(V) {
        return ModRulesDefinition.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseModRulesDefinition();
        return X.rulesVersion = V.rulesVersion ?? 0,
        X.modBuilder = V.modBuilder ?? new Uint8Array(0),
        X
    }
};
function createBaseModDataVersionBuildInfo() {
    return {
        pipelineVersion: "",
        pending: void 0,
        noBuildAvailable: void 0,
        error: void 0,
        success: void 0
    }
}
const ModDataVersionBuildInfo = {
    encode(V, X=new BinaryWriter) {
        return V.pipelineVersion !== "" && X.uint32(10).string(V.pipelineVersion),
        V.pending !== void 0 && Empty.encode(V.pending, X.uint32(26).fork()).join(),
        V.noBuildAvailable !== void 0 && Empty.encode(V.noBuildAvailable, X.uint32(34).fork()).join(),
        V.error !== void 0 && BuildStatusError.encode(V.error, X.uint32(42).fork()).join(),
        V.success !== void 0 && BuildStatusSuccess.encode(V.success, X.uint32(50).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseModDataVersionBuildInfo();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.pipelineVersion = J.string();
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.pending = Empty.decode(J, J.uint32());
                    continue
                }
            case 4:
                {
                    if (ce !== 34)
                        break;
                    ue.noBuildAvailable = Empty.decode(J, J.uint32());
                    continue
                }
            case 5:
                {
                    if (ce !== 42)
                        break;
                    ue.error = BuildStatusError.decode(J, J.uint32());
                    continue
                }
            case 6:
                {
                    if (ce !== 50)
                        break;
                    ue.success = BuildStatusSuccess.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            pipelineVersion: isSet$a(V.pipelineVersion) ? globalThis.String(V.pipelineVersion) : "",
            pending: isSet$a(V.pending) ? Empty.fromJSON(V.pending) : void 0,
            noBuildAvailable: isSet$a(V.noBuildAvailable) ? Empty.fromJSON(V.noBuildAvailable) : void 0,
            error: isSet$a(V.error) ? BuildStatusError.fromJSON(V.error) : void 0,
            success: isSet$a(V.success) ? BuildStatusSuccess.fromJSON(V.success) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.pipelineVersion !== "" && (X.pipelineVersion = V.pipelineVersion),
        V.pending !== void 0 && (X.pending = Empty.toJSON(V.pending)),
        V.noBuildAvailable !== void 0 && (X.noBuildAvailable = Empty.toJSON(V.noBuildAvailable)),
        V.error !== void 0 && (X.error = BuildStatusError.toJSON(V.error)),
        V.success !== void 0 && (X.success = BuildStatusSuccess.toJSON(V.success)),
        X
    },
    create(V) {
        return ModDataVersionBuildInfo.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseModDataVersionBuildInfo();
        return X.pipelineVersion = V.pipelineVersion ?? "",
        X.pending = V.pending !== void 0 && V.pending !== null ? Empty.fromPartial(V.pending) : void 0,
        X.noBuildAvailable = V.noBuildAvailable !== void 0 && V.noBuildAvailable !== null ? Empty.fromPartial(V.noBuildAvailable) : void 0,
        X.error = V.error !== void 0 && V.error !== null ? BuildStatusError.fromPartial(V.error) : void 0,
        X.success = V.success !== void 0 && V.success !== null ? BuildStatusSuccess.fromPartial(V.success) : void 0,
        X
    }
};
function createBaseModDataVersion() {
    return {
        id: "",
        playElementId: "",
        created: void 0,
        buildInfo: void 0
    }
}
const ModDataVersion = {
    encode(V, X=new BinaryWriter) {
        return V.id !== "" && X.uint32(10).string(V.id),
        V.playElementId !== "" && X.uint32(18).string(V.playElementId),
        V.created !== void 0 && Timestamp.encode(toTimestamp$3(V.created), X.uint32(26).fork()).join(),
        V.buildInfo !== void 0 && ModDataVersionBuildInfo.encode(V.buildInfo, X.uint32(34).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseModDataVersion();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.id = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.playElementId = J.string();
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.created = fromTimestamp$3(Timestamp.decode(J, J.uint32()));
                    continue
                }
            case 4:
                {
                    if (ce !== 34)
                        break;
                    ue.buildInfo = ModDataVersionBuildInfo.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            id: isSet$a(V.id) ? globalThis.String(V.id) : "",
            playElementId: isSet$a(V.playElementId) ? globalThis.String(V.playElementId) : "",
            created: isSet$a(V.created) ? fromJsonTimestamp$3(V.created) : void 0,
            buildInfo: isSet$a(V.buildInfo) ? ModDataVersionBuildInfo.fromJSON(V.buildInfo) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.id !== "" && (X.id = V.id),
        V.playElementId !== "" && (X.playElementId = V.playElementId),
        V.created !== void 0 && (X.created = V.created.toISOString()),
        V.buildInfo !== void 0 && (X.buildInfo = ModDataVersionBuildInfo.toJSON(V.buildInfo)),
        X
    },
    create(V) {
        return ModDataVersion.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseModDataVersion();
        return X.id = V.id ?? "",
        X.playElementId = V.playElementId ?? "",
        X.created = V.created ?? void 0,
        X.buildInfo = V.buildInfo !== void 0 && V.buildInfo !== null ? ModDataVersionBuildInfo.fromPartial(V.buildInfo) : void 0,
        X
    }
};
function createBaseBuildStatusError() {
    return {
        errorMessage: ""
    }
}
const BuildStatusError = {
    encode(V, X=new BinaryWriter) {
        return V.errorMessage !== "" && X.uint32(10).string(V.errorMessage),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseBuildStatusError();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.errorMessage = J.string();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            errorMessage: isSet$a(V.errorMessage) ? globalThis.String(V.errorMessage) : ""
        }
    },
    toJSON(V) {
        const X = {};
        return V.errorMessage !== "" && (X.errorMessage = V.errorMessage),
        X
    },
    create(V) {
        return BuildStatusError.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseBuildStatusError();
        return X.errorMessage = V.errorMessage ?? "",
        X
    }
};
function createBaseBuildStatusSuccess() {
    return {}
}
const BuildStatusSuccess = {
    encode(V, X=new BinaryWriter) {
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseBuildStatusSuccess();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {}
    },
    toJSON(V) {
        return {}
    },
    create(V) {
        return BuildStatusSuccess.fromPartial(V ?? {})
    },
    fromPartial(V) {
        return createBaseBuildStatusSuccess()
    }
};
function createBaseMapEntryRequirement() {
    return {
        levelName: "",
        levelLocation: "",
        licenseRequirements: []
    }
}
const MapEntryRequirement = {
    encode(V, X=new BinaryWriter) {
        V.levelName !== "" && X.uint32(10).string(V.levelName),
        V.levelLocation !== "" && X.uint32(18).string(V.levelLocation);
        for (const J of V.licenseRequirements)
            X.uint32(26).string(J);
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseMapEntryRequirement();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.levelName = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.levelLocation = J.string();
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.licenseRequirements.push(J.string());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            levelName: isSet$a(V.levelName) ? globalThis.String(V.levelName) : "",
            levelLocation: isSet$a(V.levelLocation) ? globalThis.String(V.levelLocation) : "",
            licenseRequirements: globalThis.Array.isArray(V == null ? void 0 : V.licenseRequirements) ? V.licenseRequirements.map(X => globalThis.String(X)) : []
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return V.levelName !== "" && (X.levelName = V.levelName),
        V.levelLocation !== "" && (X.levelLocation = V.levelLocation),
        (J = V.licenseRequirements) != null && J.length && (X.licenseRequirements = V.licenseRequirements),
        X
    },
    create(V) {
        return MapEntryRequirement.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseMapEntryRequirement();
        return X.levelName = V.levelName ?? "",
        X.levelLocation = V.levelLocation ?? "",
        X.licenseRequirements = ((J = V.licenseRequirements) == null ? void 0 : J.map(ne => ne)) || [],
        X
    }
};
function createBasePrefab() {
    return {
        prefabInstance: "",
        prefabPartition: "",
        prefabType: "",
        gemInstance: "",
        gemPartition: "",
        gemType: ""
    }
}
const Prefab = {
    encode(V, X=new BinaryWriter) {
        return V.prefabInstance !== "" && X.uint32(10).string(V.prefabInstance),
        V.prefabPartition !== "" && X.uint32(18).string(V.prefabPartition),
        V.prefabType !== "" && X.uint32(26).string(V.prefabType),
        V.gemInstance !== "" && X.uint32(34).string(V.gemInstance),
        V.gemPartition !== "" && X.uint32(42).string(V.gemPartition),
        V.gemType !== "" && X.uint32(50).string(V.gemType),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBasePrefab();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.prefabInstance = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.prefabPartition = J.string();
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.prefabType = J.string();
                    continue
                }
            case 4:
                {
                    if (ce !== 34)
                        break;
                    ue.gemInstance = J.string();
                    continue
                }
            case 5:
                {
                    if (ce !== 42)
                        break;
                    ue.gemPartition = J.string();
                    continue
                }
            case 6:
                {
                    if (ce !== 50)
                        break;
                    ue.gemType = J.string();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            prefabInstance: isSet$a(V.prefabInstance) ? globalThis.String(V.prefabInstance) : "",
            prefabPartition: isSet$a(V.prefabPartition) ? globalThis.String(V.prefabPartition) : "",
            prefabType: isSet$a(V.prefabType) ? globalThis.String(V.prefabType) : "",
            gemInstance: isSet$a(V.gemInstance) ? globalThis.String(V.gemInstance) : "",
            gemPartition: isSet$a(V.gemPartition) ? globalThis.String(V.gemPartition) : "",
            gemType: isSet$a(V.gemType) ? globalThis.String(V.gemType) : ""
        }
    },
    toJSON(V) {
        const X = {};
        return V.prefabInstance !== "" && (X.prefabInstance = V.prefabInstance),
        V.prefabPartition !== "" && (X.prefabPartition = V.prefabPartition),
        V.prefabType !== "" && (X.prefabType = V.prefabType),
        V.gemInstance !== "" && (X.gemInstance = V.gemInstance),
        V.gemPartition !== "" && (X.gemPartition = V.gemPartition),
        V.gemType !== "" && (X.gemType = V.gemType),
        X
    },
    create(V) {
        return Prefab.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBasePrefab();
        return X.prefabInstance = V.prefabInstance ?? "",
        X.prefabPartition = V.prefabPartition ?? "",
        X.prefabType = V.prefabType ?? "",
        X.gemInstance = V.gemInstance ?? "",
        X.gemPartition = V.gemPartition ?? "",
        X.gemType = V.gemType ?? "",
        X
    }
};
function createBaseEntityList() {
    return {
        entity: []
    }
}
const EntityList = {
    encode(V, X=new BinaryWriter) {
        for (const J of V.entity)
            X.uint32(10).string(J);
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseEntityList();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.entity.push(J.string());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            entity: globalThis.Array.isArray(V == null ? void 0 : V.entity) ? V.entity.map(X => globalThis.String(X)) : []
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return (J = V.entity) != null && J.length && (X.entity = V.entity),
        X
    },
    create(V) {
        return EntityList.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseEntityList();
        return X.entity = ((J = V.entity) == null ? void 0 : J.map(ne => ne)) || [],
        X
    }
};
function createBaseAssetInfo() {
    return {
        entities: {},
        prefabs: {}
    }
}
const AssetInfo = {
    encode(V, X=new BinaryWriter) {
        return Object.entries(V.entities).forEach( ([J,ne]) => {
            AssetInfo_EntitiesEntry.encode({
                key: J,
                value: ne
            }, X.uint32(10).fork()).join()
        }
        ),
        Object.entries(V.prefabs).forEach( ([J,ne]) => {
            AssetInfo_PrefabsEntry.encode({
                key: J,
                value: ne
            }, X.uint32(18).fork()).join()
        }
        ),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseAssetInfo();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    const me = AssetInfo_EntitiesEntry.decode(J, J.uint32());
                    me.value !== void 0 && (ue.entities[me.key] = me.value);
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    const me = AssetInfo_PrefabsEntry.decode(J, J.uint32());
                    me.value !== void 0 && (ue.prefabs[me.key] = me.value);
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            entities: isObject$2(V.entities) ? Object.entries(V.entities).reduce( (X, [J,ne]) => (X[J] = EntityList.fromJSON(ne),
            X), {}) : {},
            prefabs: isObject$2(V.prefabs) ? Object.entries(V.prefabs).reduce( (X, [J,ne]) => (X[J] = Prefab.fromJSON(ne),
            X), {}) : {}
        }
    },
    toJSON(V) {
        const X = {};
        if (V.entities) {
            const J = Object.entries(V.entities);
            J.length > 0 && (X.entities = {},
            J.forEach( ([ne,ue]) => {
                X.entities[ne] = EntityList.toJSON(ue)
            }
            ))
        }
        if (V.prefabs) {
            const J = Object.entries(V.prefabs);
            J.length > 0 && (X.prefabs = {},
            J.forEach( ([ne,ue]) => {
                X.prefabs[ne] = Prefab.toJSON(ue)
            }
            ))
        }
        return X
    },
    create(V) {
        return AssetInfo.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseAssetInfo();
        return X.entities = Object.entries(V.entities ?? {}).reduce( (J, [ne,ue]) => (ue !== void 0 && (J[ne] = EntityList.fromPartial(ue)),
        J), {}),
        X.prefabs = Object.entries(V.prefabs ?? {}).reduce( (J, [ne,ue]) => (ue !== void 0 && (J[ne] = Prefab.fromPartial(ue)),
        J), {}),
        X
    }
};
function createBaseAssetInfo_EntitiesEntry() {
    return {
        key: "",
        value: void 0
    }
}
const AssetInfo_EntitiesEntry = {
    encode(V, X=new BinaryWriter) {
        return V.key !== "" && X.uint32(10).string(V.key),
        V.value !== void 0 && EntityList.encode(V.value, X.uint32(18).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseAssetInfo_EntitiesEntry();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.key = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.value = EntityList.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            key: isSet$a(V.key) ? globalThis.String(V.key) : "",
            value: isSet$a(V.value) ? EntityList.fromJSON(V.value) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.key !== "" && (X.key = V.key),
        V.value !== void 0 && (X.value = EntityList.toJSON(V.value)),
        X
    },
    create(V) {
        return AssetInfo_EntitiesEntry.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseAssetInfo_EntitiesEntry();
        return X.key = V.key ?? "",
        X.value = V.value !== void 0 && V.value !== null ? EntityList.fromPartial(V.value) : void 0,
        X
    }
};
function createBaseAssetInfo_PrefabsEntry() {
    return {
        key: "",
        value: void 0
    }
}
const AssetInfo_PrefabsEntry = {
    encode(V, X=new BinaryWriter) {
        return V.key !== "" && X.uint32(10).string(V.key),
        V.value !== void 0 && Prefab.encode(V.value, X.uint32(18).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseAssetInfo_PrefabsEntry();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.key = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.value = Prefab.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            key: isSet$a(V.key) ? globalThis.String(V.key) : "",
            value: isSet$a(V.value) ? Prefab.fromJSON(V.value) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.key !== "" && (X.key = V.key),
        V.value !== void 0 && (X.value = Prefab.toJSON(V.value)),
        X
    },
    create(V) {
        return AssetInfo_PrefabsEntry.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseAssetInfo_PrefabsEntry();
        return X.key = V.key ?? "",
        X.value = V.value !== void 0 && V.value !== null ? Prefab.fromPartial(V.value) : void 0,
        X
    }
};
function bytesFromBase64$1(V) {
    if (globalThis.Buffer)
        return Uint8Array.from(globalThis.Buffer.from(V, "base64"));
    {
        const X = globalThis.atob(V)
          , J = new Uint8Array(X.length);
        for (let ne = 0; ne < X.length; ++ne)
            J[ne] = X.charCodeAt(ne);
        return J
    }
}
function base64FromBytes$1(V) {
    if (globalThis.Buffer)
        return globalThis.Buffer.from(V).toString("base64");
    {
        const X = [];
        return V.forEach(J => {
            X.push(globalThis.String.fromCharCode(J))
        }
        ),
        globalThis.btoa(X.join(""))
    }
}
function toTimestamp$3(V) {
    const X = Math.trunc(V.getTime() / 1e3)
      , J = V.getTime() % 1e3 * 1e6;
    return {
        seconds: X,
        nanos: J
    }
}
function fromTimestamp$3(V) {
    let X = (V.seconds || 0) * 1e3;
    return X += (V.nanos || 0) / 1e6,
    new globalThis.Date(X)
}
function fromJsonTimestamp$3(V) {
    return V instanceof globalThis.Date ? V : typeof V == "string" ? new globalThis.Date(V) : fromTimestamp$3(Timestamp.fromJSON(V))
}
function isObject$2(V) {
    return typeof V == "object" && V !== null
}
function isSet$a(V) {
    return V != null
}
const ASSET_CATEGORY_FALLBACK_IMG_MAP = new Map([["Portal_WebApp_AR", arImg], ["Portal_WebApp_Carbine", carbineImg], ["Portal_WebApp_DMR", sniperImg], ["Portal_WebApp_MG", lmgImg], ["Portal_WebApp_Pistol", pistolImg], ["Portal_WebApp_SR", marksmanImg], ["Portal_WebApp_SG", shotgunImg], ["Portal_WebApp_PDW", smgImg], ["Portal_WebApp_AirCombat", airImg], ["Portal_WebApp_GroundCombat", ifvImg], ["Portal_WebApp_GroundTransport", apcImg], ["Portal_WebApp_Stationary", atImg], ["Portal_WebApp_Armor", armorImg], ["Portal_WebApp_ClassGadget", supplyPouchImg], ["Portal_WebApp_Deployable", droneImg], ["Portal_WebApp_Explosive", c4Img], ["Portal_WebApp_GrenadeLauncher", m4Img], ["Portal_WebApp_Launcher", c4Img], ["Portal_WebApp_Melee", knifeImg], ["Portal_WebApp_Gadget_Misc", supplyCrateImg], ["Portal_WebApp_StrikePackage", supplyCrateImg], ["Portal_WebApp_Throwable", motionGrenadeImg]])
  , CUSTOM_GAME_MODE_ID = "ModBuilderCustom"
  , MAX_PLAYER_COUNT_MUTATOR_ID = "MaxPlayerCount_PerTeam"
  , CUSTOM_GAME_MODE_MUTATOR_ID = "ModBuilder_GameMode"
  , SPAWN_TYPE_MUTATOR_ID = "AiSpawnType"
  , AI_MAX_COUNT_MUTATOR_ID = "AiMaxCount_PerTeam"
  , MAX_TEAM_COUNT_MUTATOR_ID = "MaxTeamCount"
  , AI_SPAWN_TYPE_MUTATOR_PVE_VALUE = 1
  , AI_SPAWN_TYPE_MUTATOR_PVP_VALUE = 2
  , AI_SPAWN_TYPE_MUTATOR_NO_AI_VALUE = 0
  , VEHICLE_ASSET_TAG_PREFIX = "U_VEH_"
  , FALLBACK_EXPERIENCE_NAME_MAX_LENGTH = 64
  , FALLBACK_EXPERIENCE_DESCRIPTION_MAX_LENGTH = 256
  , MAP_ROTATION_MAX = 20;
var RESOURCE_KIND = (V => (V.FORCE_SAVE_KIND = "forceSave",
V.DISPLAY_FORMAT_KIND = "displayFormat",
V.CHILD_MUTATOR_KIND = "childMutators",
V.PARENT_ACTIVE_VALUE = "parentActiveValue",
V.DISPLAY_PRIORITY = "displayPriority",
V.CATEGORY = "category",
V.INTERNAL = "internal",
V))(RESOURCE_KIND || {})
  , RANGE_MUTATOR_DISPLAY_FORMAT = (V => (V.MINUTES = "minutes",
V.SECONDS = "seconds",
V.PERCENT = "percent",
V))(RANGE_MUTATOR_DISPLAY_FORMAT || {});
const ALL_CLASS_ASSET_TAG_NAME = "AllClass";
var ASSET_TAG_TRANSLATION_KIND = (V => (V.NAME = "8",
V.DESCRIPTION = "9",
V))(ASSET_TAG_TRANSLATION_KIND || {})
  , SERVER_TAG_TRANSLATION_KIND = (V => (V.NAME = "6",
V.DESCRIPTION = "7",
V))(SERVER_TAG_TRANSLATION_KIND || {});
const DEFAULT_SELECTED_TEAM_ID = 0;
var DIALOG_ID = (V => (V.ASSET_TAG_INFO = "assetTagInfo",
V.BLOCK_TO_SCRIPT_EXPORT = "blockToScriptExport",
V.CONFIRM_DELETE = "confirmDelete",
V.CONFIRM_LEAVE_UNSAVED_CHANGES = "confirmLeaveUnsavedChanges",
V.CONFIRM_SYNC_TEAMS = "confirmSyncTeams",
V.EQUALIZE_TEAMS = "equalizeTeams",
V.EXPORT_MOD_DIALOG = "exportModDialog",
V.EXPORT_SCRIPTS = "exportScripts",
V.EXPORT_WORKSPACE_DIALOG = "exportWorkspaceDialog",
V.IMPORT_EXPERIENCE_ERRORS = "importExperienceErrors",
V.IMPORT_EXPERIENCE_ERRORS_FROM_FILE = "importExperienceErrorsFromFile",
V.IMPORT_WORKSPACE = "importWorkspace",
V.LINK_TEAMS_MODAL = "linkTeamsModal",
V.LOCKED_ITEM_DISABLE_WARNING = "lockedItemDisabledWarning",
V.MANAGE_PANEL = "managePanel",
V.MANAGE_PATCH_VERSIONS = "managePatchVersions",
V.MOBILE_NAV_OFF_CANVAS = "mobileNavOffCanvas",
V.PUBLISH_STEP_ONE_HELP = "publishStepOneHelp",
V.REPORT_EXPERIENCE = "reportExperience",
V.RESET_EXPERIENCE = "resetExperience",
V.RULES_EDITOR_CONFIRM_DELETE_SUBROUTINE = "rulesEditorConfirmDeleteSubroutine",
V.RULES_EDITOR_CONFIRM_DELETE_VARIABLE = "rulesEditorConfirmDeleteVariable",
V.RULES_EDITOR_CONFIRM_RESET_WORKSPACE = "rulesEditorConfirmDeleteWorkspace",
V.RULES_EDITOR_CREATE_SUBROUTINE = "rulesEditorCreateSubroutine",
V.RULES_EDITOR_CREATE_VARIABLE = "rulesEditorCreateVariable",
V.RULES_EDITOR_HELP_PANEL = "rulesEditorHelpPanel",
V.RULES_EDITOR_MANAGE_VARIABLES = "rulesEditorManageVariables",
V.RULES_EDITOR_RENAME_VARIABLE = "rulesEditorRenameVariable",
V.SAVE_PANEL = "savePanel",
V.SCRIPT_EDITOR_CONFIRM_DELETE_SCRIPTS = "scriptEditorConfirmDeleteScripts",
V.SCRIPT_MANAGER_OFF_CANVAS = "scriptManagerOffCanvas",
V.SHARE_MODAL = "share",
V.SHARE_PANEL = "sharePanel",
V.SHOW_ERROR_OFF_CANVAS = "showErrorOffCanvas",
V.TEAM_SELECTION_OFF_CANVAS = "teamSelectionOffCanvas",
V.UNLOCKED_ITEM_DISABLE_WARNING = "unlockedItemDisabledWarning",
V.UPLOAD_EXPERIENCE_IMAGE_ERROR = "uploadExperienceImageError",
V.UPLOAD_EXPERIENCE_IMAGE_INTRO = "uploadExperienceImageIntro",
V.VIEW_NON_OWNER_EXPERIENCE_DETAILS_OFF_CANVAS = "viewNonOwnerExperienceDetails",
V))(DIALOG_ID || {});
const MUTATOR_TRANSLATION_KIND_ID_MAP = new Map([["2", "name"], ["3", "description"]])
  , MUTATOR_AI_SPAWN_TYPE_TO_CAPACITY_TYPE = new Map([[AI_SPAWN_TYPE_MUTATOR_PVP_VALUE, InternalCapacityType.AI_BACKFILL], [AI_SPAWN_TYPE_MUTATOR_PVE_VALUE, InternalCapacityType.AI_STATIC]]);
var RESTRICTION_PAGE_CATEGORY = (V => (V.VEHICLES = "Portal_Vehicles",
V.CHARACTERS = "Classes",
V.WEAPONS = "Portal_Weapons",
V.GADGETS = "Portal_Gadgets",
V.ATTACHMENTS = "Attachments",
V))(RESTRICTION_PAGE_CATEGORY || {})
  , RESTRICTION_PAGE_ITEM_TYPE = (V => (V.VEHICLE = "vehicle",
V.CHARACTER = "character",
V.WEAPON = "weapon",
V.GADGET = "gadget",
V.ATTACHMENT = "attachment",
V))(RESTRICTION_PAGE_ITEM_TYPE || {})
  , GAME_MODE = (V => (V.CONQUEST = "Conquest",
V.CONQUEST_SMALL = "ConquestSmall",
V.RUSH = "Rush",
V.BREAKTHROUGH = "Breakthrough",
V.BREAKTHROUGH_SMALL = "BreakthroughSmall",
V.CUSTOM_GAME_MODE = "ModBuilderCustom",
V.BR = "GraniteSquad",
V.GAUNTLET = "GraniteGauntlet",
V))(GAME_MODE || {})
  , MUTATOR_TAG_GAME_MODE = (V => (V.CONQUEST = "WA_GM_Conquest",
V.CUSTOM = "WA_GM_Custom",
V.BREAKTHROUGH = "WA_GM_Breakthrough",
V.RUSH = "WA_GM_Rush",
V.GAUNTLET = "WA_GM_Gauntlet",
V.BR = "WA_GM_BR",
V))(MUTATOR_TAG_GAME_MODE || {})
  , MUTATOR_TAG = (V => (V.GLOBAL_SETTINGS = "WA_ST_Global",
V.SOLDIER_SETTINGS = "WA_ST_Soldier",
V.VEHICLE_SETTINGS = "WA_ST_Vehicle",
V.WEAPON_SETTINGS = "WA_ST_Weapon",
V.UI_SETTINGS = "WA_ST_UI",
V.AI_SETTINGS = "WA_ST_AI",
V.AI_SYNC_SETTINGS = "WA_ST_AI_Sync",
V.ALL_GAMEMODE_SETTINGS = "WA_GM_All",
V.MODBUILDER_SETTINGS = "MB_All",
V.ERA_SETTINGS = "WA_ST_Era",
V.VISUAL_SETTINGS = "WA_ST_Visual",
V.GAMEPLAY_SETTINGS = "WA_ST_Gameplay",
V.XP_REDUCED = "WA_XP_Reduced",
V.VEHICLE_LIMIT = "WA_AL_Vehicle",
V.SETTINGS = "WA_ST_Settings",
V.TEAM_SETTINGS = "WA_ST_Teams",
V.INTERNAL = "WA_ST_ExtraSettings",
V))(MUTATOR_TAG || {});
const DEFAULT_EXPERIENCE_TITLES_BY_MODE = {
    GraniteSquad: "Battle Royale Draft",
    GraniteGauntlet: "Gauntlet Draft",
    ModBuilderCustom: "Custom Draft",
    Conquest: "Conquest Draft",
    ConquestSmall: "Conquest Draft",
    Rush: "Rush Draft",
    Breakthrough: "Breakthrough Draft",
    BreakthroughSmall: "Breakthrough Draft"
}
  , FALLBACK_DEFAULT_EXPERIENCE_TITLE = "Draft Experience"
  , GAME_MODE_TO_MUTATOR_TAG_MAP = {
    Conquest: "WA_GM_Conquest",
    Breakthrough: "WA_GM_Breakthrough",
    BreakthroughSmall: "WA_GM_Breakthrough",
    Rush: "WA_GM_Rush",
    ModBuilderCustom: "WA_GM_Custom",
    GraniteSquad: "WA_GM_BR",
    GraniteGauntlet: "WA_GM_Gauntlet"
}
  , GAME_MODE_ICON_MAP = new Map([["Conquest", ICON_NAMES.MODE_CONQUEST_FRAMED], ["ConquestSmall", ICON_NAMES.MODE_CONQUEST_FRAMED], ["Breakthrough", ICON_NAMES.MODE_BREAKTHROUGH_FRAMED], ["BreakthroughSmall", ICON_NAMES.MODE_BREAKTHROUGH_FRAMED], ["Rush", ICON_NAMES.MODE_RUSH_FRAMED], ["GraniteSquad", ICON_NAMES.MODE_BR_FRAMED], ["GraniteGauntlet", ICON_NAMES.MODE_GAUNTLET_FRAMED]])
  , GAME_MODE_SMALL_ICON_MAP = new Map([["Conquest", ICON_NAMES.MODE_CONQUEST], ["ConquestSmall", ICON_NAMES.MODE_CONQUEST], ["Breakthrough", ICON_NAMES.MODE_BREAKTHROUGH], ["BreakthroughSmall", ICON_NAMES.MODE_BREAKTHROUGH], ["Rush", ICON_NAMES.MODE_RUSH], ["GraniteSquad", ICON_NAMES.MODE_BR], ["GraniteGauntlet", ICON_NAMES.MODE_GAUNTLET]])
  , DEFAULT_GAME_SIZE_MAX = 128
  , DEFAULT_GAME_SIZE = 64
  , DEFAULT_GAME_SIZE_MIN = 1
  , MS_1_SECOND = 1e3
  , MS_30_SECONDS = MS_1_SECOND * 30
  , MS_1_MINUTE = MS_1_SECOND * 60
  , MS_5_MINUTES = MS_1_MINUTE * 5
  , MS_30_MINUTES = MS_1_MINUTE * 30
  , MS_1_HOUR = MS_1_MINUTE * 60
  , MS_12_HOURS = MS_1_HOUR * 12
  , MS_24_HOURS = MS_1_HOUR * 24
  , S_ONE_YEAR = 31536e3
  , PER_TEAM_IDENTIFIER = "PerTeam"
  , BATTLE_BINARY_PLACEHOLDER = "[BB_PREFIX]"
  , EA_HELP_SHARE_EXPERIENCE_URL = "https://help.ea.com/"
  , EA_COMMUNITY_GUIDELINES_URL = "https://help.ea.com"
  , DEFAULT_TEAM_COUNT = 2
  , DEFAULT_MIN_TEAM_COUNT = 2
  , DEFAULT_MAX_TEAM_COUNT = 128
  , MODERATION_STATUS_LABEL_MAP = {
    [ModerationStateType.MODERATION_STATE_TYPE_UNDEFINED]: {
        label: "general.na",
        description: ""
    },
    [ModerationStateType.MODERATION_STATE_TYPE_DENIED]: {
        label: "general.action-needed",
        description: "general.action-needed-description"
    },
    [ModerationStateType.MODERATION_STATE_TYPE_APPROVED]: {
        label: "general.approved",
        description: ""
    },
    [ModerationStateType.MODERATION_STATE_TYPE_IN_REVIEW]: {
        label: "general.in-review",
        description: "general.in-review-description"
    },
    [ModerationStateType.UNRECOGNIZED]: {
        label: "general.invalid",
        description: ""
    }
}
  , ATTACHMENT_METADATA_KEY = {
    MAP_ROTATION_INDEX: "mapIdx"
}
  , SPATIAL_ATTACHMENT_TEMP_VERSION = "123"
  , SCRIPT_ATTACHMENT_TEMP_VERSION = "234"
  , STRINGS_ATTACHMENT_TEMP_VERSION = "345";
var VALIDATION_RULE_NAME = (V => (V.MAX = "max",
V.MIN = "min",
V.REQUIRED = "required",
V.LICENSE = "license",
V))(VALIDATION_RULE_NAME || {});
const VIP_ACCESS_LICENSE = "lic_portal_vip_creator";
var VALIDATION_FIELD_KEY = (V => (V.NAME = "name",
V.DESCRIPTION = "description",
V.GAME_SIZE = "gameSize",
V.MAP = "map",
V))(VALIDATION_FIELD_KEY || {});
const BR_GAME_SIZE_LICENSE_LIMIT = 64
  , MAX_EXPERIENCE_COUNT = 64
  , CLASS_ASSET_TAGS = ["47EF914C-AD5B-4248-AE86-D73D1369C009", "49E59F6A-8EB7-4F27-A9E9-8C375B4AF5EB", "835AA100-F265-4065-BC6C-8376BFBDA606", "74398FCC-A02E-4AEE-B830-AC9CD400C837"]
  , HARDCODED_FORCE_SAVE_MUTATOR_IDS = ["MandownExperienceType_PerTeam", "CQ_iModeTime", "AI_ManDownExperienceType_PerTeam", "BR_LobbyPlayerCountStartTimer"]
  , LINKED_MUTATORS = {
    Portal_KitsLimit_VehicleSpawnDelayMultiplier_PerTeam: ["VehicleSpawnDelayMultiplier_PerTeam"]
}
  , GAME_MOD_TEAM_BALANCING_MAP = new Map([["GraniteSquad", TeamBalancingMethod.FILL_IN_TEAM_ORDER]])
  , GAME_MODES_THAT_DO_SUPPORT_BOTS = ["GraniteSquad"]
  , VITE_ASSET_PATH = "https://eaassets-a.akamaihd.net/battlelog/battlebinary"
  , NODE_ENV = void 0
  , VITE_VERSION = "0"
  , VITE_ENVIRONMENT = "production"
  , buildUrl = (V, X) => {
    let J = {};
    V.forEach( (ce, me) => {
        if (!ce)
            return;
        const [ge,Te] = decodeURIComponent(ce).split("?");
        Te && new URLSearchParams(Te).forEach( (Se, Ie) => J[Ie] = Se),
        V[me] = ge
    }
    ),
    J = {
        ...J,
        ...X == null ? void 0 : X.queryParams
    };
    let ne = V.join("/");
    X != null && X.endWithSlash && (ne += "/"),
    ne = ne.replace(/([^:]\/)\/+/g, "$1");
    const ue = Object.keys(J).sort( (ce, me) => ce.localeCompare(me));
    if (ue.length > 0) {
        const ce = new URLSearchParams;
        ue.forEach(me => ce.append(me, J[me] ?? "")),
        ne += "?" + ce.toString()
    }
    return ne
}
;
function getBattleBinaryUrl(V) {
    return (V == null ? void 0 : V.replace(BATTLE_BINARY_PLACEHOLDER, VITE_ASSET_PATH)) || ""
}
const getAssetPath = V => {
    const X = ["bf6", "11303125"].filter(J => !!J);
    return X.length ? "/" + [...X, V.replace(/^\//g, "")].join("/") : "/" + V.replace(/^\//g, "")
}
  , convertPathTeamParamToTeamIdx = V => V ? V.split(",").reduce( (X, J) => (isNaN(+J) || X.push(+J),
X), []) : void 0
  , cacheBustSuffix = () => `${0 + Date.now()}`
  , isString = V => typeof V == "string"
  , defer = () => {
    let V, X;
    const J = new Promise( (ne, ue) => {
        V = ne,
        X = ue
    }
    );
    return J.resolve = V,
    J.reject = X,
    J
}
  , makeString = V => V == null ? "" : "" + V
  , copy = (V, X, J) => {
    V.forEach(ne => {
        X[ne] && (J[ne] = X[ne])
    }
    )
}
  , lastOfPathSeparatorRegExp = /###/g
  , cleanKey = V => V && V.indexOf("###") > -1 ? V.replace(lastOfPathSeparatorRegExp, ".") : V
  , canNotTraverseDeeper = V => !V || isString(V)
  , getLastOfPath = (V, X, J) => {
    const ne = isString(X) ? X.split(".") : X;
    let ue = 0;
    for (; ue < ne.length - 1; ) {
        if (canNotTraverseDeeper(V))
            return {};
        const ce = cleanKey(ne[ue]);
        !V[ce] && J && (V[ce] = new J),
        Object.prototype.hasOwnProperty.call(V, ce) ? V = V[ce] : V = {},
        ++ue
    }
    return canNotTraverseDeeper(V) ? {} : {
        obj: V,
        k: cleanKey(ne[ue])
    }
}
  , setPath = (V, X, J) => {
    const {obj: ne, k: ue} = getLastOfPath(V, X, Object);
    if (ne !== void 0 || X.length === 1) {
        ne[ue] = J;
        return
    }
    let ce = X[X.length - 1]
      , me = X.slice(0, X.length - 1)
      , ge = getLastOfPath(V, me, Object);
    for (; ge.obj === void 0 && me.length; )
        ce = `${me[me.length - 1]}.${ce}`,
        me = me.slice(0, me.length - 1),
        ge = getLastOfPath(V, me, Object),
        ge && ge.obj && typeof ge.obj[`${ge.k}.${ce}`] < "u" && (ge.obj = void 0);
    ge.obj[`${ge.k}.${ce}`] = J
}
  , pushPath = (V, X, J, ne) => {
    const {obj: ue, k: ce} = getLastOfPath(V, X, Object);
    ue[ce] = ue[ce] || [],
    ue[ce].push(J)
}
  , getPath = (V, X) => {
    const {obj: J, k: ne} = getLastOfPath(V, X);
    if (J)
        return J[ne]
}
  , getPathWithDefaults = (V, X, J) => {
    const ne = getPath(V, J);
    return ne !== void 0 ? ne : getPath(X, J)
}
  , deepExtend = (V, X, J) => {
    for (const ne in X)
        ne !== "__proto__" && ne !== "constructor" && (ne in V ? isString(V[ne]) || V[ne]instanceof String || isString(X[ne]) || X[ne]instanceof String ? J && (V[ne] = X[ne]) : deepExtend(V[ne], X[ne], J) : V[ne] = X[ne]);
    return V
}
  , regexEscape = V => V.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var _entityMap = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;",
    "/": "&#x2F;"
};
const escape$1 = V => isString(V) ? V.replace(/[&<>"'\/]/g, X => _entityMap[X]) : V;
class RegExpCache {
    constructor(X) {
        this.capacity = X,
        this.regExpMap = new Map,
        this.regExpQueue = []
    }
    getRegExp(X) {
        const J = this.regExpMap.get(X);
        if (J !== void 0)
            return J;
        const ne = new RegExp(X);
        return this.regExpQueue.length === this.capacity && this.regExpMap.delete(this.regExpQueue.shift()),
        this.regExpMap.set(X, ne),
        this.regExpQueue.push(X),
        ne
    }
}
const chars = [" ", ",", "?", "!", ";"]
  , looksLikeObjectPathRegExpCache = new RegExpCache(20)
  , looksLikeObjectPath = (V, X, J) => {
    X = X || "",
    J = J || "";
    const ne = chars.filter(me => X.indexOf(me) < 0 && J.indexOf(me) < 0);
    if (ne.length === 0)
        return !0;
    const ue = looksLikeObjectPathRegExpCache.getRegExp(`(${ne.map(me => me === "?" ? "\\?" : me).join("|")})`);
    let ce = !ue.test(V);
    if (!ce) {
        const me = V.indexOf(J);
        me > 0 && !ue.test(V.substring(0, me)) && (ce = !0)
    }
    return ce
}
  , deepFind = function(V, X) {
    let J = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
    if (!V)
        return;
    if (V[X])
        return V[X];
    const ne = X.split(J);
    let ue = V;
    for (let ce = 0; ce < ne.length; ) {
        if (!ue || typeof ue != "object")
            return;
        let me, ge = "";
        for (let Te = ce; Te < ne.length; ++Te)
            if (Te !== ce && (ge += J),
            ge += ne[Te],
            me = ue[ge],
            me !== void 0) {
                if (["string", "number", "boolean"].indexOf(typeof me) > -1 && Te < ne.length - 1)
                    continue;
                ce += Te - ce + 1;
                break
            }
        ue = me
    }
    return ue
}
  , getCleanedCode = V => V && V.replace("_", "-")
  , consoleLogger = {
    type: "logger",
    log(V) {
        this.output("log", V)
    },
    warn(V) {
        this.output("warn", V)
    },
    error(V) {
        this.output("error", V)
    },
    output(V, X) {
        console && console[V] && console[V].apply(console, X)
    }
};
class Logger {
    constructor(X) {
        let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.init(X, J)
    }
    init(X) {
        let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.prefix = J.prefix || "i18next:",
        this.logger = X || consoleLogger,
        this.options = J,
        this.debug = J.debug
    }
    log() {
        for (var X = arguments.length, J = new Array(X), ne = 0; ne < X; ne++)
            J[ne] = arguments[ne];
        return this.forward(J, "log", "", !0)
    }
    warn() {
        for (var X = arguments.length, J = new Array(X), ne = 0; ne < X; ne++)
            J[ne] = arguments[ne];
        return this.forward(J, "warn", "", !0)
    }
    error() {
        for (var X = arguments.length, J = new Array(X), ne = 0; ne < X; ne++)
            J[ne] = arguments[ne];
        return this.forward(J, "error", "")
    }
    deprecate() {
        for (var X = arguments.length, J = new Array(X), ne = 0; ne < X; ne++)
            J[ne] = arguments[ne];
        return this.forward(J, "warn", "WARNING DEPRECATED: ", !0)
    }
    forward(X, J, ne, ue) {
        return ue && !this.debug ? null : (isString(X[0]) && (X[0] = `${ne}${this.prefix} ${X[0]}`),
        this.logger[J](X))
    }
    create(X) {
        return new Logger(this.logger,{
            prefix: `${this.prefix}:${X}:`,
            ...this.options
        })
    }
    clone(X) {
        return X = X || this.options,
        X.prefix = X.prefix || this.prefix,
        new Logger(this.logger,X)
    }
}
var baseLogger = new Logger;
class EventEmitter {
    constructor() {
        this.observers = {}
    }
    on(X, J) {
        return X.split(" ").forEach(ne => {
            this.observers[ne] || (this.observers[ne] = new Map);
            const ue = this.observers[ne].get(J) || 0;
            this.observers[ne].set(J, ue + 1)
        }
        ),
        this
    }
    off(X, J) {
        if (this.observers[X]) {
            if (!J) {
                delete this.observers[X];
                return
            }
            this.observers[X].delete(J)
        }
    }
    emit(X) {
        for (var J = arguments.length, ne = new Array(J > 1 ? J - 1 : 0), ue = 1; ue < J; ue++)
            ne[ue - 1] = arguments[ue];
        this.observers[X] && Array.from(this.observers[X].entries()).forEach(me => {
            let[ge,Te] = me;
            for (let _e = 0; _e < Te; _e++)
                ge(...ne)
        }
        ),
        this.observers["*"] && Array.from(this.observers["*"].entries()).forEach(me => {
            let[ge,Te] = me;
            for (let _e = 0; _e < Te; _e++)
                ge.apply(ge, [X, ...ne])
        }
        )
    }
}
class ResourceStore extends EventEmitter {
    constructor(X) {
        let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
            ns: ["translation"],
            defaultNS: "translation"
        };
        super(),
        this.data = X || {},
        this.options = J,
        this.options.keySeparator === void 0 && (this.options.keySeparator = "."),
        this.options.ignoreJSONStructure === void 0 && (this.options.ignoreJSONStructure = !0)
    }
    addNamespaces(X) {
        this.options.ns.indexOf(X) < 0 && this.options.ns.push(X)
    }
    removeNamespaces(X) {
        const J = this.options.ns.indexOf(X);
        J > -1 && this.options.ns.splice(J, 1)
    }
    getResource(X, J, ne) {
        let ue = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        const ce = ue.keySeparator !== void 0 ? ue.keySeparator : this.options.keySeparator
          , me = ue.ignoreJSONStructure !== void 0 ? ue.ignoreJSONStructure : this.options.ignoreJSONStructure;
        let ge;
        X.indexOf(".") > -1 ? ge = X.split(".") : (ge = [X, J],
        ne && (Array.isArray(ne) ? ge.push(...ne) : isString(ne) && ce ? ge.push(...ne.split(ce)) : ge.push(ne)));
        const Te = getPath(this.data, ge);
        return !Te && !J && !ne && X.indexOf(".") > -1 && (X = ge[0],
        J = ge[1],
        ne = ge.slice(2).join(".")),
        Te || !me || !isString(ne) ? Te : deepFind(this.data && this.data[X] && this.data[X][J], ne, ce)
    }
    addResource(X, J, ne, ue) {
        let ce = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
            silent: !1
        };
        const me = ce.keySeparator !== void 0 ? ce.keySeparator : this.options.keySeparator;
        let ge = [X, J];
        ne && (ge = ge.concat(me ? ne.split(me) : ne)),
        X.indexOf(".") > -1 && (ge = X.split("."),
        ue = J,
        J = ge[1]),
        this.addNamespaces(J),
        setPath(this.data, ge, ue),
        ce.silent || this.emit("added", X, J, ne, ue)
    }
    addResources(X, J, ne) {
        let ue = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
            silent: !1
        };
        for (const ce in ne)
            (isString(ne[ce]) || Array.isArray(ne[ce])) && this.addResource(X, J, ce, ne[ce], {
                silent: !0
            });
        ue.silent || this.emit("added", X, J, ne)
    }
    addResourceBundle(X, J, ne, ue, ce) {
        let me = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
            silent: !1,
            skipCopy: !1
        }
          , ge = [X, J];
        X.indexOf(".") > -1 && (ge = X.split("."),
        ue = ne,
        ne = J,
        J = ge[1]),
        this.addNamespaces(J);
        let Te = getPath(this.data, ge) || {};
        me.skipCopy || (ne = JSON.parse(JSON.stringify(ne))),
        ue ? deepExtend(Te, ne, ce) : Te = {
            ...Te,
            ...ne
        },
        setPath(this.data, ge, Te),
        me.silent || this.emit("added", X, J, ne)
    }
    removeResourceBundle(X, J) {
        this.hasResourceBundle(X, J) && delete this.data[X][J],
        this.removeNamespaces(J),
        this.emit("removed", X, J)
    }
    hasResourceBundle(X, J) {
        return this.getResource(X, J) !== void 0
    }
    getResourceBundle(X, J) {
        return J || (J = this.options.defaultNS),
        this.options.compatibilityAPI === "v1" ? {
            ...this.getResource(X, J)
        } : this.getResource(X, J)
    }
    getDataByLanguage(X) {
        return this.data[X]
    }
    hasLanguageSomeTranslations(X) {
        const J = this.getDataByLanguage(X);
        return !!(J && Object.keys(J) || []).find(ue => J[ue] && Object.keys(J[ue]).length > 0)
    }
    toJSON() {
        return this.data
    }
}
var postProcessor = {
    processors: {},
    addPostProcessor(V) {
        this.processors[V.name] = V
    },
    handle(V, X, J, ne, ue) {
        return V.forEach(ce => {
            this.processors[ce] && (X = this.processors[ce].process(X, J, ne, ue))
        }
        ),
        X
    }
};
const checkedLoadedFor = {};
class Translator extends EventEmitter {
    constructor(X) {
        let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        super(),
        copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], X, this),
        this.options = J,
        this.options.keySeparator === void 0 && (this.options.keySeparator = "."),
        this.logger = baseLogger.create("translator")
    }
    changeLanguage(X) {
        X && (this.language = X)
    }
    exists(X) {
        let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
            interpolation: {}
        };
        if (X == null)
            return !1;
        const ne = this.resolve(X, J);
        return ne && ne.res !== void 0
    }
    extractFromKey(X, J) {
        let ne = J.nsSeparator !== void 0 ? J.nsSeparator : this.options.nsSeparator;
        ne === void 0 && (ne = ":");
        const ue = J.keySeparator !== void 0 ? J.keySeparator : this.options.keySeparator;
        let ce = J.ns || this.options.defaultNS || [];
        const me = ne && X.indexOf(ne) > -1
          , ge = !this.options.userDefinedKeySeparator && !J.keySeparator && !this.options.userDefinedNsSeparator && !J.nsSeparator && !looksLikeObjectPath(X, ne, ue);
        if (me && !ge) {
            const Te = X.match(this.interpolator.nestingRegexp);
            if (Te && Te.length > 0)
                return {
                    key: X,
                    namespaces: isString(ce) ? [ce] : ce
                };
            const _e = X.split(ne);
            (ne !== ue || ne === ue && this.options.ns.indexOf(_e[0]) > -1) && (ce = _e.shift()),
            X = _e.join(ue)
        }
        return {
            key: X,
            namespaces: isString(ce) ? [ce] : ce
        }
    }
    translate(X, J, ne) {
        if (typeof J != "object" && this.options.overloadTranslationOptionHandler && (J = this.options.overloadTranslationOptionHandler(arguments)),
        typeof J == "object" && (J = {
            ...J
        }),
        J || (J = {}),
        X == null)
            return "";
        Array.isArray(X) || (X = [String(X)]);
        const ue = J.returnDetails !== void 0 ? J.returnDetails : this.options.returnDetails
          , ce = J.keySeparator !== void 0 ? J.keySeparator : this.options.keySeparator
          , {key: me, namespaces: ge} = this.extractFromKey(X[X.length - 1], J)
          , Te = ge[ge.length - 1]
          , _e = J.lng || this.language
          , Se = J.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
        if (_e && _e.toLowerCase() === "cimode") {
            if (Se) {
                const je = J.nsSeparator || this.options.nsSeparator;
                return ue ? {
                    res: `${Te}${je}${me}`,
                    usedKey: me,
                    exactUsedKey: me,
                    usedLng: _e,
                    usedNS: Te,
                    usedParams: this.getUsedParamsDetails(J)
                } : `${Te}${je}${me}`
            }
            return ue ? {
                res: me,
                usedKey: me,
                exactUsedKey: me,
                usedLng: _e,
                usedNS: Te,
                usedParams: this.getUsedParamsDetails(J)
            } : me
        }
        const Ie = this.resolve(X, J);
        let ye = Ie && Ie.res;
        const $e = Ie && Ie.usedKey || me
          , Ne = Ie && Ie.exactUsedKey || me
          , ve = Object.prototype.toString.apply(ye)
          , ke = ["[object Number]", "[object Function]", "[object RegExp]"]
          , xe = J.joinArrays !== void 0 ? J.joinArrays : this.options.joinArrays
          , we = !this.i18nFormat || this.i18nFormat.handleAsObject
          , Fe = !isString(ye) && typeof ye != "boolean" && typeof ye != "number";
        if (we && ye && Fe && ke.indexOf(ve) < 0 && !(isString(xe) && Array.isArray(ye))) {
            if (!J.returnObjects && !this.options.returnObjects) {
                this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
                const je = this.options.returnedObjectHandler ? this.options.returnedObjectHandler($e, ye, {
                    ...J,
                    ns: ge
                }) : `key '${me} (${this.language})' returned an object instead of string.`;
                return ue ? (Ie.res = je,
                Ie.usedParams = this.getUsedParamsDetails(J),
                Ie) : je
            }
            if (ce) {
                const je = Array.isArray(ye)
                  , Xe = je ? [] : {}
                  , ze = je ? Ne : $e;
                for (const qe in ye)
                    if (Object.prototype.hasOwnProperty.call(ye, qe)) {
                        const Ze = `${ze}${ce}${qe}`;
                        Xe[qe] = this.translate(Ze, {
                            ...J,
                            joinArrays: !1,
                            ns: ge
                        }),
                        Xe[qe] === Ze && (Xe[qe] = ye[qe])
                    }
                ye = Xe
            }
        } else if (we && isString(xe) && Array.isArray(ye))
            ye = ye.join(xe),
            ye && (ye = this.extendTranslation(ye, X, J, ne));
        else {
            let je = !1
              , Xe = !1;
            const ze = J.count !== void 0 && !isString(J.count)
              , qe = Translator.hasDefaultValue(J)
              , Ze = ze ? this.pluralResolver.getSuffix(_e, J.count, J) : ""
              , et = J.ordinal && ze ? this.pluralResolver.getSuffix(_e, J.count, {
                ordinal: !1
            }) : ""
              , it = ze && !J.ordinal && J.count === 0 && this.pluralResolver.shouldUseIntlApi()
              , at = it && J[`defaultValue${this.options.pluralSeparator}zero`] || J[`defaultValue${Ze}`] || J[`defaultValue${et}`] || J.defaultValue;
            !this.isValidLookup(ye) && qe && (je = !0,
            ye = at),
            this.isValidLookup(ye) || (Xe = !0,
            ye = me);
            const ft = (J.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && Xe ? void 0 : ye
              , St = qe && at !== ye && this.options.updateMissing;
            if (Xe || je || St) {
                if (this.logger.log(St ? "updateKey" : "missingKey", _e, Te, me, St ? at : ye),
                ce) {
                    const ct = this.resolve(me, {
                        ...J,
                        keySeparator: !1
                    });
                    ct && ct.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.")
                }
                let Ye = [];
                const We = this.languageUtils.getFallbackCodes(this.options.fallbackLng, J.lng || this.language);
                if (this.options.saveMissingTo === "fallback" && We && We[0])
                    for (let ct = 0; ct < We.length; ct++)
                        Ye.push(We[ct]);
                else
                    this.options.saveMissingTo === "all" ? Ye = this.languageUtils.toResolveHierarchy(J.lng || this.language) : Ye.push(J.lng || this.language);
                const nt = (ct, Et, Ke) => {
                    const mt = qe && Ke !== ye ? Ke : ft;
                    this.options.missingKeyHandler ? this.options.missingKeyHandler(ct, Te, Et, mt, St, J) : this.backendConnector && this.backendConnector.saveMissing && this.backendConnector.saveMissing(ct, Te, Et, mt, St, J),
                    this.emit("missingKey", ct, Te, Et, ye)
                }
                ;
                this.options.saveMissing && (this.options.saveMissingPlurals && ze ? Ye.forEach(ct => {
                    const Et = this.pluralResolver.getSuffixes(ct, J);
                    it && J[`defaultValue${this.options.pluralSeparator}zero`] && Et.indexOf(`${this.options.pluralSeparator}zero`) < 0 && Et.push(`${this.options.pluralSeparator}zero`),
                    Et.forEach(Ke => {
                        nt([ct], me + Ke, J[`defaultValue${Ke}`] || at)
                    }
                    )
                }
                ) : nt(Ye, me, at))
            }
            ye = this.extendTranslation(ye, X, J, Ie, ne),
            Xe && ye === me && this.options.appendNamespaceToMissingKey && (ye = `${Te}:${me}`),
            (Xe || je) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? ye = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${Te}:${me}` : me, je ? ye : void 0) : ye = this.options.parseMissingKeyHandler(ye))
        }
        return ue ? (Ie.res = ye,
        Ie.usedParams = this.getUsedParamsDetails(J),
        Ie) : ye
    }
    extendTranslation(X, J, ne, ue, ce) {
        var me = this;
        if (this.i18nFormat && this.i18nFormat.parse)
            X = this.i18nFormat.parse(X, {
                ...this.options.interpolation.defaultVariables,
                ...ne
            }, ne.lng || this.language || ue.usedLng, ue.usedNS, ue.usedKey, {
                resolved: ue
            });
        else if (!ne.skipInterpolation) {
            ne.interpolation && this.interpolator.init({
                ...ne,
                interpolation: {
                    ...this.options.interpolation,
                    ...ne.interpolation
                }
            });
            const _e = isString(X) && (ne && ne.interpolation && ne.interpolation.skipOnVariables !== void 0 ? ne.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
            let Se;
            if (_e) {
                const ye = X.match(this.interpolator.nestingRegexp);
                Se = ye && ye.length
            }
            let Ie = ne.replace && !isString(ne.replace) ? ne.replace : ne;
            if (this.options.interpolation.defaultVariables && (Ie = {
                ...this.options.interpolation.defaultVariables,
                ...Ie
            }),
            X = this.interpolator.interpolate(X, Ie, ne.lng || this.language || ue.usedLng, ne),
            _e) {
                const ye = X.match(this.interpolator.nestingRegexp)
                  , $e = ye && ye.length;
                Se < $e && (ne.nest = !1)
            }
            !ne.lng && this.options.compatibilityAPI !== "v1" && ue && ue.res && (ne.lng = this.language || ue.usedLng),
            ne.nest !== !1 && (X = this.interpolator.nest(X, function() {
                for (var ye = arguments.length, $e = new Array(ye), Ne = 0; Ne < ye; Ne++)
                    $e[Ne] = arguments[Ne];
                return ce && ce[0] === $e[0] && !ne.context ? (me.logger.warn(`It seems you are nesting recursively key: ${$e[0]} in key: ${J[0]}`),
                null) : me.translate(...$e, J)
            }, ne)),
            ne.interpolation && this.interpolator.reset()
        }
        const ge = ne.postProcess || this.options.postProcess
          , Te = isString(ge) ? [ge] : ge;
        return X != null && Te && Te.length && ne.applyPostProcessor !== !1 && (X = postProcessor.handle(Te, X, J, this.options && this.options.postProcessPassResolved ? {
            i18nResolved: {
                ...ue,
                usedParams: this.getUsedParamsDetails(ne)
            },
            ...ne
        } : ne, this)),
        X
    }
    resolve(X) {
        let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, ne, ue, ce, me, ge;
        return isString(X) && (X = [X]),
        X.forEach(Te => {
            if (this.isValidLookup(ne))
                return;
            const _e = this.extractFromKey(Te, J)
              , Se = _e.key;
            ue = Se;
            let Ie = _e.namespaces;
            this.options.fallbackNS && (Ie = Ie.concat(this.options.fallbackNS));
            const ye = J.count !== void 0 && !isString(J.count)
              , $e = ye && !J.ordinal && J.count === 0 && this.pluralResolver.shouldUseIntlApi()
              , Ne = J.context !== void 0 && (isString(J.context) || typeof J.context == "number") && J.context !== ""
              , ve = J.lngs ? J.lngs : this.languageUtils.toResolveHierarchy(J.lng || this.language, J.fallbackLng);
            Ie.forEach(ke => {
                this.isValidLookup(ne) || (ge = ke,
                !checkedLoadedFor[`${ve[0]}-${ke}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(ge) && (checkedLoadedFor[`${ve[0]}-${ke}`] = !0,
                this.logger.warn(`key "${ue}" for languages "${ve.join(", ")}" won't get resolved as namespace "${ge}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")),
                ve.forEach(xe => {
                    if (this.isValidLookup(ne))
                        return;
                    me = xe;
                    const we = [Se];
                    if (this.i18nFormat && this.i18nFormat.addLookupKeys)
                        this.i18nFormat.addLookupKeys(we, Se, xe, ke, J);
                    else {
                        let je;
                        ye && (je = this.pluralResolver.getSuffix(xe, J.count, J));
                        const Xe = `${this.options.pluralSeparator}zero`
                          , ze = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
                        if (ye && (we.push(Se + je),
                        J.ordinal && je.indexOf(ze) === 0 && we.push(Se + je.replace(ze, this.options.pluralSeparator)),
                        $e && we.push(Se + Xe)),
                        Ne) {
                            const qe = `${Se}${this.options.contextSeparator}${J.context}`;
                            we.push(qe),
                            ye && (we.push(qe + je),
                            J.ordinal && je.indexOf(ze) === 0 && we.push(qe + je.replace(ze, this.options.pluralSeparator)),
                            $e && we.push(qe + Xe))
                        }
                    }
                    let Fe;
                    for (; Fe = we.pop(); )
                        this.isValidLookup(ne) || (ce = Fe,
                        ne = this.getResource(xe, ke, Fe, J))
                }
                ))
            }
            )
        }
        ),
        {
            res: ne,
            usedKey: ue,
            exactUsedKey: ce,
            usedLng: me,
            usedNS: ge
        }
    }
    isValidLookup(X) {
        return X !== void 0 && !(!this.options.returnNull && X === null) && !(!this.options.returnEmptyString && X === "")
    }
    getResource(X, J, ne) {
        let ue = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(X, J, ne, ue) : this.resourceStore.getResource(X, J, ne, ue)
    }
    getUsedParamsDetails() {
        let X = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        const J = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"]
          , ne = X.replace && !isString(X.replace);
        let ue = ne ? X.replace : X;
        if (ne && typeof X.count < "u" && (ue.count = X.count),
        this.options.interpolation.defaultVariables && (ue = {
            ...this.options.interpolation.defaultVariables,
            ...ue
        }),
        !ne) {
            ue = {
                ...ue
            };
            for (const ce of J)
                delete ue[ce]
        }
        return ue
    }
    static hasDefaultValue(X) {
        const J = "defaultValue";
        for (const ne in X)
            if (Object.prototype.hasOwnProperty.call(X, ne) && J === ne.substring(0, J.length) && X[ne] !== void 0)
                return !0;
        return !1
    }
}
const capitalize = V => V.charAt(0).toUpperCase() + V.slice(1);
class LanguageUtil {
    constructor(X) {
        this.options = X,
        this.supportedLngs = this.options.supportedLngs || !1,
        this.logger = baseLogger.create("languageUtils")
    }
    getScriptPartFromCode(X) {
        if (X = getCleanedCode(X),
        !X || X.indexOf("-") < 0)
            return null;
        const J = X.split("-");
        return J.length === 2 || (J.pop(),
        J[J.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(J.join("-"))
    }
    getLanguagePartFromCode(X) {
        if (X = getCleanedCode(X),
        !X || X.indexOf("-") < 0)
            return X;
        const J = X.split("-");
        return this.formatLanguageCode(J[0])
    }
    formatLanguageCode(X) {
        if (isString(X) && X.indexOf("-") > -1) {
            if (typeof Intl < "u" && typeof Intl.getCanonicalLocales < "u")
                try {
                    let ue = Intl.getCanonicalLocales(X)[0];
                    if (ue && this.options.lowerCaseLng && (ue = ue.toLowerCase()),
                    ue)
                        return ue
                } catch {}
            const J = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
            let ne = X.split("-");
            return this.options.lowerCaseLng ? ne = ne.map(ue => ue.toLowerCase()) : ne.length === 2 ? (ne[0] = ne[0].toLowerCase(),
            ne[1] = ne[1].toUpperCase(),
            J.indexOf(ne[1].toLowerCase()) > -1 && (ne[1] = capitalize(ne[1].toLowerCase()))) : ne.length === 3 && (ne[0] = ne[0].toLowerCase(),
            ne[1].length === 2 && (ne[1] = ne[1].toUpperCase()),
            ne[0] !== "sgn" && ne[2].length === 2 && (ne[2] = ne[2].toUpperCase()),
            J.indexOf(ne[1].toLowerCase()) > -1 && (ne[1] = capitalize(ne[1].toLowerCase())),
            J.indexOf(ne[2].toLowerCase()) > -1 && (ne[2] = capitalize(ne[2].toLowerCase()))),
            ne.join("-")
        }
        return this.options.cleanCode || this.options.lowerCaseLng ? X.toLowerCase() : X
    }
    isSupportedCode(X) {
        return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (X = this.getLanguagePartFromCode(X)),
        !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(X) > -1
    }
    getBestMatchFromCodes(X) {
        if (!X)
            return null;
        let J;
        return X.forEach(ne => {
            if (J)
                return;
            const ue = this.formatLanguageCode(ne);
            (!this.options.supportedLngs || this.isSupportedCode(ue)) && (J = ue)
        }
        ),
        !J && this.options.supportedLngs && X.forEach(ne => {
            if (J)
                return;
            const ue = this.getLanguagePartFromCode(ne);
            if (this.isSupportedCode(ue))
                return J = ue;
            J = this.options.supportedLngs.find(ce => {
                if (ce === ue)
                    return ce;
                if (!(ce.indexOf("-") < 0 && ue.indexOf("-") < 0) && (ce.indexOf("-") > 0 && ue.indexOf("-") < 0 && ce.substring(0, ce.indexOf("-")) === ue || ce.indexOf(ue) === 0 && ue.length > 1))
                    return ce
            }
            )
        }
        ),
        J || (J = this.getFallbackCodes(this.options.fallbackLng)[0]),
        J
    }
    getFallbackCodes(X, J) {
        if (!X)
            return [];
        if (typeof X == "function" && (X = X(J)),
        isString(X) && (X = [X]),
        Array.isArray(X))
            return X;
        if (!J)
            return X.default || [];
        let ne = X[J];
        return ne || (ne = X[this.getScriptPartFromCode(J)]),
        ne || (ne = X[this.formatLanguageCode(J)]),
        ne || (ne = X[this.getLanguagePartFromCode(J)]),
        ne || (ne = X.default),
        ne || []
    }
    toResolveHierarchy(X, J) {
        const ne = this.getFallbackCodes(J || this.options.fallbackLng || [], X)
          , ue = []
          , ce = me => {
            me && (this.isSupportedCode(me) ? ue.push(me) : this.logger.warn(`rejecting language code not found in supportedLngs: ${me}`))
        }
        ;
        return isString(X) && (X.indexOf("-") > -1 || X.indexOf("_") > -1) ? (this.options.load !== "languageOnly" && ce(this.formatLanguageCode(X)),
        this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && ce(this.getScriptPartFromCode(X)),
        this.options.load !== "currentOnly" && ce(this.getLanguagePartFromCode(X))) : isString(X) && ce(this.formatLanguageCode(X)),
        ne.forEach(me => {
            ue.indexOf(me) < 0 && ce(this.formatLanguageCode(me))
        }
        ),
        ue
    }
}
let sets = [{
    lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
    nr: [1, 2],
    fc: 1
}, {
    lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
    nr: [1, 2],
    fc: 2
}, {
    lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
    nr: [1],
    fc: 3
}, {
    lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
    nr: [1, 2, 5],
    fc: 4
}, {
    lngs: ["ar"],
    nr: [0, 1, 2, 3, 11, 100],
    fc: 5
}, {
    lngs: ["cs", "sk"],
    nr: [1, 2, 5],
    fc: 6
}, {
    lngs: ["csb", "pl"],
    nr: [1, 2, 5],
    fc: 7
}, {
    lngs: ["cy"],
    nr: [1, 2, 3, 8],
    fc: 8
}, {
    lngs: ["fr"],
    nr: [1, 2],
    fc: 9
}, {
    lngs: ["ga"],
    nr: [1, 2, 3, 7, 11],
    fc: 10
}, {
    lngs: ["gd"],
    nr: [1, 2, 3, 20],
    fc: 11
}, {
    lngs: ["is"],
    nr: [1, 2],
    fc: 12
}, {
    lngs: ["jv"],
    nr: [0, 1],
    fc: 13
}, {
    lngs: ["kw"],
    nr: [1, 2, 3, 4],
    fc: 14
}, {
    lngs: ["lt"],
    nr: [1, 2, 10],
    fc: 15
}, {
    lngs: ["lv"],
    nr: [1, 2, 0],
    fc: 16
}, {
    lngs: ["mk"],
    nr: [1, 2],
    fc: 17
}, {
    lngs: ["mnk"],
    nr: [0, 1, 2],
    fc: 18
}, {
    lngs: ["mt"],
    nr: [1, 2, 11, 20],
    fc: 19
}, {
    lngs: ["or"],
    nr: [2, 1],
    fc: 2
}, {
    lngs: ["ro"],
    nr: [1, 2, 20],
    fc: 20
}, {
    lngs: ["sl"],
    nr: [5, 1, 2, 3],
    fc: 21
}, {
    lngs: ["he", "iw"],
    nr: [1, 2, 20, 21],
    fc: 22
}]
  , _rulesPluralsTypes = {
    1: V => +(V > 1),
    2: V => +(V != 1),
    3: V => 0,
    4: V => V % 10 == 1 && V % 100 != 11 ? 0 : V % 10 >= 2 && V % 10 <= 4 && (V % 100 < 10 || V % 100 >= 20) ? 1 : 2,
    5: V => V == 0 ? 0 : V == 1 ? 1 : V == 2 ? 2 : V % 100 >= 3 && V % 100 <= 10 ? 3 : V % 100 >= 11 ? 4 : 5,
    6: V => V == 1 ? 0 : V >= 2 && V <= 4 ? 1 : 2,
    7: V => V == 1 ? 0 : V % 10 >= 2 && V % 10 <= 4 && (V % 100 < 10 || V % 100 >= 20) ? 1 : 2,
    8: V => V == 1 ? 0 : V == 2 ? 1 : V != 8 && V != 11 ? 2 : 3,
    9: V => +(V >= 2),
    10: V => V == 1 ? 0 : V == 2 ? 1 : V < 7 ? 2 : V < 11 ? 3 : 4,
    11: V => V == 1 || V == 11 ? 0 : V == 2 || V == 12 ? 1 : V > 2 && V < 20 ? 2 : 3,
    12: V => +(V % 10 != 1 || V % 100 == 11),
    13: V => +(V !== 0),
    14: V => V == 1 ? 0 : V == 2 ? 1 : V == 3 ? 2 : 3,
    15: V => V % 10 == 1 && V % 100 != 11 ? 0 : V % 10 >= 2 && (V % 100 < 10 || V % 100 >= 20) ? 1 : 2,
    16: V => V % 10 == 1 && V % 100 != 11 ? 0 : V !== 0 ? 1 : 2,
    17: V => V == 1 || V % 10 == 1 && V % 100 != 11 ? 0 : 1,
    18: V => V == 0 ? 0 : V == 1 ? 1 : 2,
    19: V => V == 1 ? 0 : V == 0 || V % 100 > 1 && V % 100 < 11 ? 1 : V % 100 > 10 && V % 100 < 20 ? 2 : 3,
    20: V => V == 1 ? 0 : V == 0 || V % 100 > 0 && V % 100 < 20 ? 1 : 2,
    21: V => V % 100 == 1 ? 1 : V % 100 == 2 ? 2 : V % 100 == 3 || V % 100 == 4 ? 3 : 0,
    22: V => V == 1 ? 0 : V == 2 ? 1 : (V < 0 || V > 10) && V % 10 == 0 ? 2 : 3
};
const nonIntlVersions = ["v1", "v2", "v3"]
  , intlVersions = ["v4"]
  , suffixesOrder = {
    zero: 0,
    one: 1,
    two: 2,
    few: 3,
    many: 4,
    other: 5
}
  , createRules = () => {
    const V = {};
    return sets.forEach(X => {
        X.lngs.forEach(J => {
            V[J] = {
                numbers: X.nr,
                plurals: _rulesPluralsTypes[X.fc]
            }
        }
        )
    }
    ),
    V
}
;
class PluralResolver {
    constructor(X) {
        let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.languageUtils = X,
        this.options = J,
        this.logger = baseLogger.create("pluralResolver"),
        (!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3",
        this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")),
        this.rules = createRules(),
        this.pluralRulesCache = {}
    }
    addRule(X, J) {
        this.rules[X] = J
    }
    clearCache() {
        this.pluralRulesCache = {}
    }
    getRule(X) {
        let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (this.shouldUseIntlApi())
            try {
                const ne = getCleanedCode(X === "dev" ? "en" : X)
                  , ue = J.ordinal ? "ordinal" : "cardinal"
                  , ce = JSON.stringify({
                    cleanedCode: ne,
                    type: ue
                });
                if (ce in this.pluralRulesCache)
                    return this.pluralRulesCache[ce];
                const me = new Intl.PluralRules(ne,{
                    type: ue
                });
                return this.pluralRulesCache[ce] = me,
                me
            } catch {
                return
            }
        return this.rules[X] || this.rules[this.languageUtils.getLanguagePartFromCode(X)]
    }
    needsPlural(X) {
        let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const ne = this.getRule(X, J);
        return this.shouldUseIntlApi() ? ne && ne.resolvedOptions().pluralCategories.length > 1 : ne && ne.numbers.length > 1
    }
    getPluralFormsOfKey(X, J) {
        let ne = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return this.getSuffixes(X, ne).map(ue => `${J}${ue}`)
    }
    getSuffixes(X) {
        let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const ne = this.getRule(X, J);
        return ne ? this.shouldUseIntlApi() ? ne.resolvedOptions().pluralCategories.sort( (ue, ce) => suffixesOrder[ue] - suffixesOrder[ce]).map(ue => `${this.options.prepend}${J.ordinal ? `ordinal${this.options.prepend}` : ""}${ue}`) : ne.numbers.map(ue => this.getSuffix(X, ue, J)) : []
    }
    getSuffix(X, J) {
        let ne = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        const ue = this.getRule(X, ne);
        return ue ? this.shouldUseIntlApi() ? `${this.options.prepend}${ne.ordinal ? `ordinal${this.options.prepend}` : ""}${ue.select(J)}` : this.getSuffixRetroCompatible(ue, J) : (this.logger.warn(`no plural rule found for: ${X}`),
        "")
    }
    getSuffixRetroCompatible(X, J) {
        const ne = X.noAbs ? X.plurals(J) : X.plurals(Math.abs(J));
        let ue = X.numbers[ne];
        this.options.simplifyPluralSuffix && X.numbers.length === 2 && X.numbers[0] === 1 && (ue === 2 ? ue = "plural" : ue === 1 && (ue = ""));
        const ce = () => this.options.prepend && ue.toString() ? this.options.prepend + ue.toString() : ue.toString();
        return this.options.compatibilityJSON === "v1" ? ue === 1 ? "" : typeof ue == "number" ? `_plural_${ue.toString()}` : ce() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && X.numbers.length === 2 && X.numbers[0] === 1 ? ce() : this.options.prepend && ne.toString() ? this.options.prepend + ne.toString() : ne.toString()
    }
    shouldUseIntlApi() {
        return !nonIntlVersions.includes(this.options.compatibilityJSON)
    }
}
const deepFindWithDefaults = function(V, X, J) {
    let ne = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "."
      , ue = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0
      , ce = getPathWithDefaults(V, X, J);
    return !ce && ue && isString(J) && (ce = deepFind(V, J, ne),
    ce === void 0 && (ce = deepFind(X, J, ne))),
    ce
}
  , regexSafe = V => V.replace(/\$/g, "$$$$");
class Interpolator {
    constructor() {
        let X = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.logger = baseLogger.create("interpolator"),
        this.options = X,
        this.format = X.interpolation && X.interpolation.format || (J => J),
        this.init(X)
    }
    init() {
        let X = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        X.interpolation || (X.interpolation = {
            escapeValue: !0
        });
        const {escape: J, escapeValue: ne, useRawValueToEscape: ue, prefix: ce, prefixEscaped: me, suffix: ge, suffixEscaped: Te, formatSeparator: _e, unescapeSuffix: Se, unescapePrefix: Ie, nestingPrefix: ye, nestingPrefixEscaped: $e, nestingSuffix: Ne, nestingSuffixEscaped: ve, nestingOptionsSeparator: ke, maxReplaces: xe, alwaysFormat: we} = X.interpolation;
        this.escape = J !== void 0 ? J : escape$1,
        this.escapeValue = ne !== void 0 ? ne : !0,
        this.useRawValueToEscape = ue !== void 0 ? ue : !1,
        this.prefix = ce ? regexEscape(ce) : me || "{{",
        this.suffix = ge ? regexEscape(ge) : Te || "}}",
        this.formatSeparator = _e || ",",
        this.unescapePrefix = Se ? "" : Ie || "-",
        this.unescapeSuffix = this.unescapePrefix ? "" : Se || "",
        this.nestingPrefix = ye ? regexEscape(ye) : $e || regexEscape("$t("),
        this.nestingSuffix = Ne ? regexEscape(Ne) : ve || regexEscape(")"),
        this.nestingOptionsSeparator = ke || ",",
        this.maxReplaces = xe || 1e3,
        this.alwaysFormat = we !== void 0 ? we : !1,
        this.resetRegExp()
    }
    reset() {
        this.options && this.init(this.options)
    }
    resetRegExp() {
        const X = (J, ne) => J && J.source === ne ? (J.lastIndex = 0,
        J) : new RegExp(ne,"g");
        this.regexp = X(this.regexp, `${this.prefix}(.+?)${this.suffix}`),
        this.regexpUnescape = X(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`),
        this.nestingRegexp = X(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`)
    }
    interpolate(X, J, ne, ue) {
        let ce, me, ge;
        const Te = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {}
          , _e = $e => {
            if ($e.indexOf(this.formatSeparator) < 0) {
                const xe = deepFindWithDefaults(J, Te, $e, this.options.keySeparator, this.options.ignoreJSONStructure);
                return this.alwaysFormat ? this.format(xe, void 0, ne, {
                    ...ue,
                    ...J,
                    interpolationkey: $e
                }) : xe
            }
            const Ne = $e.split(this.formatSeparator)
              , ve = Ne.shift().trim()
              , ke = Ne.join(this.formatSeparator).trim();
            return this.format(deepFindWithDefaults(J, Te, ve, this.options.keySeparator, this.options.ignoreJSONStructure), ke, ne, {
                ...ue,
                ...J,
                interpolationkey: ve
            })
        }
        ;
        this.resetRegExp();
        const Se = ue && ue.missingInterpolationHandler || this.options.missingInterpolationHandler
          , Ie = ue && ue.interpolation && ue.interpolation.skipOnVariables !== void 0 ? ue.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
        return [{
            regex: this.regexpUnescape,
            safeValue: $e => regexSafe($e)
        }, {
            regex: this.regexp,
            safeValue: $e => this.escapeValue ? regexSafe(this.escape($e)) : regexSafe($e)
        }].forEach($e => {
            for (ge = 0; ce = $e.regex.exec(X); ) {
                const Ne = ce[1].trim();
                if (me = _e(Ne),
                me === void 0)
                    if (typeof Se == "function") {
                        const ke = Se(X, ce, ue);
                        me = isString(ke) ? ke : ""
                    } else if (ue && Object.prototype.hasOwnProperty.call(ue, Ne))
                        me = "";
                    else if (Ie) {
                        me = ce[0];
                        continue
                    } else
                        this.logger.warn(`missed to pass in variable ${Ne} for interpolating ${X}`),
                        me = "";
                else
                    !isString(me) && !this.useRawValueToEscape && (me = makeString(me));
                const ve = $e.safeValue(me);
                if (X = X.replace(ce[0], ve),
                Ie ? ($e.regex.lastIndex += me.length,
                $e.regex.lastIndex -= ce[0].length) : $e.regex.lastIndex = 0,
                ge++,
                ge >= this.maxReplaces)
                    break
            }
        }
        ),
        X
    }
    nest(X, J) {
        let ne = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, ue, ce, me;
        const ge = (Te, _e) => {
            const Se = this.nestingOptionsSeparator;
            if (Te.indexOf(Se) < 0)
                return Te;
            const Ie = Te.split(new RegExp(`${Se}[ ]*{`));
            let ye = `{${Ie[1]}`;
            Te = Ie[0],
            ye = this.interpolate(ye, me);
            const $e = ye.match(/'/g)
              , Ne = ye.match(/"/g);
            ($e && $e.length % 2 === 0 && !Ne || Ne.length % 2 !== 0) && (ye = ye.replace(/'/g, '"'));
            try {
                me = JSON.parse(ye),
                _e && (me = {
                    ..._e,
                    ...me
                })
            } catch (ve) {
                return this.logger.warn(`failed parsing options string in nesting for key ${Te}`, ve),
                `${Te}${Se}${ye}`
            }
            return me.defaultValue && me.defaultValue.indexOf(this.prefix) > -1 && delete me.defaultValue,
            Te
        }
        ;
        for (; ue = this.nestingRegexp.exec(X); ) {
            let Te = [];
            me = {
                ...ne
            },
            me = me.replace && !isString(me.replace) ? me.replace : me,
            me.applyPostProcessor = !1,
            delete me.defaultValue;
            let _e = !1;
            if (ue[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(ue[1])) {
                const Se = ue[1].split(this.formatSeparator).map(Ie => Ie.trim());
                ue[1] = Se.shift(),
                Te = Se,
                _e = !0
            }
            if (ce = J(ge.call(this, ue[1].trim(), me), me),
            ce && ue[0] === X && !isString(ce))
                return ce;
            isString(ce) || (ce = makeString(ce)),
            ce || (this.logger.warn(`missed to resolve ${ue[1]} for nesting ${X}`),
            ce = ""),
            _e && (ce = Te.reduce( (Se, Ie) => this.format(Se, Ie, ne.lng, {
                ...ne,
                interpolationkey: ue[1].trim()
            }), ce.trim())),
            X = X.replace(ue[0], ce),
            this.regexp.lastIndex = 0
        }
        return X
    }
}
const parseFormatStr = V => {
    let X = V.toLowerCase().trim();
    const J = {};
    if (V.indexOf("(") > -1) {
        const ne = V.split("(");
        X = ne[0].toLowerCase().trim();
        const ue = ne[1].substring(0, ne[1].length - 1);
        X === "currency" && ue.indexOf(":") < 0 ? J.currency || (J.currency = ue.trim()) : X === "relativetime" && ue.indexOf(":") < 0 ? J.range || (J.range = ue.trim()) : ue.split(";").forEach(me => {
            if (me) {
                const [ge,...Te] = me.split(":")
                  , _e = Te.join(":").trim().replace(/^'+|'+$/g, "")
                  , Se = ge.trim();
                J[Se] || (J[Se] = _e),
                _e === "false" && (J[Se] = !1),
                _e === "true" && (J[Se] = !0),
                isNaN(_e) || (J[Se] = parseInt(_e, 10))
            }
        }
        )
    }
    return {
        formatName: X,
        formatOptions: J
    }
}
  , createCachedFormatter = V => {
    const X = {};
    return (J, ne, ue) => {
        let ce = ue;
        ue && ue.interpolationkey && ue.formatParams && ue.formatParams[ue.interpolationkey] && ue[ue.interpolationkey] && (ce = {
            ...ce,
            [ue.interpolationkey]: void 0
        });
        const me = ne + JSON.stringify(ce);
        let ge = X[me];
        return ge || (ge = V(getCleanedCode(ne), ue),
        X[me] = ge),
        ge(J)
    }
}
;
class Formatter {
    constructor() {
        let X = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.logger = baseLogger.create("formatter"),
        this.options = X,
        this.formats = {
            number: createCachedFormatter( (J, ne) => {
                const ue = new Intl.NumberFormat(J,{
                    ...ne
                });
                return ce => ue.format(ce)
            }
            ),
            currency: createCachedFormatter( (J, ne) => {
                const ue = new Intl.NumberFormat(J,{
                    ...ne,
                    style: "currency"
                });
                return ce => ue.format(ce)
            }
            ),
            datetime: createCachedFormatter( (J, ne) => {
                const ue = new Intl.DateTimeFormat(J,{
                    ...ne
                });
                return ce => ue.format(ce)
            }
            ),
            relativetime: createCachedFormatter( (J, ne) => {
                const ue = new Intl.RelativeTimeFormat(J,{
                    ...ne
                });
                return ce => ue.format(ce, ne.range || "day")
            }
            ),
            list: createCachedFormatter( (J, ne) => {
                const ue = new Intl.ListFormat(J,{
                    ...ne
                });
                return ce => ue.format(ce)
            }
            )
        },
        this.init(X)
    }
    init(X) {
        let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
            interpolation: {}
        };
        this.formatSeparator = J.interpolation.formatSeparator || ","
    }
    add(X, J) {
        this.formats[X.toLowerCase().trim()] = J
    }
    addCached(X, J) {
        this.formats[X.toLowerCase().trim()] = createCachedFormatter(J)
    }
    format(X, J, ne) {
        let ue = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        const ce = J.split(this.formatSeparator);
        if (ce.length > 1 && ce[0].indexOf("(") > 1 && ce[0].indexOf(")") < 0 && ce.find(ge => ge.indexOf(")") > -1)) {
            const ge = ce.findIndex(Te => Te.indexOf(")") > -1);
            ce[0] = [ce[0], ...ce.splice(1, ge)].join(this.formatSeparator)
        }
        return ce.reduce( (ge, Te) => {
            const {formatName: _e, formatOptions: Se} = parseFormatStr(Te);
            if (this.formats[_e]) {
                let Ie = ge;
                try {
                    const ye = ue && ue.formatParams && ue.formatParams[ue.interpolationkey] || {}
                      , $e = ye.locale || ye.lng || ue.locale || ue.lng || ne;
                    Ie = this.formats[_e](ge, $e, {
                        ...Se,
                        ...ue,
                        ...ye
                    })
                } catch (ye) {
                    this.logger.warn(ye)
                }
                return Ie
            } else
                this.logger.warn(`there was no format function for ${_e}`);
            return ge
        }
        , X)
    }
}
const removePending = (V, X) => {
    V.pending[X] !== void 0 && (delete V.pending[X],
    V.pendingCount--)
}
;
class Connector extends EventEmitter {
    constructor(X, J, ne) {
        let ue = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        super(),
        this.backend = X,
        this.store = J,
        this.services = ne,
        this.languageUtils = ne.languageUtils,
        this.options = ue,
        this.logger = baseLogger.create("backendConnector"),
        this.waitingReads = [],
        this.maxParallelReads = ue.maxParallelReads || 10,
        this.readingCalls = 0,
        this.maxRetries = ue.maxRetries >= 0 ? ue.maxRetries : 5,
        this.retryTimeout = ue.retryTimeout >= 1 ? ue.retryTimeout : 350,
        this.state = {},
        this.queue = [],
        this.backend && this.backend.init && this.backend.init(ne, ue.backend, ue)
    }
    queueLoad(X, J, ne, ue) {
        const ce = {}
          , me = {}
          , ge = {}
          , Te = {};
        return X.forEach(_e => {
            let Se = !0;
            J.forEach(Ie => {
                const ye = `${_e}|${Ie}`;
                !ne.reload && this.store.hasResourceBundle(_e, Ie) ? this.state[ye] = 2 : this.state[ye] < 0 || (this.state[ye] === 1 ? me[ye] === void 0 && (me[ye] = !0) : (this.state[ye] = 1,
                Se = !1,
                me[ye] === void 0 && (me[ye] = !0),
                ce[ye] === void 0 && (ce[ye] = !0),
                Te[Ie] === void 0 && (Te[Ie] = !0)))
            }
            ),
            Se || (ge[_e] = !0)
        }
        ),
        (Object.keys(ce).length || Object.keys(me).length) && this.queue.push({
            pending: me,
            pendingCount: Object.keys(me).length,
            loaded: {},
            errors: [],
            callback: ue
        }),
        {
            toLoad: Object.keys(ce),
            pending: Object.keys(me),
            toLoadLanguages: Object.keys(ge),
            toLoadNamespaces: Object.keys(Te)
        }
    }
    loaded(X, J, ne) {
        const ue = X.split("|")
          , ce = ue[0]
          , me = ue[1];
        J && this.emit("failedLoading", ce, me, J),
        !J && ne && this.store.addResourceBundle(ce, me, ne, void 0, void 0, {
            skipCopy: !0
        }),
        this.state[X] = J ? -1 : 2,
        J && ne && (this.state[X] = 0);
        const ge = {};
        this.queue.forEach(Te => {
            pushPath(Te.loaded, [ce], me),
            removePending(Te, X),
            J && Te.errors.push(J),
            Te.pendingCount === 0 && !Te.done && (Object.keys(Te.loaded).forEach(_e => {
                ge[_e] || (ge[_e] = {});
                const Se = Te.loaded[_e];
                Se.length && Se.forEach(Ie => {
                    ge[_e][Ie] === void 0 && (ge[_e][Ie] = !0)
                }
                )
            }
            ),
            Te.done = !0,
            Te.errors.length ? Te.callback(Te.errors) : Te.callback())
        }
        ),
        this.emit("loaded", ge),
        this.queue = this.queue.filter(Te => !Te.done)
    }
    read(X, J, ne) {
        let ue = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0
          , ce = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout
          , me = arguments.length > 5 ? arguments[5] : void 0;
        if (!X.length)
            return me(null, {});
        if (this.readingCalls >= this.maxParallelReads) {
            this.waitingReads.push({
                lng: X,
                ns: J,
                fcName: ne,
                tried: ue,
                wait: ce,
                callback: me
            });
            return
        }
        this.readingCalls++;
        const ge = (_e, Se) => {
            if (this.readingCalls--,
            this.waitingReads.length > 0) {
                const Ie = this.waitingReads.shift();
                this.read(Ie.lng, Ie.ns, Ie.fcName, Ie.tried, Ie.wait, Ie.callback)
            }
            if (_e && Se && ue < this.maxRetries) {
                setTimeout( () => {
                    this.read.call(this, X, J, ne, ue + 1, ce * 2, me)
                }
                , ce);
                return
            }
            me(_e, Se)
        }
          , Te = this.backend[ne].bind(this.backend);
        if (Te.length === 2) {
            try {
                const _e = Te(X, J);
                _e && typeof _e.then == "function" ? _e.then(Se => ge(null, Se)).catch(ge) : ge(null, _e)
            } catch (_e) {
                ge(_e)
            }
            return
        }
        return Te(X, J, ge)
    }
    prepareLoading(X, J) {
        let ne = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}
          , ue = arguments.length > 3 ? arguments[3] : void 0;
        if (!this.backend)
            return this.logger.warn("No backend was added via i18next.use. Will not load resources."),
            ue && ue();
        isString(X) && (X = this.languageUtils.toResolveHierarchy(X)),
        isString(J) && (J = [J]);
        const ce = this.queueLoad(X, J, ne, ue);
        if (!ce.toLoad.length)
            return ce.pending.length || ue(),
            null;
        ce.toLoad.forEach(me => {
            this.loadOne(me)
        }
        )
    }
    load(X, J, ne) {
        this.prepareLoading(X, J, {}, ne)
    }
    reload(X, J, ne) {
        this.prepareLoading(X, J, {
            reload: !0
        }, ne)
    }
    loadOne(X) {
        let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
        const ne = X.split("|")
          , ue = ne[0]
          , ce = ne[1];
        this.read(ue, ce, "read", void 0, void 0, (me, ge) => {
            me && this.logger.warn(`${J}loading namespace ${ce} for language ${ue} failed`, me),
            !me && ge && this.logger.log(`${J}loaded namespace ${ce} for language ${ue}`, ge),
            this.loaded(X, me, ge)
        }
        )
    }
    saveMissing(X, J, ne, ue, ce) {
        let me = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {}
          , ge = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {}
        ;
        if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(J)) {
            this.logger.warn(`did not save key "${ne}" as the namespace "${J}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
            return
        }
        if (!(ne == null || ne === "")) {
            if (this.backend && this.backend.create) {
                const Te = {
                    ...me,
                    isUpdate: ce
                }
                  , _e = this.backend.create.bind(this.backend);
                if (_e.length < 6)
                    try {
                        let Se;
                        _e.length === 5 ? Se = _e(X, J, ne, ue, Te) : Se = _e(X, J, ne, ue),
                        Se && typeof Se.then == "function" ? Se.then(Ie => ge(null, Ie)).catch(ge) : ge(null, Se)
                    } catch (Se) {
                        ge(Se)
                    }
                else
                    _e(X, J, ne, ue, ge, Te)
            }
            !X || !X[0] || this.store.addResource(X[0], J, ne, ue)
        }
    }
}
const get$1 = () => ({
    debug: !1,
    initImmediate: !0,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: !1,
    supportedLngs: !1,
    nonExplicitSupportedLngs: !1,
    load: "all",
    preload: !1,
    simplifyPluralSuffix: !0,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: !1,
    saveMissing: !1,
    updateMissing: !1,
    saveMissingTo: "fallback",
    saveMissingPlurals: !0,
    missingKeyHandler: !1,
    missingInterpolationHandler: !1,
    postProcess: !1,
    postProcessPassResolved: !1,
    returnNull: !1,
    returnEmptyString: !0,
    returnObjects: !1,
    joinArrays: !1,
    returnedObjectHandler: !1,
    parseMissingKeyHandler: !1,
    appendNamespaceToMissingKey: !1,
    appendNamespaceToCIMode: !1,
    overloadTranslationOptionHandler: V => {
        let X = {};
        if (typeof V[1] == "object" && (X = V[1]),
        isString(V[1]) && (X.defaultValue = V[1]),
        isString(V[2]) && (X.tDescription = V[2]),
        typeof V[2] == "object" || typeof V[3] == "object") {
            const J = V[3] || V[2];
            Object.keys(J).forEach(ne => {
                X[ne] = J[ne]
            }
            )
        }
        return X
    }
    ,
    interpolation: {
        escapeValue: !0,
        format: V => V,
        prefix: "{{",
        suffix: "}}",
        formatSeparator: ",",
        unescapePrefix: "-",
        nestingPrefix: "$t(",
        nestingSuffix: ")",
        nestingOptionsSeparator: ",",
        maxReplaces: 1e3,
        skipOnVariables: !0
    }
})
  , transformOptions = V => (isString(V.ns) && (V.ns = [V.ns]),
isString(V.fallbackLng) && (V.fallbackLng = [V.fallbackLng]),
isString(V.fallbackNS) && (V.fallbackNS = [V.fallbackNS]),
V.supportedLngs && V.supportedLngs.indexOf("cimode") < 0 && (V.supportedLngs = V.supportedLngs.concat(["cimode"])),
V)
  , noop$4 = () => {}
  , bindMemberFunctions = V => {
    Object.getOwnPropertyNames(Object.getPrototypeOf(V)).forEach(J => {
        typeof V[J] == "function" && (V[J] = V[J].bind(V))
    }
    )
}
;
class I18n extends EventEmitter {
    constructor() {
        let X = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
          , J = arguments.length > 1 ? arguments[1] : void 0;
        if (super(),
        this.options = transformOptions(X),
        this.services = {},
        this.logger = baseLogger,
        this.modules = {
            external: []
        },
        bindMemberFunctions(this),
        J && !this.isInitialized && !X.isClone) {
            if (!this.options.initImmediate)
                return this.init(X, J),
                this;
            setTimeout( () => {
                this.init(X, J)
            }
            , 0)
        }
    }
    init() {
        var X = this;
        let J = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
          , ne = arguments.length > 1 ? arguments[1] : void 0;
        this.isInitializing = !0,
        typeof J == "function" && (ne = J,
        J = {}),
        !J.defaultNS && J.defaultNS !== !1 && J.ns && (isString(J.ns) ? J.defaultNS = J.ns : J.ns.indexOf("translation") < 0 && (J.defaultNS = J.ns[0]));
        const ue = get$1();
        this.options = {
            ...ue,
            ...this.options,
            ...transformOptions(J)
        },
        this.options.compatibilityAPI !== "v1" && (this.options.interpolation = {
            ...ue.interpolation,
            ...this.options.interpolation
        }),
        J.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = J.keySeparator),
        J.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = J.nsSeparator);
        const ce = Se => Se ? typeof Se == "function" ? new Se : Se : null;
        if (!this.options.isClone) {
            this.modules.logger ? baseLogger.init(ce(this.modules.logger), this.options) : baseLogger.init(null, this.options);
            let Se;
            this.modules.formatter ? Se = this.modules.formatter : typeof Intl < "u" && (Se = Formatter);
            const Ie = new LanguageUtil(this.options);
            this.store = new ResourceStore(this.options.resources,this.options);
            const ye = this.services;
            ye.logger = baseLogger,
            ye.resourceStore = this.store,
            ye.languageUtils = Ie,
            ye.pluralResolver = new PluralResolver(Ie,{
                prepend: this.options.pluralSeparator,
                compatibilityJSON: this.options.compatibilityJSON,
                simplifyPluralSuffix: this.options.simplifyPluralSuffix
            }),
            Se && (!this.options.interpolation.format || this.options.interpolation.format === ue.interpolation.format) && (ye.formatter = ce(Se),
            ye.formatter.init(ye, this.options),
            this.options.interpolation.format = ye.formatter.format.bind(ye.formatter)),
            ye.interpolator = new Interpolator(this.options),
            ye.utils = {
                hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
            },
            ye.backendConnector = new Connector(ce(this.modules.backend),ye.resourceStore,ye,this.options),
            ye.backendConnector.on("*", function($e) {
                for (var Ne = arguments.length, ve = new Array(Ne > 1 ? Ne - 1 : 0), ke = 1; ke < Ne; ke++)
                    ve[ke - 1] = arguments[ke];
                X.emit($e, ...ve)
            }),
            this.modules.languageDetector && (ye.languageDetector = ce(this.modules.languageDetector),
            ye.languageDetector.init && ye.languageDetector.init(ye, this.options.detection, this.options)),
            this.modules.i18nFormat && (ye.i18nFormat = ce(this.modules.i18nFormat),
            ye.i18nFormat.init && ye.i18nFormat.init(this)),
            this.translator = new Translator(this.services,this.options),
            this.translator.on("*", function($e) {
                for (var Ne = arguments.length, ve = new Array(Ne > 1 ? Ne - 1 : 0), ke = 1; ke < Ne; ke++)
                    ve[ke - 1] = arguments[ke];
                X.emit($e, ...ve)
            }),
            this.modules.external.forEach($e => {
                $e.init && $e.init(this)
            }
            )
        }
        if (this.format = this.options.interpolation.format,
        ne || (ne = noop$4),
        this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
            const Se = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
            Se.length > 0 && Se[0] !== "dev" && (this.options.lng = Se[0])
        }
        !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined"),
        ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach(Se => {
            this[Se] = function() {
                return X.store[Se](...arguments)
            }
        }
        ),
        ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach(Se => {
            this[Se] = function() {
                return X.store[Se](...arguments),
                X
            }
        }
        );
        const Te = defer()
          , _e = () => {
            const Se = (Ie, ye) => {
                this.isInitializing = !1,
                this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"),
                this.isInitialized = !0,
                this.options.isClone || this.logger.log("initialized", this.options),
                this.emit("initialized", this.options),
                Te.resolve(ye),
                ne(Ie, ye)
            }
            ;
            if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized)
                return Se(null, this.t.bind(this));
            this.changeLanguage(this.options.lng, Se)
        }
        ;
        return this.options.resources || !this.options.initImmediate ? _e() : setTimeout(_e, 0),
        Te
    }
    loadResources(X) {
        let ne = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$4;
        const ue = isString(X) ? X : this.language;
        if (typeof X == "function" && (ne = X),
        !this.options.resources || this.options.partialBundledLanguages) {
            if (ue && ue.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0))
                return ne();
            const ce = []
              , me = ge => {
                if (!ge || ge === "cimode")
                    return;
                this.services.languageUtils.toResolveHierarchy(ge).forEach(_e => {
                    _e !== "cimode" && ce.indexOf(_e) < 0 && ce.push(_e)
                }
                )
            }
            ;
            ue ? me(ue) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach(Te => me(Te)),
            this.options.preload && this.options.preload.forEach(ge => me(ge)),
            this.services.backendConnector.load(ce, this.options.ns, ge => {
                !ge && !this.resolvedLanguage && this.language && this.setResolvedLanguage(this.language),
                ne(ge)
            }
            )
        } else
            ne(null)
    }
    reloadResources(X, J, ne) {
        const ue = defer();
        return typeof X == "function" && (ne = X,
        X = void 0),
        typeof J == "function" && (ne = J,
        J = void 0),
        X || (X = this.languages),
        J || (J = this.options.ns),
        ne || (ne = noop$4),
        this.services.backendConnector.reload(X, J, ce => {
            ue.resolve(),
            ne(ce)
        }
        ),
        ue
    }
    use(X) {
        if (!X)
            throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
        if (!X.type)
            throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
        return X.type === "backend" && (this.modules.backend = X),
        (X.type === "logger" || X.log && X.warn && X.error) && (this.modules.logger = X),
        X.type === "languageDetector" && (this.modules.languageDetector = X),
        X.type === "i18nFormat" && (this.modules.i18nFormat = X),
        X.type === "postProcessor" && postProcessor.addPostProcessor(X),
        X.type === "formatter" && (this.modules.formatter = X),
        X.type === "3rdParty" && this.modules.external.push(X),
        this
    }
    setResolvedLanguage(X) {
        if (!(!X || !this.languages) && !(["cimode", "dev"].indexOf(X) > -1))
            for (let J = 0; J < this.languages.length; J++) {
                const ne = this.languages[J];
                if (!(["cimode", "dev"].indexOf(ne) > -1) && this.store.hasLanguageSomeTranslations(ne)) {
                    this.resolvedLanguage = ne;
                    break
                }
            }
    }
    changeLanguage(X, J) {
        var ne = this;
        this.isLanguageChangingTo = X;
        const ue = defer();
        this.emit("languageChanging", X);
        const ce = Te => {
            this.language = Te,
            this.languages = this.services.languageUtils.toResolveHierarchy(Te),
            this.resolvedLanguage = void 0,
            this.setResolvedLanguage(Te)
        }
          , me = (Te, _e) => {
            _e ? (ce(_e),
            this.translator.changeLanguage(_e),
            this.isLanguageChangingTo = void 0,
            this.emit("languageChanged", _e),
            this.logger.log("languageChanged", _e)) : this.isLanguageChangingTo = void 0,
            ue.resolve(function() {
                return ne.t(...arguments)
            }),
            J && J(Te, function() {
                return ne.t(...arguments)
            })
        }
          , ge = Te => {
            !X && !Te && this.services.languageDetector && (Te = []);
            const _e = isString(Te) ? Te : this.services.languageUtils.getBestMatchFromCodes(Te);
            _e && (this.language || ce(_e),
            this.translator.language || this.translator.changeLanguage(_e),
            this.services.languageDetector && this.services.languageDetector.cacheUserLanguage && this.services.languageDetector.cacheUserLanguage(_e)),
            this.loadResources(_e, Se => {
                me(Se, _e)
            }
            )
        }
        ;
        return !X && this.services.languageDetector && !this.services.languageDetector.async ? ge(this.services.languageDetector.detect()) : !X && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(ge) : this.services.languageDetector.detect(ge) : ge(X),
        ue
    }
    getFixedT(X, J, ne) {
        var ue = this;
        const ce = function(me, ge) {
            let Te;
            if (typeof ge != "object") {
                for (var _e = arguments.length, Se = new Array(_e > 2 ? _e - 2 : 0), Ie = 2; Ie < _e; Ie++)
                    Se[Ie - 2] = arguments[Ie];
                Te = ue.options.overloadTranslationOptionHandler([me, ge].concat(Se))
            } else
                Te = {
                    ...ge
                };
            Te.lng = Te.lng || ce.lng,
            Te.lngs = Te.lngs || ce.lngs,
            Te.ns = Te.ns || ce.ns,
            Te.keyPrefix !== "" && (Te.keyPrefix = Te.keyPrefix || ne || ce.keyPrefix);
            const ye = ue.options.keySeparator || ".";
            let $e;
            return Te.keyPrefix && Array.isArray(me) ? $e = me.map(Ne => `${Te.keyPrefix}${ye}${Ne}`) : $e = Te.keyPrefix ? `${Te.keyPrefix}${ye}${me}` : me,
            ue.t($e, Te)
        };
        return isString(X) ? ce.lng = X : ce.lngs = X,
        ce.ns = J,
        ce.keyPrefix = ne,
        ce
    }
    t() {
        return this.translator && this.translator.translate(...arguments)
    }
    exists() {
        return this.translator && this.translator.exists(...arguments)
    }
    setDefaultNamespace(X) {
        this.options.defaultNS = X
    }
    hasLoadedNamespace(X) {
        let J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (!this.isInitialized)
            return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages),
            !1;
        if (!this.languages || !this.languages.length)
            return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages),
            !1;
        const ne = J.lng || this.resolvedLanguage || this.languages[0]
          , ue = this.options ? this.options.fallbackLng : !1
          , ce = this.languages[this.languages.length - 1];
        if (ne.toLowerCase() === "cimode")
            return !0;
        const me = (ge, Te) => {
            const _e = this.services.backendConnector.state[`${ge}|${Te}`];
            return _e === -1 || _e === 0 || _e === 2
        }
        ;
        if (J.precheck) {
            const ge = J.precheck(this, me);
            if (ge !== void 0)
                return ge
        }
        return !!(this.hasResourceBundle(ne, X) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || me(ne, X) && (!ue || me(ce, X)))
    }
    loadNamespaces(X, J) {
        const ne = defer();
        return this.options.ns ? (isString(X) && (X = [X]),
        X.forEach(ue => {
            this.options.ns.indexOf(ue) < 0 && this.options.ns.push(ue)
        }
        ),
        this.loadResources(ue => {
            ne.resolve(),
            J && J(ue)
        }
        ),
        ne) : (J && J(),
        Promise.resolve())
    }
    loadLanguages(X, J) {
        const ne = defer();
        isString(X) && (X = [X]);
        const ue = this.options.preload || []
          , ce = X.filter(me => ue.indexOf(me) < 0 && this.services.languageUtils.isSupportedCode(me));
        return ce.length ? (this.options.preload = ue.concat(ce),
        this.loadResources(me => {
            ne.resolve(),
            J && J(me)
        }
        ),
        ne) : (J && J(),
        Promise.resolve())
    }
    dir(X) {
        if (X || (X = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)),
        !X)
            return "rtl";
        const J = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"]
          , ne = this.services && this.services.languageUtils || new LanguageUtil(get$1());
        return J.indexOf(ne.getLanguagePartFromCode(X)) > -1 || X.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr"
    }
    static createInstance() {
        let X = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
          , J = arguments.length > 1 ? arguments[1] : void 0;
        return new I18n(X,J)
    }
    cloneInstance() {
        let X = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}
          , J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$4;
        const ne = X.forkResourceStore;
        ne && delete X.forkResourceStore;
        const ue = {
            ...this.options,
            ...X,
            isClone: !0
        }
          , ce = new I18n(ue);
        return (X.debug !== void 0 || X.prefix !== void 0) && (ce.logger = ce.logger.clone(X)),
        ["store", "services", "language"].forEach(ge => {
            ce[ge] = this[ge]
        }
        ),
        ce.services = {
            ...this.services
        },
        ce.services.utils = {
            hasLoadedNamespace: ce.hasLoadedNamespace.bind(ce)
        },
        ne && (ce.store = new ResourceStore(this.store.data,ue),
        ce.services.resourceStore = ce.store),
        ce.translator = new Translator(ce.services,ue),
        ce.translator.on("*", function(ge) {
            for (var Te = arguments.length, _e = new Array(Te > 1 ? Te - 1 : 0), Se = 1; Se < Te; Se++)
                _e[Se - 1] = arguments[Se];
            ce.emit(ge, ..._e)
        }),
        ce.init(ue, J),
        ce.translator.options = ue,
        ce.translator.backendConnector.services.utils = {
            hasLoadedNamespace: ce.hasLoadedNamespace.bind(ce)
        },
        ce
    }
    toJSON() {
        return {
            options: this.options,
            store: this.store,
            language: this.language,
            languages: this.languages,
            resolvedLanguage: this.resolvedLanguage
        }
    }
}
const instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
instance.createInstance;
instance.dir;
instance.init;
instance.loadResources;
instance.reloadResources;
instance.use;
instance.changeLanguage;
instance.getFixedT;
const t$1 = instance.t;
instance.exists;
instance.setDefaultNamespace;
instance.hasLoadedNamespace;
instance.loadNamespaces;
instance.loadLanguages;
function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function(V) {
        for (var X = 1; X < arguments.length; X++) {
            var J = arguments[X];
            for (var ne in J)
                ({}).hasOwnProperty.call(J, ne) && (V[ne] = J[ne])
        }
        return V
    }
    ,
    _extends.apply(null, arguments)
}
var voidElements = {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
};
const e = getDefaultExportFromCjs(voidElements);
var t = /\s([^'"/\s><]+?)[\s/>]|([^\s=]+)=\s?(".*?"|'.*?')/g;
function n$1(V) {
    var X = {
        type: "tag",
        name: "",
        voidElement: !1,
        attrs: {},
        children: []
    }
      , J = V.match(/<\/?([^\s]+?)[/\s>]/);
    if (J && (X.name = J[1],
    (e[J[1]] || V.charAt(V.length - 2) === "/") && (X.voidElement = !0),
    X.name.startsWith("!--"))) {
        var ne = V.indexOf("-->");
        return {
            type: "comment",
            comment: ne !== -1 ? V.slice(4, ne) : ""
        }
    }
    for (var ue = new RegExp(t), ce = null; (ce = ue.exec(V)) !== null; )
        if (ce[0].trim())
            if (ce[1]) {
                var me = ce[1].trim()
                  , ge = [me, ""];
                me.indexOf("=") > -1 && (ge = me.split("=")),
                X.attrs[ge[0]] = ge[1],
                ue.lastIndex--
            } else
                ce[2] && (X.attrs[ce[2]] = ce[3].trim().substring(1, ce[3].length - 1));
    return X
}
var r$1 = /<[a-zA-Z0-9\-\!\/](?:"[^"]*"|'[^']*'|[^'">])*>/g
  , i$1 = /^\s*$/
  , s$1 = Object.create(null);
function a$1(V, X) {
    switch (X.type) {
    case "text":
        return V + X.content;
    case "tag":
        return V += "<" + X.name + (X.attrs ? function(J) {
            var ne = [];
            for (var ue in J)
                ne.push(ue + '="' + J[ue] + '"');
            return ne.length ? " " + ne.join(" ") : ""
        }(X.attrs) : "") + (X.voidElement ? "/>" : ">"),
        X.voidElement ? V : V + X.children.reduce(a$1, "") + "</" + X.name + ">";
    case "comment":
        return V + "<!--" + X.comment + "-->"
    }
}
var c$1 = {
    parse: function(V, X) {
        X || (X = {}),
        X.components || (X.components = s$1);
        var J, ne = [], ue = [], ce = -1, me = !1;
        if (V.indexOf("<") !== 0) {
            var ge = V.indexOf("<");
            ne.push({
                type: "text",
                content: ge === -1 ? V : V.substring(0, ge)
            })
        }
        return V.replace(r$1, function(Te, _e) {
            if (me) {
                if (Te !== "</" + J.name + ">")
                    return;
                me = !1
            }
            var Se, Ie = Te.charAt(1) !== "/", ye = Te.startsWith("<!--"), $e = _e + Te.length, Ne = V.charAt($e);
            if (ye) {
                var ve = n$1(Te);
                return ce < 0 ? (ne.push(ve),
                ne) : ((Se = ue[ce]).children.push(ve),
                ne)
            }
            if (Ie && (ce++,
            (J = n$1(Te)).type === "tag" && X.components[J.name] && (J.type = "component",
            me = !0),
            J.voidElement || me || !Ne || Ne === "<" || J.children.push({
                type: "text",
                content: V.slice($e, V.indexOf("<", $e))
            }),
            ce === 0 && ne.push(J),
            (Se = ue[ce - 1]) && Se.children.push(J),
            ue[ce] = J),
            (!Ie || J.voidElement) && (ce > -1 && (J.voidElement || J.name === Te.slice(2, -1)) && (ce--,
            J = ce === -1 ? ne : ue[ce]),
            !me && Ne !== "<" && Ne)) {
                Se = ce === -1 ? ne : ue[ce].children;
                var ke = V.indexOf("<", $e)
                  , xe = V.slice($e, ke === -1 ? void 0 : ke);
                i$1.test(xe) && (xe = " "),
                (ke > -1 && ce + Se.length >= 0 || xe !== " ") && Se.push({
                    type: "text",
                    content: xe
                })
            }
        }),
        ne
    },
    stringify: function(V) {
        return V.reduce(function(X, J) {
            return X + a$1("", J)
        }, "")
    }
};
function warn() {
    if (console && console.warn) {
        for (var V = arguments.length, X = new Array(V), J = 0; J < V; J++)
            X[J] = arguments[J];
        typeof X[0] == "string" && (X[0] = `react-i18next:: ${X[0]}`),
        console.warn(...X)
    }
}
const alreadyWarned$1 = {};
function warnOnce$1() {
    for (var V = arguments.length, X = new Array(V), J = 0; J < V; J++)
        X[J] = arguments[J];
    typeof X[0] == "string" && alreadyWarned$1[X[0]] || (typeof X[0] == "string" && (alreadyWarned$1[X[0]] = new Date),
    warn(...X))
}
const loadedClb = (V, X) => () => {
    if (V.isInitialized)
        X();
    else {
        const J = () => {
            setTimeout( () => {
                V.off("initialized", J)
            }
            , 0),
            X()
        }
        ;
        V.on("initialized", J)
    }
}
;
function loadNamespaces(V, X, J) {
    V.loadNamespaces(X, loadedClb(V, J))
}
function loadLanguages(V, X, J, ne) {
    typeof J == "string" && (J = [J]),
    J.forEach(ue => {
        V.options.ns.indexOf(ue) < 0 && V.options.ns.push(ue)
    }
    ),
    V.loadLanguages(X, loadedClb(V, ne))
}
function oldI18nextHasLoadedNamespace(V, X) {
    let J = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const ne = X.languages[0]
      , ue = X.options ? X.options.fallbackLng : !1
      , ce = X.languages[X.languages.length - 1];
    if (ne.toLowerCase() === "cimode")
        return !0;
    const me = (ge, Te) => {
        const _e = X.services.backendConnector.state[`${ge}|${Te}`];
        return _e === -1 || _e === 2
    }
    ;
    return J.bindI18n && J.bindI18n.indexOf("languageChanging") > -1 && X.services.backendConnector.backend && X.isLanguageChangingTo && !me(X.isLanguageChangingTo, V) ? !1 : !!(X.hasResourceBundle(ne, V) || !X.services.backendConnector.backend || X.options.resources && !X.options.partialBundledLanguages || me(ne, V) && (!ue || me(ce, V)))
}
function hasLoadedNamespace(V, X) {
    let J = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return !X.languages || !X.languages.length ? (warnOnce$1("i18n.languages were undefined or empty", X.languages),
    !0) : X.options.ignoreJSONStructure !== void 0 ? X.hasLoadedNamespace(V, {
        lng: J.lng,
        precheck: (ue, ce) => {
            if (J.bindI18n && J.bindI18n.indexOf("languageChanging") > -1 && ue.services.backendConnector.backend && ue.isLanguageChangingTo && !ce(ue.isLanguageChangingTo, V))
                return !1
        }
    }) : oldI18nextHasLoadedNamespace(V, X, J)
}
const matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g
  , htmlEntities = {
    "&amp;": "&",
    "&#38;": "&",
    "&lt;": "<",
    "&#60;": "<",
    "&gt;": ">",
    "&#62;": ">",
    "&apos;": "'",
    "&#39;": "'",
    "&quot;": '"',
    "&#34;": '"',
    "&nbsp;": " ",
    "&#160;": " ",
    "&copy;": "©",
    "&#169;": "©",
    "&reg;": "®",
    "&#174;": "®",
    "&hellip;": "…",
    "&#8230;": "…",
    "&#x2F;": "/",
    "&#47;": "/"
}
  , unescapeHtmlEntity = V => htmlEntities[V]
  , unescape = V => V.replace(matchHtmlEntity, unescapeHtmlEntity);
let defaultOptions = {
    bindI18n: "languageChanged",
    bindI18nStore: "",
    transEmptyNodeValue: "",
    transSupportBasicHtmlNodes: !0,
    transWrapTextNodes: "",
    transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
    useSuspense: !0,
    unescape
};
function setDefaults() {
    let V = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    defaultOptions = {
        ...defaultOptions,
        ...V
    }
}
function getDefaults$2() {
    return defaultOptions
}
let i18nInstance;
function setI18n(V) {
    i18nInstance = V
}
function getI18n() {
    return i18nInstance
}
function hasChildren(V, X) {
    if (!V)
        return !1;
    const J = V.props ? V.props.children : V.children;
    return X ? J.length > 0 : !!J
}
function getChildren(V) {
    if (!V)
        return [];
    const X = V.props ? V.props.children : V.children;
    return V.props && V.props.i18nIsDynamicList ? getAsArray(X) : X
}
function hasValidReactChildren(V) {
    return Object.prototype.toString.call(V) !== "[object Array]" ? !1 : V.every(X => reactExports.isValidElement(X))
}
function getAsArray(V) {
    return Array.isArray(V) ? V : [V]
}
function mergeProps(V, X) {
    const J = {
        ...X
    };
    return J.props = Object.assign(V.props, X.props),
    J
}
function nodesToString(V, X) {
    if (!V)
        return "";
    let J = "";
    const ne = getAsArray(V)
      , ue = X.transSupportBasicHtmlNodes && X.transKeepBasicHtmlNodesFor ? X.transKeepBasicHtmlNodesFor : [];
    return ne.forEach( (ce, me) => {
        if (typeof ce == "string")
            J += `${ce}`;
        else if (reactExports.isValidElement(ce)) {
            const ge = Object.keys(ce.props).length
              , Te = ue.indexOf(ce.type) > -1
              , _e = ce.props.children;
            if (!_e && Te && ge === 0)
                J += `<${ce.type}/>`;
            else if (!_e && (!Te || ge !== 0))
                J += `<${me}></${me}>`;
            else if (ce.props.i18nIsDynamicList)
                J += `<${me}></${me}>`;
            else if (Te && ge === 1 && typeof _e == "string")
                J += `<${ce.type}>${_e}</${ce.type}>`;
            else {
                const Se = nodesToString(_e, X);
                J += `<${me}>${Se}</${me}>`
            }
        } else if (ce === null)
            warn("Trans: the passed in value is invalid - seems you passed in a null child.");
        else if (typeof ce == "object") {
            const {format: ge, ...Te} = ce
              , _e = Object.keys(Te);
            if (_e.length === 1) {
                const Se = ge ? `${_e[0]}, ${ge}` : _e[0];
                J += `{{${Se}}}`
            } else
                warn("react-i18next: the passed in object contained more than one variable - the object should look like {{ value, format }} where format is optional.", ce)
        } else
            warn("Trans: the passed in value is invalid - seems you passed in a variable like {number} - please pass in variables for interpolation as full objects like {{number}}.", ce)
    }
    ),
    J
}
function renderNodes(V, X, J, ne, ue, ce) {
    if (X === "")
        return [];
    const me = ne.transKeepBasicHtmlNodesFor || []
      , ge = X && new RegExp(me.map(ke => `<${ke}`).join("|")).test(X);
    if (!V && !ge && !ce)
        return [X];
    const Te = {};
    function _e(ke) {
        getAsArray(ke).forEach(we => {
            typeof we != "string" && (hasChildren(we) ? _e(getChildren(we)) : typeof we == "object" && !reactExports.isValidElement(we) && Object.assign(Te, we))
        }
        )
    }
    _e(V);
    const Se = c$1.parse(`<0>${X}</0>`)
      , Ie = {
        ...Te,
        ...ue
    };
    function ye(ke, xe, we) {
        const Fe = getChildren(ke)
          , je = Ne(Fe, xe.children, we);
        return hasValidReactChildren(Fe) && je.length === 0 || ke.props && ke.props.i18nIsDynamicList ? Fe : je
    }
    function $e(ke, xe, we, Fe, je) {
        ke.dummy ? (ke.children = xe,
        we.push(reactExports.cloneElement(ke, {
            key: Fe
        }, je ? void 0 : xe))) : we.push(...reactExports.Children.map([ke], Xe => {
            const ze = {
                ...Xe.props
            };
            return delete ze.i18nIsDynamicList,
            React$2.createElement(Xe.type, _extends({}, ze, {
                key: Fe,
                ref: Xe.ref
            }, je ? {} : {
                children: xe
            }))
        }
        ))
    }
    function Ne(ke, xe, we) {
        const Fe = getAsArray(ke);
        return getAsArray(xe).reduce( (Xe, ze, qe) => {
            const Ze = ze.children && ze.children[0] && ze.children[0].content && J.services.interpolator.interpolate(ze.children[0].content, Ie, J.language);
            if (ze.type === "tag") {
                let et = Fe[parseInt(ze.name, 10)];
                we.length === 1 && !et && (et = we[0][ze.name]),
                et || (et = {});
                const it = Object.keys(ze.attrs).length !== 0 ? mergeProps({
                    props: ze.attrs
                }, et) : et
                  , at = reactExports.isValidElement(it)
                  , rt = at && hasChildren(ze, !0) && !ze.voidElement
                  , ft = ge && typeof it == "object" && it.dummy && !at
                  , St = typeof V == "object" && V !== null && Object.hasOwnProperty.call(V, ze.name);
                if (typeof it == "string") {
                    const Ye = J.services.interpolator.interpolate(it, Ie, J.language);
                    Xe.push(Ye)
                } else if (hasChildren(it) || rt) {
                    const Ye = ye(it, ze, we);
                    $e(it, Ye, Xe, qe)
                } else if (ft) {
                    const Ye = Ne(Fe, ze.children, we);
                    $e(it, Ye, Xe, qe)
                } else if (Number.isNaN(parseFloat(ze.name)))
                    if (St) {
                        const Ye = ye(it, ze, we);
                        $e(it, Ye, Xe, qe, ze.voidElement)
                    } else if (ne.transSupportBasicHtmlNodes && me.indexOf(ze.name) > -1)
                        if (ze.voidElement)
                            Xe.push(reactExports.createElement(ze.name, {
                                key: `${ze.name}-${qe}`
                            }));
                        else {
                            const Ye = Ne(Fe, ze.children, we);
                            Xe.push(reactExports.createElement(ze.name, {
                                key: `${ze.name}-${qe}`
                            }, Ye))
                        }
                    else if (ze.voidElement)
                        Xe.push(`<${ze.name} />`);
                    else {
                        const Ye = Ne(Fe, ze.children, we);
                        Xe.push(`<${ze.name}>${Ye}</${ze.name}>`)
                    }
                else if (typeof it == "object" && !at) {
                    const Ye = ze.children[0] ? Ze : null;
                    Ye && Xe.push(Ye)
                } else
                    $e(it, Ze, Xe, qe, ze.children.length !== 1 || !Ze)
            } else if (ze.type === "text") {
                const et = ne.transWrapTextNodes
                  , it = ce ? ne.unescape(J.services.interpolator.interpolate(ze.content, Ie, J.language)) : J.services.interpolator.interpolate(ze.content, Ie, J.language);
                et ? Xe.push(reactExports.createElement(et, {
                    key: `${ze.name}-${qe}`
                }, it)) : Xe.push(it)
            }
            return Xe
        }
        , [])
    }
    const ve = Ne([{
        dummy: !0,
        children: V || []
    }], Se, getAsArray(V || []));
    return getChildren(ve[0])
}
function Trans$1(V) {
    let {children: X, count: J, parent: ne, i18nKey: ue, context: ce, tOptions: me={}, values: ge, defaults: Te, components: _e, ns: Se, i18n: Ie, t: ye, shouldUnescape: $e, ...Ne} = V;
    const ve = Ie || getI18n();
    if (!ve)
        return warnOnce$1("You will need to pass in an i18next instance by using i18nextReactModule"),
        X;
    const ke = ye || ve.t.bind(ve) || (rt => rt);
    ce && (me.context = ce);
    const xe = {
        ...getDefaults$2(),
        ...ve.options && ve.options.react
    };
    let we = Se || ke.ns || ve.options && ve.options.defaultNS;
    we = typeof we == "string" ? [we] : we || ["translation"];
    const Fe = nodesToString(X, xe)
      , je = Te || Fe || xe.transEmptyNodeValue || ue
      , {hashTransKey: Xe} = xe
      , ze = ue || (Xe ? Xe(Fe || je) : Fe || je);
    ve.options && ve.options.interpolation && ve.options.interpolation.defaultVariables && (ge = ge && Object.keys(ge).length > 0 ? {
        ...ge,
        ...ve.options.interpolation.defaultVariables
    } : {
        ...ve.options.interpolation.defaultVariables
    });
    const qe = ge ? me.interpolation : {
        interpolation: {
            ...me.interpolation,
            prefix: "#$?",
            suffix: "?$#"
        }
    }
      , Ze = {
        ...me,
        count: J,
        ...ge,
        ...qe,
        defaultValue: je,
        ns: we
    }
      , et = ze ? ke(ze, Ze) : je;
    _e && Object.keys(_e).forEach(rt => {
        const ft = _e[rt];
        if (typeof ft.type == "function" || !ft.props || !ft.props.children || et.indexOf(`${rt}/>`) < 0 && et.indexOf(`${rt} />`) < 0)
            return;
        function St() {
            return React$2.createElement(React$2.Fragment, null, ft)
        }
        _e[rt] = React$2.createElement(St, null)
    }
    );
    const it = renderNodes(_e || X, et, ve, xe, Ze, $e)
      , at = ne !== void 0 ? ne : xe.defaultTransParent;
    return at ? reactExports.createElement(at, Ne, it) : it
}
const initReactI18next = {
    type: "3rdParty",
    init(V) {
        setDefaults(V.options.react),
        setI18n(V)
    }
}
  , I18nContext = reactExports.createContext();
class ReportNamespaces {
    constructor() {
        this.usedNamespaces = {}
    }
    addUsedNamespaces(X) {
        X.forEach(J => {
            this.usedNamespaces[J] || (this.usedNamespaces[J] = !0)
        }
        )
    }
    getUsedNamespaces() {
        return Object.keys(this.usedNamespaces)
    }
}
function Trans(V) {
    let {children: X, count: J, parent: ne, i18nKey: ue, context: ce, tOptions: me={}, values: ge, defaults: Te, components: _e, ns: Se, i18n: Ie, t: ye, shouldUnescape: $e, ...Ne} = V;
    const {i18n: ve, defaultNS: ke} = reactExports.useContext(I18nContext) || {}
      , xe = Ie || ve || getI18n()
      , we = ye || xe && xe.t.bind(xe);
    return Trans$1({
        children: X,
        count: J,
        parent: ne,
        i18nKey: ue,
        context: ce,
        tOptions: me,
        values: ge,
        defaults: Te,
        components: _e,
        ns: Se || we && we.ns || ke || xe && xe.options && xe.options.defaultNS,
        i18n: xe,
        t: ye,
        shouldUnescape: $e,
        ...Ne
    })
}
const usePrevious = (V, X) => {
    const J = reactExports.useRef();
    return reactExports.useEffect( () => {
        J.current = V
    }
    , [V, X]),
    J.current
}
;
function useTranslation(V) {
    let X = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {i18n: J} = X
      , {i18n: ne, defaultNS: ue} = reactExports.useContext(I18nContext) || {}
      , ce = J || ne || getI18n();
    if (ce && !ce.reportNamespaces && (ce.reportNamespaces = new ReportNamespaces),
    !ce) {
        warnOnce$1("You will need to pass in an i18next instance by using initReactI18next");
        const Fe = (Xe, ze) => typeof ze == "string" ? ze : ze && typeof ze == "object" && typeof ze.defaultValue == "string" ? ze.defaultValue : Array.isArray(Xe) ? Xe[Xe.length - 1] : Xe
          , je = [Fe, {}, !1];
        return je.t = Fe,
        je.i18n = {},
        je.ready = !1,
        je
    }
    ce.options.react && ce.options.react.wait !== void 0 && warnOnce$1("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
    const me = {
        ...getDefaults$2(),
        ...ce.options.react,
        ...X
    }
      , {useSuspense: ge, keyPrefix: Te} = me;
    let _e = ue || ce.options && ce.options.defaultNS;
    _e = typeof _e == "string" ? [_e] : _e || ["translation"],
    ce.reportNamespaces.addUsedNamespaces && ce.reportNamespaces.addUsedNamespaces(_e);
    const Se = (ce.isInitialized || ce.initializedStoreOnce) && _e.every(Fe => hasLoadedNamespace(Fe, ce, me));
    function Ie() {
        return ce.getFixedT(X.lng || null, me.nsMode === "fallback" ? _e : _e[0], Te)
    }
    const [ye,$e] = reactExports.useState(Ie);
    let Ne = _e.join();
    X.lng && (Ne = `${X.lng}${Ne}`);
    const ve = usePrevious(Ne)
      , ke = reactExports.useRef(!0);
    reactExports.useEffect( () => {
        const {bindI18n: Fe, bindI18nStore: je} = me;
        ke.current = !0,
        !Se && !ge && (X.lng ? loadLanguages(ce, X.lng, _e, () => {
            ke.current && $e(Ie)
        }
        ) : loadNamespaces(ce, _e, () => {
            ke.current && $e(Ie)
        }
        )),
        Se && ve && ve !== Ne && ke.current && $e(Ie);
        function Xe() {
            ke.current && $e(Ie)
        }
        return Fe && ce && ce.on(Fe, Xe),
        je && ce && ce.store.on(je, Xe),
        () => {
            ke.current = !1,
            Fe && ce && Fe.split(" ").forEach(ze => ce.off(ze, Xe)),
            je && ce && je.split(" ").forEach(ze => ce.store.off(ze, Xe))
        }
    }
    , [ce, Ne]);
    const xe = reactExports.useRef(!0);
    reactExports.useEffect( () => {
        ke.current && !xe.current && $e(Ie),
        xe.current = !1
    }
    , [ce, Te]);
    const we = [ye, ce, Se];
    if (we.t = ye,
    we.i18n = ce,
    we.ready = Se,
    Se || !Se && !ge)
        return we;
    throw new Promise(Fe => {
        X.lng ? loadLanguages(ce, X.lng, _e, () => Fe()) : loadNamespaces(ce, _e, () => Fe())
    }
    )
}
const footer$2 = "_footer_l9jrz_1"
  , wrapper$7 = "_wrapper_l9jrz_5"
  , version = "_version_l9jrz_10"
  , styles$F = {
    footer: footer$2,
    wrapper: wrapper$7,
    version
}
  , logger$k = Logger$1.get("EAFooter")
  , EAFooter = () => {
    const {t} = useTranslation()
      , networkFooterRef = reactExports.useRef(null)
      , hasFooterScriptRun = reactExports.useRef(!1)
      , localFooterUrl = buildUrl(["https://www.ea.com", "/api/component/localFooter/", instance.language.toLocaleLowerCase(), "games/battlefield/battlefield-6"])
      , networkFooterUrl = buildUrl(["https://www.ea.com", "/api/component/networkFooter/", instance.language.toLocaleLowerCase(), "games/battlefield/battlefield-6"])
      , {status: localFooterStatus, error: localFooterError, data: localFooterData} = useQuery({
        queryKey: [QUERY_KEY.LOCAL_FOOTER, localFooterUrl],
        refetchOnWindowFocus: !1,
        queryFn: async () => await (await fetch(localFooterUrl)).text()
    })
      , {status: networkFooterStatus, error: networkFooterError, data: networkFooterData} = useQuery({
        queryKey: [QUERY_KEY.NETWORK_FOOTER, networkFooterUrl],
        refetchOnWindowFocus: !1,
        queryFn: async () => await (await fetch(networkFooterUrl)).text()
    });
    return reactExports.useEffect( () => {
        let intervalId;
        const checkForFooterScript = () => {
            if (networkFooterData && networkFooterRef.current && !hasFooterScriptRun.current) {
                const scriptElem = networkFooterRef.current.querySelector("ea-network-footer script")
                  , scriptContent = scriptElem == null ? void 0 : scriptElem.textContent
                  , scriptSrc = scriptElem == null ? void 0 : scriptElem.getAttribute("src");
                if (scriptContent != null && scriptContent.length || scriptSrc) {
                    if (scriptSrc) {
                        const V = document.createElement("script");
                        V.type = "text/javascript",
                        V.async = !0,
                        V.src = scriptSrc,
                        document.getElementsByTagName("head")[0].appendChild(V)
                    } else
                        scriptContent != null && scriptContent.length && eval(scriptContent);
                    hasFooterScriptRun.current = !0,
                    clearInterval(intervalId)
                }
            }
        }
        ;
        return intervalId = setInterval(checkForFooterScript, 300),
        () => {
            clearInterval(intervalId)
        }
    }
    , [networkFooterData]),
    localFooterStatus === "pending" || networkFooterStatus === "pending" ? jsxRuntimeExports.jsx(LoadingSpinner, {
        statusText: t("general.loading")
    }) : (networkFooterError && logger$k.debug("Fetched EA NetworkFooter! ", networkFooterError),
    localFooterError && logger$k.debug("Fetched EA LocalFooter!", localFooterError),
    jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsx("div", {
            dangerouslySetInnerHTML: {
                __html: localFooterData ?? ""
            }
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$F.wrapper,
            children: [jsxRuntimeExports.jsx("div", {
                ref: networkFooterRef,
                dangerouslySetInnerHTML: {
                    __html: networkFooterData ?? ""
                },
                className: styles$F.footer
            }), jsxRuntimeExports.jsx("div", {
                className: styles$F.version,
                children: "1.0.1.0c"
            })]
        })]
    }))
}
;
var LOCALE = (V => (V.ARABIC = "ar-SA",
V.GERMAN = "de-DE",
V.ENGLISH_US = "en-US",
V.ENGLISH_GB = "en-GB",
V.ENGLISH_AU = "en-AU",
V.SPANISH = "es-ES",
V.MEXICAN = "es-MX",
V.FRENCH = "fr-FR",
V.ITALIAN = "it-IT",
V.JAPANESE = "ja-JP",
V.KOREAN = "ko-KR",
V.POLISH = "pl-PL",
V.PORTUGUESE = "pt-BR",
V.RUSSIAN = "ru-RU",
V.CHINESE_SIMPLIFIED = "zh-CN",
V.CHINESE_TAIWAN = "zh-TW",
V))(LOCALE || {});
const REROUTED_LOCALES = new Map([["en-AU", "en-US"], ["en-GB", "en-US"]])
  , LOCALES_REPRESENTED_IN_PARAMS = ["en-GB", "en-AU", "ar-SA", "de-DE", "es-ES", "es-MX", "fr-FR", "it-IT", "ja-JP", "ko-KR", "pl-PL", "pt-BR", "ru-RU", "zh-CN", "zh-TW"]
  , RTL_LOCALES = ["ar-SA"]
  , DEFAULT_LOCALE = "en-US"
  , SUPPORTED_LOCALES = common_utils.enumToArray(LOCALE)
  , I18N_NAMESPACE_KEY = "translation"
  , languageFontFallbacks = {
    ["ar-SA".toLowerCase()]: "BFText-Regular-AR",
    ["de-DE".toLowerCase()]: void 0,
    ["en-US".toLowerCase()]: void 0,
    ["en-GB".toLowerCase()]: void 0,
    ["en-AU".toLowerCase()]: void 0,
    ["es-ES".toLowerCase()]: void 0,
    ["es-MX".toLowerCase()]: void 0,
    ["fr-FR".toLowerCase()]: void 0,
    ["it-IT".toLowerCase()]: void 0,
    ["ja-JP".toLowerCase()]: "BFText-Regular-JP",
    ["ko-KR".toLowerCase()]: "BFText-Regular-KR",
    ["pl-PL".toLowerCase()]: void 0,
    ["pt-BR".toLowerCase()]: void 0,
    ["ru-RU".toLowerCase()]: void 0,
    ["zh-CN".toLowerCase()]: "BFText-Regular-SC",
    ["zh-TW".toLowerCase()]: "BFText-Regular-TC"
};
var ROUTE = (V => (V.AI = "bots",
V.ATTACHMENTS = "attachments",
V.BLOCKS = "blocks",
V.CLASSES = "classes",
V.DISTRIBUTION = "teams",
V.ERA = "era",
V.EXPERIENCE = "experience",
V.EXPERIENCE_NOT_FOUND = "experience-not-found",
V.GADGETS = "gadgets",
V.GAME_MODE = "game-mode",
V.GAME_MODE_DETAILS = "mode-settings",
V.GAMEPLAY = "gameplay",
V.HOME = "experiences",
V.LOGIN = "login",
V.LOGOUT = "logout",
V.MAP_ROTATION = "choose-maps",
V.MODE = "mode",
V.MODIFIERS = "modifiers",
V.PUBLISH = "publish",
V.PUBLISH_STEP_ONE = "step-one",
V.PUBLISH_STEP_THREE = "step-three",
V.PUBLISH_STEP_TWO = "step-two",
V.RESTRICTIONS = "restrictions",
V.RULES_EDITOR = "rules",
V.SCRIPT_EDITOR = "script",
V.SETTINGS = "settings",
V.SOLDIER = "soldier",
V.SUPER_USER = "import-patches",
V.UI = "ui",
V.VEHICLE = "vehicle",
V.VEHICLES = "vehicles",
V.VERSION = "version",
V.WEAPONS = "weapons",
V.SERVICE_UNAVAILABLE = "service-unavailable",
V))(ROUTE || {})
  , QUERY_PARAM_KEY = (V => (V.CODE = "code",
V.STATE = "state",
V.EXPERIENCE_ID = "id",
V.SELECTED_TEAMS = "teams",
V))(QUERY_PARAM_KEY || {});
async function fetchNav() {
    const V = buildUrl(["https://www.ea.com", "/api/component/localNav/", instance.language.toLowerCase(), "games/battlefield/battlefield-6"]);
    return await (await fetch(V)).text()
}
const useGetEaNav = (V=!0) => {
    const X = `/bf6${instance.language === DEFAULT_LOCALE ? "" : `/${instance.language.toLowerCase()}`}`
      , {data: J, isFetching: ne} = useQuery({
        queryKey: [QUERY_KEY.EA_NAV, instance.language],
        queryFn: () => fetchNav(),
        refetchOnWindowFocus: !1,
        enabled: V,
        select: ue => `<ea-elements-loader elements="ea-network-nav"></ea-elements-loader>
                             <ea-network-nav
                                 unresolved
                                 content="https://nds-network-nav.ea.com/${instance.language.toLowerCase()}/network-nav"
                                 login-url="${X}/${ROUTE.LOGIN}"
                                 logout-url="${X}/${ROUTE.LOGOUT}"
                             ></ea-network-nav>${ue}`
    });
    return [J, ne]
}
  , logger$j = Logger$1.get("EAHeader")
  , EAHeader = ({sessionId: V, player: X}) => {
    const [J,ne] = useGetEaNav()
      , ue = reactExports.useRef(null)
      , ce = reactExports.useRef(void 0)
      , me = ""
      , ge = (X == null ? void 0 : X.nucleusId) ?? -1
      , Te = "https://portal.battlefield.com" + me;
    return reactExports.useEffect( () => (ce.current = setInterval( () => {
        var $e, Ne;
        const _e = document.querySelector("ea-network-nav:not([unresolved])")
          , Se = document.querySelector("ea-local-nav:not([unresolved])") ?? document.querySelector("ea-local-nav-advanced:not([unresolved])")
          , Ie = document.querySelector("ea-player:not([unresolved])")
          , ye = (Ne = ($e = _e == null ? void 0 : _e.shadowRoot) == null ? void 0 : $e.querySelector("#content")) == null ? void 0 : Ne.hasChildNodes();
        if (Se && Se.querySelectorAll(`[link-href^="${Te}"]`).forEach(ve => {
            var xe;
            ve.setAttribute("link-href", ((xe = ve == null ? void 0 : ve.getAttribute("link-href")) == null ? void 0 : xe.replace(Te, "")) ?? "");
            const ke = ve.getAttribute("link-href");
            ve.onclick = we => {
                we.preventDefault(),
                window.location.href = ke ?? "/"
            }
        }
        ),
        Ie && _e && !ne) {
            const ve = {
                authenticated: !!V,
                pid: ge
            };
            logger$j.debug("EA Player and NetworkNav elements resolved! Setting playerData:", ve),
            Ie.playerData = ve,
            Ie.playerDataRetrieved = !0,
            document.dispatchEvent(new CustomEvent("player-state-check"))
        }
        ye && Ie && !ne && _e && Se && clearInterval(ce.current)
    }
    , 500),
    () => {
        clearInterval(ce.current)
    }
    ), [V, ge, Te, ne]),
    jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
        children: J && jsxRuntimeExports.jsx("div", {
            ref: ue,
            dangerouslySetInnerHTML: {
                __html: J
            }
        })
    })
}
;
var grpcWebClient_umd = {
    exports: {}
};
(function(V, X) {
    (function(J, ne) {
        V.exports = ne()
    }
    )(commonjsGlobal, function() {
        return J = {
            418: function(ue, ce) {
                (function(me, ge) {
                    for (var Te in ge)
                        me[Te] = ge[Te]
                }
                )(ce, function(me) {
                    var ge = {};
                    function Te(_e) {
                        if (ge[_e])
                            return ge[_e].exports;
                        var Se = ge[_e] = {
                            i: _e,
                            l: !1,
                            exports: {}
                        };
                        return me[_e].call(Se.exports, Se, Se.exports, Te),
                        Se.l = !0,
                        Se.exports
                    }
                    return Te.m = me,
                    Te.c = ge,
                    Te.i = function(_e) {
                        return _e
                    }
                    ,
                    Te.d = function(_e, Se, Ie) {
                        Te.o(_e, Se) || Object.defineProperty(_e, Se, {
                            configurable: !1,
                            enumerable: !0,
                            get: Ie
                        })
                    }
                    ,
                    Te.n = function(_e) {
                        var Se = _e && _e.__esModule ? function() {
                            return _e.default
                        }
                        : function() {
                            return _e
                        }
                        ;
                        return Te.d(Se, "a", Se),
                        Se
                    }
                    ,
                    Te.o = function(_e, Se) {
                        return Object.prototype.hasOwnProperty.call(_e, Se)
                    }
                    ,
                    Te.p = "",
                    Te(Te.s = 1)
                }([function(me, ge, Te) {
                    Object.defineProperty(ge, "__esModule", {
                        value: !0
                    });
                    var _e = Te(3)
                      , Se = function() {
                        function Ie(ye, $e) {
                            ye === void 0 && (ye = {}),
                            $e === void 0 && ($e = {
                                splitValues: !1
                            });
                            var Ne, ve = this;
                            this.headersMap = {},
                            ye && (typeof Headers < "u" && ye instanceof Headers ? _e.getHeaderKeys(ye).forEach(function(ke) {
                                _e.getHeaderValues(ye, ke).forEach(function(xe) {
                                    $e.splitValues ? ve.append(ke, _e.splitHeaderValue(xe)) : ve.append(ke, xe)
                                })
                            }) : typeof (Ne = ye) == "object" && typeof Ne.headersMap == "object" && typeof Ne.forEach == "function" ? ye.forEach(function(ke, xe) {
                                ve.append(ke, xe)
                            }) : typeof Map < "u" && ye instanceof Map ? ye.forEach(function(ke, xe) {
                                ve.append(xe, ke)
                            }) : typeof ye == "string" ? this.appendFromString(ye) : typeof ye == "object" && Object.getOwnPropertyNames(ye).forEach(function(ke) {
                                var xe = ye[ke];
                                Array.isArray(xe) ? xe.forEach(function(we) {
                                    ve.append(ke, we)
                                }) : ve.append(ke, xe)
                            }))
                        }
                        return Ie.prototype.appendFromString = function(ye) {
                            for (var $e = ye.split(`\r
`), Ne = 0; Ne < $e.length; Ne++) {
                                var ve = $e[Ne]
                                  , ke = ve.indexOf(":");
                                if (ke > 0) {
                                    var xe = ve.substring(0, ke).trim()
                                      , we = ve.substring(ke + 1).trim();
                                    this.append(xe, we)
                                }
                            }
                        }
                        ,
                        Ie.prototype.delete = function(ye, $e) {
                            var Ne = _e.normalizeName(ye);
                            if ($e === void 0)
                                delete this.headersMap[Ne];
                            else {
                                var ve = this.headersMap[Ne];
                                if (ve) {
                                    var ke = ve.indexOf($e);
                                    ke >= 0 && ve.splice(ke, 1),
                                    ve.length === 0 && delete this.headersMap[Ne]
                                }
                            }
                        }
                        ,
                        Ie.prototype.append = function(ye, $e) {
                            var Ne = this
                              , ve = _e.normalizeName(ye);
                            Array.isArray(this.headersMap[ve]) || (this.headersMap[ve] = []),
                            Array.isArray($e) ? $e.forEach(function(ke) {
                                Ne.headersMap[ve].push(_e.normalizeValue(ke))
                            }) : this.headersMap[ve].push(_e.normalizeValue($e))
                        }
                        ,
                        Ie.prototype.set = function(ye, $e) {
                            var Ne = _e.normalizeName(ye);
                            if (Array.isArray($e)) {
                                var ve = [];
                                $e.forEach(function(ke) {
                                    ve.push(_e.normalizeValue(ke))
                                }),
                                this.headersMap[Ne] = ve
                            } else
                                this.headersMap[Ne] = [_e.normalizeValue($e)]
                        }
                        ,
                        Ie.prototype.has = function(ye, $e) {
                            var Ne = this.headersMap[_e.normalizeName(ye)];
                            if (!Array.isArray(Ne))
                                return !1;
                            if ($e !== void 0) {
                                var ve = _e.normalizeValue($e);
                                return Ne.indexOf(ve) >= 0
                            }
                            return !0
                        }
                        ,
                        Ie.prototype.get = function(ye) {
                            var $e = this.headersMap[_e.normalizeName(ye)];
                            return $e !== void 0 ? $e.concat() : []
                        }
                        ,
                        Ie.prototype.forEach = function(ye) {
                            var $e = this;
                            Object.getOwnPropertyNames(this.headersMap).forEach(function(Ne) {
                                ye(Ne, $e.headersMap[Ne])
                            }, this)
                        }
                        ,
                        Ie.prototype.toHeaders = function() {
                            if (typeof Headers < "u") {
                                var ye = new Headers;
                                return this.forEach(function($e, Ne) {
                                    Ne.forEach(function(ve) {
                                        ye.append($e, ve)
                                    })
                                }),
                                ye
                            }
                            throw new Error("Headers class is not defined")
                        }
                        ,
                        Ie
                    }();
                    ge.BrowserHeaders = Se
                }
                , function(me, ge, Te) {
                    Object.defineProperty(ge, "__esModule", {
                        value: !0
                    });
                    var _e = Te(0);
                    ge.BrowserHeaders = _e.BrowserHeaders
                }
                , function(me, ge, Te) {
                    Object.defineProperty(ge, "__esModule", {
                        value: !0
                    }),
                    ge.iterateHeaders = function(_e, Se) {
                        for (var Ie = _e[Symbol.iterator](), ye = Ie.next(); !ye.done; )
                            Se(ye.value[0]),
                            ye = Ie.next()
                    }
                    ,
                    ge.iterateHeadersKeys = function(_e, Se) {
                        for (var Ie = _e.keys(), ye = Ie.next(); !ye.done; )
                            Se(ye.value),
                            ye = Ie.next()
                    }
                }
                , function(me, ge, Te) {
                    Object.defineProperty(ge, "__esModule", {
                        value: !0
                    });
                    var _e = Te(2);
                    ge.normalizeName = function(Se) {
                        if (typeof Se != "string" && (Se = String(Se)),
                        /[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(Se))
                            throw new TypeError("Invalid character in header field name");
                        return Se.toLowerCase()
                    }
                    ,
                    ge.normalizeValue = function(Se) {
                        return typeof Se != "string" && (Se = String(Se)),
                        Se
                    }
                    ,
                    ge.getHeaderValues = function(Se, Ie) {
                        var ye = Se;
                        if (ye instanceof Headers && ye.getAll)
                            return ye.getAll(Ie);
                        var $e = ye.get(Ie);
                        return $e && typeof $e == "string" ? [$e] : $e
                    }
                    ,
                    ge.getHeaderKeys = function(Se) {
                        var Ie = Se
                          , ye = {}
                          , $e = [];
                        return Ie.keys ? _e.iterateHeadersKeys(Ie, function(Ne) {
                            ye[Ne] || (ye[Ne] = !0,
                            $e.push(Ne))
                        }) : Ie.forEach ? Ie.forEach(function(Ne, ve) {
                            ye[ve] || (ye[ve] = !0,
                            $e.push(ve))
                        }) : _e.iterateHeaders(Ie, function(Ne) {
                            var ve = Ne[0];
                            ye[ve] || (ye[ve] = !0,
                            $e.push(ve))
                        }),
                        $e
                    }
                    ,
                    ge.splitHeaderValue = function(Se) {
                        var Ie = [];
                        return Se.split(", ").forEach(function(ye) {
                            ye.split(",").forEach(function($e) {
                                Ie.push($e)
                            })
                        }),
                        Ie
                    }
                }
                ]))
            },
            617: function(ue, ce, me) {
                Object.defineProperty(ce, "__esModule", {
                    value: !0
                }),
                ce.ChunkParser = ce.ChunkType = ce.encodeASCII = ce.decodeASCII = void 0;
                var ge, Te = me(65);
                function _e(ke) {
                    return (xe = ke) === 9 || xe === 10 || xe === 13 || ke >= 32 && ke <= 126;
                    var xe
                }
                function Se(ke) {
                    for (var xe = 0; xe !== ke.length; ++xe)
                        if (!_e(ke[xe]))
                            throw new Error("Metadata is not valid (printable) ASCII");
                    return String.fromCharCode.apply(String, Array.prototype.slice.call(ke))
                }
                function Ie(ke) {
                    return (128 & ke.getUint8(0)) == 128
                }
                function ye(ke) {
                    return ke.getUint32(1, !1)
                }
                function $e(ke, xe, we) {
                    return ke.byteLength - xe >= we
                }
                function Ne(ke, xe, we) {
                    if (ke.slice)
                        return ke.slice(xe, we);
                    var Fe = ke.length;
                    we !== void 0 && (Fe = we);
                    for (var je = new Uint8Array(Fe - xe), Xe = 0, ze = xe; ze < Fe; ze++)
                        je[Xe++] = ke[ze];
                    return je
                }
                ce.decodeASCII = Se,
                ce.encodeASCII = function(ke) {
                    for (var xe = new Uint8Array(ke.length), we = 0; we !== ke.length; ++we) {
                        var Fe = ke.charCodeAt(we);
                        if (!_e(Fe))
                            throw new Error("Metadata contains invalid ASCII");
                        xe[we] = Fe
                    }
                    return xe
                }
                ,
                function(ke) {
                    ke[ke.MESSAGE = 1] = "MESSAGE",
                    ke[ke.TRAILERS = 2] = "TRAILERS"
                }(ge = ce.ChunkType || (ce.ChunkType = {}));
                var ve = function() {
                    function ke() {
                        this.buffer = null,
                        this.position = 0
                    }
                    return ke.prototype.parse = function(xe, we) {
                        if (xe.length === 0 && we)
                            return [];
                        var Fe, je = [];
                        if (this.buffer == null)
                            this.buffer = xe,
                            this.position = 0;
                        else if (this.position === this.buffer.byteLength)
                            this.buffer = xe,
                            this.position = 0;
                        else {
                            var Xe = this.buffer.byteLength - this.position
                              , ze = new Uint8Array(Xe + xe.byteLength)
                              , qe = Ne(this.buffer, this.position);
                            ze.set(qe, 0);
                            var Ze = new Uint8Array(xe);
                            ze.set(Ze, Xe),
                            this.buffer = ze,
                            this.position = 0
                        }
                        for (; ; ) {
                            if (!$e(this.buffer, this.position, 5))
                                return je;
                            var et = Ne(this.buffer, this.position, this.position + 5)
                              , it = new DataView(et.buffer,et.byteOffset,et.byteLength)
                              , at = ye(it);
                            if (!$e(this.buffer, this.position, 5 + at))
                                return je;
                            var rt = Ne(this.buffer, this.position + 5, this.position + 5 + at);
                            if (this.position += 5 + at,
                            Ie(it))
                                return je.push({
                                    chunkType: ge.TRAILERS,
                                    trailers: (Fe = rt,
                                    new Te.Metadata(Se(Fe)))
                                }),
                                je;
                            je.push({
                                chunkType: ge.MESSAGE,
                                data: rt
                            })
                        }
                    }
                    ,
                    ke
                }();
                ce.ChunkParser = ve
            },
            8: function(ue, ce) {
                var me;
                Object.defineProperty(ce, "__esModule", {
                    value: !0
                }),
                ce.httpStatusToCode = ce.Code = void 0,
                function(ge) {
                    ge[ge.OK = 0] = "OK",
                    ge[ge.Canceled = 1] = "Canceled",
                    ge[ge.Unknown = 2] = "Unknown",
                    ge[ge.InvalidArgument = 3] = "InvalidArgument",
                    ge[ge.DeadlineExceeded = 4] = "DeadlineExceeded",
                    ge[ge.NotFound = 5] = "NotFound",
                    ge[ge.AlreadyExists = 6] = "AlreadyExists",
                    ge[ge.PermissionDenied = 7] = "PermissionDenied",
                    ge[ge.ResourceExhausted = 8] = "ResourceExhausted",
                    ge[ge.FailedPrecondition = 9] = "FailedPrecondition",
                    ge[ge.Aborted = 10] = "Aborted",
                    ge[ge.OutOfRange = 11] = "OutOfRange",
                    ge[ge.Unimplemented = 12] = "Unimplemented",
                    ge[ge.Internal = 13] = "Internal",
                    ge[ge.Unavailable = 14] = "Unavailable",
                    ge[ge.DataLoss = 15] = "DataLoss",
                    ge[ge.Unauthenticated = 16] = "Unauthenticated"
                }(me = ce.Code || (ce.Code = {})),
                ce.httpStatusToCode = function(ge) {
                    switch (ge) {
                    case 0:
                        return me.Internal;
                    case 200:
                        return me.OK;
                    case 400:
                        return me.InvalidArgument;
                    case 401:
                        return me.Unauthenticated;
                    case 403:
                        return me.PermissionDenied;
                    case 404:
                        return me.NotFound;
                    case 409:
                        return me.Aborted;
                    case 412:
                        return me.FailedPrecondition;
                    case 429:
                        return me.ResourceExhausted;
                    case 499:
                        return me.Canceled;
                    case 500:
                        return me.Unknown;
                    case 501:
                        return me.Unimplemented;
                    case 503:
                        return me.Unavailable;
                    case 504:
                        return me.DeadlineExceeded;
                    default:
                        return me.Unknown
                    }
                }
            },
            934: function(ue, ce, me) {
                Object.defineProperty(ce, "__esModule", {
                    value: !0
                }),
                ce.client = void 0;
                var ge = me(65)
                  , Te = me(617)
                  , _e = me(8)
                  , Se = me(346)
                  , Ie = me(57)
                  , ye = me(882);
                ce.client = function(ve, ke) {
                    return new $e(ve,ke)
                }
                ;
                var $e = function() {
                    function ve(ke, xe) {
                        this.started = !1,
                        this.sentFirstMessage = !1,
                        this.completed = !1,
                        this.closed = !1,
                        this.finishedSending = !1,
                        this.onHeadersCallbacks = [],
                        this.onMessageCallbacks = [],
                        this.onEndCallbacks = [],
                        this.parser = new Te.ChunkParser,
                        this.methodDefinition = ke,
                        this.props = xe,
                        this.createTransport()
                    }
                    return ve.prototype.createTransport = function() {
                        var ke = this.props.host + "/" + this.methodDefinition.service.serviceName + "/" + this.methodDefinition.methodName
                          , xe = {
                            methodDefinition: this.methodDefinition,
                            debug: this.props.debug || !1,
                            url: ke,
                            onHeaders: this.onTransportHeaders.bind(this),
                            onChunk: this.onTransportChunk.bind(this),
                            onEnd: this.onTransportEnd.bind(this)
                        };
                        this.props.transport ? this.transport = this.props.transport(xe) : this.transport = Ie.makeDefaultTransport(xe)
                    }
                    ,
                    ve.prototype.onTransportHeaders = function(ke, xe) {
                        if (this.props.debug && Se.debug("onHeaders", ke, xe),
                        this.closed)
                            this.props.debug && Se.debug("grpc.onHeaders received after request was closed - ignoring");
                        else if (xe !== 0) {
                            this.responseHeaders = ke,
                            this.props.debug && Se.debug("onHeaders.responseHeaders", JSON.stringify(this.responseHeaders, null, 2));
                            var we = Ne(ke);
                            this.props.debug && Se.debug("onHeaders.gRPCStatus", we);
                            var Fe = we && we >= 0 ? we : _e.httpStatusToCode(xe);
                            this.props.debug && Se.debug("onHeaders.code", Fe);
                            var je = ke.get("grpc-message") || [];
                            if (this.props.debug && Se.debug("onHeaders.gRPCMessage", je),
                            this.rawOnHeaders(ke),
                            Fe !== _e.Code.OK) {
                                var Xe = this.decodeGRPCStatus(je[0]);
                                this.rawOnError(Fe, Xe, ke)
                            }
                        }
                    }
                    ,
                    ve.prototype.onTransportChunk = function(ke) {
                        var xe = this;
                        if (this.closed)
                            this.props.debug && Se.debug("grpc.onChunk received after request was closed - ignoring");
                        else {
                            var we = [];
                            try {
                                we = this.parser.parse(ke)
                            } catch (Fe) {
                                return this.props.debug && Se.debug("onChunk.parsing error", Fe, Fe.message),
                                void this.rawOnError(_e.Code.Internal, "parsing error: " + Fe.message)
                            }
                            we.forEach(function(Fe) {
                                if (Fe.chunkType === Te.ChunkType.MESSAGE) {
                                    var je = xe.methodDefinition.responseType.deserializeBinary(Fe.data);
                                    xe.rawOnMessage(je)
                                } else
                                    Fe.chunkType === Te.ChunkType.TRAILERS && (xe.responseHeaders ? (xe.responseTrailers = new ge.Metadata(Fe.trailers),
                                    xe.props.debug && Se.debug("onChunk.trailers", xe.responseTrailers)) : (xe.responseHeaders = new ge.Metadata(Fe.trailers),
                                    xe.rawOnHeaders(xe.responseHeaders)))
                            })
                        }
                    }
                    ,
                    ve.prototype.onTransportEnd = function() {
                        if (this.props.debug && Se.debug("grpc.onEnd"),
                        this.closed)
                            this.props.debug && Se.debug("grpc.onEnd received after request was closed - ignoring");
                        else if (this.responseTrailers !== void 0) {
                            var ke = Ne(this.responseTrailers);
                            if (ke !== null) {
                                var xe = this.responseTrailers.get("grpc-message")
                                  , we = this.decodeGRPCStatus(xe[0]);
                                this.rawOnEnd(ke, we, this.responseTrailers)
                            } else
                                this.rawOnError(_e.Code.Internal, "Response closed without grpc-status (Trailers provided)")
                        } else {
                            if (this.responseHeaders === void 0)
                                return void this.rawOnError(_e.Code.Unknown, "Response closed without headers");
                            var Fe = Ne(this.responseHeaders)
                              , je = this.responseHeaders.get("grpc-message");
                            if (this.props.debug && Se.debug("grpc.headers only response ", Fe, je),
                            Fe === null)
                                return void this.rawOnEnd(_e.Code.Unknown, "Response closed without grpc-status (Headers only)", this.responseHeaders);
                            var Xe = this.decodeGRPCStatus(je[0]);
                            this.rawOnEnd(Fe, Xe, this.responseHeaders)
                        }
                    }
                    ,
                    ve.prototype.decodeGRPCStatus = function(ke) {
                        if (!ke)
                            return "";
                        try {
                            return decodeURIComponent(ke)
                        } catch {
                            return ke
                        }
                    }
                    ,
                    ve.prototype.rawOnEnd = function(ke, xe, we) {
                        var Fe = this;
                        this.props.debug && Se.debug("rawOnEnd", ke, xe, we),
                        this.completed || (this.completed = !0,
                        this.onEndCallbacks.forEach(function(je) {
                            if (!Fe.closed)
                                try {
                                    je(ke, xe, we)
                                } catch (Xe) {
                                    setTimeout(function() {
                                        throw Xe
                                    }, 0)
                                }
                        }))
                    }
                    ,
                    ve.prototype.rawOnHeaders = function(ke) {
                        this.props.debug && Se.debug("rawOnHeaders", ke),
                        this.completed || this.onHeadersCallbacks.forEach(function(xe) {
                            try {
                                xe(ke)
                            } catch (we) {
                                setTimeout(function() {
                                    throw we
                                }, 0)
                            }
                        })
                    }
                    ,
                    ve.prototype.rawOnError = function(ke, xe, we) {
                        var Fe = this;
                        we === void 0 && (we = new ge.Metadata),
                        this.props.debug && Se.debug("rawOnError", ke, xe),
                        this.completed || (this.completed = !0,
                        this.onEndCallbacks.forEach(function(je) {
                            if (!Fe.closed)
                                try {
                                    je(ke, xe, we)
                                } catch (Xe) {
                                    setTimeout(function() {
                                        throw Xe
                                    }, 0)
                                }
                        }))
                    }
                    ,
                    ve.prototype.rawOnMessage = function(ke) {
                        var xe = this;
                        this.props.debug && Se.debug("rawOnMessage", ke.toObject()),
                        this.completed || this.closed || this.onMessageCallbacks.forEach(function(we) {
                            if (!xe.closed)
                                try {
                                    we(ke)
                                } catch (Fe) {
                                    setTimeout(function() {
                                        throw Fe
                                    }, 0)
                                }
                        })
                    }
                    ,
                    ve.prototype.onHeaders = function(ke) {
                        this.onHeadersCallbacks.push(ke)
                    }
                    ,
                    ve.prototype.onMessage = function(ke) {
                        this.onMessageCallbacks.push(ke)
                    }
                    ,
                    ve.prototype.onEnd = function(ke) {
                        this.onEndCallbacks.push(ke)
                    }
                    ,
                    ve.prototype.start = function(ke) {
                        if (this.started)
                            throw new Error("Client already started - cannot .start()");
                        this.started = !0;
                        var xe = new ge.Metadata(ke || {});
                        xe.set("content-type", "application/grpc-web+proto"),
                        xe.set("x-grpc-web", "1"),
                        this.transport.start(xe)
                    }
                    ,
                    ve.prototype.send = function(ke) {
                        if (!this.started)
                            throw new Error("Client not started - .start() must be called before .send()");
                        if (this.closed)
                            throw new Error("Client already closed - cannot .send()");
                        if (this.finishedSending)
                            throw new Error("Client already finished sending - cannot .send()");
                        if (!this.methodDefinition.requestStream && this.sentFirstMessage)
                            throw new Error("Message already sent for non-client-streaming method - cannot .send()");
                        this.sentFirstMessage = !0;
                        var xe = ye.frameRequest(ke);
                        this.transport.sendMessage(xe)
                    }
                    ,
                    ve.prototype.finishSend = function() {
                        if (!this.started)
                            throw new Error("Client not started - .finishSend() must be called before .close()");
                        if (this.closed)
                            throw new Error("Client already closed - cannot .send()");
                        if (this.finishedSending)
                            throw new Error("Client already finished sending - cannot .finishSend()");
                        this.finishedSending = !0,
                        this.transport.finishSend()
                    }
                    ,
                    ve.prototype.close = function() {
                        if (!this.started)
                            throw new Error("Client not started - .start() must be called before .close()");
                        if (this.closed)
                            throw new Error("Client already closed - cannot .close()");
                        this.closed = !0,
                        this.props.debug && Se.debug("request.abort aborting request"),
                        this.transport.cancel()
                    }
                    ,
                    ve
                }();
                function Ne(ve) {
                    var ke = ve.get("grpc-status") || [];
                    if (ke.length > 0)
                        try {
                            var xe = ke[0];
                            return parseInt(xe, 10)
                        } catch {
                            return null
                        }
                    return null
                }
            },
            346: function(ue, ce) {
                Object.defineProperty(ce, "__esModule", {
                    value: !0
                }),
                ce.debug = void 0,
                ce.debug = function() {
                    for (var me = [], ge = 0; ge < arguments.length; ge++)
                        me[ge] = arguments[ge];
                    console.debug ? console.debug.apply(null, me) : console.log.apply(null, me)
                }
            },
            607: function(ue, ce, me) {
                Object.defineProperty(ce, "__esModule", {
                    value: !0
                }),
                ce.grpc = void 0;
                var ge, Te = me(418), _e = me(57), Se = me(229), Ie = me(540), ye = me(210), $e = me(859), Ne = me(8), ve = me(938), ke = me(35), xe = me(934);
                (ge = ce.grpc || (ce.grpc = {})).setDefaultTransport = _e.setDefaultTransportFactory,
                ge.CrossBrowserHttpTransport = $e.CrossBrowserHttpTransport,
                ge.FetchReadableStreamTransport = Se.FetchReadableStreamTransport,
                ge.XhrTransport = ye.XhrTransport,
                ge.WebsocketTransport = Ie.WebsocketTransport,
                ge.Code = Ne.Code,
                ge.Metadata = Te.BrowserHeaders,
                ge.client = function(we, Fe) {
                    return xe.client(we, Fe)
                }
                ,
                ge.invoke = ve.invoke,
                ge.unary = ke.unary
            },
            938: function(ue, ce, me) {
                Object.defineProperty(ce, "__esModule", {
                    value: !0
                }),
                ce.invoke = void 0;
                var ge = me(934);
                ce.invoke = function(Te, _e) {
                    if (Te.requestStream)
                        throw new Error(".invoke cannot be used with client-streaming methods. Use .client instead.");
                    var Se = ge.client(Te, {
                        host: _e.host,
                        transport: _e.transport,
                        debug: _e.debug
                    });
                    return _e.onHeaders && Se.onHeaders(_e.onHeaders),
                    _e.onMessage && Se.onMessage(_e.onMessage),
                    _e.onEnd && Se.onEnd(_e.onEnd),
                    Se.start(_e.metadata),
                    Se.send(_e.request),
                    Se.finishSend(),
                    {
                        close: function() {
                            Se.close()
                        }
                    }
                }
            },
            65: function(ue, ce, me) {
                Object.defineProperty(ce, "__esModule", {
                    value: !0
                }),
                ce.Metadata = void 0;
                var ge = me(418);
                Object.defineProperty(ce, "Metadata", {
                    enumerable: !0,
                    get: function() {
                        return ge.BrowserHeaders
                    }
                })
            },
            57: function(ue, ce, me) {
                Object.defineProperty(ce, "__esModule", {
                    value: !0
                }),
                ce.makeDefaultTransport = ce.setDefaultTransportFactory = void 0;
                var ge = me(859)
                  , Te = function(_e) {
                    return ge.CrossBrowserHttpTransport({
                        withCredentials: !1
                    })(_e)
                };
                ce.setDefaultTransportFactory = function(_e) {
                    Te = _e
                }
                ,
                ce.makeDefaultTransport = function(_e) {
                    return Te(_e)
                }
            },
            229: function(ue, ce, me) {
                var ge = this && this.__assign || function() {
                    return (ge = Object.assign || function(Ie) {
                        for (var ye, $e = 1, Ne = arguments.length; $e < Ne; $e++)
                            for (var ve in ye = arguments[$e])
                                Object.prototype.hasOwnProperty.call(ye, ve) && (Ie[ve] = ye[ve]);
                        return Ie
                    }
                    ).apply(this, arguments)
                }
                ;
                Object.defineProperty(ce, "__esModule", {
                    value: !0
                }),
                ce.detectFetchSupport = ce.FetchReadableStreamTransport = void 0;
                var Te = me(65)
                  , _e = me(346);
                ce.FetchReadableStreamTransport = function(Ie) {
                    return function(ye) {
                        return function($e, Ne) {
                            return $e.debug && _e.debug("fetchRequest", $e),
                            new Se($e,Ne)
                        }(ye, Ie)
                    }
                }
                ;
                var Se = function() {
                    function Ie(ye, $e) {
                        this.cancelled = !1,
                        this.controller = self.AbortController && new AbortController,
                        this.options = ye,
                        this.init = $e
                    }
                    return Ie.prototype.pump = function(ye, $e) {
                        var Ne = this;
                        if (this.reader = ye,
                        this.cancelled)
                            return this.options.debug && _e.debug("Fetch.pump.cancel at first pump"),
                            void this.reader.cancel().catch(function(ve) {
                                Ne.options.debug && _e.debug("Fetch.pump.reader.cancel exception", ve)
                            });
                        this.reader.read().then(function(ve) {
                            if (ve.done)
                                return Ne.options.onEnd(),
                                $e;
                            Ne.options.onChunk(ve.value),
                            Ne.pump(Ne.reader, $e)
                        }).catch(function(ve) {
                            Ne.cancelled ? Ne.options.debug && _e.debug("Fetch.catch - request cancelled") : (Ne.cancelled = !0,
                            Ne.options.debug && _e.debug("Fetch.catch", ve.message),
                            Ne.options.onEnd(ve))
                        })
                    }
                    ,
                    Ie.prototype.send = function(ye) {
                        var $e = this;
                        fetch(this.options.url, ge(ge({}, this.init), {
                            headers: this.metadata.toHeaders(),
                            method: "POST",
                            body: ye,
                            signal: this.controller && this.controller.signal
                        })).then(function(Ne) {
                            if ($e.options.debug && _e.debug("Fetch.response", Ne),
                            $e.options.onHeaders(new Te.Metadata(Ne.headers), Ne.status),
                            !Ne.body)
                                return Ne;
                            $e.pump(Ne.body.getReader(), Ne)
                        }).catch(function(Ne) {
                            $e.cancelled ? $e.options.debug && _e.debug("Fetch.catch - request cancelled") : ($e.cancelled = !0,
                            $e.options.debug && _e.debug("Fetch.catch", Ne.message),
                            $e.options.onEnd(Ne))
                        })
                    }
                    ,
                    Ie.prototype.sendMessage = function(ye) {
                        this.send(ye)
                    }
                    ,
                    Ie.prototype.finishSend = function() {}
                    ,
                    Ie.prototype.start = function(ye) {
                        this.metadata = ye
                    }
                    ,
                    Ie.prototype.cancel = function() {
                        var ye = this;
                        this.cancelled ? this.options.debug && _e.debug("Fetch.cancel already cancelled") : (this.cancelled = !0,
                        this.controller ? (this.options.debug && _e.debug("Fetch.cancel.controller.abort"),
                        this.controller.abort()) : this.options.debug && _e.debug("Fetch.cancel.missing abort controller"),
                        this.reader ? (this.options.debug && _e.debug("Fetch.cancel.reader.cancel"),
                        this.reader.cancel().catch(function($e) {
                            ye.options.debug && _e.debug("Fetch.cancel.reader.cancel exception", $e)
                        })) : this.options.debug && _e.debug("Fetch.cancel before reader"))
                    }
                    ,
                    Ie
                }();
                ce.detectFetchSupport = function() {
                    return typeof Response < "u" && Response.prototype.hasOwnProperty("body") && typeof Headers == "function"
                }
            },
            859: function(ue, ce, me) {
                Object.defineProperty(ce, "__esModule", {
                    value: !0
                }),
                ce.CrossBrowserHttpTransport = void 0;
                var ge = me(229)
                  , Te = me(210);
                ce.CrossBrowserHttpTransport = function(_e) {
                    if (ge.detectFetchSupport()) {
                        var Se = {
                            credentials: _e.withCredentials ? "include" : "same-origin"
                        };
                        return ge.FetchReadableStreamTransport(Se)
                    }
                    return Te.XhrTransport({
                        withCredentials: _e.withCredentials
                    })
                }
            },
            210: function(ue, ce, me) {
                var ge, Te = this && this.__extends || (ge = function(ke, xe) {
                    return (ge = Object.setPrototypeOf || {
                        __proto__: []
                    }instanceof Array && function(we, Fe) {
                        we.__proto__ = Fe
                    }
                    || function(we, Fe) {
                        for (var je in Fe)
                            Object.prototype.hasOwnProperty.call(Fe, je) && (we[je] = Fe[je])
                    }
                    )(ke, xe)
                }
                ,
                function(ke, xe) {
                    function we() {
                        this.constructor = ke
                    }
                    ge(ke, xe),
                    ke.prototype = xe === null ? Object.create(xe) : (we.prototype = xe.prototype,
                    new we)
                }
                );
                Object.defineProperty(ce, "__esModule", {
                    value: !0
                }),
                ce.stringToArrayBuffer = ce.MozChunkedArrayBufferXHR = ce.XHR = ce.XhrTransport = void 0;
                var _e = me(65)
                  , Se = me(346)
                  , Ie = me(849);
                ce.XhrTransport = function(ke) {
                    return function(xe) {
                        if (Ie.detectMozXHRSupport())
                            return new $e(xe,ke);
                        if (Ie.detectXHROverrideMimeTypeSupport())
                            return new ye(xe,ke);
                        throw new Error("This environment's XHR implementation cannot support binary transfer.")
                    }
                }
                ;
                var ye = function() {
                    function ke(xe, we) {
                        this.options = xe,
                        this.init = we
                    }
                    return ke.prototype.onProgressEvent = function() {
                        this.options.debug && Se.debug("XHR.onProgressEvent.length: ", this.xhr.response.length);
                        var xe = this.xhr.response.substr(this.index);
                        this.index = this.xhr.response.length;
                        var we = ve(xe);
                        this.options.onChunk(we)
                    }
                    ,
                    ke.prototype.onLoadEvent = function() {
                        this.options.debug && Se.debug("XHR.onLoadEvent"),
                        this.options.onEnd()
                    }
                    ,
                    ke.prototype.onStateChange = function() {
                        this.options.debug && Se.debug("XHR.onStateChange", this.xhr.readyState),
                        this.xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED && this.options.onHeaders(new _e.Metadata(this.xhr.getAllResponseHeaders()), this.xhr.status)
                    }
                    ,
                    ke.prototype.sendMessage = function(xe) {
                        this.xhr.send(xe)
                    }
                    ,
                    ke.prototype.finishSend = function() {}
                    ,
                    ke.prototype.start = function(xe) {
                        var we = this;
                        this.metadata = xe;
                        var Fe = new XMLHttpRequest;
                        this.xhr = Fe,
                        Fe.open("POST", this.options.url),
                        this.configureXhr(),
                        this.metadata.forEach(function(je, Xe) {
                            Fe.setRequestHeader(je, Xe.join(", "))
                        }),
                        Fe.withCredentials = !!this.init.withCredentials,
                        Fe.addEventListener("readystatechange", this.onStateChange.bind(this)),
                        Fe.addEventListener("progress", this.onProgressEvent.bind(this)),
                        Fe.addEventListener("loadend", this.onLoadEvent.bind(this)),
                        Fe.addEventListener("error", function(je) {
                            we.options.debug && Se.debug("XHR.error", je),
                            we.options.onEnd(je.error)
                        })
                    }
                    ,
                    ke.prototype.configureXhr = function() {
                        this.xhr.responseType = "text",
                        this.xhr.overrideMimeType("text/plain; charset=x-user-defined")
                    }
                    ,
                    ke.prototype.cancel = function() {
                        this.options.debug && Se.debug("XHR.abort"),
                        this.xhr.abort()
                    }
                    ,
                    ke
                }();
                ce.XHR = ye;
                var $e = function(ke) {
                    function xe() {
                        return ke !== null && ke.apply(this, arguments) || this
                    }
                    return Te(xe, ke),
                    xe.prototype.configureXhr = function() {
                        this.options.debug && Se.debug("MozXHR.configureXhr: setting responseType to 'moz-chunked-arraybuffer'"),
                        this.xhr.responseType = "moz-chunked-arraybuffer"
                    }
                    ,
                    xe.prototype.onProgressEvent = function() {
                        var we = this.xhr.response;
                        this.options.debug && Se.debug("MozXHR.onProgressEvent: ", new Uint8Array(we)),
                        this.options.onChunk(new Uint8Array(we))
                    }
                    ,
                    xe
                }(ye);
                function Ne(ke, xe) {
                    var we = ke.charCodeAt(xe);
                    if (we >= 55296 && we <= 56319) {
                        var Fe = ke.charCodeAt(xe + 1);
                        Fe >= 56320 && Fe <= 57343 && (we = 65536 + (we - 55296 << 10) + (Fe - 56320))
                    }
                    return we
                }
                function ve(ke) {
                    for (var xe = new Uint8Array(ke.length), we = 0, Fe = 0; Fe < ke.length; Fe++) {
                        var je = String.prototype.codePointAt ? ke.codePointAt(Fe) : Ne(ke, Fe);
                        xe[we++] = 255 & je
                    }
                    return xe
                }
                ce.MozChunkedArrayBufferXHR = $e,
                ce.stringToArrayBuffer = ve
            },
            849: function(ue, ce) {
                var me;
                function ge() {
                    if (me !== void 0)
                        return me;
                    if (XMLHttpRequest) {
                        me = new XMLHttpRequest;
                        try {
                            me.open("GET", "https://localhost")
                        } catch {}
                    }
                    return me
                }
                function Te(_e) {
                    var Se = ge();
                    if (!Se)
                        return !1;
                    try {
                        return Se.responseType = _e,
                        Se.responseType === _e
                    } catch {}
                    return !1
                }
                Object.defineProperty(ce, "__esModule", {
                    value: !0
                }),
                ce.detectXHROverrideMimeTypeSupport = ce.detectMozXHRSupport = ce.xhrSupportsResponseType = void 0,
                ce.xhrSupportsResponseType = Te,
                ce.detectMozXHRSupport = function() {
                    return typeof XMLHttpRequest < "u" && Te("moz-chunked-arraybuffer")
                }
                ,
                ce.detectXHROverrideMimeTypeSupport = function() {
                    return typeof XMLHttpRequest < "u" && XMLHttpRequest.prototype.hasOwnProperty("overrideMimeType")
                }
            },
            540: function(ue, ce, me) {
                Object.defineProperty(ce, "__esModule", {
                    value: !0
                }),
                ce.WebsocketTransport = void 0;
                var ge, Te = me(346), _e = me(617);
                (function(Ie) {
                    Ie[Ie.FINISH_SEND = 1] = "FINISH_SEND"
                }
                )(ge || (ge = {}));
                var Se = new Uint8Array([1]);
                ce.WebsocketTransport = function() {
                    return function(Ie) {
                        return function(ye) {
                            ye.debug && Te.debug("websocketRequest", ye);
                            var $e, Ne = function(xe) {
                                if (xe.substr(0, 8) === "https://")
                                    return "wss://" + xe.substr(8);
                                if (xe.substr(0, 7) === "http://")
                                    return "ws://" + xe.substr(7);
                                throw new Error("Websocket transport constructed with non-https:// or http:// host.")
                            }(ye.url), ve = [];
                            function ke(xe) {
                                if (xe === ge.FINISH_SEND)
                                    $e.send(Se);
                                else {
                                    var we = xe
                                      , Fe = new Int8Array(we.byteLength + 1);
                                    Fe.set(new Uint8Array([0])),
                                    Fe.set(we, 1),
                                    $e.send(Fe)
                                }
                            }
                            return {
                                sendMessage: function(xe) {
                                    $e && $e.readyState !== $e.CONNECTING ? ke(xe) : ve.push(xe)
                                },
                                finishSend: function() {
                                    $e && $e.readyState !== $e.CONNECTING ? ke(ge.FINISH_SEND) : ve.push(ge.FINISH_SEND)
                                },
                                start: function(xe) {
                                    ($e = new WebSocket(Ne,["grpc-websockets"])).binaryType = "arraybuffer",
                                    $e.onopen = function() {
                                        var we;
                                        ye.debug && Te.debug("websocketRequest.onopen"),
                                        $e.send((we = "",
                                        xe.forEach(function(Fe, je) {
                                            we += Fe + ": " + je.join(", ") + `\r
`
                                        }),
                                        _e.encodeASCII(we))),
                                        ve.forEach(function(Fe) {
                                            ke(Fe)
                                        })
                                    }
                                    ,
                                    $e.onclose = function(we) {
                                        ye.debug && Te.debug("websocketRequest.onclose", we),
                                        ye.onEnd()
                                    }
                                    ,
                                    $e.onerror = function(we) {
                                        ye.debug && Te.debug("websocketRequest.onerror", we)
                                    }
                                    ,
                                    $e.onmessage = function(we) {
                                        ye.onChunk(new Uint8Array(we.data))
                                    }
                                },
                                cancel: function() {
                                    ye.debug && Te.debug("websocket.abort"),
                                    $e.close()
                                }
                            }
                        }(Ie)
                    }
                }
            },
            35: function(ue, ce, me) {
                Object.defineProperty(ce, "__esModule", {
                    value: !0
                }),
                ce.unary = void 0;
                var ge = me(65)
                  , Te = me(934);
                ce.unary = function(_e, Se) {
                    if (_e.responseStream)
                        throw new Error(".unary cannot be used with server-streaming methods. Use .invoke or .client instead.");
                    if (_e.requestStream)
                        throw new Error(".unary cannot be used with client-streaming methods. Use .client instead.");
                    var Ie = null
                      , ye = null
                      , $e = Te.client(_e, {
                        host: Se.host,
                        transport: Se.transport,
                        debug: Se.debug
                    });
                    return $e.onHeaders(function(Ne) {
                        Ie = Ne
                    }),
                    $e.onMessage(function(Ne) {
                        ye = Ne
                    }),
                    $e.onEnd(function(Ne, ve, ke) {
                        Se.onEnd({
                            status: Ne,
                            statusMessage: ve,
                            headers: Ie || new ge.Metadata,
                            message: ye,
                            trailers: ke
                        })
                    }),
                    $e.start(Se.metadata),
                    $e.send(Se.request),
                    $e.finishSend(),
                    {
                        close: function() {
                            $e.close()
                        }
                    }
                }
            },
            882: function(ue, ce) {
                Object.defineProperty(ce, "__esModule", {
                    value: !0
                }),
                ce.frameRequest = void 0,
                ce.frameRequest = function(me) {
                    var ge = me.serializeBinary()
                      , Te = new ArrayBuffer(ge.byteLength + 5);
                    return new DataView(Te,1,4).setUint32(0, ge.length, !1),
                    new Uint8Array(Te,5).set(ge),
                    new Uint8Array(Te)
                }
            }
        },
        ne = {},
        function ue(ce) {
            if (ne[ce])
                return ne[ce].exports;
            var me = ne[ce] = {
                exports: {}
            };
            return J[ce].call(me.exports, me, me.exports, ue),
            me.exports
        }(607);
        var J, ne
    })
}
)(grpcWebClient_umd);
var grpcWebClient_umdExports = grpcWebClient_umd.exports
  , browserHeaders_umd = {
    exports: {}
};
(function(V, X) {
    (function(ne, ue) {
        V.exports = ue()
    }
    )(commonjsGlobal, function() {
        return function(J) {
            var ne = {};
            function ue(ce) {
                if (ne[ce])
                    return ne[ce].exports;
                var me = ne[ce] = {
                    i: ce,
                    l: !1,
                    exports: {}
                };
                return J[ce].call(me.exports, me, me.exports, ue),
                me.l = !0,
                me.exports
            }
            return ue.m = J,
            ue.c = ne,
            ue.i = function(ce) {
                return ce
            }
            ,
            ue.d = function(ce, me, ge) {
                ue.o(ce, me) || Object.defineProperty(ce, me, {
                    configurable: !1,
                    enumerable: !0,
                    get: ge
                })
            }
            ,
            ue.n = function(ce) {
                var me = ce && ce.__esModule ? function() {
                    return ce.default
                }
                : function() {
                    return ce
                }
                ;
                return ue.d(me, "a", me),
                me
            }
            ,
            ue.o = function(ce, me) {
                return Object.prototype.hasOwnProperty.call(ce, me)
            }
            ,
            ue.p = "",
            ue(ue.s = 1)
        }([function(J, ne, ue) {
            Object.defineProperty(ne, "__esModule", {
                value: !0
            });
            var ce = ue(3);
            function me(Te) {
                return typeof Te == "object" && typeof Te.headersMap == "object" && typeof Te.forEach == "function"
            }
            var ge = function() {
                function Te(_e, Se) {
                    _e === void 0 && (_e = {}),
                    Se === void 0 && (Se = {
                        splitValues: !1
                    });
                    var Ie = this;
                    if (this.headersMap = {},
                    _e)
                        if (typeof Headers < "u" && _e instanceof Headers) {
                            var ye = ce.getHeaderKeys(_e);
                            ye.forEach(function(Ne) {
                                var ve = ce.getHeaderValues(_e, Ne);
                                ve.forEach(function(ke) {
                                    Se.splitValues ? Ie.append(Ne, ce.splitHeaderValue(ke)) : Ie.append(Ne, ke)
                                })
                            })
                        } else if (me(_e))
                            _e.forEach(function(Ne, ve) {
                                Ie.append(Ne, ve)
                            });
                        else if (typeof Map < "u" && _e instanceof Map) {
                            var $e = _e;
                            $e.forEach(function(Ne, ve) {
                                Ie.append(ve, Ne)
                            })
                        } else
                            typeof _e == "string" ? this.appendFromString(_e) : typeof _e == "object" && Object.getOwnPropertyNames(_e).forEach(function(Ne) {
                                var ve = _e
                                  , ke = ve[Ne];
                                Array.isArray(ke) ? ke.forEach(function(xe) {
                                    Ie.append(Ne, xe)
                                }) : Ie.append(Ne, ke)
                            })
                }
                return Te.prototype.appendFromString = function(_e) {
                    for (var Se = _e.split(`\r
`), Ie = 0; Ie < Se.length; Ie++) {
                        var ye = Se[Ie]
                          , $e = ye.indexOf(":");
                        if ($e > 0) {
                            var Ne = ye.substring(0, $e).trim()
                              , ve = ye.substring($e + 1).trim();
                            this.append(Ne, ve)
                        }
                    }
                }
                ,
                Te.prototype.delete = function(_e, Se) {
                    var Ie = ce.normalizeName(_e);
                    if (Se === void 0)
                        delete this.headersMap[Ie];
                    else {
                        var ye = this.headersMap[Ie];
                        if (ye) {
                            var $e = ye.indexOf(Se);
                            $e >= 0 && ye.splice($e, 1),
                            ye.length === 0 && delete this.headersMap[Ie]
                        }
                    }
                }
                ,
                Te.prototype.append = function(_e, Se) {
                    var Ie = this
                      , ye = ce.normalizeName(_e);
                    Array.isArray(this.headersMap[ye]) || (this.headersMap[ye] = []),
                    Array.isArray(Se) ? Se.forEach(function($e) {
                        Ie.headersMap[ye].push(ce.normalizeValue($e))
                    }) : this.headersMap[ye].push(ce.normalizeValue(Se))
                }
                ,
                Te.prototype.set = function(_e, Se) {
                    var Ie = ce.normalizeName(_e);
                    if (Array.isArray(Se)) {
                        var ye = [];
                        Se.forEach(function($e) {
                            ye.push(ce.normalizeValue($e))
                        }),
                        this.headersMap[Ie] = ye
                    } else
                        this.headersMap[Ie] = [ce.normalizeValue(Se)]
                }
                ,
                Te.prototype.has = function(_e, Se) {
                    var Ie = this.headersMap[ce.normalizeName(_e)]
                      , ye = Array.isArray(Ie);
                    if (!ye)
                        return !1;
                    if (Se !== void 0) {
                        var $e = ce.normalizeValue(Se);
                        return Ie.indexOf($e) >= 0
                    } else
                        return !0
                }
                ,
                Te.prototype.get = function(_e) {
                    var Se = this.headersMap[ce.normalizeName(_e)];
                    return Se !== void 0 ? Se.concat() : []
                }
                ,
                Te.prototype.forEach = function(_e) {
                    var Se = this;
                    Object.getOwnPropertyNames(this.headersMap).forEach(function(Ie) {
                        _e(Ie, Se.headersMap[Ie])
                    }, this)
                }
                ,
                Te.prototype.toHeaders = function() {
                    if (typeof Headers < "u") {
                        var _e = new Headers;
                        return this.forEach(function(Se, Ie) {
                            Ie.forEach(function(ye) {
                                _e.append(Se, ye)
                            })
                        }),
                        _e
                    } else
                        throw new Error("Headers class is not defined")
                }
                ,
                Te
            }();
            ne.BrowserHeaders = ge
        }
        , function(J, ne, ue) {
            Object.defineProperty(ne, "__esModule", {
                value: !0
            });
            var ce = ue(0);
            ne.BrowserHeaders = ce.BrowserHeaders
        }
        , function(J, ne, ue) {
            Object.defineProperty(ne, "__esModule", {
                value: !0
            });
            function ce(ge, Te) {
                for (var _e = ge[Symbol.iterator](), Se = _e.next(); !Se.done; )
                    Te(Se.value[0]),
                    Se = _e.next()
            }
            ne.iterateHeaders = ce;
            function me(ge, Te) {
                for (var _e = ge.keys(), Se = _e.next(); !Se.done; )
                    Te(Se.value),
                    Se = _e.next()
            }
            ne.iterateHeadersKeys = me
        }
        , function(J, ne, ue) {
            Object.defineProperty(ne, "__esModule", {
                value: !0
            });
            var ce = ue(2);
            function me(ye) {
                if (typeof ye != "string" && (ye = String(ye)),
                /[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(ye))
                    throw new TypeError("Invalid character in header field name");
                return ye.toLowerCase()
            }
            ne.normalizeName = me;
            function ge(ye) {
                return typeof ye != "string" && (ye = String(ye)),
                ye
            }
            ne.normalizeValue = ge;
            function Te(ye, $e) {
                var Ne = ye;
                if (Ne instanceof Headers && Ne.getAll)
                    return Ne.getAll($e);
                var ve = Ne.get($e);
                return ve && typeof ve == "string" ? [ve] : ve
            }
            ne.getHeaderValues = Te;
            function _e(ye) {
                return ye
            }
            function Se(ye) {
                var $e = ye
                  , Ne = {}
                  , ve = [];
                return $e.keys ? ce.iterateHeadersKeys($e, function(ke) {
                    Ne[ke] || (Ne[ke] = !0,
                    ve.push(ke))
                }) : $e.forEach ? $e.forEach(function(ke, xe) {
                    Ne[xe] || (Ne[xe] = !0,
                    ve.push(xe))
                }) : ce.iterateHeaders($e, function(ke) {
                    var xe = ke[0];
                    Ne[xe] || (Ne[xe] = !0,
                    ve.push(xe))
                }),
                ve
            }
            ne.getHeaderKeys = Se;
            function Ie(ye) {
                var $e = []
                  , Ne = ye.split(", ");
                return Ne.forEach(function(ve) {
                    ve.split(",").forEach(function(ke) {
                        $e.push(ke)
                    })
                }),
                $e
            }
            ne.splitHeaderValue = Ie
        }
        ])
    })
}
)(browserHeaders_umd);
var browserHeaders_umdExports = browserHeaders_umd.exports;
function createBaseProgressionEntry() {
    return {
        progressionMode: "",
        progressibles: []
    }
}
const ProgressionEntry = {
    encode(V, X=new BinaryWriter) {
        V.progressionMode !== "" && X.uint32(10).string(V.progressionMode);
        for (const J of V.progressibles)
            Mutator.encode(J, X.uint32(18).fork()).join();
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseProgressionEntry();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.progressionMode = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.progressibles.push(Mutator.decode(J, J.uint32()));
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            progressionMode: isSet$9(V.progressionMode) ? globalThis.String(V.progressionMode) : "",
            progressibles: globalThis.Array.isArray(V == null ? void 0 : V.progressibles) ? V.progressibles.map(X => Mutator.fromJSON(X)) : []
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return V.progressionMode !== "" && (X.progressionMode = V.progressionMode),
        (J = V.progressibles) != null && J.length && (X.progressibles = V.progressibles.map(ne => Mutator.toJSON(ne))),
        X
    },
    create(V) {
        return ProgressionEntry.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseProgressionEntry();
        return X.progressionMode = V.progressionMode ?? "",
        X.progressibles = ((J = V.progressibles) == null ? void 0 : J.map(ne => Mutator.fromPartial(ne))) || [],
        X
    }
};
function isSet$9(V) {
    return V != null
}
function experienceOrderByFromJSON(V) {
    switch (V) {
    case 0:
    case "EXPERIENCE_ORDER_BY_UNSPECIFIED":
        return 0;
    case 1:
    case "EXPERIENCE_ORDER_BY_UPDATED_ASC":
        return 1;
    case 2:
    case "EXPERIENCE_ORDER_BY_UPDATED_DESC":
        return 2;
    case 3:
    case "EXPERIENCE_ORDER_BY_CREATED_ASC":
        return 3;
    case 4:
    case "EXPERIENCE_ORDER_BY_CREATED_DESC":
        return 4;
    case 5:
    case "EXPERIENCE_ORDER_BY_POPULARITY_ASC":
        return 5;
    case 6:
    case "EXPERIENCE_ORDER_BY_POPULARITY_DESC":
        return 6;
    case 7:
    case "EXPERIENCE_ORDER_BY_LIKES_ASC":
        return 7;
    case 8:
    case "EXPERIENCE_ORDER_BY_LIKES_DESC":
        return 8;
    case -1:
    case "UNRECOGNIZED":
    default:
        return -1
    }
}
function experienceOrderByToJSON(V) {
    switch (V) {
    case 0:
        return "EXPERIENCE_ORDER_BY_UNSPECIFIED";
    case 1:
        return "EXPERIENCE_ORDER_BY_UPDATED_ASC";
    case 2:
        return "EXPERIENCE_ORDER_BY_UPDATED_DESC";
    case 3:
        return "EXPERIENCE_ORDER_BY_CREATED_ASC";
    case 4:
        return "EXPERIENCE_ORDER_BY_CREATED_DESC";
    case 5:
        return "EXPERIENCE_ORDER_BY_POPULARITY_ASC";
    case 6:
        return "EXPERIENCE_ORDER_BY_POPULARITY_DESC";
    case 7:
        return "EXPERIENCE_ORDER_BY_LIKES_ASC";
    case 8:
        return "EXPERIENCE_ORDER_BY_LIKES_DESC";
    case -1:
    default:
        return "UNRECOGNIZED"
    }
}
function createBasePagination() {
    return {
        pageNumber: void 0,
        token: void 0
    }
}
const Pagination = {
    encode(V, X=new BinaryWriter) {
        return V.pageNumber !== void 0 && X.uint32(8).int32(V.pageNumber),
        V.token !== void 0 && X.uint32(18).string(V.token),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBasePagination();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 8)
                        break;
                    ue.pageNumber = J.int32();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.token = J.string();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            pageNumber: isSet$8(V.pageNumber) ? globalThis.Number(V.pageNumber) : void 0,
            token: isSet$8(V.token) ? globalThis.String(V.token) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.pageNumber !== void 0 && (X.pageNumber = Math.round(V.pageNumber)),
        V.token !== void 0 && (X.token = V.token),
        X
    },
    create(V) {
        return Pagination.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBasePagination();
        return X.pageNumber = V.pageNumber ?? void 0,
        X.token = V.token ?? void 0,
        X
    }
};
function isSet$8(V) {
    return V != null
}
function createBasePlayExperienceQuery() {
    return {
        mapsEq: [],
        levelLocationsEq: [],
        maxPlayerCountEq: [],
        tagsEq: [],
        playerCreatorEq: void 0,
        ordering: 0,
        pageSize: 0,
        namePrefix: void 0,
        shortCode: void 0
    }
}
const PlayExperienceQuery = {
    encode(V, X=new BinaryWriter) {
        for (const J of V.mapsEq)
            X.uint32(10).string(J);
        for (const J of V.levelLocationsEq)
            X.uint32(18).string(J);
        X.uint32(26).fork();
        for (const J of V.maxPlayerCountEq)
            X.int32(J);
        X.join();
        for (const J of V.tagsEq)
            X.uint32(34).string(J);
        return V.playerCreatorEq !== void 0 && PlayerCreator.encode(V.playerCreatorEq, X.uint32(58).fork()).join(),
        V.ordering !== 0 && X.uint32(64).int32(V.ordering),
        V.pageSize !== 0 && X.uint32(72).int32(V.pageSize),
        V.namePrefix !== void 0 && StringValue.encode({
            value: V.namePrefix
        }, X.uint32(82).fork()).join(),
        V.shortCode !== void 0 && StringValue.encode({
            value: V.shortCode
        }, X.uint32(90).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBasePlayExperienceQuery();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.mapsEq.push(J.string());
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.levelLocationsEq.push(J.string());
                    continue
                }
            case 3:
                {
                    if (ce === 24) {
                        ue.maxPlayerCountEq.push(J.int32());
                        continue
                    }
                    if (ce === 26) {
                        const me = J.uint32() + J.pos;
                        for (; J.pos < me; )
                            ue.maxPlayerCountEq.push(J.int32());
                        continue
                    }
                    break
                }
            case 4:
                {
                    if (ce !== 34)
                        break;
                    ue.tagsEq.push(J.string());
                    continue
                }
            case 7:
                {
                    if (ce !== 58)
                        break;
                    ue.playerCreatorEq = PlayerCreator.decode(J, J.uint32());
                    continue
                }
            case 8:
                {
                    if (ce !== 64)
                        break;
                    ue.ordering = J.int32();
                    continue
                }
            case 9:
                {
                    if (ce !== 72)
                        break;
                    ue.pageSize = J.int32();
                    continue
                }
            case 10:
                {
                    if (ce !== 82)
                        break;
                    ue.namePrefix = StringValue.decode(J, J.uint32()).value;
                    continue
                }
            case 11:
                {
                    if (ce !== 90)
                        break;
                    ue.shortCode = StringValue.decode(J, J.uint32()).value;
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            mapsEq: globalThis.Array.isArray(V == null ? void 0 : V.mapsEq) ? V.mapsEq.map(X => globalThis.String(X)) : [],
            levelLocationsEq: globalThis.Array.isArray(V == null ? void 0 : V.levelLocationsEq) ? V.levelLocationsEq.map(X => globalThis.String(X)) : [],
            maxPlayerCountEq: globalThis.Array.isArray(V == null ? void 0 : V.maxPlayerCountEq) ? V.maxPlayerCountEq.map(X => globalThis.Number(X)) : [],
            tagsEq: globalThis.Array.isArray(V == null ? void 0 : V.tagsEq) ? V.tagsEq.map(X => globalThis.String(X)) : [],
            playerCreatorEq: isSet$7(V.playerCreatorEq) ? PlayerCreator.fromJSON(V.playerCreatorEq) : void 0,
            ordering: isSet$7(V.ordering) ? experienceOrderByFromJSON(V.ordering) : 0,
            pageSize: isSet$7(V.pageSize) ? globalThis.Number(V.pageSize) : 0,
            namePrefix: isSet$7(V.namePrefix) ? String(V.namePrefix) : void 0,
            shortCode: isSet$7(V.shortCode) ? String(V.shortCode) : void 0
        }
    },
    toJSON(V) {
        var J, ne, ue, ce;
        const X = {};
        return (J = V.mapsEq) != null && J.length && (X.mapsEq = V.mapsEq),
        (ne = V.levelLocationsEq) != null && ne.length && (X.levelLocationsEq = V.levelLocationsEq),
        (ue = V.maxPlayerCountEq) != null && ue.length && (X.maxPlayerCountEq = V.maxPlayerCountEq.map(me => Math.round(me))),
        (ce = V.tagsEq) != null && ce.length && (X.tagsEq = V.tagsEq),
        V.playerCreatorEq !== void 0 && (X.playerCreatorEq = PlayerCreator.toJSON(V.playerCreatorEq)),
        V.ordering !== 0 && (X.ordering = experienceOrderByToJSON(V.ordering)),
        V.pageSize !== 0 && (X.pageSize = Math.round(V.pageSize)),
        V.namePrefix !== void 0 && (X.namePrefix = V.namePrefix),
        V.shortCode !== void 0 && (X.shortCode = V.shortCode),
        X
    },
    create(V) {
        return PlayExperienceQuery.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J, ne, ue, ce;
        const X = createBasePlayExperienceQuery();
        return X.mapsEq = ((J = V.mapsEq) == null ? void 0 : J.map(me => me)) || [],
        X.levelLocationsEq = ((ne = V.levelLocationsEq) == null ? void 0 : ne.map(me => me)) || [],
        X.maxPlayerCountEq = ((ue = V.maxPlayerCountEq) == null ? void 0 : ue.map(me => me)) || [],
        X.tagsEq = ((ce = V.tagsEq) == null ? void 0 : ce.map(me => me)) || [],
        X.playerCreatorEq = V.playerCreatorEq !== void 0 && V.playerCreatorEq !== null ? PlayerCreator.fromPartial(V.playerCreatorEq) : void 0,
        X.ordering = V.ordering ?? 0,
        X.pageSize = V.pageSize ?? 0,
        X.namePrefix = V.namePrefix ?? void 0,
        X.shortCode = V.shortCode ?? void 0,
        X
    }
};
function createBasePlayExperience() {
    return {
        id: "",
        name: "",
        creator: void 0,
        description: void 0,
        shortCode: void 0,
        thumbnailUrl: void 0,
        likes: void 0,
        playerCount: void 0,
        created: void 0,
        updated: void 0,
        mapRotation: void 0,
        tags: [],
        isPremium: !1
    }
}
const PlayExperience = {
    encode(V, X=new BinaryWriter) {
        V.id !== "" && X.uint32(10).string(V.id),
        V.name !== "" && X.uint32(18).string(V.name),
        V.creator !== void 0 && Creator.encode(V.creator, X.uint32(26).fork()).join(),
        V.description !== void 0 && StringValue.encode({
            value: V.description
        }, X.uint32(34).fork()).join(),
        V.shortCode !== void 0 && StringValue.encode({
            value: V.shortCode
        }, X.uint32(42).fork()).join(),
        V.thumbnailUrl !== void 0 && StringValue.encode({
            value: V.thumbnailUrl
        }, X.uint32(50).fork()).join(),
        V.likes !== void 0 && Int32Value.encode({
            value: V.likes
        }, X.uint32(58).fork()).join(),
        V.playerCount !== void 0 && Int32Value.encode({
            value: V.playerCount
        }, X.uint32(66).fork()).join(),
        V.created !== void 0 && Timestamp.encode(toTimestamp$2(V.created), X.uint32(74).fork()).join(),
        V.updated !== void 0 && Timestamp.encode(toTimestamp$2(V.updated), X.uint32(82).fork()).join(),
        V.mapRotation !== void 0 && MapRotation.encode(V.mapRotation, X.uint32(90).fork()).join();
        for (const J of V.tags)
            Tag.encode(J, X.uint32(98).fork()).join();
        return V.isPremium !== !1 && X.uint32(104).bool(V.isPremium),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBasePlayExperience();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.id = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.name = J.string();
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.creator = Creator.decode(J, J.uint32());
                    continue
                }
            case 4:
                {
                    if (ce !== 34)
                        break;
                    ue.description = StringValue.decode(J, J.uint32()).value;
                    continue
                }
            case 5:
                {
                    if (ce !== 42)
                        break;
                    ue.shortCode = StringValue.decode(J, J.uint32()).value;
                    continue
                }
            case 6:
                {
                    if (ce !== 50)
                        break;
                    ue.thumbnailUrl = StringValue.decode(J, J.uint32()).value;
                    continue
                }
            case 7:
                {
                    if (ce !== 58)
                        break;
                    ue.likes = Int32Value.decode(J, J.uint32()).value;
                    continue
                }
            case 8:
                {
                    if (ce !== 66)
                        break;
                    ue.playerCount = Int32Value.decode(J, J.uint32()).value;
                    continue
                }
            case 9:
                {
                    if (ce !== 74)
                        break;
                    ue.created = fromTimestamp$2(Timestamp.decode(J, J.uint32()));
                    continue
                }
            case 10:
                {
                    if (ce !== 82)
                        break;
                    ue.updated = fromTimestamp$2(Timestamp.decode(J, J.uint32()));
                    continue
                }
            case 11:
                {
                    if (ce !== 90)
                        break;
                    ue.mapRotation = MapRotation.decode(J, J.uint32());
                    continue
                }
            case 12:
                {
                    if (ce !== 98)
                        break;
                    ue.tags.push(Tag.decode(J, J.uint32()));
                    continue
                }
            case 13:
                {
                    if (ce !== 104)
                        break;
                    ue.isPremium = J.bool();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            id: isSet$7(V.id) ? globalThis.String(V.id) : "",
            name: isSet$7(V.name) ? globalThis.String(V.name) : "",
            creator: isSet$7(V.creator) ? Creator.fromJSON(V.creator) : void 0,
            description: isSet$7(V.description) ? String(V.description) : void 0,
            shortCode: isSet$7(V.shortCode) ? String(V.shortCode) : void 0,
            thumbnailUrl: isSet$7(V.thumbnailUrl) ? String(V.thumbnailUrl) : void 0,
            likes: isSet$7(V.likes) ? Number(V.likes) : void 0,
            playerCount: isSet$7(V.playerCount) ? Number(V.playerCount) : void 0,
            created: isSet$7(V.created) ? fromJsonTimestamp$2(V.created) : void 0,
            updated: isSet$7(V.updated) ? fromJsonTimestamp$2(V.updated) : void 0,
            mapRotation: isSet$7(V.mapRotation) ? MapRotation.fromJSON(V.mapRotation) : void 0,
            tags: globalThis.Array.isArray(V == null ? void 0 : V.tags) ? V.tags.map(X => Tag.fromJSON(X)) : [],
            isPremium: isSet$7(V.isPremium) ? globalThis.Boolean(V.isPremium) : !1
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return V.id !== "" && (X.id = V.id),
        V.name !== "" && (X.name = V.name),
        V.creator !== void 0 && (X.creator = Creator.toJSON(V.creator)),
        V.description !== void 0 && (X.description = V.description),
        V.shortCode !== void 0 && (X.shortCode = V.shortCode),
        V.thumbnailUrl !== void 0 && (X.thumbnailUrl = V.thumbnailUrl),
        V.likes !== void 0 && (X.likes = V.likes),
        V.playerCount !== void 0 && (X.playerCount = V.playerCount),
        V.created !== void 0 && (X.created = V.created.toISOString()),
        V.updated !== void 0 && (X.updated = V.updated.toISOString()),
        V.mapRotation !== void 0 && (X.mapRotation = MapRotation.toJSON(V.mapRotation)),
        (J = V.tags) != null && J.length && (X.tags = V.tags.map(ne => Tag.toJSON(ne))),
        V.isPremium !== !1 && (X.isPremium = V.isPremium),
        X
    },
    create(V) {
        return PlayExperience.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBasePlayExperience();
        return X.id = V.id ?? "",
        X.name = V.name ?? "",
        X.creator = V.creator !== void 0 && V.creator !== null ? Creator.fromPartial(V.creator) : void 0,
        X.description = V.description ?? void 0,
        X.shortCode = V.shortCode ?? void 0,
        X.thumbnailUrl = V.thumbnailUrl ?? void 0,
        X.likes = V.likes ?? void 0,
        X.playerCount = V.playerCount ?? void 0,
        X.created = V.created ?? void 0,
        X.updated = V.updated ?? void 0,
        X.mapRotation = V.mapRotation !== void 0 && V.mapRotation !== null ? MapRotation.fromPartial(V.mapRotation) : void 0,
        X.tags = ((J = V.tags) == null ? void 0 : J.map(ne => Tag.fromPartial(ne))) || [],
        X.isPremium = V.isPremium ?? !1,
        X
    }
};
function toTimestamp$2(V) {
    const X = Math.trunc(V.getTime() / 1e3)
      , J = V.getTime() % 1e3 * 1e6;
    return {
        seconds: X,
        nanos: J
    }
}
function fromTimestamp$2(V) {
    let X = (V.seconds || 0) * 1e3;
    return X += (V.nanos || 0) / 1e6,
    new globalThis.Date(X)
}
function fromJsonTimestamp$2(V) {
    return V instanceof globalThis.Date ? V : typeof V == "string" ? new globalThis.Date(V) : fromTimestamp$2(Timestamp.fromJSON(V))
}
function isSet$7(V) {
    return V != null
}
function createBaseCreatePlayElementRequest() {
    return {
        name: "",
        description: void 0,
        designMetadata: void 0,
        mapRotation: void 0,
        mutators: [],
        assetCategories: [],
        originalModRules: new Uint8Array(0),
        playElementSettings: void 0,
        publishState: 0,
        modLevelDataId: void 0,
        thumbnailUrl: void 0,
        attachments: []
    }
}
const CreatePlayElementRequest = {
    encode(V, X=new BinaryWriter) {
        V.name !== "" && X.uint32(10).string(V.name),
        V.description !== void 0 && StringValue.encode({
            value: V.description
        }, X.uint32(18).fork()).join(),
        V.designMetadata !== void 0 && DesignMetadata.encode(V.designMetadata, X.uint32(26).fork()).join(),
        V.mapRotation !== void 0 && MapRotation.encode(V.mapRotation, X.uint32(34).fork()).join();
        for (const J of V.mutators)
            Mutator.encode(J, X.uint32(42).fork()).join();
        for (const J of V.assetCategories)
            AssetCategory.encode(J, X.uint32(50).fork()).join();
        V.originalModRules.length !== 0 && X.uint32(58).bytes(V.originalModRules),
        V.playElementSettings !== void 0 && PlayElementSettings.encode(V.playElementSettings, X.uint32(74).fork()).join(),
        V.publishState !== 0 && X.uint32(80).int32(V.publishState),
        V.modLevelDataId !== void 0 && StringValue.encode({
            value: V.modLevelDataId
        }, X.uint32(90).fork()).join(),
        V.thumbnailUrl !== void 0 && StringValue.encode({
            value: V.thumbnailUrl
        }, X.uint32(98).fork()).join();
        for (const J of V.attachments)
            Attachment.encode(J, X.uint32(106).fork()).join();
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseCreatePlayElementRequest();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.name = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.description = StringValue.decode(J, J.uint32()).value;
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.designMetadata = DesignMetadata.decode(J, J.uint32());
                    continue
                }
            case 4:
                {
                    if (ce !== 34)
                        break;
                    ue.mapRotation = MapRotation.decode(J, J.uint32());
                    continue
                }
            case 5:
                {
                    if (ce !== 42)
                        break;
                    ue.mutators.push(Mutator.decode(J, J.uint32()));
                    continue
                }
            case 6:
                {
                    if (ce !== 50)
                        break;
                    ue.assetCategories.push(AssetCategory.decode(J, J.uint32()));
                    continue
                }
            case 7:
                {
                    if (ce !== 58)
                        break;
                    ue.originalModRules = J.bytes();
                    continue
                }
            case 9:
                {
                    if (ce !== 74)
                        break;
                    ue.playElementSettings = PlayElementSettings.decode(J, J.uint32());
                    continue
                }
            case 10:
                {
                    if (ce !== 80)
                        break;
                    ue.publishState = J.int32();
                    continue
                }
            case 11:
                {
                    if (ce !== 90)
                        break;
                    ue.modLevelDataId = StringValue.decode(J, J.uint32()).value;
                    continue
                }
            case 12:
                {
                    if (ce !== 98)
                        break;
                    ue.thumbnailUrl = StringValue.decode(J, J.uint32()).value;
                    continue
                }
            case 13:
                {
                    if (ce !== 106)
                        break;
                    ue.attachments.push(Attachment.decode(J, J.uint32()));
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            name: isSet$6(V.name) ? globalThis.String(V.name) : "",
            description: isSet$6(V.description) ? String(V.description) : void 0,
            designMetadata: isSet$6(V.designMetadata) ? DesignMetadata.fromJSON(V.designMetadata) : void 0,
            mapRotation: isSet$6(V.mapRotation) ? MapRotation.fromJSON(V.mapRotation) : void 0,
            mutators: globalThis.Array.isArray(V == null ? void 0 : V.mutators) ? V.mutators.map(X => Mutator.fromJSON(X)) : [],
            assetCategories: globalThis.Array.isArray(V == null ? void 0 : V.assetCategories) ? V.assetCategories.map(X => AssetCategory.fromJSON(X)) : [],
            originalModRules: isSet$6(V.originalModRules) ? bytesFromBase64(V.originalModRules) : new Uint8Array(0),
            playElementSettings: isSet$6(V.playElementSettings) ? PlayElementSettings.fromJSON(V.playElementSettings) : void 0,
            publishState: isSet$6(V.publishState) ? publishStateTypeFromJSON(V.publishState) : 0,
            modLevelDataId: isSet$6(V.modLevelDataId) ? String(V.modLevelDataId) : void 0,
            thumbnailUrl: isSet$6(V.thumbnailUrl) ? String(V.thumbnailUrl) : void 0,
            attachments: globalThis.Array.isArray(V == null ? void 0 : V.attachments) ? V.attachments.map(X => Attachment.fromJSON(X)) : []
        }
    },
    toJSON(V) {
        var J, ne, ue;
        const X = {};
        return V.name !== "" && (X.name = V.name),
        V.description !== void 0 && (X.description = V.description),
        V.designMetadata !== void 0 && (X.designMetadata = DesignMetadata.toJSON(V.designMetadata)),
        V.mapRotation !== void 0 && (X.mapRotation = MapRotation.toJSON(V.mapRotation)),
        (J = V.mutators) != null && J.length && (X.mutators = V.mutators.map(ce => Mutator.toJSON(ce))),
        (ne = V.assetCategories) != null && ne.length && (X.assetCategories = V.assetCategories.map(ce => AssetCategory.toJSON(ce))),
        V.originalModRules.length !== 0 && (X.originalModRules = base64FromBytes(V.originalModRules)),
        V.playElementSettings !== void 0 && (X.playElementSettings = PlayElementSettings.toJSON(V.playElementSettings)),
        V.publishState !== 0 && (X.publishState = publishStateTypeToJSON(V.publishState)),
        V.modLevelDataId !== void 0 && (X.modLevelDataId = V.modLevelDataId),
        V.thumbnailUrl !== void 0 && (X.thumbnailUrl = V.thumbnailUrl),
        (ue = V.attachments) != null && ue.length && (X.attachments = V.attachments.map(ce => Attachment.toJSON(ce))),
        X
    },
    create(V) {
        return CreatePlayElementRequest.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J, ne, ue;
        const X = createBaseCreatePlayElementRequest();
        return X.name = V.name ?? "",
        X.description = V.description ?? void 0,
        X.designMetadata = V.designMetadata !== void 0 && V.designMetadata !== null ? DesignMetadata.fromPartial(V.designMetadata) : void 0,
        X.mapRotation = V.mapRotation !== void 0 && V.mapRotation !== null ? MapRotation.fromPartial(V.mapRotation) : void 0,
        X.mutators = ((J = V.mutators) == null ? void 0 : J.map(ce => Mutator.fromPartial(ce))) || [],
        X.assetCategories = ((ne = V.assetCategories) == null ? void 0 : ne.map(ce => AssetCategory.fromPartial(ce))) || [],
        X.originalModRules = V.originalModRules ?? new Uint8Array(0),
        X.playElementSettings = V.playElementSettings !== void 0 && V.playElementSettings !== null ? PlayElementSettings.fromPartial(V.playElementSettings) : void 0,
        X.publishState = V.publishState ?? 0,
        X.modLevelDataId = V.modLevelDataId ?? void 0,
        X.thumbnailUrl = V.thumbnailUrl ?? void 0,
        X.attachments = ((ue = V.attachments) == null ? void 0 : ue.map(ce => Attachment.fromPartial(ce))) || [],
        X
    }
};
function createBasePlayElementResponse() {
    return {
        playElement: void 0,
        playElementDesign: void 0,
        progressionMode: void 0
    }
}
const PlayElementResponse = {
    encode(V, X=new BinaryWriter) {
        return V.playElement !== void 0 && PlayElement.encode(V.playElement, X.uint32(10).fork()).join(),
        V.playElementDesign !== void 0 && PlayElementDesign.encode(V.playElementDesign, X.uint32(18).fork()).join(),
        V.progressionMode !== void 0 && StringValue.encode({
            value: V.progressionMode
        }, X.uint32(26).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBasePlayElementResponse();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.playElement = PlayElement.decode(J, J.uint32());
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.playElementDesign = PlayElementDesign.decode(J, J.uint32());
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.progressionMode = StringValue.decode(J, J.uint32()).value;
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            playElement: isSet$6(V.playElement) ? PlayElement.fromJSON(V.playElement) : void 0,
            playElementDesign: isSet$6(V.playElementDesign) ? PlayElementDesign.fromJSON(V.playElementDesign) : void 0,
            progressionMode: isSet$6(V.progressionMode) ? String(V.progressionMode) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.playElement !== void 0 && (X.playElement = PlayElement.toJSON(V.playElement)),
        V.playElementDesign !== void 0 && (X.playElementDesign = PlayElementDesign.toJSON(V.playElementDesign)),
        V.progressionMode !== void 0 && (X.progressionMode = V.progressionMode),
        X
    },
    create(V) {
        return PlayElementResponse.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBasePlayElementResponse();
        return X.playElement = V.playElement !== void 0 && V.playElement !== null ? PlayElement.fromPartial(V.playElement) : void 0,
        X.playElementDesign = V.playElementDesign !== void 0 && V.playElementDesign !== null ? PlayElementDesign.fromPartial(V.playElementDesign) : void 0,
        X.progressionMode = V.progressionMode ?? void 0,
        X
    }
};
function createBaseGetPlayElementRequest() {
    return {
        id: "",
        includeDenied: !1
    }
}
const GetPlayElementRequest = {
    encode(V, X=new BinaryWriter) {
        return V.id !== "" && X.uint32(10).string(V.id),
        V.includeDenied !== !1 && X.uint32(16).bool(V.includeDenied),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseGetPlayElementRequest();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.id = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 16)
                        break;
                    ue.includeDenied = J.bool();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            id: isSet$6(V.id) ? globalThis.String(V.id) : "",
            includeDenied: isSet$6(V.includeDenied) ? globalThis.Boolean(V.includeDenied) : !1
        }
    },
    toJSON(V) {
        const X = {};
        return V.id !== "" && (X.id = V.id),
        V.includeDenied !== !1 && (X.includeDenied = V.includeDenied),
        X
    },
    create(V) {
        return GetPlayElementRequest.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseGetPlayElementRequest();
        return X.id = V.id ?? "",
        X.includeDenied = V.includeDenied ?? !1,
        X
    }
};
function createBaseUpdatePlayElementRequest() {
    return {
        id: "",
        name: "",
        description: void 0,
        designMetadata: void 0,
        mapRotation: void 0,
        mutators: [],
        assetCategories: [],
        originalModRules: new Uint8Array(0),
        playElementSettings: void 0,
        publishState: 0,
        modLevelDataId: void 0,
        thumbnailUrl: void 0,
        attachments: []
    }
}
const UpdatePlayElementRequest = {
    encode(V, X=new BinaryWriter) {
        V.id !== "" && X.uint32(10).string(V.id),
        V.name !== "" && X.uint32(18).string(V.name),
        V.description !== void 0 && StringValue.encode({
            value: V.description
        }, X.uint32(26).fork()).join(),
        V.designMetadata !== void 0 && DesignMetadata.encode(V.designMetadata, X.uint32(34).fork()).join(),
        V.mapRotation !== void 0 && MapRotation.encode(V.mapRotation, X.uint32(42).fork()).join();
        for (const J of V.mutators)
            Mutator.encode(J, X.uint32(50).fork()).join();
        for (const J of V.assetCategories)
            AssetCategory.encode(J, X.uint32(58).fork()).join();
        V.originalModRules.length !== 0 && X.uint32(66).bytes(V.originalModRules),
        V.playElementSettings !== void 0 && PlayElementSettings.encode(V.playElementSettings, X.uint32(82).fork()).join(),
        V.publishState !== 0 && X.uint32(88).int32(V.publishState),
        V.modLevelDataId !== void 0 && StringValue.encode({
            value: V.modLevelDataId
        }, X.uint32(98).fork()).join(),
        V.thumbnailUrl !== void 0 && StringValue.encode({
            value: V.thumbnailUrl
        }, X.uint32(106).fork()).join();
        for (const J of V.attachments)
            Attachment.encode(J, X.uint32(114).fork()).join();
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseUpdatePlayElementRequest();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.id = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.name = J.string();
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.description = StringValue.decode(J, J.uint32()).value;
                    continue
                }
            case 4:
                {
                    if (ce !== 34)
                        break;
                    ue.designMetadata = DesignMetadata.decode(J, J.uint32());
                    continue
                }
            case 5:
                {
                    if (ce !== 42)
                        break;
                    ue.mapRotation = MapRotation.decode(J, J.uint32());
                    continue
                }
            case 6:
                {
                    if (ce !== 50)
                        break;
                    ue.mutators.push(Mutator.decode(J, J.uint32()));
                    continue
                }
            case 7:
                {
                    if (ce !== 58)
                        break;
                    ue.assetCategories.push(AssetCategory.decode(J, J.uint32()));
                    continue
                }
            case 8:
                {
                    if (ce !== 66)
                        break;
                    ue.originalModRules = J.bytes();
                    continue
                }
            case 10:
                {
                    if (ce !== 82)
                        break;
                    ue.playElementSettings = PlayElementSettings.decode(J, J.uint32());
                    continue
                }
            case 11:
                {
                    if (ce !== 88)
                        break;
                    ue.publishState = J.int32();
                    continue
                }
            case 12:
                {
                    if (ce !== 98)
                        break;
                    ue.modLevelDataId = StringValue.decode(J, J.uint32()).value;
                    continue
                }
            case 13:
                {
                    if (ce !== 106)
                        break;
                    ue.thumbnailUrl = StringValue.decode(J, J.uint32()).value;
                    continue
                }
            case 14:
                {
                    if (ce !== 114)
                        break;
                    ue.attachments.push(Attachment.decode(J, J.uint32()));
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            id: isSet$6(V.id) ? globalThis.String(V.id) : "",
            name: isSet$6(V.name) ? globalThis.String(V.name) : "",
            description: isSet$6(V.description) ? String(V.description) : void 0,
            designMetadata: isSet$6(V.designMetadata) ? DesignMetadata.fromJSON(V.designMetadata) : void 0,
            mapRotation: isSet$6(V.mapRotation) ? MapRotation.fromJSON(V.mapRotation) : void 0,
            mutators: globalThis.Array.isArray(V == null ? void 0 : V.mutators) ? V.mutators.map(X => Mutator.fromJSON(X)) : [],
            assetCategories: globalThis.Array.isArray(V == null ? void 0 : V.assetCategories) ? V.assetCategories.map(X => AssetCategory.fromJSON(X)) : [],
            originalModRules: isSet$6(V.originalModRules) ? bytesFromBase64(V.originalModRules) : new Uint8Array(0),
            playElementSettings: isSet$6(V.playElementSettings) ? PlayElementSettings.fromJSON(V.playElementSettings) : void 0,
            publishState: isSet$6(V.publishState) ? publishStateTypeFromJSON(V.publishState) : 0,
            modLevelDataId: isSet$6(V.modLevelDataId) ? String(V.modLevelDataId) : void 0,
            thumbnailUrl: isSet$6(V.thumbnailUrl) ? String(V.thumbnailUrl) : void 0,
            attachments: globalThis.Array.isArray(V == null ? void 0 : V.attachments) ? V.attachments.map(X => Attachment.fromJSON(X)) : []
        }
    },
    toJSON(V) {
        var J, ne, ue;
        const X = {};
        return V.id !== "" && (X.id = V.id),
        V.name !== "" && (X.name = V.name),
        V.description !== void 0 && (X.description = V.description),
        V.designMetadata !== void 0 && (X.designMetadata = DesignMetadata.toJSON(V.designMetadata)),
        V.mapRotation !== void 0 && (X.mapRotation = MapRotation.toJSON(V.mapRotation)),
        (J = V.mutators) != null && J.length && (X.mutators = V.mutators.map(ce => Mutator.toJSON(ce))),
        (ne = V.assetCategories) != null && ne.length && (X.assetCategories = V.assetCategories.map(ce => AssetCategory.toJSON(ce))),
        V.originalModRules.length !== 0 && (X.originalModRules = base64FromBytes(V.originalModRules)),
        V.playElementSettings !== void 0 && (X.playElementSettings = PlayElementSettings.toJSON(V.playElementSettings)),
        V.publishState !== 0 && (X.publishState = publishStateTypeToJSON(V.publishState)),
        V.modLevelDataId !== void 0 && (X.modLevelDataId = V.modLevelDataId),
        V.thumbnailUrl !== void 0 && (X.thumbnailUrl = V.thumbnailUrl),
        (ue = V.attachments) != null && ue.length && (X.attachments = V.attachments.map(ce => Attachment.toJSON(ce))),
        X
    },
    create(V) {
        return UpdatePlayElementRequest.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J, ne, ue;
        const X = createBaseUpdatePlayElementRequest();
        return X.id = V.id ?? "",
        X.name = V.name ?? "",
        X.description = V.description ?? void 0,
        X.designMetadata = V.designMetadata !== void 0 && V.designMetadata !== null ? DesignMetadata.fromPartial(V.designMetadata) : void 0,
        X.mapRotation = V.mapRotation !== void 0 && V.mapRotation !== null ? MapRotation.fromPartial(V.mapRotation) : void 0,
        X.mutators = ((J = V.mutators) == null ? void 0 : J.map(ce => Mutator.fromPartial(ce))) || [],
        X.assetCategories = ((ne = V.assetCategories) == null ? void 0 : ne.map(ce => AssetCategory.fromPartial(ce))) || [],
        X.originalModRules = V.originalModRules ?? new Uint8Array(0),
        X.playElementSettings = V.playElementSettings !== void 0 && V.playElementSettings !== null ? PlayElementSettings.fromPartial(V.playElementSettings) : void 0,
        X.publishState = V.publishState ?? 0,
        X.modLevelDataId = V.modLevelDataId ?? void 0,
        X.thumbnailUrl = V.thumbnailUrl ?? void 0,
        X.attachments = ((ue = V.attachments) == null ? void 0 : ue.map(ce => Attachment.fromPartial(ce))) || [],
        X
    }
};
function createBaseGetOwnedPlayElementsRequest() {
    return {
        publishStates: [],
        includeDenied: !1
    }
}
const GetOwnedPlayElementsRequest = {
    encode(V, X=new BinaryWriter) {
        X.uint32(10).fork();
        for (const J of V.publishStates)
            X.int32(J);
        return X.join(),
        V.includeDenied !== !1 && X.uint32(16).bool(V.includeDenied),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseGetOwnedPlayElementsRequest();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce === 8) {
                        ue.publishStates.push(J.int32());
                        continue
                    }
                    if (ce === 10) {
                        const me = J.uint32() + J.pos;
                        for (; J.pos < me; )
                            ue.publishStates.push(J.int32());
                        continue
                    }
                    break
                }
            case 2:
                {
                    if (ce !== 16)
                        break;
                    ue.includeDenied = J.bool();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            publishStates: globalThis.Array.isArray(V == null ? void 0 : V.publishStates) ? V.publishStates.map(X => publishStateTypeFromJSON(X)) : [],
            includeDenied: isSet$6(V.includeDenied) ? globalThis.Boolean(V.includeDenied) : !1
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return (J = V.publishStates) != null && J.length && (X.publishStates = V.publishStates.map(ne => publishStateTypeToJSON(ne))),
        V.includeDenied !== !1 && (X.includeDenied = V.includeDenied),
        X
    },
    create(V) {
        return GetOwnedPlayElementsRequest.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseGetOwnedPlayElementsRequest();
        return X.publishStates = ((J = V.publishStates) == null ? void 0 : J.map(ne => ne)) || [],
        X.includeDenied = V.includeDenied ?? !1,
        X
    }
};
function createBaseGetOwnedPlayElementsResponse() {
    return {
        playElements: []
    }
}
const GetOwnedPlayElementsResponse = {
    encode(V, X=new BinaryWriter) {
        for (const J of V.playElements)
            PlayElement.encode(J, X.uint32(10).fork()).join();
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseGetOwnedPlayElementsResponse();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.playElements.push(PlayElement.decode(J, J.uint32()));
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            playElements: globalThis.Array.isArray(V == null ? void 0 : V.playElements) ? V.playElements.map(X => PlayElement.fromJSON(X)) : []
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return (J = V.playElements) != null && J.length && (X.playElements = V.playElements.map(ne => PlayElement.toJSON(ne))),
        X
    },
    create(V) {
        return GetOwnedPlayElementsResponse.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseGetOwnedPlayElementsResponse();
        return X.playElements = ((J = V.playElements) == null ? void 0 : J.map(ne => PlayElement.fromPartial(ne))) || [],
        X
    }
};
function createBaseEnrichedPlayElement() {
    return {
        playElement: void 0,
        mapRotation: void 0
    }
}
const EnrichedPlayElement = {
    encode(V, X=new BinaryWriter) {
        return V.playElement !== void 0 && PlayElement.encode(V.playElement, X.uint32(10).fork()).join(),
        V.mapRotation !== void 0 && MapRotation.encode(V.mapRotation, X.uint32(18).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseEnrichedPlayElement();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.playElement = PlayElement.decode(J, J.uint32());
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.mapRotation = MapRotation.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            playElement: isSet$6(V.playElement) ? PlayElement.fromJSON(V.playElement) : void 0,
            mapRotation: isSet$6(V.mapRotation) ? MapRotation.fromJSON(V.mapRotation) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.playElement !== void 0 && (X.playElement = PlayElement.toJSON(V.playElement)),
        V.mapRotation !== void 0 && (X.mapRotation = MapRotation.toJSON(V.mapRotation)),
        X
    },
    create(V) {
        return EnrichedPlayElement.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseEnrichedPlayElement();
        return X.playElement = V.playElement !== void 0 && V.playElement !== null ? PlayElement.fromPartial(V.playElement) : void 0,
        X.mapRotation = V.mapRotation !== void 0 && V.mapRotation !== null ? MapRotation.fromPartial(V.mapRotation) : void 0,
        X
    }
};
function createBaseGetOwnedPlayElementsResponseV2() {
    return {
        playElements: []
    }
}
const GetOwnedPlayElementsResponseV2 = {
    encode(V, X=new BinaryWriter) {
        for (const J of V.playElements)
            EnrichedPlayElement.encode(J, X.uint32(10).fork()).join();
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseGetOwnedPlayElementsResponseV2();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.playElements.push(EnrichedPlayElement.decode(J, J.uint32()));
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            playElements: globalThis.Array.isArray(V == null ? void 0 : V.playElements) ? V.playElements.map(X => EnrichedPlayElement.fromJSON(X)) : []
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return (J = V.playElements) != null && J.length && (X.playElements = V.playElements.map(ne => EnrichedPlayElement.toJSON(ne))),
        X
    },
    create(V) {
        return GetOwnedPlayElementsResponseV2.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseGetOwnedPlayElementsResponseV2();
        return X.playElements = ((J = V.playElements) == null ? void 0 : J.map(ne => EnrichedPlayElement.fromPartial(ne))) || [],
        X
    }
};
function createBaseDeletePlayElementRequest() {
    return {
        playElementId: ""
    }
}
const DeletePlayElementRequest = {
    encode(V, X=new BinaryWriter) {
        return V.playElementId !== "" && X.uint32(10).string(V.playElementId),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseDeletePlayElementRequest();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.playElementId = J.string();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            playElementId: isSet$6(V.playElementId) ? globalThis.String(V.playElementId) : ""
        }
    },
    toJSON(V) {
        const X = {};
        return V.playElementId !== "" && (X.playElementId = V.playElementId),
        X
    },
    create(V) {
        return DeletePlayElementRequest.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseDeletePlayElementRequest();
        return X.playElementId = V.playElementId ?? "",
        X
    }
};
function createBaseDeletePlayElementResponse() {
    return {}
}
const DeletePlayElementResponse = {
    encode(V, X=new BinaryWriter) {
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseDeletePlayElementResponse();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {}
    },
    toJSON(V) {
        return {}
    },
    create(V) {
        return DeletePlayElementResponse.fromPartial(V ?? {})
    },
    fromPartial(V) {
        return createBaseDeletePlayElementResponse()
    }
};
function createBaseGetScheduledBlueprintsRequest() {
    return {}
}
const GetScheduledBlueprintsRequest = {
    encode(V, X=new BinaryWriter) {
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseGetScheduledBlueprintsRequest();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {}
    },
    toJSON(V) {
        return {}
    },
    create(V) {
        return GetScheduledBlueprintsRequest.fromPartial(V ?? {})
    },
    fromPartial(V) {
        return createBaseGetScheduledBlueprintsRequest()
    }
};
function createBaseGetScheduledBlueprintsResponse() {
    return {
        blueprintIds: []
    }
}
const GetScheduledBlueprintsResponse = {
    encode(V, X=new BinaryWriter) {
        for (const J of V.blueprintIds)
            BlueprintId.encode(J, X.uint32(10).fork()).join();
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseGetScheduledBlueprintsResponse();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.blueprintIds.push(BlueprintId.decode(J, J.uint32()));
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            blueprintIds: globalThis.Array.isArray(V == null ? void 0 : V.blueprintIds) ? V.blueprintIds.map(X => BlueprintId.fromJSON(X)) : []
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return (J = V.blueprintIds) != null && J.length && (X.blueprintIds = V.blueprintIds.map(ne => BlueprintId.toJSON(ne))),
        X
    },
    create(V) {
        return GetScheduledBlueprintsResponse.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseGetScheduledBlueprintsResponse();
        return X.blueprintIds = ((J = V.blueprintIds) == null ? void 0 : J.map(ne => BlueprintId.fromPartial(ne))) || [],
        X
    }
};
function createBaseGetBlueprintsByIdRequest() {
    return {
        blueprintIds: []
    }
}
const GetBlueprintsByIdRequest = {
    encode(V, X=new BinaryWriter) {
        for (const J of V.blueprintIds)
            BlueprintId.encode(J, X.uint32(10).fork()).join();
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseGetBlueprintsByIdRequest();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.blueprintIds.push(BlueprintId.decode(J, J.uint32()));
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            blueprintIds: globalThis.Array.isArray(V == null ? void 0 : V.blueprintIds) ? V.blueprintIds.map(X => BlueprintId.fromJSON(X)) : []
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return (J = V.blueprintIds) != null && J.length && (X.blueprintIds = V.blueprintIds.map(ne => BlueprintId.toJSON(ne))),
        X
    },
    create(V) {
        return GetBlueprintsByIdRequest.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseGetBlueprintsByIdRequest();
        return X.blueprintIds = ((J = V.blueprintIds) == null ? void 0 : J.map(ne => BlueprintId.fromPartial(ne))) || [],
        X
    }
};
function createBaseGetBlueprintsByIdResponse() {
    return {
        blueprints: []
    }
}
const GetBlueprintsByIdResponse = {
    encode(V, X=new BinaryWriter) {
        for (const J of V.blueprints)
            Blueprint.encode(J, X.uint32(10).fork()).join();
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseGetBlueprintsByIdResponse();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.blueprints.push(Blueprint.decode(J, J.uint32()));
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            blueprints: globalThis.Array.isArray(V == null ? void 0 : V.blueprints) ? V.blueprints.map(X => Blueprint.fromJSON(X)) : []
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return (J = V.blueprints) != null && J.length && (X.blueprints = V.blueprints.map(ne => Blueprint.toJSON(ne))),
        X
    },
    create(V) {
        return GetBlueprintsByIdResponse.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseGetBlueprintsByIdResponse();
        return X.blueprints = ((J = V.blueprints) == null ? void 0 : J.map(ne => Blueprint.fromPartial(ne))) || [],
        X
    }
};
function createBaseCreateModDataVersionRequest() {
    return {
        playElementId: ""
    }
}
const CreateModDataVersionRequest = {
    encode(V, X=new BinaryWriter) {
        return V.playElementId !== "" && X.uint32(10).string(V.playElementId),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseCreateModDataVersionRequest();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.playElementId = J.string();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            playElementId: isSet$6(V.playElementId) ? globalThis.String(V.playElementId) : ""
        }
    },
    toJSON(V) {
        const X = {};
        return V.playElementId !== "" && (X.playElementId = V.playElementId),
        X
    },
    create(V) {
        return CreateModDataVersionRequest.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseCreateModDataVersionRequest();
        return X.playElementId = V.playElementId ?? "",
        X
    }
};
function createBaseCreateModDataVersionResponse() {
    return {
        signedUrl: "",
        validUntil: void 0,
        modLevelDataId: ""
    }
}
const CreateModDataVersionResponse = {
    encode(V, X=new BinaryWriter) {
        return V.signedUrl !== "" && X.uint32(10).string(V.signedUrl),
        V.validUntil !== void 0 && Timestamp.encode(toTimestamp$1(V.validUntil), X.uint32(18).fork()).join(),
        V.modLevelDataId !== "" && X.uint32(26).string(V.modLevelDataId),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseCreateModDataVersionResponse();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.signedUrl = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.validUntil = fromTimestamp$1(Timestamp.decode(J, J.uint32()));
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.modLevelDataId = J.string();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            signedUrl: isSet$6(V.signedUrl) ? globalThis.String(V.signedUrl) : "",
            validUntil: isSet$6(V.validUntil) ? fromJsonTimestamp$1(V.validUntil) : void 0,
            modLevelDataId: isSet$6(V.modLevelDataId) ? globalThis.String(V.modLevelDataId) : ""
        }
    },
    toJSON(V) {
        const X = {};
        return V.signedUrl !== "" && (X.signedUrl = V.signedUrl),
        V.validUntil !== void 0 && (X.validUntil = V.validUntil.toISOString()),
        V.modLevelDataId !== "" && (X.modLevelDataId = V.modLevelDataId),
        X
    },
    create(V) {
        return CreateModDataVersionResponse.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseCreateModDataVersionResponse();
        return X.signedUrl = V.signedUrl ?? "",
        X.validUntil = V.validUntil ?? void 0,
        X.modLevelDataId = V.modLevelDataId ?? "",
        X
    }
};
function createBaseListModDataVersionsRequest() {
    return {
        playElementId: ""
    }
}
const ListModDataVersionsRequest = {
    encode(V, X=new BinaryWriter) {
        return V.playElementId !== "" && X.uint32(10).string(V.playElementId),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseListModDataVersionsRequest();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.playElementId = J.string();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            playElementId: isSet$6(V.playElementId) ? globalThis.String(V.playElementId) : ""
        }
    },
    toJSON(V) {
        const X = {};
        return V.playElementId !== "" && (X.playElementId = V.playElementId),
        X
    },
    create(V) {
        return ListModDataVersionsRequest.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseListModDataVersionsRequest();
        return X.playElementId = V.playElementId ?? "",
        X
    }
};
function createBaseListModDataVersionsResponse() {
    return {
        modDataVersions: []
    }
}
const ListModDataVersionsResponse = {
    encode(V, X=new BinaryWriter) {
        for (const J of V.modDataVersions)
            ModDataVersion.encode(J, X.uint32(10).fork()).join();
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseListModDataVersionsResponse();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.modDataVersions.push(ModDataVersion.decode(J, J.uint32()));
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            modDataVersions: globalThis.Array.isArray(V == null ? void 0 : V.modDataVersions) ? V.modDataVersions.map(X => ModDataVersion.fromJSON(X)) : []
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return (J = V.modDataVersions) != null && J.length && (X.modDataVersions = V.modDataVersions.map(ne => ModDataVersion.toJSON(ne))),
        X
    },
    create(V) {
        return ListModDataVersionsResponse.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseListModDataVersionsResponse();
        return X.modDataVersions = ((J = V.modDataVersions) == null ? void 0 : J.map(ne => ModDataVersion.fromPartial(ne))) || [],
        X
    }
};
function createBaseUploadExperienceThumbnailRequest() {
    return {
        image: new Uint8Array(0),
        mimeType: ""
    }
}
const UploadExperienceThumbnailRequest = {
    encode(V, X=new BinaryWriter) {
        return V.image.length !== 0 && X.uint32(10).bytes(V.image),
        V.mimeType !== "" && X.uint32(18).string(V.mimeType),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseUploadExperienceThumbnailRequest();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.image = J.bytes();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.mimeType = J.string();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            image: isSet$6(V.image) ? bytesFromBase64(V.image) : new Uint8Array(0),
            mimeType: isSet$6(V.mimeType) ? globalThis.String(V.mimeType) : ""
        }
    },
    toJSON(V) {
        const X = {};
        return V.image.length !== 0 && (X.image = base64FromBytes(V.image)),
        V.mimeType !== "" && (X.mimeType = V.mimeType),
        X
    },
    create(V) {
        return UploadExperienceThumbnailRequest.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseUploadExperienceThumbnailRequest();
        return X.image = V.image ?? new Uint8Array(0),
        X.mimeType = V.mimeType ?? "",
        X
    }
};
function createBaseUploadExperienceThumbnailResponse() {
    return {
        assetId: "",
        url: "",
        verificationUrl: ""
    }
}
const UploadExperienceThumbnailResponse = {
    encode(V, X=new BinaryWriter) {
        return V.assetId !== "" && X.uint32(10).string(V.assetId),
        V.url !== "" && X.uint32(18).string(V.url),
        V.verificationUrl !== "" && X.uint32(26).string(V.verificationUrl),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseUploadExperienceThumbnailResponse();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.assetId = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.url = J.string();
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.verificationUrl = J.string();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            assetId: isSet$6(V.assetId) ? globalThis.String(V.assetId) : "",
            url: isSet$6(V.url) ? globalThis.String(V.url) : "",
            verificationUrl: isSet$6(V.verificationUrl) ? globalThis.String(V.verificationUrl) : ""
        }
    },
    toJSON(V) {
        const X = {};
        return V.assetId !== "" && (X.assetId = V.assetId),
        V.url !== "" && (X.url = V.url),
        V.verificationUrl !== "" && (X.verificationUrl = V.verificationUrl),
        X
    },
    create(V) {
        return UploadExperienceThumbnailResponse.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseUploadExperienceThumbnailResponse();
        return X.assetId = V.assetId ?? "",
        X.url = V.url ?? "",
        X.verificationUrl = V.verificationUrl ?? "",
        X
    }
};
function createBaseGetProgressionTypesRequest() {
    return {}
}
const GetProgressionTypesRequest = {
    encode(V, X=new BinaryWriter) {
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseGetProgressionTypesRequest();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {}
    },
    toJSON(V) {
        return {}
    },
    create(V) {
        return GetProgressionTypesRequest.fromPartial(V ?? {})
    },
    fromPartial(V) {
        return createBaseGetProgressionTypesRequest()
    }
};
function createBaseGetProgressionTypesResponse() {
    return {
        entries: []
    }
}
const GetProgressionTypesResponse = {
    encode(V, X=new BinaryWriter) {
        for (const J of V.entries)
            ProgressionEntry.encode(J, X.uint32(10).fork()).join();
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseGetProgressionTypesResponse();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.entries.push(ProgressionEntry.decode(J, J.uint32()));
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            entries: globalThis.Array.isArray(V == null ? void 0 : V.entries) ? V.entries.map(X => ProgressionEntry.fromJSON(X)) : []
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return (J = V.entries) != null && J.length && (X.entries = V.entries.map(ne => ProgressionEntry.toJSON(ne))),
        X
    },
    create(V) {
        return GetProgressionTypesResponse.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseGetProgressionTypesResponse();
        return X.entries = ((J = V.entries) == null ? void 0 : J.map(ne => ProgressionEntry.fromPartial(ne))) || [],
        X
    }
};
function createBaseGetLicenseRequirementsRequest() {
    return {}
}
const GetLicenseRequirementsRequest = {
    encode(V, X=new BinaryWriter) {
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseGetLicenseRequirementsRequest();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {}
    },
    toJSON(V) {
        return {}
    },
    create(V) {
        return GetLicenseRequirementsRequest.fromPartial(V ?? {})
    },
    fromPartial(V) {
        return createBaseGetLicenseRequirementsRequest()
    }
};
function createBaseGetLicenseRequirementsResponse() {
    return {
        ownedLicenses: [],
        mapEntryRequirements: []
    }
}
const GetLicenseRequirementsResponse = {
    encode(V, X=new BinaryWriter) {
        for (const J of V.ownedLicenses)
            X.uint32(10).string(J);
        for (const J of V.mapEntryRequirements)
            MapEntryRequirement.encode(J, X.uint32(18).fork()).join();
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseGetLicenseRequirementsResponse();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.ownedLicenses.push(J.string());
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.mapEntryRequirements.push(MapEntryRequirement.decode(J, J.uint32()));
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            ownedLicenses: globalThis.Array.isArray(V == null ? void 0 : V.ownedLicenses) ? V.ownedLicenses.map(X => globalThis.String(X)) : [],
            mapEntryRequirements: globalThis.Array.isArray(V == null ? void 0 : V.mapEntryRequirements) ? V.mapEntryRequirements.map(X => MapEntryRequirement.fromJSON(X)) : []
        }
    },
    toJSON(V) {
        var J, ne;
        const X = {};
        return (J = V.ownedLicenses) != null && J.length && (X.ownedLicenses = V.ownedLicenses),
        (ne = V.mapEntryRequirements) != null && ne.length && (X.mapEntryRequirements = V.mapEntryRequirements.map(ue => MapEntryRequirement.toJSON(ue))),
        X
    },
    create(V) {
        return GetLicenseRequirementsResponse.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J, ne;
        const X = createBaseGetLicenseRequirementsResponse();
        return X.ownedLicenses = ((J = V.ownedLicenses) == null ? void 0 : J.map(ue => ue)) || [],
        X.mapEntryRequirements = ((ne = V.mapEntryRequirements) == null ? void 0 : ne.map(ue => MapEntryRequirement.fromPartial(ue))) || [],
        X
    }
};
function createBaseGetAvailableTagsRequest() {
    return {}
}
const GetAvailableTagsRequest = {
    encode(V, X=new BinaryWriter) {
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseGetAvailableTagsRequest();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {}
    },
    toJSON(V) {
        return {}
    },
    create(V) {
        return GetAvailableTagsRequest.fromPartial(V ?? {})
    },
    fromPartial(V) {
        return createBaseGetAvailableTagsRequest()
    }
};
function createBaseGetAvailableTagsResponse() {
    return {
        availableTags: void 0
    }
}
const GetAvailableTagsResponse = {
    encode(V, X=new BinaryWriter) {
        return V.availableTags !== void 0 && AvailableTags.encode(V.availableTags, X.uint32(10).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseGetAvailableTagsResponse();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.availableTags = AvailableTags.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            availableTags: isSet$6(V.availableTags) ? AvailableTags.fromJSON(V.availableTags) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.availableTags !== void 0 && (X.availableTags = AvailableTags.toJSON(V.availableTags)),
        X
    },
    create(V) {
        return GetAvailableTagsResponse.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseGetAvailableTagsResponse();
        return X.availableTags = V.availableTags !== void 0 && V.availableTags !== null ? AvailableTags.fromPartial(V.availableTags) : void 0,
        X
    }
};
function createBaseListExperiencesRequest() {
    return {
        filter: void 0,
        page: void 0
    }
}
const ListExperiencesRequest = {
    encode(V, X=new BinaryWriter) {
        return V.filter !== void 0 && PlayExperienceQuery.encode(V.filter, X.uint32(26).fork()).join(),
        V.page !== void 0 && Pagination.encode(V.page, X.uint32(34).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseListExperiencesRequest();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.filter = PlayExperienceQuery.decode(J, J.uint32());
                    continue
                }
            case 4:
                {
                    if (ce !== 34)
                        break;
                    ue.page = Pagination.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            filter: isSet$6(V.filter) ? PlayExperienceQuery.fromJSON(V.filter) : void 0,
            page: isSet$6(V.page) ? Pagination.fromJSON(V.page) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.filter !== void 0 && (X.filter = PlayExperienceQuery.toJSON(V.filter)),
        V.page !== void 0 && (X.page = Pagination.toJSON(V.page)),
        X
    },
    create(V) {
        return ListExperiencesRequest.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseListExperiencesRequest();
        return X.filter = V.filter !== void 0 && V.filter !== null ? PlayExperienceQuery.fromPartial(V.filter) : void 0,
        X.page = V.page !== void 0 && V.page !== null ? Pagination.fromPartial(V.page) : void 0,
        X
    }
};
function createBaseListExperiencesResponse() {
    return {
        experiences: [],
        nextPage: void 0
    }
}
const ListExperiencesResponse = {
    encode(V, X=new BinaryWriter) {
        for (const J of V.experiences)
            PlayExperience.encode(J, X.uint32(10).fork()).join();
        return V.nextPage !== void 0 && Pagination.encode(V.nextPage, X.uint32(18).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseListExperiencesResponse();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.experiences.push(PlayExperience.decode(J, J.uint32()));
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.nextPage = Pagination.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            experiences: globalThis.Array.isArray(V == null ? void 0 : V.experiences) ? V.experiences.map(X => PlayExperience.fromJSON(X)) : [],
            nextPage: isSet$6(V.nextPage) ? Pagination.fromJSON(V.nextPage) : void 0
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return (J = V.experiences) != null && J.length && (X.experiences = V.experiences.map(ne => PlayExperience.toJSON(ne))),
        V.nextPage !== void 0 && (X.nextPage = Pagination.toJSON(V.nextPage)),
        X
    },
    create(V) {
        return ListExperiencesResponse.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseListExperiencesResponse();
        return X.experiences = ((J = V.experiences) == null ? void 0 : J.map(ne => PlayExperience.fromPartial(ne))) || [],
        X.nextPage = V.nextPage !== void 0 && V.nextPage !== null ? Pagination.fromPartial(V.nextPage) : void 0,
        X
    }
};
function createBaseDeleteAttachmentsRequest() {
    return {
        playElementDesignId: "",
        attachmentIds: []
    }
}
const DeleteAttachmentsRequest = {
    encode(V, X=new BinaryWriter) {
        V.playElementDesignId !== "" && X.uint32(10).string(V.playElementDesignId);
        for (const J of V.attachmentIds)
            X.uint32(18).string(J);
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseDeleteAttachmentsRequest();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.playElementDesignId = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.attachmentIds.push(J.string());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            playElementDesignId: isSet$6(V.playElementDesignId) ? globalThis.String(V.playElementDesignId) : "",
            attachmentIds: globalThis.Array.isArray(V == null ? void 0 : V.attachmentIds) ? V.attachmentIds.map(X => globalThis.String(X)) : []
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return V.playElementDesignId !== "" && (X.playElementDesignId = V.playElementDesignId),
        (J = V.attachmentIds) != null && J.length && (X.attachmentIds = V.attachmentIds),
        X
    },
    create(V) {
        return DeleteAttachmentsRequest.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseDeleteAttachmentsRequest();
        return X.playElementDesignId = V.playElementDesignId ?? "",
        X.attachmentIds = ((J = V.attachmentIds) == null ? void 0 : J.map(ne => ne)) || [],
        X
    }
};
function createBaseDeleteAttachmentsResponse() {
    return {}
}
const DeleteAttachmentsResponse = {
    encode(V, X=new BinaryWriter) {
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseDeleteAttachmentsResponse();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {}
    },
    toJSON(V) {
        return {}
    },
    create(V) {
        return DeleteAttachmentsResponse.fromPartial(V ?? {})
    },
    fromPartial(V) {
        return createBaseDeleteAttachmentsResponse()
    }
};
class WebPlayClientImpl {
    constructor(X) {
        Tt(this, "rpc");
        this.rpc = X,
        this.createPlayElement = this.createPlayElement.bind(this),
        this.getPlayElement = this.getPlayElement.bind(this),
        this.updatePlayElement = this.updatePlayElement.bind(this),
        this.deletePlayElement = this.deletePlayElement.bind(this),
        this.getOwnedPlayElements = this.getOwnedPlayElements.bind(this),
        this.getOwnedPlayElementsV2 = this.getOwnedPlayElementsV2.bind(this),
        this.getBlueprintsById = this.getBlueprintsById.bind(this),
        this.getScheduledBlueprints = this.getScheduledBlueprints.bind(this),
        this.createModDataVersion = this.createModDataVersion.bind(this),
        this.listModDataVersions = this.listModDataVersions.bind(this),
        this.UploadExperienceThumbnail = this.UploadExperienceThumbnail.bind(this),
        this.GetProgressionTypes = this.GetProgressionTypes.bind(this),
        this.GetLicenseRequirements = this.GetLicenseRequirements.bind(this),
        this.GetAvailableTags = this.GetAvailableTags.bind(this),
        this.ListExperiences = this.ListExperiences.bind(this),
        this.DeleteAttachments = this.DeleteAttachments.bind(this)
    }
    createPlayElement(X, J) {
        return this.rpc.unary(WebPlaycreatePlayElementDesc, CreatePlayElementRequest.fromPartial(X), J)
    }
    getPlayElement(X, J) {
        return this.rpc.unary(WebPlaygetPlayElementDesc, GetPlayElementRequest.fromPartial(X), J)
    }
    updatePlayElement(X, J) {
        return this.rpc.unary(WebPlayupdatePlayElementDesc, UpdatePlayElementRequest.fromPartial(X), J)
    }
    deletePlayElement(X, J) {
        return this.rpc.unary(WebPlaydeletePlayElementDesc, DeletePlayElementRequest.fromPartial(X), J)
    }
    getOwnedPlayElements(X, J) {
        return this.rpc.unary(WebPlaygetOwnedPlayElementsDesc, GetOwnedPlayElementsRequest.fromPartial(X), J)
    }
    getOwnedPlayElementsV2(X, J) {
        return this.rpc.unary(WebPlaygetOwnedPlayElementsV2Desc, GetOwnedPlayElementsRequest.fromPartial(X), J)
    }
    getBlueprintsById(X, J) {
        return this.rpc.unary(WebPlaygetBlueprintsByIdDesc, GetBlueprintsByIdRequest.fromPartial(X), J)
    }
    getScheduledBlueprints(X, J) {
        return this.rpc.unary(WebPlaygetScheduledBlueprintsDesc, GetScheduledBlueprintsRequest.fromPartial(X), J)
    }
    createModDataVersion(X, J) {
        return this.rpc.unary(WebPlaycreateModDataVersionDesc, CreateModDataVersionRequest.fromPartial(X), J)
    }
    listModDataVersions(X, J) {
        return this.rpc.unary(WebPlaylistModDataVersionsDesc, ListModDataVersionsRequest.fromPartial(X), J)
    }
    UploadExperienceThumbnail(X, J) {
        return this.rpc.unary(WebPlayUploadExperienceThumbnailDesc, UploadExperienceThumbnailRequest.fromPartial(X), J)
    }
    GetProgressionTypes(X, J) {
        return this.rpc.unary(WebPlayGetProgressionTypesDesc, GetProgressionTypesRequest.fromPartial(X), J)
    }
    GetLicenseRequirements(X, J) {
        return this.rpc.unary(WebPlayGetLicenseRequirementsDesc, GetLicenseRequirementsRequest.fromPartial(X), J)
    }
    GetAvailableTags(X, J) {
        return this.rpc.unary(WebPlayGetAvailableTagsDesc, GetAvailableTagsRequest.fromPartial(X), J)
    }
    ListExperiences(X, J) {
        return this.rpc.unary(WebPlayListExperiencesDesc, ListExperiencesRequest.fromPartial(X), J)
    }
    DeleteAttachments(X, J) {
        return this.rpc.unary(WebPlayDeleteAttachmentsDesc, DeleteAttachmentsRequest.fromPartial(X), J)
    }
}
const WebPlayDesc = {
    serviceName: "santiago.web.play.WebPlay"
}
  , WebPlaycreatePlayElementDesc = {
    methodName: "createPlayElement",
    service: WebPlayDesc,
    requestStream: !1,
    responseStream: !1,
    requestType: {
        serializeBinary() {
            return CreatePlayElementRequest.encode(this).finish()
        }
    },
    responseType: {
        deserializeBinary(V) {
            const X = PlayElementResponse.decode(V);
            return {
                ...X,
                toObject() {
                    return X
                }
            }
        }
    }
}
  , WebPlaygetPlayElementDesc = {
    methodName: "getPlayElement",
    service: WebPlayDesc,
    requestStream: !1,
    responseStream: !1,
    requestType: {
        serializeBinary() {
            return GetPlayElementRequest.encode(this).finish()
        }
    },
    responseType: {
        deserializeBinary(V) {
            const X = PlayElementResponse.decode(V);
            return {
                ...X,
                toObject() {
                    return X
                }
            }
        }
    }
}
  , WebPlayupdatePlayElementDesc = {
    methodName: "updatePlayElement",
    service: WebPlayDesc,
    requestStream: !1,
    responseStream: !1,
    requestType: {
        serializeBinary() {
            return UpdatePlayElementRequest.encode(this).finish()
        }
    },
    responseType: {
        deserializeBinary(V) {
            const X = PlayElementResponse.decode(V);
            return {
                ...X,
                toObject() {
                    return X
                }
            }
        }
    }
}
  , WebPlaydeletePlayElementDesc = {
    methodName: "deletePlayElement",
    service: WebPlayDesc,
    requestStream: !1,
    responseStream: !1,
    requestType: {
        serializeBinary() {
            return DeletePlayElementRequest.encode(this).finish()
        }
    },
    responseType: {
        deserializeBinary(V) {
            const X = DeletePlayElementResponse.decode(V);
            return {
                ...X,
                toObject() {
                    return X
                }
            }
        }
    }
}
  , WebPlaygetOwnedPlayElementsDesc = {
    methodName: "getOwnedPlayElements",
    service: WebPlayDesc,
    requestStream: !1,
    responseStream: !1,
    requestType: {
        serializeBinary() {
            return GetOwnedPlayElementsRequest.encode(this).finish()
        }
    },
    responseType: {
        deserializeBinary(V) {
            const X = GetOwnedPlayElementsResponse.decode(V);
            return {
                ...X,
                toObject() {
                    return X
                }
            }
        }
    }
}
  , WebPlaygetOwnedPlayElementsV2Desc = {
    methodName: "getOwnedPlayElementsV2",
    service: WebPlayDesc,
    requestStream: !1,
    responseStream: !1,
    requestType: {
        serializeBinary() {
            return GetOwnedPlayElementsRequest.encode(this).finish()
        }
    },
    responseType: {
        deserializeBinary(V) {
            const X = GetOwnedPlayElementsResponseV2.decode(V);
            return {
                ...X,
                toObject() {
                    return X
                }
            }
        }
    }
}
  , WebPlaygetBlueprintsByIdDesc = {
    methodName: "getBlueprintsById",
    service: WebPlayDesc,
    requestStream: !1,
    responseStream: !1,
    requestType: {
        serializeBinary() {
            return GetBlueprintsByIdRequest.encode(this).finish()
        }
    },
    responseType: {
        deserializeBinary(V) {
            const X = GetBlueprintsByIdResponse.decode(V);
            return {
                ...X,
                toObject() {
                    return X
                }
            }
        }
    }
}
  , WebPlaygetScheduledBlueprintsDesc = {
    methodName: "getScheduledBlueprints",
    service: WebPlayDesc,
    requestStream: !1,
    responseStream: !1,
    requestType: {
        serializeBinary() {
            return GetScheduledBlueprintsRequest.encode(this).finish()
        }
    },
    responseType: {
        deserializeBinary(V) {
            const X = GetScheduledBlueprintsResponse.decode(V);
            return {
                ...X,
                toObject() {
                    return X
                }
            }
        }
    }
}
  , WebPlaycreateModDataVersionDesc = {
    methodName: "createModDataVersion",
    service: WebPlayDesc,
    requestStream: !1,
    responseStream: !1,
    requestType: {
        serializeBinary() {
            return CreateModDataVersionRequest.encode(this).finish()
        }
    },
    responseType: {
        deserializeBinary(V) {
            const X = CreateModDataVersionResponse.decode(V);
            return {
                ...X,
                toObject() {
                    return X
                }
            }
        }
    }
}
  , WebPlaylistModDataVersionsDesc = {
    methodName: "listModDataVersions",
    service: WebPlayDesc,
    requestStream: !1,
    responseStream: !1,
    requestType: {
        serializeBinary() {
            return ListModDataVersionsRequest.encode(this).finish()
        }
    },
    responseType: {
        deserializeBinary(V) {
            const X = ListModDataVersionsResponse.decode(V);
            return {
                ...X,
                toObject() {
                    return X
                }
            }
        }
    }
}
  , WebPlayUploadExperienceThumbnailDesc = {
    methodName: "UploadExperienceThumbnail",
    service: WebPlayDesc,
    requestStream: !1,
    responseStream: !1,
    requestType: {
        serializeBinary() {
            return UploadExperienceThumbnailRequest.encode(this).finish()
        }
    },
    responseType: {
        deserializeBinary(V) {
            const X = UploadExperienceThumbnailResponse.decode(V);
            return {
                ...X,
                toObject() {
                    return X
                }
            }
        }
    }
}
  , WebPlayGetProgressionTypesDesc = {
    methodName: "GetProgressionTypes",
    service: WebPlayDesc,
    requestStream: !1,
    responseStream: !1,
    requestType: {
        serializeBinary() {
            return GetProgressionTypesRequest.encode(this).finish()
        }
    },
    responseType: {
        deserializeBinary(V) {
            const X = GetProgressionTypesResponse.decode(V);
            return {
                ...X,
                toObject() {
                    return X
                }
            }
        }
    }
}
  , WebPlayGetLicenseRequirementsDesc = {
    methodName: "GetLicenseRequirements",
    service: WebPlayDesc,
    requestStream: !1,
    responseStream: !1,
    requestType: {
        serializeBinary() {
            return GetLicenseRequirementsRequest.encode(this).finish()
        }
    },
    responseType: {
        deserializeBinary(V) {
            const X = GetLicenseRequirementsResponse.decode(V);
            return {
                ...X,
                toObject() {
                    return X
                }
            }
        }
    }
}
  , WebPlayGetAvailableTagsDesc = {
    methodName: "GetAvailableTags",
    service: WebPlayDesc,
    requestStream: !1,
    responseStream: !1,
    requestType: {
        serializeBinary() {
            return GetAvailableTagsRequest.encode(this).finish()
        }
    },
    responseType: {
        deserializeBinary(V) {
            const X = GetAvailableTagsResponse.decode(V);
            return {
                ...X,
                toObject() {
                    return X
                }
            }
        }
    }
}
  , WebPlayListExperiencesDesc = {
    methodName: "ListExperiences",
    service: WebPlayDesc,
    requestStream: !1,
    responseStream: !1,
    requestType: {
        serializeBinary() {
            return ListExperiencesRequest.encode(this).finish()
        }
    },
    responseType: {
        deserializeBinary(V) {
            const X = ListExperiencesResponse.decode(V);
            return {
                ...X,
                toObject() {
                    return X
                }
            }
        }
    }
}
  , WebPlayDeleteAttachmentsDesc = {
    methodName: "DeleteAttachments",
    service: WebPlayDesc,
    requestStream: !1,
    responseStream: !1,
    requestType: {
        serializeBinary() {
            return DeleteAttachmentsRequest.encode(this).finish()
        }
    },
    responseType: {
        deserializeBinary(V) {
            const X = DeleteAttachmentsResponse.decode(V);
            return {
                ...X,
                toObject() {
                    return X
                }
            }
        }
    }
};
function bytesFromBase64(V) {
    if (globalThis.Buffer)
        return Uint8Array.from(globalThis.Buffer.from(V, "base64"));
    {
        const X = globalThis.atob(V)
          , J = new Uint8Array(X.length);
        for (let ne = 0; ne < X.length; ++ne)
            J[ne] = X.charCodeAt(ne);
        return J
    }
}
function base64FromBytes(V) {
    if (globalThis.Buffer)
        return globalThis.Buffer.from(V).toString("base64");
    {
        const X = [];
        return V.forEach(J => {
            X.push(globalThis.String.fromCharCode(J))
        }
        ),
        globalThis.btoa(X.join(""))
    }
}
function toTimestamp$1(V) {
    const X = Math.trunc(V.getTime() / 1e3)
      , J = V.getTime() % 1e3 * 1e6;
    return {
        seconds: X,
        nanos: J
    }
}
function fromTimestamp$1(V) {
    let X = (V.seconds || 0) * 1e3;
    return X += (V.nanos || 0) / 1e6,
    new globalThis.Date(X)
}
function fromJsonTimestamp$1(V) {
    return V instanceof globalThis.Date ? V : typeof V == "string" ? new globalThis.Date(V) : fromTimestamp$1(Timestamp.fromJSON(V))
}
function isSet$6(V) {
    return V != null
}
var MUTATOR_UI_NAMES = (V => (V.NUMBER = "number",
V.SELECT = "select",
V.DISTRIBUTION = "distribution",
V.BOOL = "bool",
V))(MUTATOR_UI_NAMES || {})
  , MUTATOR_KIND_NAME = (V => (V.MUTATOR_BOOLEAN = "mutatorBoolean",
V.MUTATOR_FLOAT = "mutatorFloatValues",
V.MUTATOR_INT = "mutatorIntValues",
V.MUTATOR_SPARSE_BOOLEAN = "mutatorSparseBoolean",
V.MUTATOR_SPARSE_FLOAT = "mutatorSparseFloatValues",
V.MUTATOR_SPARSE_INT = "mutatorSparseIntValues",
V.MUTATOR_STRING = "mutatorString",
V))(MUTATOR_KIND_NAME || {});
const mutatorKindNameMapping = new Map([["mutatorBoolean", "mutatorBoolean"], ["mutatorString", "mutatorString"], ["mutatorFloatValues", "mutatorFloat"], ["mutatorIntValues", "mutatorInt"], ["mutatorSparseBoolean", "mutatorSparseBoolean"], ["mutatorSparseIntValues", "mutatorSparseInt"], ["mutatorSparseFloatValues", "mutatorSparseFloat"]]);
var BUTTON_TYPES = (V => (V.SUBMIT = "submit",
V.BUTTON = "button",
V.RESET = "reset",
V))(BUTTON_TYPES || {});
/*! js-cookie v3.0.5 | MIT */
function assign$1(V) {
    for (var X = 1; X < arguments.length; X++) {
        var J = arguments[X];
        for (var ne in J)
            V[ne] = J[ne]
    }
    return V
}
var defaultConverter = {
    read: function(V) {
        return V[0] === '"' && (V = V.slice(1, -1)),
        V.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent)
    },
    write: function(V) {
        return encodeURIComponent(V).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g, decodeURIComponent)
    }
};
function init$2(V, X) {
    function J(ue, ce, me) {
        if (!(typeof document > "u")) {
            me = assign$1({}, X, me),
            typeof me.expires == "number" && (me.expires = new Date(Date.now() + me.expires * 864e5)),
            me.expires && (me.expires = me.expires.toUTCString()),
            ue = encodeURIComponent(ue).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
            var ge = "";
            for (var Te in me)
                me[Te] && (ge += "; " + Te,
                me[Te] !== !0 && (ge += "=" + me[Te].split(";")[0]));
            return document.cookie = ue + "=" + V.write(ce, ue) + ge
        }
    }
    function ne(ue) {
        if (!(typeof document > "u" || arguments.length && !ue)) {
            for (var ce = document.cookie ? document.cookie.split("; ") : [], me = {}, ge = 0; ge < ce.length; ge++) {
                var Te = ce[ge].split("=")
                  , _e = Te.slice(1).join("=");
                try {
                    var Se = decodeURIComponent(Te[0]);
                    if (me[Se] = V.read(_e, Se),
                    ue === Se)
                        break
                } catch {}
            }
            return ue ? me[ue] : me
        }
    }
    return Object.create({
        set: J,
        get: ne,
        remove: function(ue, ce) {
            J(ue, "", assign$1({}, ce, {
                expires: -1
            }))
        },
        withAttributes: function(ue) {
            return init$2(this.converter, assign$1({}, this.attributes, ue))
        },
        withConverter: function(ue) {
            return init$2(assign$1({}, this.converter, ue), this.attributes)
        }
    }, {
        attributes: {
            value: Object.freeze(X)
        },
        converter: {
            value: Object.freeze(V)
        }
    })
}
var api = init$2(defaultConverter, {
    path: "/"
});
const distributeEvenly = (V, X) => {
    const J = Array.from({
        length: X
    }).fill(0)
      , ne = Math.floor(V / X)
      , ue = V % X
      , ce = J.map( () => ne);
    return Array.from({
        length: ue
    }).forEach( (me, ge) => {
        ce[ge] += 1
    }
    ),
    ce
}
  , getNumbersFromEndOfString = V => {
    const X = V.match(/(\d+)$/);
    return X ? X[0] : null
}
  , sanitizeFilename = V => V.replaceAll(/[<>:"/\\|?*\x00-\x1F\]\[]/g, "").replaceAll(" ", "_").toLowerCase()
  , getNewTeamDistribution = (V, X, J) => new Map(distributeEvenly(V, X).map( (ne, ue) => [ue + 1, {
    humanCapacity: ne,
    aiCapacity: 0,
    aiType: J
}]))
  , getCurrentArrivalPatchVersion = () => {}
  , getDefaultExperienceTitle = V => DEFAULT_EXPERIENCE_TITLES_BY_MODE[V] ?? FALLBACK_DEFAULT_EXPERIENCE_TITLE
  , compareMaps = (V, X, J) => {
    const ne = new Set(V.keys())
      , ue = new Set(X.keys())
      , ce = Array.from(ne).filter(me => ue.has(me));
    return V.size === X.size && ce.length === V.size && ce.every(me => V.get(me) === X.get(me))
}
  , getTruncatedFilename = (V, X) => {
    const J = V.split(".")
      , ne = J[J.length - 1];
    return V.length - ne.length < X ? V : `${V.substring(0, X)}(...).${ne}`
}
  , logger$i = Logger$1.get("blueprint", "util")
  , tagNameToMutatorName = V => `VehicleLimit_Asset_${V.slice(VEHICLE_ASSET_TAG_PREFIX.length)}_PerTeam`
  , findAllNestedChildren = ({tagIds: V, availableAssetCategories: X, immediateParent: J, useRootTags: ne, allCategoriesMap: ue=new Map}) => {
    const ce = ne ? X == null ? void 0 : X.rootTags : X == null ? void 0 : X.tags
      , me = common_utils.enumToArray(RESTRICTION_PAGE_CATEGORY).flatMap(Te => {
        var _e;
        return (_e = X == null ? void 0 : X.rootTags.find(Se => Se.tagId === Te)) == null ? void 0 : _e.childrenTags
    }
    ).filter(Te => Te !== void 0);
    return [V.reduce( (Te, _e) => {
        var ze;
        const {childrenTags: Se=[], name: Ie, metadata: ye, tagId: $e} = ce.find( ({tagId: qe}) => qe === _e) ?? {}
          , Ne = ((ye == null ? void 0 : ye.resources) ?? []).reduce( (qe, {kind: Ze, location: et}) => (Ze === "lic" ? qe.isProgressionLocked = !0 : Ze === "image" && !qe.image || Ze === "webImage" ? qe.image = getBattleBinaryUrl((et == null ? void 0 : et.url) ?? "") : Ze === "svgImage" && (et != null && et.url) ? qe.icon = getBattleBinaryUrl(et.url) : Ze === "webImageMed" && (et != null && et.url) ? qe.webImageMedium = getBattleBinaryUrl(et.url) : Ze === "webImageSmall" && (et != null && et.url) && (qe.webImageSmall = getBattleBinaryUrl(et.url)),
        qe), {
            image: "",
            webImageSmall: "",
            webImageMedium: "",
            isProgressionLocked: !1
        })
          , ve = Ie == null ? void 0 : Ie.substring(0, Ie == null ? void 0 : Ie.indexOf(" - "))
          , ke = X.tags.find(qe => qe.name === ve)
          , xe = (ye && getTranslationIdFromMetadata(ye, ASSET_TAG_TRANSLATION_KIND.NAME)) ?? ""
          , we = ye && getTranslationIdFromMetadata(ye, ASSET_TAG_TRANSLATION_KIND.DESCRIPTION)
          , Fe = ke && ((ze = ke.metadata) == null ? void 0 : ze.translations[0].translationId);
        if (!$e || !Ie)
            return Te;
        J && ue.set(_e, new Set([...Array.from(ue.get(_e) ?? []), J]));
        const je = Se.length && (Se.length > 1 || Se.length === 1 && ce.some( ({tagId: qe}) => qe === Se[0]))
          , Xe = Array.from(ue.get(_e) ?? []).filter(qe => me.includes(qe) || je);
        if (je) {
            _e in Te.categories ? Te.categories[_e].parentCategories = Xe : Te.categories[_e] = {
                name: Ie,
                parentCategories: [...Xe],
                translationIds: {
                    name: xe,
                    description: we
                },
                ...Ne,
                childrenTags: Se
            };
            const qe = findAllNestedChildren({
                tagIds: Se,
                availableAssetCategories: X,
                immediateParent: _e,
                allCategoriesMap: ue
            });
            ue = new Map([...ue, ...qe[1]]),
            Te.categories[_e].leafTags = Object.keys(qe[0].tags),
            Te.tags = {
                ...Te.tags,
                ...qe[0].tags
            },
            Te.categories = {
                ...Te.categories,
                ...qe[0].categories
            }
        } else
            Te.tags[_e] = {
                name: Ie,
                parentCategories: [...Xe],
                translationIds: {
                    name: xe,
                    model: Fe,
                    description: we
                },
                ...Ne
            };
        return Te
    }
    , {
        tags: {},
        categories: {}
    }), ue]
}
  , getMapMetaData = V => V.reduce( (X, {kind: J, location: ne}) => {
    if (J === "custom" && ne && ne.url) {
        const ue = decodeURIComponent(ne.url)
          , ce = new URLSearchParams(ue);
        X.push({
            image: ce.get("webImage") ?? void 0,
            mapSize: ce.get("mapSize") ?? void 0,
            title: ce.get("title") ?? void 0
        })
    }
    return X
}
, [])
  , getRawKindData = V => {
    const X = V ? Object.entries(V).find(ue => ue[1] !== void 0) : void 0;
    if (X === void 0)
        return {};
    const [J,ne] = X;
    return {
        kind: J,
        kindValue: ne
    }
}
  , getMutatorValues = (V, X) => V.reduce( (J, {kind: ne, name: ue}) => {
    if (!ne)
        return J;
    const {kind: ce, kindValue: me} = getRawKindData(ne)
      , ge = ce === mutatorKindNameMapping.get(MUTATOR_KIND_NAME.MUTATOR_FLOAT) || ce === mutatorKindNameMapping.get(MUTATOR_KIND_NAME.MUTATOR_SPARSE_FLOAT);
    if (!me)
        return J;
    if ("value"in me)
        J[ue] = ge && typeof me.value == "number" ? roundFloatFromAPI(me.value) : me.value;
    else if ("defaultValue"in me) {
        const Te = me.sparseValues.length ? new Map(Array.from({
            length: X
        }).map( (_e, Se) => {
            var ye;
            const Ie = (ye = me.sparseValues.find($e => $e.index - 1 === Se)) == null ? void 0 : ye.value;
            return [Se, Ie ?? me.defaultValue]
        }
        )) : me.defaultValue;
        J[ue] = ge && typeof Te == "number" ? roundFloatFromAPI(Te) : Te
    }
    return J
}
, {})
  , getMutatorKindData = (V, X) => {
    var ce, me, ge;
    const {kind: J, kindValue: ne} = getRawKindData(V)
      , ue = X.slice(-1 * PER_TEAM_IDENTIFIER.length) === PER_TEAM_IDENTIFIER;
    if (!(!ne || !J || J === MUTATOR_KIND_NAME.MUTATOR_STRING)) {
        if ("availableValues"in ne && "mutator"in ne && ne.mutator) {
            const Te = (ce = ne.availableValues) == null ? void 0 : ce.range
              , _e = (ge = (me = ne.availableValues) == null ? void 0 : me.sparseValues) == null ? void 0 : ge.values
              , Se = J === MUTATOR_KIND_NAME.MUTATOR_FLOAT || J === MUTATOR_KIND_NAME.MUTATOR_SPARSE_FLOAT
              , Ie = "defaultValue"in ne.mutator ? ne.mutator.defaultValue : ne.mutator.value
              , ye = Te ? MUTATOR_UI_NAMES.NUMBER : MUTATOR_UI_NAMES.SELECT;
            if (ye === MUTATOR_UI_NAMES.NUMBER && Te)
                return {
                    isPerTeam: ue,
                    defaultValue: Ie,
                    mutatorUi: ye,
                    step: Se ? .1 : 1,
                    range: {
                        min: common_utils.roundToPrecision(Te.minValue, 1) ?? 0,
                        max: common_utils.roundToPrecision(Te.maxValue ?? 0, 1)
                    }
                };
            if (ye === MUTATOR_UI_NAMES.SELECT)
                return {
                    isPerTeam: ue,
                    defaultValue: Ie,
                    mutatorUi: ye,
                    ..._e && {
                        availableValues: _e
                    }
                }
        } else {
            const Te = "defaultValue"in ne ? ne.defaultValue : "value"in ne ? ne.value : void 0;
            if (Te !== void 0)
                return {
                    isPerTeam: ue,
                    mutatorUi: MUTATOR_UI_NAMES.BOOL,
                    defaultValue: Te
                }
        }
        logger$i.warn(`Mutator "${X}" did not match any of the criteria and was not included`)
    }
}
  , getMutatorsByCategories = (V, X) => Object.entries(V).reduce( (J, [ne,ue]) => {
    const {tags: ce} = ue;
    return X.some(me => ce.includes(me)) && (J[ne] = ue),
    J
}
, {})
  , getWebGameModeData = ({name: V, id: X, gameSize: J, allowedTeamsRange: ne}) => {
    var Te, _e, Se, Ie;
    const {availableValues: ue, defaultValue: ce=DEFAULT_GAME_SIZE} = J ?? {}
      , me = {
        min: DEFAULT_GAME_SIZE_MIN,
        max: DEFAULT_GAME_SIZE_MAX
    };
    let ge = !1;
    if (ue && "range"in ue && ue.range)
        me.min = ue.range.minValue,
        me.max = ue.range.maxValue;
    else if (ue && "sparseValues"in ue && ue.sparseValues) {
        const {values: ye} = ue.sparseValues;
        me.min = ye[0],
        me.max = ye[ye.length - 1],
        ge = !0
    }
    return {
        id: X,
        name: V,
        teamRange: {
            min: ((_e = (Te = ne == null ? void 0 : ne.availableValues) == null ? void 0 : Te.range) == null ? void 0 : _e.minValue) ?? DEFAULT_MIN_TEAM_COUNT,
            max: ((Ie = (Se = ne == null ? void 0 : ne.availableValues) == null ? void 0 : Se.range) == null ? void 0 : Ie.maxValue) ?? DEFAULT_MAX_TEAM_COUNT,
            defaultValue: (ne == null ? void 0 : ne.defaultValue) ?? DEFAULT_TEAM_COUNT
        },
        playerSize: {
            evenOnly: ge,
            range: me,
            defaultValue: ce
        }
    }
}
  , formatToWebBlueprint = V => {
    var ne, ue, ce, me, ge, Te, _e;
    const X = ((ne = V.availableGameData) == null ? void 0 : ne.maps.reduce( (Se, {levelLocation: Ie, gameSize: ye, allowedTeamsRange: $e}) => {
        const Ne = Ie.replace(/\d+$/, "")
          , ve = getWebGameModeData({
            id: Ne,
            name: Ne,
            allowedTeamsRange: $e,
            gameSize: ye
        });
        return Se.some(ke => ke.name === Ne) || Se.push(ve),
        Se
    }
    , [])) ?? []
      , {availableThumbnailUrls: J} = V;
    return {
        constraints: {
            maxNameSize: FALLBACK_EXPERIENCE_NAME_MAX_LENGTH,
            maxDescriptionSize: FALLBACK_EXPERIENCE_DESCRIPTION_MAX_LENGTH,
            maxSecretSize: 512,
            maxMapsInRotation: 32,
            maxMutators: 256,
            maxConfigNameSize: 128,
            maxConfigDescriptionSize: 256
        },
        availableThumbnailUrls: (J == null ? void 0 : J.reduce( (Se, Ie) => (Se[Ie] = getBattleBinaryUrl(Ie),
        Se), {})) ?? {},
        maps: ((ce = (ue = V.availableGameData) == null ? void 0 : ue.maps) == null ? void 0 : ce.reduce( (Se, Ie) => {
            var $e;
            const ye = getMapMetaData((($e = Ie.metadata) == null ? void 0 : $e.resources) ?? []);
            return ye == null || ye.forEach( ({mapSize: Ne="", title: ve=""}) => {
                var je, Xe, ze, qe, Ze, et;
                const ke = ((ze = (Xe = (je = Ie.metadata) == null ? void 0 : je.resources.find( ({kind: it}) => it === "webImage")) == null ? void 0 : Xe.location) == null ? void 0 : ze.url) ?? ""
                  , xe = ((et = (Ze = (qe = Ie.metadata) == null ? void 0 : qe.resources.find( ({kind: it}) => it === "image")) == null ? void 0 : Ze.location) == null ? void 0 : et.url) ?? ""
                  , we = getBattleBinaryUrl(ke ?? xe)
                  , Fe = getGameModeFromLevelLocation(Ie.levelLocation);
                Se.push({
                    image: we,
                    mapSize: Ne,
                    title: ve,
                    levelLocation: Ie.levelLocation,
                    gameMode: Fe,
                    levelName: Ie.levelName
                })
            }
            ),
            Se
        }
        , [])) ?? [],
        gameModes: X,
        assetTags: (me = V.availableGameData) != null && me.assetCategories ? findAllNestedChildren({
            tagIds: V.availableGameData.assetCategories.rootTags.map( ({tagId: Se}) => Se),
            availableAssetCategories: V.availableGameData.assetCategories,
            useRootTags: !0
        })[0] : {
            tags: {},
            categories: {}
        },
        mutators: ((ge = V.availableGameData) == null ? void 0 : ge.mutators.reduce( (Se, {name: Ie, kind: ye, category: $e, metadata: Ne}) => {
            var it, at;
            let ve;
            const {translations: ke=[], resources: xe=[]} = Ne ?? {}
              , we = (at = (it = xe.find( ({kind: rt}) => rt === RESOURCE_KIND.CHILD_MUTATOR_KIND)) == null ? void 0 : it.location) == null ? void 0 : at.url
              , Fe = getResourceMetadata(xe, RESOURCE_KIND.DISPLAY_FORMAT_KIND)
              , je = getResourceMetadata(xe, RESOURCE_KIND.FORCE_SAVE_KIND) === "true" || HARDCODED_FORCE_SAVE_MUTATOR_IDS.includes(Ie)
              , Xe = doesResourceKindExist(xe, RESOURCE_KIND.INTERNAL)
              , ze = getResourceMetadata(xe, RESOURCE_KIND.DISPLAY_PRIORITY)
              , qe = getResourceMetadata(xe, RESOURCE_KIND.CATEGORY)
              , Ze = Array.from(new URLSearchParams(we)).reduce( (rt, [ft,St]) => {
                var Ye;
                if (ft === RESOURCE_KIND.PARENT_ACTIVE_VALUE)
                    ve = convertStringToType(St);
                else if ((Ye = V.availableGameData) == null ? void 0 : Ye.mutators.find(nt => nt.name === ft)) {
                    const nt = convertStringToType(St);
                    rt.push({
                        name: ft,
                        lockToValue: nt
                    })
                }
                return rt
            }
            , []) ?? []
              , et = $e.split(",");
            if (ye) {
                const rt = getMutatorKindData(ye, Ie);
                let ft;
                if ((rt == null ? void 0 : rt.mutatorUi) === MUTATOR_UI_NAMES.NUMBER)
                    switch (Fe) {
                    case "minutes":
                        ft = RANGE_MUTATOR_DISPLAY_FORMAT.MINUTES;
                        break;
                    case "seconds":
                        ft = RANGE_MUTATOR_DISPLAY_FORMAT.SECONDS;
                        break;
                    case "percent":
                        ft = RANGE_MUTATOR_DISPLAY_FORMAT.PERCENT;
                        break
                    }
                const St = ke.reduce( (Ye, {kind: We, translationId: nt}) => {
                    var Et, Ke;
                    const ct = MUTATOR_TRANSLATION_KIND_ID_MAP.get(We);
                    if (ct)
                        Ye[ct] = nt;
                    else if (We.includes("Value")) {
                        const mt = (Et = We.match(/Value\s(-?\d+)/)) == null ? void 0 : Et[1];
                        mt && ((Ke = rt == null ? void 0 : rt.availableValues) != null && Ke.includes(Number(mt))) && ("options"in Ye && Ye.options ? Ye.options.set(mt, nt) : Ye.options = new Map([[mt, nt]]))
                    }
                    return Ye
                }
                , {
                    name: ""
                });
                rt && (Se[Ie] = {
                    ...rt,
                    tags: et,
                    translationIds: St,
                    ...qe && {
                        category: qe
                    },
                    ...je && {
                        isForceSave: je
                    },
                    ...ze !== void 0 && !isNaN(Number(ze)) && {
                        displayPriority: Number(ze)
                    },
                    ...ft && {
                        displayFormat: ft
                    },
                    ...Xe && {
                        isInternal: Xe
                    },
                    ...ve !== void 0 && {
                        parentActiveValue: ve
                    },
                    ...Ze.length && {
                        childMutators: Ze
                    }
                })
            }
            return Se
        }
        , {})) ?? {},
        blocklyDefinitions: getBlocklyDefinitions(V),
        rulesVersion: ((_e = (Te = V == null ? void 0 : V.availableGameData) == null ? void 0 : Te.modRules) == null ? void 0 : _e.rulesVersion) ?? 0
    }
}
  , getRawBlocklyDefinitions = V => {
    var J, ne;
    const X = new TextDecoder;
    return (ne = (J = V == null ? void 0 : V.availableGameData) == null ? void 0 : J.modRules) != null && ne.modBuilder ? JSON.parse(X.decode(V.availableGameData.modRules.modBuilder)) : void 0
}
  , getBlocklyDefinitions = V => {
    var _e, Se, Ie, ye, $e, Ne, ve, ke, xe, we, Fe, je, Xe, ze;
    const X = new TextDecoder
      , J = (Se = (_e = V == null ? void 0 : V.availableGameData) == null ? void 0 : _e.mutators) == null ? void 0 : Se.find(qe => qe.name === "ModBuilder_MaxGlobalVariableCount")
      , ne = (ye = (Ie = V == null ? void 0 : V.availableGameData) == null ? void 0 : Ie.mutators) == null ? void 0 : ye.find(qe => qe.name === "ModBuilder_MaxObjectVariableCount")
      , ue = (ke = (ve = (Ne = ($e = J == null ? void 0 : J.kind) == null ? void 0 : $e.mutatorIntValues) == null ? void 0 : Ne.availableValues) == null ? void 0 : ve.range) == null ? void 0 : ke.maxValue
      , ce = (je = (Fe = (we = (xe = ne == null ? void 0 : ne.kind) == null ? void 0 : xe.mutatorIntValues) == null ? void 0 : we.availableValues) == null ? void 0 : Fe.range) == null ? void 0 : je.maxValue
      , me = {
        maxDepth: 64,
        maxGlobalVariables: ue ?? 16,
        maxObjectVariables: ce ?? 16
    }
      , ge = (ze = (Xe = V == null ? void 0 : V.availableGameData) == null ? void 0 : Xe.modRules) != null && ze.modBuilder ? JSON.parse(X.decode(V.availableGameData.modRules.modBuilder)) : {};
    return {
        ...Object.entries(ge).reduce( (qe, [Ze,et]) => ({
            ...qe,
            [Ze]: et.filter(it => !!it.name)
        }), {
            actions: [],
            controlActions: [],
            events: [],
            objects: [],
            selectionLists: [],
            types: [],
            values: [],
            constraints: {
                maxDepth: 0,
                maxGlobalVariables: 0,
                maxObjectVariables: 0
            }
        }),
        constraints: me
    }
}
  , extractAllSIDs = V => {
    var ne, ue, ce, me, ge, Te, _e, Se, Ie, ye, $e;
    const X = new Set
      , J = getBlocklyDefinitions(V);
    return (ce = (ue = (ne = V == null ? void 0 : V.availableGameData) == null ? void 0 : ne.assetCategories) == null ? void 0 : ue.tags) == null || ce.forEach(Ne => {
        var ve, ke;
        (ke = (ve = Ne.metadata) == null ? void 0 : ve.translations) == null || ke.forEach(xe => xe.translationId && X.add(xe.translationId))
    }
    ),
    (me = V == null ? void 0 : V.availableTags) == null || me.tags.forEach(Ne => {
        var ve;
        (ve = Ne.metadata) == null || ve.translations.forEach(ke => ke.translationId && X.add(ke.translationId))
    }
    ),
    (Te = (ge = V == null ? void 0 : V.availableGameData) == null ? void 0 : ge.maps) == null || Te.forEach(Ne => {
        var ve, ke;
        (ke = (ve = Ne.metadata) == null ? void 0 : ve.resources) == null || ke.forEach(xe => {
            var we;
            if (xe.kind === "custom") {
                const Fe = new URLSearchParams(((we = xe.location) == null ? void 0 : we.url) ?? "").get("title");
                Fe && X.add(Fe)
            }
        }
        )
    }
    ),
    (Se = (_e = V == null ? void 0 : V.availableGameData) == null ? void 0 : _e.mutators) == null || Se.forEach(Ne => {
        var ve, ke;
        (ke = (ve = Ne.metadata) == null ? void 0 : ve.translations) == null || ke.forEach(xe => xe.translationId && X.add(xe.translationId))
    }
    ),
    ($e = (ye = (Ie = V == null ? void 0 : V.availableGameData) == null ? void 0 : Ie.assetCategories) == null ? void 0 : ye.tags) == null || $e.forEach(Ne => {
        var ve, ke;
        (ke = (ve = Ne.metadata) == null ? void 0 : ve.translations) == null || ke.forEach(xe => xe.translationId && X.add(xe.translationId))
    }
    ),
    [...J.actions, ...J.values, ...J.objects, ...J.events].forEach(Ne => {
        Ne.displayNameSID && X.add(Ne.displayNameSID)
    }
    ),
    J.selectionLists.forEach(Ne => {
        Ne.displayNameSID && X.add(Ne.displayNameSID),
        Ne.selectionValues.forEach(ve => {
            ve.displayNameSID && X.add(ve.displayNameSID)
        }
        )
    }
    ),
    X
}
  , getSelectionTabulations = (V, X, J, ne, ue) => V.reduce( (ce, me) => {
    const ge = ue && ue.get(me);
    if (ue === void 0 && (!(me in X) || getAssetTagValue(X[me], ne)) || ge) {
        const Te = J[me];
        ce.selectedIds.add(me),
        Te.isProgressionLocked || (ce.totalSelectedAndUnlocked += 1)
    }
    return ce
}
, {
    selectedIds: new Set,
    totalSelectedAndUnlocked: 0
})
  , getTagDisabledState = (V, X, J, ne) => ({
    isLastUnlocked: X === 1 && !J && ne.size > 1 && ne.has(V),
    isAllUnselected: X === 0 && J
})
  , getSubCategory = ({mainCategory: V, allCategories: X, itemCategoryIds: J}) => J.find(ne => {
    var ue, ce;
    return (ce = (ue = X[V]) == null ? void 0 : ue.childrenTags) == null ? void 0 : ce.includes(ne)
}
)
  , getTranslationIdFromMetadata = (V, X) => {
    var J;
    return (J = V == null ? void 0 : V.translations.find(ne => ne.kind === X)) == null ? void 0 : J.translationId
}
  , getRawMapData = (V, X, J) => J.find(ne => V === ne.levelLocation && X === ne.levelName)
  , buildMutatorKindFromAvailableMutator = ({mutatorKindName: V, value: X, rawMutator: J, fallbackValue: ne, size: ue}) => {
    var ge, Te;
    const ce = MutatorKind.fromPartial({})
      , me = mutatorKindNameMapping.get(V);
    if (me && me in ce)
        switch (V) {
        case MUTATOR_KIND_NAME.MUTATOR_BOOLEAN:
        case MUTATOR_KIND_NAME.MUTATOR_INT:
        case MUTATOR_KIND_NAME.MUTATOR_FLOAT:
        case MUTATOR_KIND_NAME.MUTATOR_STRING:
            !(X instanceof Map) && X !== void 0 && (ce[me] = {
                value: X
            });
            break;
        case MUTATOR_KIND_NAME.MUTATOR_SPARSE_INT:
        case MUTATOR_KIND_NAME.MUTATOR_SPARSE_FLOAT:
        case MUTATOR_KIND_NAME.MUTATOR_SPARSE_BOOLEAN:
            {
                const _e = (ge = J == null ? void 0 : J.kind) == null ? void 0 : ge[V];
                if (_e) {
                    let Se = getMutatorValue(X, ne, 0);
                    const Ie = ("mutator"in _e ? (Te = _e.mutator) == null ? void 0 : Te.size : "size"in _e ? _e.size : 0) ?? 0
                      , ye = mutatorValueToSparseValues(X, ue ?? Ie, Se);
                    Array.isArray(ye) || (Se = ye),
                    ce[me] = {
                        defaultValue: Se,
                        size: ue ?? Ie,
                        sparseValues: Array.isArray(ye) ? ye : []
                    }
                }
                break
            }
        default:
            logger$i.warn(`Mutator type "${V}" is unrecognized!`)
        }
    else
        logger$i.warn(`Failed to prep mutator "${me}" for payload`);
    return ce
}
  , getGameModeFromLevelLocation = V => V.startsWith(CUSTOM_GAME_MODE_ID) ? CUSTOM_GAME_MODE_ID : V.replace(/\d+$/, "")
  , getPatchedMutatorValue = ({newValue: V, mutatorsState: X, mutatorId: J, mutatorMeta: ne, numberOfTeams: ue=0, teamIndexes: ce}) => {
    const me = {
        ...X
    };
    return ce != null && ce.length && ne.isPerTeam ? ce.forEach(ge => {
        if (me[J]instanceof Map)
            me[J].set(ge, V);
        else if (ne.defaultValue === me[J] && me[J] !== void 0)
            me[J] = new Map([[ge, V]]);
        else {
            const Te = me[J] === void 0 ? ne.defaultValue : me[J];
            me[J] = new Map(Array.from({
                length: ue
            }).map( (_e, Se) => [Se, Se === ge ? V : Te]))
        }
    }
    ) : me[J] = V,
    me
}
  , getPatchedAssetTagValue = ({newValue: V, assetTagsState: X, assetTagId: J, numberOfTeams: ne=0, teamIndexes: ue}) => {
    const ce = {
        ...X
    };
    return ue !== void 0 ? ue.forEach(me => {
        ce[J]instanceof Map ? ce[J].set(me, V) : ce[J] === void 0 ? ce[J] = new Map([[me, V]]) : ce[J] = new Map(Array.from({
            length: ne
        }).map( (ge, Te) => [Te, Te === me ? V : ce[J]]))
    }
    ) : ce[J] = V,
    ce
}
  , getMutatorValue = (V, X, J) => (V instanceof Map ? V.get(J ?? 0) : V) ?? X
  , getTeamsGroupedByMutatorOrAssetTagValue = ({teamIndexesToCheck: V, mutator: X, assetTag: J, ignoreTeam0: ne}) => V.reduce( (ue, ce) => {
    if (ne && !ce)
        return ue;
    const me = X ? getMutatorValue(X, void 0, ce) : void 0
      , ge = J ? getAssetTagValue(J, ce) : void 0
      , Te = me === void 0 ? ge : me
      , _e = ue.findIndex( ({value: Se}) => Se === Te);
    return _e === -1 ? ue.push({
        value: Te,
        teamsIndexes: [ce]
    }) : ue[_e].teamsIndexes.push(ce),
    ue
}
, [])
  , getAssetTagValue = (V, X) => V instanceof Map ? V.get(X ?? 0) === void 0 ? !0 : V.get(X ?? 0) : V
  , mutatorValueToSparseValues = (V, X, J) => {
    if (V instanceof Map) {
        const ne = checkAreAllValuesTheSame(V)
          , ue = Array.from(V)[0][1];
        return ne && (V.size === X - 1 || J === ue) ? ue : Array.from(V).map( ([ce,me]) => ({
            index: ce + 1,
            value: me
        }))
    }
    return V
}
  , getSyncMutatorsOrAssetTags = V => Object.entries(V).reduce( (X, [J,ne]) => {
    if (ne instanceof Map) {
        const ue = Array.from(ne)[0][1];
        X[J] = ue
    } else
        X[J] = ne;
    return X
}
, {})
  , getSyncTeamComposition = V => {
    var ge;
    const X = Array.from(V)
      , [J,ne] = X.reduce( (Te, _e) => (Te[0] += _e[1].humanCapacity ?? 0,
    Te[1] += _e[1].aiCapacity ?? 0,
    Te), [0, 0])
      , ue = Math.min(...distributeEvenly(J, V.size))
      , ce = Math.min(...distributeEvenly(ne, V.size))
      , me = ce ? ((ge = X.find(Te => Te[1].aiType !== void 0)) == null ? void 0 : ge[1].aiType) ?? InternalCapacityType.AI_STATIC : void 0;
    return X.reduce( (Te, [_e]) => (Te.set(_e, {
        humanCapacity: ue,
        aiCapacity: me === InternalCapacityType.AI_STATIC ? ce : void 0,
        aiType: me
    }),
    Te), new Map)
}
  , checkForUnlinkedValues = V => Object.entries(V).some(X => !checkAreAllValuesTheSame(X[1]))
  , checkAreAllValuesTheSame = V => V instanceof Map ? new Set([...V].map(X => X[1])).size === 1 : !0;
function roundFloatFromAPI(V) {
    return Math.round(V * 1e3) / 1e3
}
const getMutatorBasedFromTeamComposition = V => {
    const X = Array.from(V);
    if (!X.length)
        return {};
    const J = X.every(ue => ue[1].aiCapacity === X[0][1].aiCapacity)
      , ne = X.every(ue => ue[1].humanCapacity === X[0][1].humanCapacity);
    return {
        [MAX_TEAM_COUNT_MUTATOR_ID]: V.size + 1,
        [AI_MAX_COUNT_MUTATOR_ID]: X[0][1].aiType === InternalCapacityType.AI_STATIC ? J ? X[0][1].aiCapacity : new Map(X.map( ([ue,{aiCapacity: ce}]) => [ue - 1, ce ?? 0])) : void 0,
        [MAX_PLAYER_COUNT_MUTATOR_ID]: ne ? X[0][1].humanCapacity : new Map(X.map( ([ue,{humanCapacity: ce}]) => [ue - 1, ce ?? 0]))
    }
}
  , getDefaultSpatialDataByMap = (V, X) => X[`${V.levelName.toLowerCase()}${getNumbersFromEndOfString(V.levelLocation)}`]
  , getUsersMapLicenseData = ({mapEntryRequirements: V, ownedLicenses: X, levelName: J}) => {
    var ce;
    const ne = (ce = V == null ? void 0 : V.find(me => me.levelName == J)) == null ? void 0 : ce.licenseRequirements
      , ue = ne == null ? void 0 : ne.find(me => !(X != null && X.includes(me)));
    return {
        licenseRequirements: ne,
        missingLicense: ue
    }
}
  , getMutatorsForPage = ({mutators: V, tags: X, gameMode: J, mutatorIds: ne=[]}) => {
    const ue = GAME_MODE_TO_MUTATOR_TAG_MAP[J]
      , ce = common_utils.enumToArray(MUTATOR_TAG_GAME_MODE)
      , me = {
        ...getMutatorsByCategories(V, X),
        ...ne.reduce( (ge, Te) => {
            const _e = V[Te];
            return _e && (ge[Te] = _e),
            ge
        }
        , {})
    };
    return Object.entries(me).reduce( (ge, [Te,_e]) => {
        const Se = _e.tags.filter(Ie => ce.includes(Ie));
        return (!Se.length || Se.includes(ue)) && (ge[Te] = _e),
        ge
    }
    , {})
}
  , getIsConflict = (V, X, J) => {
    const ne = getTeamsGroupedByMutatorOrAssetTagValue({
        mutator: V,
        teamIndexesToCheck: X ?? [],
        ignoreTeam0: J
    });
    return X !== void 0 && ne.length > 1
}
  , convertStringToType = V => V.toLocaleLowerCase() === "false" ? !1 : V.toLocaleLowerCase() === "true" ? !0 : V === "undefined" ? void 0 : isNaN(Number(V)) ? V : Number(V)
  , collapseAssetRestrictionCategories = (V, X) => {
    const J = new Set;
    return Object.entries(V).reduce( (ne, [ue,ce]) => {
        var Se, Ie, ye;
        if (CLASS_ASSET_TAGS.includes(ue))
            return ne[ue] = ce,
            ne;
        const me = X.tags[ue];
        if (!me)
            return ne;
        const {parentCategories: ge} = me
          , Te = ge == null ? void 0 : ge[0]
          , _e = X.categories[Te ?? ""];
        return _e && !J.has(ue) && (((Se = _e.leafTags) == null ? void 0 : Se.every(Ne => {
            if (Ne in V) {
                const ve = V[Ne];
                return ve instanceof Map && ce instanceof Map ? compareMaps(ve, ce) : ve === ce
            }
            return !1
        }
        )) && Te ? (ne[Te] = ce,
        (Ie = _e.leafTags) == null || Ie.forEach(Ne => {
            J.add(Ne)
        }
        )) : (ye = _e.leafTags) == null || ye.forEach(Ne => {
            const ve = V[Ne];
            ve !== void 0 && (J.add(Ne),
            ne[Ne] = ve)
        }
        )),
        ne
    }
    , {})
}
  , expandAssetRestrictionCategories = (V, X) => Object.entries(V).reduce( (J, [ne,ue]) => {
    var me;
    const ce = X == null ? void 0 : X.categories[ne];
    return CLASS_ASSET_TAGS.includes(ne) ? (J[ne] = ue,
    J) : (ce ? (me = ce.childrenTags) == null || me.forEach(ge => {
        J[ge] = ue
    }
    ) : J[ne] = ue,
    J)
}
, {})
  , combineAssetTagValues = (V, X) => Object.entries(V).reduce( (J, [ne,ue]) => {
    if (ue instanceof Map && ue.size === X) {
        const ce = Array.from(ue)
          , me = ce[1][1];
        if (ce.every(ge => ge[1] === me))
            return J[ne] = me,
            J
    }
    return J[ne] = ue,
    J
}
, {})
  , getResourceMetadata = (V, X) => {
    var J, ne, ue, ce;
    return (ce = (ue = Array.from(new URLSearchParams((ne = (J = V.find( ({kind: me}) => me === X)) == null ? void 0 : J.location) == null ? void 0 : ne.url))) == null ? void 0 : ue[0]) == null ? void 0 : ce[1]
}
  , doesResourceKindExist = (V, X) => V.some( ({kind: J}) => J === X)
  , formatServerTags = (V, X) => V.map( ({tagId: J, metadata: ne}) => {
    var ge, Te;
    const ue = ne == null ? void 0 : ne.translations
      , ce = X(((ge = ue == null ? void 0 : ue.find( ({kind: _e}) => _e === SERVER_TAG_TRANSLATION_KIND.NAME)) == null ? void 0 : ge.translationId) ?? "")
      , me = X(((Te = ue == null ? void 0 : ue.find( ({kind: _e}) => _e === SERVER_TAG_TRANSLATION_KIND.DESCRIPTION)) == null ? void 0 : Te.translationId) ?? "");
    return {
        name: ce,
        description: me,
        tagId: J
    }
}
);
function protocolVersionOverrideReasonFromJSON(V) {
    switch (V) {
    case 0:
    case "NONE":
        return 0;
    case 1:
    case "SYNC":
        return 1;
    case -1:
    case "UNRECOGNIZED":
    default:
        return -1
    }
}
function protocolVersionOverrideReasonToJSON(V) {
    switch (V) {
    case 0:
        return "NONE";
    case 1:
        return "SYNC";
    case -1:
    default:
        return "UNRECOGNIZED"
    }
}
function createBaseTimeTravel() {
    return {
        offset: void 0
    }
}
const TimeTravel = {
    encode(V, X=new BinaryWriter) {
        return V.offset !== void 0 && Duration.encode(V.offset, X.uint32(10).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseTimeTravel();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.offset = Duration.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            offset: isSet$5(V.offset) ? Duration.fromJSON(V.offset) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.offset !== void 0 && (X.offset = Duration.toJSON(V.offset)),
        X
    },
    create(V) {
        return TimeTravel.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseTimeTravel();
        return X.offset = V.offset !== void 0 && V.offset !== null ? Duration.fromPartial(V.offset) : void 0,
        X
    }
};
function createBaseProtocolVersionOverride() {
    return {
        original: "",
        overridden: "",
        reason: 0
    }
}
const ProtocolVersionOverride = {
    encode(V, X=new BinaryWriter) {
        return V.original !== "" && X.uint32(10).string(V.original),
        V.overridden !== "" && X.uint32(18).string(V.overridden),
        V.reason !== 0 && X.uint32(24).int32(V.reason),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseProtocolVersionOverride();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.original = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.overridden = J.string();
                    continue
                }
            case 3:
                {
                    if (ce !== 24)
                        break;
                    ue.reason = J.int32();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            original: isSet$5(V.original) ? globalThis.String(V.original) : "",
            overridden: isSet$5(V.overridden) ? globalThis.String(V.overridden) : "",
            reason: isSet$5(V.reason) ? protocolVersionOverrideReasonFromJSON(V.reason) : 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.original !== "" && (X.original = V.original),
        V.overridden !== "" && (X.overridden = V.overridden),
        V.reason !== 0 && (X.reason = protocolVersionOverrideReasonToJSON(V.reason)),
        X
    },
    create(V) {
        return ProtocolVersionOverride.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseProtocolVersionOverride();
        return X.original = V.original ?? "",
        X.overridden = V.overridden ?? "",
        X.reason = V.reason ?? 0,
        X
    }
};
function isSet$5(V) {
    return V != null
}
function createBaseAuthCodeAuthentication() {
    return {
        authCode: "",
        platform: 0,
        redirectUri: void 0,
        patchVersion: void 0,
        protocolVersion: void 0
    }
}
const AuthCodeAuthentication = {
    encode(V, X=new BinaryWriter) {
        return V.authCode !== "" && X.uint32(10).string(V.authCode),
        V.platform !== 0 && X.uint32(16).int32(V.platform),
        V.redirectUri !== void 0 && StringValue.encode({
            value: V.redirectUri
        }, X.uint32(26).fork()).join(),
        V.patchVersion !== void 0 && StringValue.encode({
            value: V.patchVersion
        }, X.uint32(34).fork()).join(),
        V.protocolVersion !== void 0 && StringValue.encode({
            value: V.protocolVersion
        }, X.uint32(42).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseAuthCodeAuthentication();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.authCode = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 16)
                        break;
                    ue.platform = J.int32();
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.redirectUri = StringValue.decode(J, J.uint32()).value;
                    continue
                }
            case 4:
                {
                    if (ce !== 34)
                        break;
                    ue.patchVersion = StringValue.decode(J, J.uint32()).value;
                    continue
                }
            case 5:
                {
                    if (ce !== 42)
                        break;
                    ue.protocolVersion = StringValue.decode(J, J.uint32()).value;
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            authCode: isSet$4(V.authCode) ? globalThis.String(V.authCode) : "",
            platform: isSet$4(V.platform) ? platformFromJSON(V.platform) : 0,
            redirectUri: isSet$4(V.redirectUri) ? String(V.redirectUri) : void 0,
            patchVersion: isSet$4(V.patchVersion) ? String(V.patchVersion) : void 0,
            protocolVersion: isSet$4(V.protocolVersion) ? String(V.protocolVersion) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.authCode !== "" && (X.authCode = V.authCode),
        V.platform !== 0 && (X.platform = platformToJSON(V.platform)),
        V.redirectUri !== void 0 && (X.redirectUri = V.redirectUri),
        V.patchVersion !== void 0 && (X.patchVersion = V.patchVersion),
        V.protocolVersion !== void 0 && (X.protocolVersion = V.protocolVersion),
        X
    },
    create(V) {
        return AuthCodeAuthentication.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseAuthCodeAuthentication();
        return X.authCode = V.authCode ?? "",
        X.platform = V.platform ?? 0,
        X.redirectUri = V.redirectUri ?? void 0,
        X.patchVersion = V.patchVersion ?? void 0,
        X.protocolVersion = V.protocolVersion ?? void 0,
        X
    }
};
function createBaseAuthenticationResponse() {
    return {
        sessionId: "",
        player: void 0,
        timeTravel: void 0,
        protocolVersionOverride: void 0,
        patchVersion: ""
    }
}
const AuthenticationResponse = {
    encode(V, X=new BinaryWriter) {
        return V.sessionId !== "" && X.uint32(10).string(V.sessionId),
        V.player !== void 0 && Player.encode(V.player, X.uint32(18).fork()).join(),
        V.timeTravel !== void 0 && TimeTravel.encode(V.timeTravel, X.uint32(26).fork()).join(),
        V.protocolVersionOverride !== void 0 && ProtocolVersionOverride.encode(V.protocolVersionOverride, X.uint32(34).fork()).join(),
        V.patchVersion !== "" && X.uint32(42).string(V.patchVersion),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseAuthenticationResponse();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.sessionId = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.player = Player.decode(J, J.uint32());
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.timeTravel = TimeTravel.decode(J, J.uint32());
                    continue
                }
            case 4:
                {
                    if (ce !== 34)
                        break;
                    ue.protocolVersionOverride = ProtocolVersionOverride.decode(J, J.uint32());
                    continue
                }
            case 5:
                {
                    if (ce !== 42)
                        break;
                    ue.patchVersion = J.string();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            sessionId: isSet$4(V.sessionId) ? globalThis.String(V.sessionId) : "",
            player: isSet$4(V.player) ? Player.fromJSON(V.player) : void 0,
            timeTravel: isSet$4(V.timeTravel) ? TimeTravel.fromJSON(V.timeTravel) : void 0,
            protocolVersionOverride: isSet$4(V.protocolVersionOverride) ? ProtocolVersionOverride.fromJSON(V.protocolVersionOverride) : void 0,
            patchVersion: isSet$4(V.patchVersion) ? globalThis.String(V.patchVersion) : ""
        }
    },
    toJSON(V) {
        const X = {};
        return V.sessionId !== "" && (X.sessionId = V.sessionId),
        V.player !== void 0 && (X.player = Player.toJSON(V.player)),
        V.timeTravel !== void 0 && (X.timeTravel = TimeTravel.toJSON(V.timeTravel)),
        V.protocolVersionOverride !== void 0 && (X.protocolVersionOverride = ProtocolVersionOverride.toJSON(V.protocolVersionOverride)),
        V.patchVersion !== "" && (X.patchVersion = V.patchVersion),
        X
    },
    create(V) {
        return AuthenticationResponse.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseAuthenticationResponse();
        return X.sessionId = V.sessionId ?? "",
        X.player = V.player !== void 0 && V.player !== null ? Player.fromPartial(V.player) : void 0,
        X.timeTravel = V.timeTravel !== void 0 && V.timeTravel !== null ? TimeTravel.fromPartial(V.timeTravel) : void 0,
        X.protocolVersionOverride = V.protocolVersionOverride !== void 0 && V.protocolVersionOverride !== null ? ProtocolVersionOverride.fromPartial(V.protocolVersionOverride) : void 0,
        X.patchVersion = V.patchVersion ?? "",
        X
    }
};
class WebAuthenticationClientImpl {
    constructor(X) {
        Tt(this, "rpc");
        this.rpc = X,
        this.viaAuthCode = this.viaAuthCode.bind(this),
        this.logout = this.logout.bind(this)
    }
    viaAuthCode(X, J) {
        return this.rpc.unary(WebAuthenticationviaAuthCodeDesc, AuthCodeAuthentication.fromPartial(X), J)
    }
    logout(X, J) {
        return this.rpc.unary(WebAuthenticationlogoutDesc, Empty.fromPartial(X), J)
    }
}
const WebAuthenticationDesc = {
    serviceName: "santiago.web.authentication.WebAuthentication"
}
  , WebAuthenticationviaAuthCodeDesc = {
    methodName: "viaAuthCode",
    service: WebAuthenticationDesc,
    requestStream: !1,
    responseStream: !1,
    requestType: {
        serializeBinary() {
            return AuthCodeAuthentication.encode(this).finish()
        }
    },
    responseType: {
        deserializeBinary(V) {
            const X = AuthenticationResponse.decode(V);
            return {
                ...X,
                toObject() {
                    return X
                }
            }
        }
    }
}
  , WebAuthenticationlogoutDesc = {
    methodName: "logout",
    service: WebAuthenticationDesc,
    requestStream: !1,
    responseStream: !1,
    requestType: {
        serializeBinary() {
            return Empty.encode(this).finish()
        }
    },
    responseType: {
        deserializeBinary(V) {
            const X = Empty.decode(V);
            return {
                ...X,
                toObject() {
                    return X
                }
            }
        }
    }
};
class GrpcWebImpl {
    constructor(X, J) {
        Tt(this, "host");
        Tt(this, "options");
        this.host = X,
        this.options = J
    }
    unary(X, J, ne) {
        var me;
        const ue = {
            ...J,
            ...X.requestType
        }
          , ce = ne && this.options.metadata ? new browserHeaders_umdExports.BrowserHeaders({
            ...(me = this.options) == null ? void 0 : me.metadata.headersMap,
            ...ne == null ? void 0 : ne.headersMap
        }) : ne ?? this.options.metadata;
        return new Promise( (ge, Te) => {
            grpcWebClient_umdExports.grpc.unary(X, {
                request: ue,
                host: this.host,
                metadata: ce ?? {},
                ...this.options.transport !== void 0 ? {
                    transport: this.options.transport
                } : {},
                debug: this.options.debug ?? !1,
                onEnd: function(_e) {
                    if (_e.status === grpcWebClient_umdExports.grpc.Code.OK)
                        ge(_e.message.toObject());
                    else {
                        const Se = new GrpcWebError(_e.statusMessage,_e.status,_e.trailers);
                        Te(Se)
                    }
                }
            })
        }
        )
    }
}
function isSet$4(V) {
    return V != null
}
class GrpcWebError extends globalThis.Error {
    constructor(X, J, ne) {
        super(X),
        this.code = J,
        this.metadata = ne
    }
}
function createBaseSidList() {
    return {
        sids: []
    }
}
const SidList = {
    encode(V, X=new BinaryWriter) {
        for (const J of V.sids)
            X.uint32(10).string(J);
        return X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseSidList();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.sids.push(J.string());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            sids: globalThis.Array.isArray(V == null ? void 0 : V.sids) ? V.sids.map(X => globalThis.String(X)) : []
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return (J = V.sids) != null && J.length && (X.sids = V.sids),
        X
    },
    create(V) {
        return SidList.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseSidList();
        return X.sids = ((J = V.sids) == null ? void 0 : J.map(ne => ne)) || [],
        X
    }
};
function createBaseCategoryIdList() {
    return {
        ids: []
    }
}
const CategoryIdList = {
    encode(V, X=new BinaryWriter) {
        X.uint32(10).fork();
        for (const J of V.ids)
            X.int32(J);
        return X.join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseCategoryIdList();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce === 8) {
                        ue.ids.push(J.int32());
                        continue
                    }
                    if (ce === 10) {
                        const me = J.uint32() + J.pos;
                        for (; J.pos < me; )
                            ue.ids.push(J.int32());
                        continue
                    }
                    break
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            ids: globalThis.Array.isArray(V == null ? void 0 : V.ids) ? V.ids.map(X => globalThis.Number(X)) : []
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return (J = V.ids) != null && J.length && (X.ids = V.ids.map(ne => Math.round(ne))),
        X
    },
    create(V) {
        return CategoryIdList.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseCategoryIdList();
        return X.ids = ((J = V.ids) == null ? void 0 : J.map(ne => ne)) || [],
        X
    }
};
function createBaseSubCategoryIdList() {
    return {
        ids: []
    }
}
const SubCategoryIdList = {
    encode(V, X=new BinaryWriter) {
        X.uint32(10).fork();
        for (const J of V.ids)
            X.int32(J);
        return X.join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseSubCategoryIdList();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce === 8) {
                        ue.ids.push(J.int32());
                        continue
                    }
                    if (ce === 10) {
                        const me = J.uint32() + J.pos;
                        for (; J.pos < me; )
                            ue.ids.push(J.int32());
                        continue
                    }
                    break
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            ids: globalThis.Array.isArray(V == null ? void 0 : V.ids) ? V.ids.map(X => globalThis.Number(X)) : []
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return (J = V.ids) != null && J.length && (X.ids = V.ids.map(ne => Math.round(ne))),
        X
    },
    create(V) {
        return SubCategoryIdList.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseSubCategoryIdList();
        return X.ids = ((J = V.ids) == null ? void 0 : J.map(ne => ne)) || [],
        X
    }
};
function createBaseTranslationsQuery() {
    return {
        sidList: void 0,
        categoryIdList: void 0,
        subCategoryIdList: void 0
    }
}
const TranslationsQuery = {
    encode(V, X=new BinaryWriter) {
        return V.sidList !== void 0 && SidList.encode(V.sidList, X.uint32(10).fork()).join(),
        V.categoryIdList !== void 0 && CategoryIdList.encode(V.categoryIdList, X.uint32(18).fork()).join(),
        V.subCategoryIdList !== void 0 && SubCategoryIdList.encode(V.subCategoryIdList, X.uint32(26).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseTranslationsQuery();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.sidList = SidList.decode(J, J.uint32());
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.categoryIdList = CategoryIdList.decode(J, J.uint32());
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.subCategoryIdList = SubCategoryIdList.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            sidList: isSet$3(V.sidList) ? SidList.fromJSON(V.sidList) : void 0,
            categoryIdList: isSet$3(V.categoryIdList) ? CategoryIdList.fromJSON(V.categoryIdList) : void 0,
            subCategoryIdList: isSet$3(V.subCategoryIdList) ? SubCategoryIdList.fromJSON(V.subCategoryIdList) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.sidList !== void 0 && (X.sidList = SidList.toJSON(V.sidList)),
        V.categoryIdList !== void 0 && (X.categoryIdList = CategoryIdList.toJSON(V.categoryIdList)),
        V.subCategoryIdList !== void 0 && (X.subCategoryIdList = SubCategoryIdList.toJSON(V.subCategoryIdList)),
        X
    },
    create(V) {
        return TranslationsQuery.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseTranslationsQuery();
        return X.sidList = V.sidList !== void 0 && V.sidList !== null ? SidList.fromPartial(V.sidList) : void 0,
        X.categoryIdList = V.categoryIdList !== void 0 && V.categoryIdList !== null ? CategoryIdList.fromPartial(V.categoryIdList) : void 0,
        X.subCategoryIdList = V.subCategoryIdList !== void 0 && V.subCategoryIdList !== null ? SubCategoryIdList.fromPartial(V.subCategoryIdList) : void 0,
        X
    }
};
function createBaseLocalizedText() {
    return {
        sid: "",
        localizedText: "",
        categoryId: 0
    }
}
const LocalizedText = {
    encode(V, X=new BinaryWriter) {
        return V.sid !== "" && X.uint32(10).string(V.sid),
        V.localizedText !== "" && X.uint32(18).string(V.localizedText),
        V.categoryId !== 0 && X.uint32(24).int32(V.categoryId),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseLocalizedText();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.sid = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.localizedText = J.string();
                    continue
                }
            case 3:
                {
                    if (ce !== 24)
                        break;
                    ue.categoryId = J.int32();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            sid: isSet$3(V.sid) ? globalThis.String(V.sid) : "",
            localizedText: isSet$3(V.localizedText) ? globalThis.String(V.localizedText) : "",
            categoryId: isSet$3(V.categoryId) ? globalThis.Number(V.categoryId) : 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.sid !== "" && (X.sid = V.sid),
        V.localizedText !== "" && (X.localizedText = V.localizedText),
        V.categoryId !== 0 && (X.categoryId = Math.round(V.categoryId)),
        X
    },
    create(V) {
        return LocalizedText.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseLocalizedText();
        return X.sid = V.sid ?? "",
        X.localizedText = V.localizedText ?? "",
        X.categoryId = V.categoryId ?? 0,
        X
    }
};
function isSet$3(V) {
    return V != null
}
function createBaseGetTranslationsRequest() {
    return {
        translationsQuery: void 0,
        locale: "",
        fetchFrom: void 0
    }
}
const GetTranslationsRequest = {
    encode(V, X=new BinaryWriter) {
        return V.translationsQuery !== void 0 && TranslationsQuery.encode(V.translationsQuery, X.uint32(10).fork()).join(),
        V.locale !== "" && X.uint32(18).string(V.locale),
        V.fetchFrom !== void 0 && Timestamp.encode(toTimestamp(V.fetchFrom), X.uint32(26).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseGetTranslationsRequest();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.translationsQuery = TranslationsQuery.decode(J, J.uint32());
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.locale = J.string();
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.fetchFrom = fromTimestamp(Timestamp.decode(J, J.uint32()));
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            translationsQuery: isSet$2(V.translationsQuery) ? TranslationsQuery.fromJSON(V.translationsQuery) : void 0,
            locale: isSet$2(V.locale) ? globalThis.String(V.locale) : "",
            fetchFrom: isSet$2(V.fetchFrom) ? fromJsonTimestamp(V.fetchFrom) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.translationsQuery !== void 0 && (X.translationsQuery = TranslationsQuery.toJSON(V.translationsQuery)),
        V.locale !== "" && (X.locale = V.locale),
        V.fetchFrom !== void 0 && (X.fetchFrom = V.fetchFrom.toISOString()),
        X
    },
    create(V) {
        return GetTranslationsRequest.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseGetTranslationsRequest();
        return X.translationsQuery = V.translationsQuery !== void 0 && V.translationsQuery !== null ? TranslationsQuery.fromPartial(V.translationsQuery) : void 0,
        X.locale = V.locale ?? "",
        X.fetchFrom = V.fetchFrom ?? void 0,
        X
    }
};
function createBaseGetTranslationsResponse() {
    return {
        localizedTexts: [],
        fetchedUntil: void 0
    }
}
const GetTranslationsResponse = {
    encode(V, X=new BinaryWriter) {
        for (const J of V.localizedTexts)
            LocalizedText.encode(J, X.uint32(10).fork()).join();
        return V.fetchedUntil !== void 0 && Timestamp.encode(toTimestamp(V.fetchedUntil), X.uint32(18).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseGetTranslationsResponse();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.localizedTexts.push(LocalizedText.decode(J, J.uint32()));
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.fetchedUntil = fromTimestamp(Timestamp.decode(J, J.uint32()));
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            localizedTexts: globalThis.Array.isArray(V == null ? void 0 : V.localizedTexts) ? V.localizedTexts.map(X => LocalizedText.fromJSON(X)) : [],
            fetchedUntil: isSet$2(V.fetchedUntil) ? fromJsonTimestamp(V.fetchedUntil) : void 0
        }
    },
    toJSON(V) {
        var J;
        const X = {};
        return (J = V.localizedTexts) != null && J.length && (X.localizedTexts = V.localizedTexts.map(ne => LocalizedText.toJSON(ne))),
        V.fetchedUntil !== void 0 && (X.fetchedUntil = V.fetchedUntil.toISOString()),
        X
    },
    create(V) {
        return GetTranslationsResponse.fromPartial(V ?? {})
    },
    fromPartial(V) {
        var J;
        const X = createBaseGetTranslationsResponse();
        return X.localizedTexts = ((J = V.localizedTexts) == null ? void 0 : J.map(ne => LocalizedText.fromPartial(ne))) || [],
        X.fetchedUntil = V.fetchedUntil ?? void 0,
        X
    }
};
class ClientLocalizationClientImpl {
    constructor(X) {
        Tt(this, "rpc");
        this.rpc = X,
        this.getTranslations = this.getTranslations.bind(this)
    }
    getTranslations(X, J) {
        return this.rpc.unary(ClientLocalizationgetTranslationsDesc, GetTranslationsRequest.fromPartial(X), J)
    }
}
const ClientLocalizationDesc = {
    serviceName: "santiago.web.localization.ClientLocalization"
}
  , ClientLocalizationgetTranslationsDesc = {
    methodName: "getTranslations",
    service: ClientLocalizationDesc,
    requestStream: !1,
    responseStream: !1,
    requestType: {
        serializeBinary() {
            return GetTranslationsRequest.encode(this).finish()
        }
    },
    responseType: {
        deserializeBinary(V) {
            const X = GetTranslationsResponse.decode(V);
            return {
                ...X,
                toObject() {
                    return X
                }
            }
        }
    }
};
function toTimestamp(V) {
    const X = Math.trunc(V.getTime() / 1e3)
      , J = V.getTime() % 1e3 * 1e6;
    return {
        seconds: X,
        nanos: J
    }
}
function fromTimestamp(V) {
    let X = (V.seconds || 0) * 1e3;
    return X += (V.nanos || 0) / 1e6,
    new globalThis.Date(X)
}
function fromJsonTimestamp(V) {
    return V instanceof globalThis.Date ? V : typeof V == "string" ? new globalThis.Date(V) : fromTimestamp(Timestamp.fromJSON(V))
}
function isSet$2(V) {
    return V != null
}
function reportingErrorTypeFromJSON(V) {
    switch (V) {
    case 0:
    case "ERROR_TYPES_GENERIC_SERVICE_FAILURE":
        return 0;
    case 1:
    case "ERROR_TYPES_GENERIC_BUSINESS_FAILURE":
        return 1;
    case 2:
    case "ERROR_TYPES_INVALID_ARGUMENT":
        return 2;
    case 3:
    case "ERROR_TYPES_RATE_LIMITED":
        return 3;
    case -1:
    case "UNRECOGNIZED":
    default:
        return -1
    }
}
function reportingErrorTypeToJSON(V) {
    switch (V) {
    case 0:
        return "ERROR_TYPES_GENERIC_SERVICE_FAILURE";
    case 1:
        return "ERROR_TYPES_GENERIC_BUSINESS_FAILURE";
    case 2:
        return "ERROR_TYPES_INVALID_ARGUMENT";
    case 3:
        return "ERROR_TYPES_RATE_LIMITED";
    case -1:
    default:
        return "UNRECOGNIZED"
    }
}
function createBaseReportPlayerRequest() {
    return {
        offendingPlayer: void 0,
        subject: void 0
    }
}
const ReportPlayerRequest = {
    encode(V, X=new BinaryWriter) {
        return V.offendingPlayer !== void 0 && Player.encode(V.offendingPlayer, X.uint32(10).fork()).join(),
        V.subject !== void 0 && StringValue.encode({
            value: V.subject
        }, X.uint32(18).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseReportPlayerRequest();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.offendingPlayer = Player.decode(J, J.uint32());
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.subject = StringValue.decode(J, J.uint32()).value;
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            offendingPlayer: isSet$1(V.offendingPlayer) ? Player.fromJSON(V.offendingPlayer) : void 0,
            subject: isSet$1(V.subject) ? String(V.subject) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.offendingPlayer !== void 0 && (X.offendingPlayer = Player.toJSON(V.offendingPlayer)),
        V.subject !== void 0 && (X.subject = V.subject),
        X
    },
    create(V) {
        return ReportPlayerRequest.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseReportPlayerRequest();
        return X.offendingPlayer = V.offendingPlayer !== void 0 && V.offendingPlayer !== null ? Player.fromPartial(V.offendingPlayer) : void 0,
        X.subject = V.subject ?? void 0,
        X
    }
};
function createBaseReportExperienceRequest() {
    return {
        experienceId: "",
        subject: void 0
    }
}
const ReportExperienceRequest = {
    encode(V, X=new BinaryWriter) {
        return V.experienceId !== "" && X.uint32(10).string(V.experienceId),
        V.subject !== void 0 && StringValue.encode({
            value: V.subject
        }, X.uint32(18).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseReportExperienceRequest();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.experienceId = J.string();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.subject = StringValue.decode(J, J.uint32()).value;
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            experienceId: isSet$1(V.experienceId) ? globalThis.String(V.experienceId) : "",
            subject: isSet$1(V.subject) ? String(V.subject) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.experienceId !== "" && (X.experienceId = V.experienceId),
        V.subject !== void 0 && (X.subject = V.subject),
        X
    },
    create(V) {
        return ReportExperienceRequest.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseReportExperienceRequest();
        return X.experienceId = V.experienceId ?? "",
        X.subject = V.subject ?? void 0,
        X
    }
};
function createBaseReportingResponse() {
    return {
        success: void 0,
        error: void 0
    }
}
const ReportingResponse = {
    encode(V, X=new BinaryWriter) {
        return V.success !== void 0 && CreatePetitionSuccess.encode(V.success, X.uint32(10).fork()).join(),
        V.error !== void 0 && CreatePetitionError.encode(V.error, X.uint32(18).fork()).join(),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseReportingResponse();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.success = CreatePetitionSuccess.decode(J, J.uint32());
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.error = CreatePetitionError.decode(J, J.uint32());
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            success: isSet$1(V.success) ? CreatePetitionSuccess.fromJSON(V.success) : void 0,
            error: isSet$1(V.error) ? CreatePetitionError.fromJSON(V.error) : void 0
        }
    },
    toJSON(V) {
        const X = {};
        return V.success !== void 0 && (X.success = CreatePetitionSuccess.toJSON(V.success)),
        V.error !== void 0 && (X.error = CreatePetitionError.toJSON(V.error)),
        X
    },
    create(V) {
        return ReportingResponse.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseReportingResponse();
        return X.success = V.success !== void 0 && V.success !== null ? CreatePetitionSuccess.fromPartial(V.success) : void 0,
        X.error = V.error !== void 0 && V.error !== null ? CreatePetitionError.fromPartial(V.error) : void 0,
        X
    }
};
function createBaseCreatePetitionSuccess() {
    return {
        petitionId: ""
    }
}
const CreatePetitionSuccess = {
    encode(V, X=new BinaryWriter) {
        return V.petitionId !== "" && X.uint32(10).string(V.petitionId),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseCreatePetitionSuccess();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 10)
                        break;
                    ue.petitionId = J.string();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            petitionId: isSet$1(V.petitionId) ? globalThis.String(V.petitionId) : ""
        }
    },
    toJSON(V) {
        const X = {};
        return V.petitionId !== "" && (X.petitionId = V.petitionId),
        X
    },
    create(V) {
        return CreatePetitionSuccess.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseCreatePetitionSuccess();
        return X.petitionId = V.petitionId ?? "",
        X
    }
};
function createBaseCreatePetitionError() {
    return {
        errorType: 0,
        errorMessage: ""
    }
}
const CreatePetitionError = {
    encode(V, X=new BinaryWriter) {
        return V.errorType !== 0 && X.uint32(8).int32(V.errorType),
        V.errorMessage !== "" && X.uint32(18).string(V.errorMessage),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseCreatePetitionError();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 8)
                        break;
                    ue.errorType = J.int32();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.errorMessage = J.string();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            errorType: isSet$1(V.errorType) ? reportingErrorTypeFromJSON(V.errorType) : 0,
            errorMessage: isSet$1(V.errorMessage) ? globalThis.String(V.errorMessage) : ""
        }
    },
    toJSON(V) {
        const X = {};
        return V.errorType !== 0 && (X.errorType = reportingErrorTypeToJSON(V.errorType)),
        V.errorMessage !== "" && (X.errorMessage = V.errorMessage),
        X
    },
    create(V) {
        return CreatePetitionError.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseCreatePetitionError();
        return X.errorType = V.errorType ?? 0,
        X.errorMessage = V.errorMessage ?? "",
        X
    }
};
class WebReportingClientImpl {
    constructor(X) {
        Tt(this, "rpc");
        this.rpc = X,
        this.ReportPlayer = this.ReportPlayer.bind(this),
        this.ReportExperience = this.ReportExperience.bind(this)
    }
    ReportPlayer(X, J) {
        return this.rpc.unary(WebReportingReportPlayerDesc, ReportPlayerRequest.fromPartial(X), J)
    }
    ReportExperience(X, J) {
        return this.rpc.unary(WebReportingReportExperienceDesc, ReportExperienceRequest.fromPartial(X), J)
    }
}
const WebReportingDesc = {
    serviceName: "santiago.web.reporting.WebReporting"
}
  , WebReportingReportPlayerDesc = {
    methodName: "ReportPlayer",
    service: WebReportingDesc,
    requestStream: !1,
    responseStream: !1,
    requestType: {
        serializeBinary() {
            return ReportPlayerRequest.encode(this).finish()
        }
    },
    responseType: {
        deserializeBinary(V) {
            const X = ReportingResponse.decode(V);
            return {
                ...X,
                toObject() {
                    return X
                }
            }
        }
    }
}
  , WebReportingReportExperienceDesc = {
    methodName: "ReportExperience",
    service: WebReportingDesc,
    requestStream: !1,
    responseStream: !1,
    requestType: {
        serializeBinary() {
            return ReportExperienceRequest.encode(this).finish()
        }
    },
    responseType: {
        deserializeBinary(V) {
            const X = ReportingResponse.decode(V);
            return {
                ...X,
                toObject() {
                    return X
                }
            }
        }
    }
};
function isSet$1(V) {
    return V != null
}
const host = "https://santiago-prod-wgw-envoy.ops.dice.se"
  , rpc = new GrpcWebImpl(host,{
    debug: !1,
    metadata: new grpcWebClient_umdExports.grpc.Metadata({
        "x-dice-tenancy": "prod_default-prod_default-santiago-common"
    })
})
  , clients = {
    authentication: new WebAuthenticationClientImpl(rpc),
    localization: new ClientLocalizationClientImpl(rpc),
    play: new WebPlayClientImpl(rpc),
    webReporting: new WebReportingClientImpl(rpc)
}
  , logger$h = Logger$1.get("App")
  , blueprintLogger = logger$h.extend("blueprint")
  , fetchScheduledBlueprints = async V => {
    const X = await clients.play.getScheduledBlueprints({}, new grpcWebClient_umdExports.grpc.Metadata({
        "x-gateway-session-id": V
    }));
    return GetScheduledBlueprintsResponse.fromPartial(X)
}
  , fetchBlueprint = async (V, X, J) => {
    const ne = await clients.play.getBlueprintsById({
        blueprintIds: [{
            id: X,
            version: J
        }]
    }, new grpcWebClient_umdExports.grpc.Metadata({
        "x-gateway-session-id": V
    }));
    return GetBlueprintsByIdResponse.fromPartial(ne)
}
  , useScheduledBlueprintIdQuery = (V, X) => {
    const J = !!X
      , {data: ne, isLoading: ue} = useQuery({
        queryKey: [QUERY_KEY.SCHEDULED_BLUEPRINTS, V, J],
        queryFn: () => fetchScheduledBlueprints(X || ""),
        enabled: J,
        staleTime: MS_1_MINUTE * 5,
        select: ({blueprintIds: ce}) => ce == null ? void 0 : ce[0]
    });
    return [ne, ue]
}
  , useBlueprintQuery = V => {
    const X = getCurrentArrivalPatchVersion() ?? "default"
      , [J,ne] = useScheduledBlueprintIdQuery(X, V) ?? {}
      , {id: ue, version: ce} = J ?? {}
      , me = !!V && !!ue && !!ce
      , {data: ge, isFetching: Te, isError: _e} = useQuery({
        queryKey: [QUERY_KEY.BLUEPRINT, ue, ce, X],
        queryFn: async () => (blueprintLogger.log("Requesting blueprint..."),
        await fetchBlueprint(V ?? "", ue ?? "", ce)),
        enabled: me,
        staleTime: MS_12_HOURS,
        gcTime: 1 / 0,
        select: $e => ($e == null ? void 0 : $e.blueprints[0]) ?? {}
    })
      , Se = performance.now()
      , Ie = reactExports.useMemo( () => ge ? formatToWebBlueprint(ge) : void 0, [ge])
      , ye = performance.now();
    return blueprintLogger.log(`Formatting to web blueprint format (${(new TextEncoder().encode(JSON.stringify(Ie)).length / 1024).toFixed(2)}kb) took ${(ye - Se).toFixed(1)}ms.`),
    blueprintLogger.log("Blueprint Received: ", ge),
    blueprintLogger.log("Web Blueprint Data: ", Ie),
    {
        blueprint: ge,
        webBlueprint: Ie,
        blueprintId: ue,
        isFetching: Te || ne,
        isError: _e
    }
}
  , BlueprintContext = reactExports.createContext({})
  , BlueprintProvider = ({sessionId: V, children: X}) => {
    const {blueprint: J, webBlueprint: ne, blueprintId: ue, isFetching: ce, isError: me} = useBlueprintQuery(V)
      , ge = J ? extractAllSIDs(J) : void 0
      , {t: Te} = useTranslation();
    return ce ? jsxRuntimeExports.jsx(LoadingSpinner, {
        statusText: Te("general.loading-configs")
    }) : jsxRuntimeExports.jsx(BlueprintContext.Provider, {
        value: {
            blueprint: ne,
            rawBlueprint: J,
            blueprintId: ue,
            sids: ge,
            isFetching: ce,
            isError: me
        },
        children: X
    })
}
  , logger$g = Logger$1.get("session", "util");
function hasSessionInCookies() {
    return !!getSessionIdFromCookie() && !!getPlayerFromCookie()
}
const getPlayerFromCookie = () => {
    let V;
    try {
        const X = api.get(COOKIE_KEY.PLAYER);
        V = X ? JSON.parse(X) : void 0
    } catch (X) {
        V = void 0,
        logger$g.error(X)
    }
    return V
}
;
function getSessionIdFromCookie() {
    return api.get(COOKIE_KEY.SESSION_ID)
}
function clearSessionCookies() {
    api.remove(COOKIE_KEY.SESSION_ID),
    api.remove(COOKIE_KEY.PLAYER)
}
function setSessionCookies(V, X) {
    if (V) {
        const J = new Date;
        J.setSeconds(J.getSeconds() + 86400),
        api.set(COOKIE_KEY.SESSION_ID, V, {
            expires: J,
            sameSite: "Strict",
            secure: NODE_ENV === "production"
        })
    } else
        api.remove(COOKIE_KEY.SESSION_ID);
    if (X) {
        const J = new Date;
        J.setSeconds(J.getSeconds() + 86400),
        api.set(COOKIE_KEY.PLAYER, JSON.stringify(X), {
            expires: J,
            sameSite: "Strict",
            secure: NODE_ENV === "production"
        })
    } else
        api.remove(COOKIE_KEY.PLAYER)
}
function isLocalStorageAvailable() {
    try {
        const V = "__storage_test__";
        return window.localStorage.setItem(V, V),
        window.localStorage.removeItem(V),
        !0
    } catch {
        return !1
    }
}
const SessionContext = reactExports.createContext({
    clearSession: () => {}
    ,
    isError: !1,
    updateSession: () => {}
})
  , SessionProvider = ({children: V}) => {
    const X = getSessionIdFromCookie()
      , J = getPlayerFromCookie()
      , [ne,ue] = reactExports.useState(X)
      , [ce,me] = reactExports.useState(J == null ? void 0 : J.nucleusId)
      , [ge,Te] = reactExports.useState(J == null ? void 0 : J.personaId)
      , [_e,Se] = reactExports.useState(J == null ? void 0 : J.platform)
      , [Ie,ye] = reactExports.useState(!1)
      , $e = Ne => {
        var ve, ke, xe;
        ue(Ne.sessionId),
        me((ve = Ne.player) == null ? void 0 : ve.nucleusId),
        Te((ke = Ne.player) == null ? void 0 : ke.personaId),
        Se((xe = Ne.player) == null ? void 0 : xe.platform),
        ye(!!Ne.isError)
    }
    ;
    return jsxRuntimeExports.jsx(SessionContext.Provider, {
        value: {
            sessionId: ne,
            player: ce && ge && _e !== void 0 ? {
                nucleusId: ce,
                personaId: ge,
                platform: _e
            } : void 0,
            clearSession: () => {
                clearSessionCookies()
            }
            ,
            isError: Ie,
            updateSession: $e
        },
        children: V
    })
}
;
class ImpressionCounter {
    constructor() {
        Tt(this, "impressionCount", new Map)
    }
    incrementCount(X) {
        const J = this.impressionCount.get(X) ?? 1;
        this.impressionCount.set(X, J + 1)
    }
    getCount(X) {
        return this.impressionCount.get(X) ?? 1
    }
}
class SessionLapseTime {
    constructor() {
        Tt(this, "pageDuration");
        Tt(this, "sessionStartTime");
        this.pageDuration = Date.now(),
        this.sessionStartTime = Date.now()
    }
    getLapsedSessionDuration() {
        return this.getLapseTime(this.sessionStartTime)
    }
    getLapsedPageDuration() {
        return this.getLapseTime(this.pageDuration)
    }
    resetPageDuration() {
        this.pageDuration = Date.now()
    }
    getLapseTime(X) {
        return Math.floor((Date.now() - X) / 1e3)
    }
}
var TelemetryLoginStatus = (V => (V.ERROR = "error",
V.SUCCESS = "success",
V.CANCEL = "cancel",
V))(TelemetryLoginStatus || {});
const TelemetryPageViewCategory = {
    HOME: "home",
    CHECKOUT: "checkout",
    LOGIN: "login",
    LOGOUT: "logout",
    INITIAL_LAUNCH: "initial_launch",
    OTHER: "other"
}
  , TelemetryPageViewType = {
    WEB_PAGE: "web_page",
    POPUP: "popup",
    TAKEOVER: "takeover"
}
  , TelemetryPlatform = {
    PC: "pc",
    MAC: "mac",
    WEB: "web"
};
var TelemetrySettingsStatusTypes = (V => (V.BOOT = "boot",
V.UPDATE = "update",
V.SENT = "sent",
V))(TelemetrySettingsStatusTypes || {})
  , TelemetryUserClientType = (V => (V.DESKTOP = "DESKTOP",
V.IOS = "IOS",
V.ANDROID = "ANDROID",
V.WEB = "WEB",
V.PS = "PS",
V.XBOX = "XBOX",
V))(TelemetryUserClientType || {})
  , TelemetrySaveType = (V => (V.CUSTOM = "CUSTOM",
V.VERIFIED = "VERIFIED",
V))(TelemetrySaveType || {})
  , TelemetrySaveStatus = (V => (V.DRAFT = "DRAFT",
V.PUBLISHED = "PUBLISHED",
V.ACTION_NEEDED = "ACTION_NEEDED",
V.ERROR = "ERROR",
V))(TelemetrySaveStatus || {})
  , TelemetryType = (V => (V.PIN = "PIN",
V.GA = "GA",
V.ADEPT = "ADEPT",
V))(TelemetryType || {});
const mapTelemetryLocale = ({locale: V, telemetryType: X, region: J}) => {
    const ne = V.slice(0, 2).toLowerCase()
      , ue = X === "GA" ? "-" : "_";
    return J ? `${ne}${ue}${J.toUpperCase()}` : `${ne}${ue}US`
}
  , getCategoryFromPath = V => {
    const J = V.replace(/^\//, "").split(/[?#/]/)[0] || ""
      , ne = Object.values(TelemetryPageViewCategory);
    for (const ue of ne) {
        if (!J)
            return TelemetryPageViewCategory.HOME;
        if (J === ue.toString())
            return ue
    }
    return TelemetryPageViewCategory.OTHER
}
  , getTelemetrySaveStatusFromPublishAndModerationStates = (V, X) => V === PublishStateType.PUBLISH_STATE_TYPE_DRAFT ? TelemetrySaveStatus.DRAFT : V === PublishStateType.PUBLISH_STATE_TYPE_PUBLISHED ? X && X === ModerationStateType.MODERATION_STATE_TYPE_DENIED ? TelemetrySaveStatus.ACTION_NEEDED : TelemetrySaveStatus.PUBLISHED : V === PublishStateType.PUBLISH_STATE_TYPE_ERROR ? TelemetrySaveStatus.ERROR : TelemetrySaveStatus.DRAFT;
class BeaconClient {
    constructor(X) {
        Tt(this, "sendBeacon");
        this.sendBeacon = X
    }
}
class FetchClient {
    constructor(X) {
        Tt(this, "fetch");
        this.fetch = X
    }
}
const MAX_RETRY_COUNT = 6
  , SEND_INTERVAL = 3e3;
class PINBatchClient {
    constructor(X) {
        Tt(this, "requests", []);
        Tt(this, "pinEndpoint");
        Tt(this, "errorCallback", () => {}
        );
        this.pinEndpoint = X
    }
    addRequest(X) {
        this.requests.push(X)
    }
    setErrorCallback(X) {
        this.errorCallback = X
    }
    getBackOffTime(X) {
        return Date.now() + SEND_INTERVAL * Math.pow(2, X)
    }
    updateRetryTime(X) {
        X.pending = !1,
        X.retryCount += 1,
        X.nextRetryTime = this.getBackOffTime(X.retryCount),
        X.retryCount > MAX_RETRY_COUNT && this.requests.shift()
    }
}
class PINBatchClientBeacon extends PINBatchClient {
    constructor(J, ne) {
        super(ne);
        Tt(this, "sendBeacon");
        this.sendBeacon = J.sendBeacon
    }
    async cleanUp() {
        const J = this.send.bind(this);
        this.requests.forEach(J),
        this.requests = []
    }
    triggerPINSend() {
        if (this.requests.length === 0 || this.requests[0] === void 0)
            return;
        const J = this.requests[0];
        if (Date.now() < J.nextRetryTime)
            return;
        if (!this.send(J)) {
            this.updateRetryTime(J),
            this.errorCallback(new Error("PIN Client - Beacon Queue Error - failed to queue request."));
            return
        }
        this.requests.shift()
    }
    send(J) {
        return this.sendBeacon(this.pinEndpoint, JSON.stringify([J.body]))
    }
}
const RETRY_STATUS_CODES = [500, 501, 503, 429];
class PINBatchClientFetch extends PINBatchClient {
    constructor(J, ne) {
        super(ne);
        Tt(this, "fetch");
        this.fetch = J.fetch
    }
    async cleanUp() {
        const J = this.send.bind(this)
          , ne = this.requests.filter(ue => !ue.pending).map(J);
        await Promise.all(ne),
        this.requests = []
    }
    async triggerPINSend() {
        if (this.requests.length === 0 || this.requests[0] === void 0)
            return;
        const J = this.requests[0];
        J.pending || Date.now() < J.nextRetryTime || (J.pending = !0,
        await this.send(J).then(ne => {
            if (ne.status && RETRY_STATUS_CODES.includes(ne.status)) {
                this.updateRetryTime(J),
                this.errorCallback(new Error(`PIN Client - HTTP Error - response code received ${ne.status}.`));
                return
            }
            this.requests.shift()
        }
        ).catch(ne => {
            this.updateRetryTime(J),
            this.errorCallback(ne)
        }
        ))
    }
    async send(J) {
        return this.fetch(this.pinEndpoint, {
            method: "POST",
            body: JSON.stringify([J.body]),
            headers: J.headers,
            keepalive: !0
        })
    }
}
var PINEventCoreEventType = (V => (V.CLIENT = "client",
V.SERVER_WEBSTORE = "server_webstore",
V.WEB_BUILDER = "client_web_builder",
V))(PINEventCoreEventType || {})
  , PINEventCorePidType = (V => (V.NUCLEUS = "nucleus",
V.SYNERGY = "synergy",
V.PERSONA = "persona",
V.UID = "uid",
V))(PINEventCorePidType || {})
  , PINLoginStatus = (V => (V.ERROR = "error",
V.SUCCESS = "success",
V.CANCEL = "cancel",
V.START_FLOW = "start_flow",
V))(PINLoginStatus || {})
  , PINLoginType = (V => (V.BLAZE = "blaze",
V.NUCLEUS = "nucleus",
V.UTAS = "utas",
V.PAS = "pas",
V.FACEBOOK = "facebook",
V.GAME_CENTER = "game_center",
V.GAME = "game",
V))(PINLoginType || {});
class PINLoginEvent {
    constructor(X) {
        Tt(this, "eventName", "login");
        Tt(this, "options");
        this.options = X
    }
}
var PINLogoutReason = (V => (V.NORMAL = "normal",
V.ERROR = "error",
V.OUT_OF_TEL = "cancel",
V.UNKNOWN = "unknown",
V))(PINLogoutReason || {})
  , PINLogoutType = (V => (V.BLAZE = "blaze",
V.NUCLEUS = "nucleus",
V.UTAS = "utas",
V.PAS = "pas",
V.FACEBOOK = "facebook",
V.GAME_CENTER = "game_center",
V.GAME = "game",
V))(PINLogoutType || {});
class PINLogoutEvent {
    constructor(X) {
        Tt(this, "eventName", "logout");
        Tt(this, "options");
        this.options = X
    }
}
class PINPageViewEvent {
    constructor(X) {
        Tt(this, "eventName", "page_view");
        Tt(this, "options");
        this.options = X
    }
}
var PINMessageStatus = (V => (V.SENT = "sent",
V.RECEIVED = "received",
V.CLICK = "click",
V.DEEP_LINK_CLICK = "deep_link_click",
V.CONVERSION = "conversion",
V.ERROR = "error",
V.OPENED = "opened",
V.STARTED = "started",
V.PARTIAL_VIEW = "partial_view",
V.COMPLETE = "complete",
V.END_CLICK = "end_click",
V.IMPRESSION = "impression",
V.CANCELED = "canceled",
V.TIME_OUT = "time_out",
V.BOOT = "boot",
V.UPDATE = "update",
V))(PINMessageStatus || {});
class PINSettingsEvent {
    constructor(X) {
        Tt(this, "eventName", "settings");
        Tt(this, "options");
        this.options = X
    }
}
var PINSaveExperienceType = (V => (V.CUSTOM = "CUSTOM",
V.VERIFIED = "VERIFIED",
V))(PINSaveExperienceType || {})
  , PINSaveExperienceStatus = (V => (V.DRAFT = "DRAFT",
V.PUBLISHED = "PUBLISHED",
V.ACTION_NEEDED = "ACTION_NEEDED",
V.ERROR = "ERROR",
V))(PINSaveExperienceStatus || {});
class PINSaveExperienceEvent {
    constructor(X) {
        Tt(this, "eventName", "save_experience");
        Tt(this, "options");
        this.options = X
    }
}
var PINRequestEntityType = (V => (V.PLAYER = "player",
V))(PINRequestEntityType || {})
  , PINRequestHeaderEnvironment = (V => (V.DEV = "dev",
V.TEST = "test",
V.STAGE = "stage",
V.LT = "lt",
V.PROD = "prod",
V))(PINRequestHeaderEnvironment || {})
  , PINRequestHeadersContentType = (V => (V.APPLICATION_JSON = "application/json",
V))(PINRequestHeadersContentType || {})
  , PINRequestPlatformType = (V => (V.ANDROID = "android",
V.IOS = "ios",
V.UNKNOWN = "unknown",
V.OTHER = "other",
V.PC = "pc",
V.MAC = "mac",
V.PS3 = "ps3",
V.PS4 = "ps4",
V.XBOX_ONE = "xbox_one",
V.XBOX_360 = "xbox_360",
V.SWITCH = "switch",
V.WEB = "web",
V))(PINRequestPlatformType || {})
  , PINRequestReleaseType = (V => (V.PROD = "prod",
V.DEMO = "demo",
V.TRIAL = "trial",
V.BETA = "beta",
V))(PINRequestReleaseType || {})
  , PINRequestTitleIdType = (V => (V.PROJECTID = "projectid",
V.SELLID = "sellid",
V.SKU = "sku",
V.SERVICE = "service",
V))(PINRequestTitleIdType || {});
const constructModRules = ({workspace: V, rulesVersion: X, patchId: J}) => V && Object.keys(V).length ? {
    ...!(V != null && V.mainWorkspace) && {
        mod: {
            blocks: {
                blocks: []
            },
            patch: J ? bytesToBase64(new TextEncoder().encode(JSON.stringify({
                id: J
            }))) : void 0,
            rulesVersion: X ?? void 0
        },
        ...V
    }
} : void 0
  , migrateModeRules = (V, X) => {
    var ce, me, ge, Te, _e, Se, Ie, ye;
    const J = X ? [...X] : []
      , ne = [];
    let ue = null;
    if (V) {
        const $e = (ce = V == null ? void 0 : V.mod) != null && ce.spatial ? base64ToBytes(V.mod.spatial) : void 0
          , Ne = (me = V == null ? void 0 : V.mod) != null && me.script ? base64ToBytes((ge = V == null ? void 0 : V.mod) == null ? void 0 : ge.script) : void 0
          , ve = (Te = V == null ? void 0 : V.mod) != null && Te.strings ? base64ToBytes((_e = V == null ? void 0 : V.mod) == null ? void 0 : _e.strings) : void 0;
        if ($e) {
            const ke = getSpatialAttachmentAtIndex(X, 0)
              , xe = ke && indexedDB.cmp($e, (Se = ke == null ? void 0 : ke.attachmentData) == null ? void 0 : Se.original) !== 0;
            if (!ke || xe) {
                console.debug("This experience has modJson spatial data which will be migrated to an Attachment at Map Rotation index 0 upon saving.");
                const we = {
                    attachmentData: {
                        original: $e,
                        compiled: void 0
                    },
                    errors: [],
                    filename: "spatial-migrated-from-modJson-spatial.json",
                    id: generateUUID(),
                    metadata: getMetadataForSpatialAttachment(0),
                    version: SPATIAL_ATTACHMENT_TEMP_VERSION,
                    isProcessable: !0,
                    processingStatus: ProcessingStatus.PROCESSING_STATUS_PENDING,
                    attachmentType: AttachmentType.ATTACHMENT_TYPE_SPATIAL
                };
                xe ? (ke && (ue = {
                    ...ke
                }),
                J.splice(J.findIndex(Fe => Fe.id === (ke == null ? void 0 : ke.id)), 1, we),
                ne.push(ke == null ? void 0 : ke.id),
                console.warn("Your Spatial Attachment at Map Rotation index 0 has been replaced with your modJson Spatial data.  This will only take permanent effect upon saving your Experience.")) : J.push(we),
                delete V.mod.spatial
            }
        }
        if (Ne) {
            const ke = J.find(we => we.attachmentType === AttachmentType.ATTACHMENT_TYPE_SCRIPT)
              , xe = ke && indexedDB.cmp(Ne, (Ie = ke == null ? void 0 : ke.attachmentData) == null ? void 0 : Ie.original) !== 0;
            if (!ke || xe) {
                const we = {
                    attachmentData: {
                        original: Ne,
                        compiled: void 0
                    },
                    errors: [],
                    filename: "script-migrated-from-modJson-script.ts",
                    id: generateUUID(),
                    metadata: void 0,
                    version: SCRIPT_ATTACHMENT_TEMP_VERSION,
                    isProcessable: !0,
                    processingStatus: ProcessingStatus.PROCESSING_STATUS_PENDING,
                    attachmentType: AttachmentType.ATTACHMENT_TYPE_SCRIPT
                };
                xe ? (J.splice(J.findIndex(Fe => Fe.id === (ke == null ? void 0 : ke.id)), 1, we),
                ne.push(ke == null ? void 0 : ke.id),
                console.warn("Your Script Attachment has been replaced with your modJson Script data.  This will only take permanent effect upon saving your Experience.")) : J.push(we),
                delete V.mod.script
            }
        }
        if (ve) {
            const ke = J.find(we => we.attachmentType === AttachmentType.ATTACHMENT_TYPE_STRINGS)
              , xe = ke && indexedDB.cmp(Ne, (ye = ke == null ? void 0 : ke.attachmentData) == null ? void 0 : ye.original) !== 0;
            if (!ke || xe) {
                const we = {
                    attachmentData: {
                        original: ve,
                        compiled: void 0
                    },
                    errors: [],
                    filename: "strings-migrated-from-modJson-strings.json",
                    id: generateUUID(),
                    metadata: void 0,
                    version: STRINGS_ATTACHMENT_TEMP_VERSION,
                    isProcessable: !1,
                    processingStatus: ProcessingStatus.PROCESSING_STATUS_PROCESSED,
                    attachmentType: AttachmentType.ATTACHMENT_TYPE_STRINGS
                };
                xe ? (J.splice(J.findIndex(Fe => Fe.id === (ke == null ? void 0 : ke.id)), 1, we),
                ne.push(ke == null ? void 0 : ke.id),
                console.warn("Your Strings Attachment has been replaced with your modJson Strings data.  This will only take permanent effect upon saving your Experience.")) : J.push(we),
                delete V.mod.strings
            }
        }
    }
    return {
        orphanedSpatialAttachment: ue,
        deletionIds: ne
    }
}
  , base64ToBytes = V => {
    const X = atob(V);
    return Uint8Array.from(X, J => J.codePointAt(0))
}
  , getModRules = V => {
    var J, ne, ue, ce, me, ge, Te, _e, Se, Ie, ye, $e, Ne, ve, ke, xe;
    const X = (J = V == null ? void 0 : V.compatibleRules) != null && J.original && ((ne = V == null ? void 0 : V.compatibleRules) == null ? void 0 : ne.original.length) > 0 ? (ue = V == null ? void 0 : V.compatibleRules) == null ? void 0 : ue.original : (ce = V == null ? void 0 : V.errorRules) != null && ce.original && ((me = V == null ? void 0 : V.errorRules) == null ? void 0 : me.original.length) > 0 ? (ge = V == null ? void 0 : V.errorRules) == null ? void 0 : ge.original : void 0;
    if (X)
        try {
            const we = JSON.parse(new TextDecoder().decode(X));
            return (Ie = (Se = (_e = (Te = we.mod) == null ? void 0 : Te.mod) == null ? void 0 : _e.blocks) == null ? void 0 : Se.blocks) != null && Ie.length || ($e = (ye = we.mod) == null ? void 0 : ye.mod) != null && $e.spatial || (ve = (Ne = we.mod) == null ? void 0 : Ne.mod) != null && ve.script || (xe = (ke = we.mod) == null ? void 0 : ke.mod) != null && xe.strings ? (console.debug("Unwrapping old modJson which was overly-nested"),
            we.mod) : we
        } catch (we) {
            return console.error("Could not parse errorRules:", we),
            {}
        }
    return {}
}
  , getModRulesPayload = V => {
    const J = new TextEncoder().encode(JSON.stringify(V));
    return V && Object.keys(V).length ? J : void 0
}
  , bytesToBase64 = V => {
    const X = Array.from(V, J => String.fromCodePoint(J)).join("");
    return btoa(X)
}
  , downloadFile = (V, X) => {
    const J = document.createElement("a");
    J.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(X)),
    J.setAttribute("download", V),
    J.style.display = "none",
    document.body.appendChild(J),
    J.click(),
    document.body.removeChild(J)
}
  , generateUUID = () => crypto != null && crypto.randomUUID ? crypto.randomUUID() : Array.from(new Array(32)).map( () => (crypto.getRandomValues(new Uint8Array(1))[0] & 15).toString(16)).join("")
  , loadFile = (V, X=["application/json"], J=!1) => {
    const ne = document.createElement("input");
    ne.setAttribute("type", "file"),
    ne.setAttribute("accept", X.join(",")),
    ne.addEventListener("change", () => {
        if (ne.files && ne.files[0]) {
            const ue = new FileReader;
            J ? ue.readAsArrayBuffer(ne.files[0]) : ue.readAsText(ne.files[0]),
            ue.onload = ce => {
                var me, ge, Te, _e, Se, Ie;
                V(ce, (ge = (me = ne == null ? void 0 : ne.files) == null ? void 0 : me[0]) == null ? void 0 : ge.name, (_e = (Te = ne == null ? void 0 : ne.files) == null ? void 0 : Te[0]) == null ? void 0 : _e.size, (Ie = (Se = ne == null ? void 0 : ne.files) == null ? void 0 : Se[0]) == null ? void 0 : Ie.type)
            }
        }
    }
    , !1),
    ne.style.display = "none",
    document.body.appendChild(ne),
    ne.click(),
    document.body.removeChild(ne)
}
  , getMetadataForSpatialAttachment = (V, X) => {
    const J = new URLSearchParams(X ?? "");
    return J.set(ATTACHMENT_METADATA_KEY.MAP_ROTATION_INDEX, `${V}`),
    J.toString()
}
  , getSpatialAttachmentMapRotationIndex = V => {
    if (V.metadata)
        return Number(new URLSearchParams(V.metadata).get(ATTACHMENT_METADATA_KEY.MAP_ROTATION_INDEX))
}
  , getSpatialAttachmentAtIndex = (V=[], X) => V == null ? void 0 : V.find(J => J.attachmentType === AttachmentType.ATTACHMENT_TYPE_SPATIAL && getSpatialAttachmentMapRotationIndex(J) == X)
  , getNewAttachmentsAndDeletionIds = (V, X) => {
    const J = [];
    return X.forEach(ne => {
        if (ne.attachmentType === AttachmentType.ATTACHMENT_TYPE_SCRIPT) {
            const ue = V.filter(ce => ce.attachmentType === AttachmentType.ATTACHMENT_TYPE_SCRIPT);
            ue && J.push(...ue.map(ce => ce.id))
        }
        if (ne.attachmentType === AttachmentType.ATTACHMENT_TYPE_STRINGS) {
            const ue = V.filter(ce => ce.attachmentType === AttachmentType.ATTACHMENT_TYPE_STRINGS);
            ue && J.push(...ue.map(ce => ce.id))
        }
    }
    ),
    {
        attachments: [...V.filter(ne => !J.some(ue => ue === ne.id)), ...X],
        deletionIds: J
    }
}
  , updateAttachmentsAndDeletionIds = (V, X, J) => {
    const ne = []
      , ue = V.find(ce => ce.id === J);
    return ue && Object.assign(ue, {
        attachmentData: {
            original: new TextEncoder().encode(X),
            compiled: void 0
        }
    }),
    {
        attachments: V,
        deletionIds: ne
    }
}
  , getFormattedErrorsFromAttachments = V => (V == null ? void 0 : V.map(X => X.errors.length ? `
                [${t$1(`attachments.attachment-type${X.attachmentType}`).toUpperCase()} ${X.filename}]: ${X.errors.length} error(s)
                  ` : "")) ?? [];
function generateStringFile(V) {
    const X = {}
      , J = V.split(`
`)
      , ne = V.replaceAll(`
`, "")
      , ue = /(?:const|let|var)\s+godotStrings\s+\=\s\{(\s*([\"\']([\w ]*)[\"\'])\s*:\s*([\"\']([\w ]*)[\"\'])\s*,?\s*)*\}/g
      , ce = ne.match(ue);
    if (ce && ce.length > 0) {
        const _e = ce[0].indexOf("=") + 1
          , Se = JSON.parse(ce[0].slice(_e));
        Object.keys(Se).forEach(ye => {
            X[ye] = Se[ye]
        }
        )
    }
    const me = /'([^'"]*)'|"([^'"]*)"/g
      , ge = new Set;
    return J.forEach(_e => {
        for (const Se of _e.matchAll(me)) {
            const Ie = Se[1] ? Se[1] : Se[2];
            ge.add(Ie)
        }
    }
    ),
    Array.from(ge).forEach( (_e, Se) => {
        X[Se] = _e
    }
    ),
    JSON.stringify(X, null, 2)
}
function generateAttachments(V, X) {
    const J = [];
    if (V) {
        const ne = {
            attachmentData: {
                original: new TextEncoder().encode(V),
                compiled: void 0
            },
            attachmentType: AttachmentType.ATTACHMENT_TYPE_SCRIPT,
            errors: [],
            filename: "Script.ts",
            id: generateUUID(),
            isProcessable: !0,
            metadata: void 0,
            processingStatus: ProcessingStatus.PROCESSING_STATUS_PENDING,
            version: SCRIPT_ATTACHMENT_TEMP_VERSION
        };
        J.push(ne)
    }
    if (X) {
        const ne = {
            attachmentData: {
                original: new TextEncoder().encode(X),
                compiled: void 0
            },
            attachmentType: AttachmentType.ATTACHMENT_TYPE_STRINGS,
            errors: [],
            filename: "Strings.json",
            id: generateUUID(),
            isProcessable: !1,
            metadata: void 0,
            processingStatus: ProcessingStatus.PROCESSING_STATUS_PROCESSED,
            version: STRINGS_ATTACHMENT_TEMP_VERSION
        };
        J.push(ne)
    }
    return J
}
const bytesToMbString = V => {
    const X = Number(V);
    return X >= 1048576 ? (X / 1048576).toFixed(2) + " MB" : `${X} B`
}
  , DEFAULT_QUEUE_LENGTH = 50;
class PINClient {
    constructor(X, J, ne) {
        Tt(this, "events", []);
        Tt(this, "clientOptions");
        Tt(this, "userOptions");
        Tt(this, "sessionId");
        Tt(this, "eventQueueLength");
        Tt(this, "batchClient");
        Tt(this, "stepId");
        Tt(this, "eventQueueDuration");
        Tt(this, "eventQueueTimeoutId");
        this.clientOptions = X,
        this.userOptions = J,
        this.sessionId = J.sessionId ? J.sessionId : generateUUID(),
        this.eventQueueLength = 1,
        this.batchClient = ne,
        this.stepId = 0,
        this.eventQueueDuration = X.eventQueueDuration
    }
    async addEvent(X) {
        this.events.length || this.startEventQueueTimer();
        const J = {};
        this.clientOptions.spaVersion && (J.spa_version = this.clientOptions.spaVersion),
        this.stepId += 1;
        const ne = {
            core: {
                s: this.stepId,
                en: X.eventName,
                et: this.clientOptions.eventType,
                ts_event: new Date().toISOString(),
                pid: this.userOptions.nucleusId || this.sessionId,
                pidt: PINEventCorePidType.UID,
                pidm: this.userOptions.playerId ? {
                    persona: this.userOptions.playerId
                } : {},
                ...this.userOptions.dateOfBirth && {
                    dob: this.userOptions.dateOfBirth
                },
                ...Object.keys(J).length !== 0 && {
                    custom: J
                }
            },
            ...structuredClone(X.options)
        };
        this.clientOptions.isDebugMode && console.debug(`%cPINClient: ${X.eventName}`, "background-color: blue; color: white;", ne),
        this.events.push(ne),
        this.events.length >= this.eventQueueLength && this.sendBatch(),
        await this.batchClient.triggerPINSend(),
        this.eventQueueLength = this.clientOptions.eventQueueLength || DEFAULT_QUEUE_LENGTH
    }
    updateUserState(X) {
        X.sessionId && (this.sessionId = X.sessionId),
        this.userOptions = X
    }
    cleanUp() {
        this.events.length > 0 && this.sendBatch(),
        this.batchClient.cleanUp()
    }
    sendBatch() {
        const X = {
            body: structuredClone(this.buildRequestBody()),
            headers: structuredClone(this.buildRequestHeaders()),
            retryCount: 1,
            pending: !1,
            nextRetryTime: Date.now()
        };
        this.batchClient.addRequest(X),
        this.flushEventQueue()
    }
    buildRequestBody() {
        const X = {};
        this.userOptions.screenDimension && (X.screen_dimension = this.userOptions.screenDimension),
        this.userOptions.referer && (X.referer = this.userOptions.referer),
        this.userOptions.userAgent && (X.user_agent = this.userOptions.userAgent);
        const J = this.userOptions.utmTrackingParams;
        return J && (X.utm_tracking = {
            ...J
        }),
        {
            tidt: this.clientOptions.titleIdType,
            tid: this.clientOptions.titleId,
            rel: PINRequestReleaseType.PROD,
            v: this.clientOptions.applicationVersion,
            plat: this.clientOptions.platform,
            et: this.clientOptions.eventType,
            entity_type: PINRequestEntityType.PLAYER,
            taxv: this.clientOptions.taxonomyVersion,
            sid: this.sessionId,
            contexts: [{
                loc: this.userOptions.locale,
                events: this.events
            }],
            ...Object.keys(X).length !== 0 ? {
                custom: X
            } : void 0,
            ts_post: new Date().toISOString()
        }
    }
    buildRequestHeaders() {
        return {
            "content-type": PINRequestHeadersContentType.APPLICATION_JSON,
            "x-ea-taxv": this.clientOptions.taxonomyVersion,
            "x-ea-env": PINRequestHeaderEnvironment.PROD
        }
    }
    flushEventQueue() {
        this.events = [],
        this.clearEventQueueTimer()
    }
    startEventQueueTimer() {
        this.eventQueueDuration !== void 0 && (this.eventQueueTimeoutId = window.setTimeout( () => {
            this.sendBatch(),
            this.batchClient.cleanUp()
        }
        , this.eventQueueDuration))
    }
    clearEventQueueTimer() {
        window.clearTimeout(this.eventQueueTimeoutId)
    }
}
const createClient = (V, X) => {
    let J;
    return V.httpAdapter instanceof FetchClient ? J = new PINBatchClientFetch(V.httpAdapter,V.pinEndpoint) : V.httpAdapter instanceof BeaconClient ? J = new PINBatchClientBeacon(V.httpAdapter,V.pinEndpoint) : (V.errorCallback && V.errorCallback(new Error("Must provide fetch or beacon to batch client")),
    J = new PINBatchClientBeacon(V.httpAdapter,V.pinEndpoint)),
    V.errorCallback && J.setErrorCallback && J.setErrorCallback(V.errorCallback),
    new PINClient(V,X,J)
}
  , platformMap = new Map([[TelemetryPlatform.WEB, PINRequestPlatformType.WEB], [TelemetryPlatform.PC, PINRequestPlatformType.PC], [TelemetryPlatform.MAC, PINRequestPlatformType.MAC]])
  , loginStatusMap = new Map([[TelemetryLoginStatus.SUCCESS, PINLoginStatus.SUCCESS], [TelemetryLoginStatus.ERROR, PINLoginStatus.ERROR], [TelemetryLoginStatus.CANCEL, PINLoginStatus.CANCEL]])
  , settingsStatusMap = {
    [TelemetrySettingsStatusTypes.BOOT]: PINMessageStatus.BOOT,
    [TelemetrySettingsStatusTypes.SENT]: PINMessageStatus.SENT,
    [TelemetrySettingsStatusTypes.UPDATE]: PINMessageStatus.UPDATE
}
  , DEFAULT_ROUTE = TelemetryPageViewCategory.INITIAL_LAUNCH;
class PINAdapter {
    constructor(X) {
        Tt(this, "name", "PINAdapter");
        Tt(this, "client");
        Tt(this, "previousPage");
        Tt(this, "currentPage");
        Tt(this, "messageCounter");
        Tt(this, "locale", "en");
        Tt(this, "pd");
        Tt(this, "sessionLapseTime");
        Tt(this, "clientType");
        this.client = PINAdapter.createPINClient(X),
        this.previousPage = DEFAULT_ROUTE,
        this.currentPage = DEFAULT_ROUTE,
        this.sessionLapseTime = new SessionLapseTime,
        this.messageCounter = new ImpressionCounter
    }
    static createPINClient(X) {
        const {pinEndpoint: J, pinTitleId: ne, pinEventsQueueLength: ue, eventQueueDuration: ce, isDebugMode: me=!1} = X.pinConfiguration;
        if (!J)
            throw new Error("PIN endpoint is not defined");
        const ge = console.warn
          , Te = {
            taxonomyVersion: "2.0",
            applicationVersion: "",
            spaVersion: X.appVersion,
            platform: platformMap.get(TelemetryPlatform.WEB) ?? PINRequestPlatformType.WEB,
            titleId: ne,
            titleIdType: PINRequestTitleIdType.SERVICE,
            eventType: PINEventCoreEventType.WEB_BUILDER,
            pinEndpoint: J,
            isDebugMode: me,
            eventQueueDuration: ce ?? 3e4,
            eventQueueLength: ue,
            httpAdapter: new BeaconClient(navigator.sendBeacon.bind(navigator)),
            errorCallback: ge
        };
        return createClient(Te, {
            locale: X.locale
        })
    }
    async publishLoginEvent(X) {
        const J = loginStatusMap.get(X.status);
        if (!J)
            throw new Error(`Login event status ${X.status} is not valid.`);
        await this.client.addEvent(new PINLoginEvent({
            status: J,
            type: PINLoginType.NUCLEUS
        }))
    }
    async publishLoginErrorEvent(X) {
        await this.client.addEvent(new PINLoginEvent({
            status: PINLoginStatus.ERROR,
            status_code: X.errorReason,
            type: PINLoginType.NUCLEUS
        }))
    }
    async publishLogoutEvent() {
        await this.client.addEvent(new PINLogoutEvent({
            end_reason: PINLogoutReason.NORMAL,
            type: PINLogoutType.NUCLEUS
        }))
    }
    async publishPageViewEvent(X) {
        const J = this.sessionLapseTime.getLapsedSessionDuration();
        this.sessionLapseTime.resetPageDuration(),
        this.previousPage = X.previous ? X.previous : DEFAULT_ROUTE,
        this.currentPage = X.next,
        await this.client.addEvent(new PINPageViewEvent({
            fromid: this.previousPage,
            pgid: X.next,
            from_category: getCategoryFromPath(this.previousPage),
            category: getCategoryFromPath(this.currentPage),
            type: TelemetryPageViewType.WEB_PAGE,
            pgdur: J
        }))
    }
    async publishSaveExperienceEvent(X) {
        await this.client.addEvent(new PINSaveExperienceEvent({
            id: X.id,
            title: X.title,
            description: X.description,
            is_modified: X.isModified,
            short_code: X.shortCode,
            status: PINSaveExperienceStatus[X.status],
            type: PINSaveExperienceType[X.type],
            is_clone: X.isClone,
            clone_coupe_id: X.cloneCoupeId,
            thumbnail: X.thumbnail,
            tags: X.tags,
            script_count: X.scriptCount,
            spatial_count: X.spatialCount,
            maps: X.maps,
            game_mode: X.gameMode
        }))
    }
    async publishUserStateEvent(X) {
        if (this.locale = X.locale,
        X.pd && (this.pd = X.pd),
        X.client) {
            if (!(X.client in TelemetryUserClientType))
                throw new Error(`UserState event client ${X.client} is not valid.`);
            this.clientType = X.client
        }
        const J = mapTelemetryLocale({
            locale: X.locale,
            region: X.region,
            telemetryType: TelemetryType.PIN
        });
        this.client.updateUserState({
            locale: J,
            ...X.pd && {
                nucleusId: X.pd
            },
            ...X.dateOfBirth && {
                dateOfBirth: X.dateOfBirth
            },
            ...X.referrer && {
                referer: X.referrer
            },
            ...X.userAgent && {
                userAgent: X.userAgent
            },
            ...X.utmTrackingParams && {
                utmTrackingParams: X.utmTrackingParams
            },
            ...X.sessionId && {
                sessionId: X.sessionId
            },
            ...X.playerId && {
                playerId: X.playerId
            },
            ...X.screenDimension && {
                screenDimension: X.screenDimension
            }
        })
    }
    async publishSettingsEvent(X) {
        const J = settingsStatusMap[X.status];
        return this.client.addEvent(new PINSettingsEvent({
            status: J,
            destination_name: X.destinationName,
            setting: X.settings
        }))
    }
    cleanUp() {
        this.client.cleanUp()
    }
}
class TelemetryError extends Error {
    constructor(J, ne) {
        super(J);
        Tt(this, "message");
        Tt(this, "failures");
        this.message = J,
        this.failures = ne
    }
}
class TelemetryBaseClient {
    constructor(X) {
        Tt(this, "adapters", []);
        Tt(this, "client");
        Tt(this, "sessionId");
        Tt(this, "entityId");
        this.adapters = X.adapters,
        this.client = X.client,
        this.sessionId = generateUUID()
    }
    async loginError(X) {
        const J = this.adapters.reduce( (ne, ue) => ue.publishLoginErrorEvent ? ne.concat(ue.publishLoginErrorEvent(X)) : ne.concat(Promise.resolve()), []);
        return this.handleAdapters(J, "LoginError")
    }
    async updateUserState(X) {
        X.sessionId ? this.sessionId = X.sessionId : X.sessionId = this.sessionId,
        this.entityId || (this.entityId = X.pd ? X.pd : X.sessionId),
        X.entityId = this.entityId;
        const J = this.adapters.reduce( (ne, ue) => ue.publishUserStateEvent ? ne.concat(ue.publishUserStateEvent(X)) : ne.concat(Promise.resolve()), []);
        return this.handleAdapters(J, "User state")
    }
    cleanUp() {
        this.adapters.forEach(X => {
            var J;
            (J = X.cleanUp) == null || J.call(X)
        }
        )
    }
    async handleAdapters(X, J) {
        try {
            await Promise.all(X)
        } catch (ne) {
            await this.handleError(`${J} - message failed to send with error: ${ne}`, X)
        }
    }
    async handleError(X, J) {
        const ne = [];
        let ue = 0;
        for (const ce of J)
            await ce.catch(me => {
                me instanceof Error && ne.push({
                    adapter: this.adapters[ue],
                    error: me
                })
            }
            ),
            ue = ue + 1;
        throw new TelemetryError(X,ne)
    }
}
class TelemetryClient extends TelemetryBaseClient {
    async login(X) {
        const J = this.adapters.reduce( (ne, ue) => ue.publishLoginEvent ? ne.concat(ue.publishLoginEvent(X)) : ne.concat(Promise.resolve()), []);
        return this.handleAdapters(J, "Login")
    }
    async logout() {
        const X = this.adapters.reduce( (J, ne) => ne.publishLogoutEvent ? J.concat(ne.publishLogoutEvent()) : J.concat(Promise.resolve()), []);
        return this.handleAdapters(X, "Logout")
    }
    async unload() {
        const X = this.adapters.reduce( (J, ne) => ne.publishUnloadEvent ? J.concat(ne.publishUnloadEvent()) : J.concat(Promise.resolve()), []);
        return this.handleAdapters(X, "Time to interactive")
    }
    async pageView(X) {
        const J = this.adapters.reduce( (ne, ue) => ue.publishPageViewEvent ? ne.concat(ue.publishPageViewEvent(X)) : ne.concat(Promise.resolve()), []);
        return this.handleAdapters(J, "Page view")
    }
    async settings(X) {
        const J = this.adapters.reduce( (ne, ue) => ue.publishSettingsEvent ? ne.concat(ue.publishSettingsEvent(X)) : ne.concat(Promise.resolve()), []);
        return this.handleAdapters(J, "Settings")
    }
    async saveExperience(X) {
        const J = this.adapters.reduce( (ne, ue) => ue.publishSaveExperienceEvent ? ne.concat(ue.publishSaveExperienceEvent(X)) : ne.concat(Promise.resolve()), []);
        return this.handleAdapters(J, "Save Experience")
    }
}
class TelemetryCriticalEventsClient extends TelemetryBaseClient {
    async unload() {
        return Promise.resolve()
    }
    async login(X) {
        return Promise.resolve()
    }
    async logout() {
        return Promise.resolve()
    }
    async pageView(X) {
        return Promise.resolve()
    }
    async settings(X) {
        return Promise.resolve()
    }
    async saveExperience(X) {
        return Promise.resolve()
    }
}
const createTelemetryClient = V => new TelemetryClient(V)
  , createCriticalEventsClient = V => new TelemetryCriticalEventsClient(V)
  , TrustArcPreference = {
    REQUIRED: "0:",
    FUNCTIONAL: "1:",
    ALL: "2:"
}
  , TRUST_ARC_PREFERENCES_LOCAL_STORAGE_KEY = "truste.eu.cookie.notice_preferences"
  , COUNTRY_COOKIE_KEY = "COUNTRY"
  , REGION_COOKIE_KEY = "REGION"
  , COOKIE_TRUST_ARC_PREFERENCE = "notice_preferences"
  , COUNTRY_CODES = {
    AUSTRALIA: "au",
    AUSTRIA: "at",
    BELARUS: "by",
    BELGIUM: "be",
    BRAZIL: "br",
    BULGARIA: "bg",
    CANADA: "ca",
    CHINA: "cn",
    CROATIA: "hr",
    CUBA: "cu",
    CYPRUS: "cy",
    CZECH_REPUBLIC: "cz",
    DENMARK: "dk",
    ESTONIA: "ee",
    FINLAND: "fi",
    FRANCE: "fr",
    GERMANY: "de",
    GREAT_BRITAIN: "gb",
    GREECE: "gr",
    HONG_KONG: "hk",
    HUNGARY: "hu",
    INDIA: "in",
    IRAN: "ir",
    IRELAND: "ie",
    ITALY: "it",
    JAPAN: "jp",
    KOREA: "kr",
    LATVIA: "lv",
    LITHUANIA: "lt",
    LUXEMBOURG: "lu",
    MALTA: "mt",
    MEXICO: "mx",
    NETHERLANDS: "nl",
    NEW_ZEALAND: "nz",
    NORTH_KOREA: "kp",
    NORWAY: "no",
    PORTUGAL: "pt",
    POLAND: "pl",
    ROMANIA: "ro",
    RUSSIA: "ru",
    SINGAPORE: "sg",
    SLOVAKIA: "sk",
    SLOVENIA: "si",
    SOUTH_AFRICA: "za",
    SPAIN: "es",
    SWEDEN: "se",
    SWITZERLAND: "ch",
    SYRIA: "sy",
    TAIWAN: "tw",
    THAILAND: "th",
    TURKEY: "tu",
    UKRAINE: "ua",
    UNITED_STATES: "us"
}
  , CANADA_REGION_CODES = {
    QUEBEC: "QC"
}
  , DEFAULT_COUNTRY = COUNTRY_CODES.UNITED_STATES
  , VALID_COUNTRY_OVERRIDE_LOCATIONS_MAP = {
    at: "",
    be: "",
    bg: "",
    hr: "",
    cy: "",
    cz: "",
    dk: "",
    ee: "",
    fi: "",
    fr: "",
    de: "",
    gr: "",
    hu: "",
    is: "",
    ie: "",
    it: "",
    lv: "",
    li: "",
    lt: "",
    lu: "",
    mt: "",
    nl: "",
    no: "",
    pl: "",
    pt: "",
    ro: "",
    sk: "",
    si: "",
    es: "",
    se: "",
    ch: "",
    gb: ""
}
  , getTrustArcPreferenceFromLocalStorage = () => {
    if (typeof navigator == "object" && !navigator.cookieEnabled)
        return TrustArcPreference.REQUIRED;
    const V = isLocalStorageAvailable() && localStorage.getItem(TRUST_ARC_PREFERENCES_LOCAL_STORAGE_KEY);
    if (V)
        try {
            const X = JSON.parse(V);
            if (X && typeof X == "object" && "value"in X && typeof X.value == "string")
                return X.value
        } catch {}
    return null
}
  , getDefaultTrustArcPreference = () => {
    var J;
    const V = (api.get(COUNTRY_COOKIE_KEY) ?? DEFAULT_COUNTRY).toLowerCase()
      , X = (J = api.get(REGION_COOKIE_KEY)) == null ? void 0 : J.toLowerCase();
    return Object.prototype.hasOwnProperty.call(VALID_COUNTRY_OVERRIDE_LOCATIONS_MAP, V) || V === COUNTRY_CODES.KOREA.toLowerCase() || V === COUNTRY_CODES.CANADA.toLowerCase() && X === CANADA_REGION_CODES.QUEBEC.toLocaleLowerCase() ? TrustArcPreference.REQUIRED : TrustArcPreference.ALL
}
  , getTrustArcPreference = () => {
    const V = getTrustArcPreferenceFromLocalStorage();
    switch (V || getTrustArcPreferenceCookie()) {
    case TrustArcPreference.ALL:
        return TrustArcPreference.ALL;
    case TrustArcPreference.FUNCTIONAL:
        return TrustArcPreference.FUNCTIONAL;
    case TrustArcPreference.REQUIRED:
        return TrustArcPreference.REQUIRED;
    default:
        return getDefaultTrustArcPreference()
    }
}
  , getTrustArcPreferenceCookie = () => {
    const V = typeof document > "u" ? "" : document.cookie;
    let X = !1
      , J = TrustArcPreference.ALL;
    return V.split(";").forEach(ne => {
        const [ue,ce] = ne.split("=").map(me => me.trim());
        ue === COOKIE_TRUST_ARC_PREFERENCE && ce && (X = !0,
        parseInt(ce, 10) < parseInt(J, 10) && (J = ce))
    }
    ),
    X ? J : void 0
}
  , isClient = typeof window < "u"
  , getSessionFromLocalStorage = () => {
    if (!isClient)
        return "";
    const V = localStorage.getItem(LOCAL_STORAGE_KEY.TELEMETRY_SESSION_ID);
    if (V !== null)
        return V;
    {
        const X = generateUUID();
        return localStorage.setItem(LOCAL_STORAGE_KEY.TELEMETRY_SESSION_ID, X),
        X
    }
}
  , pi = class pi {
    constructor(X) {
        Tt(this, "_locale", "en-us");
        Tt(this, "_telemetryOptOut", !1);
        Tt(this, "_telemetryOptions");
        Tt(this, "_appVersion");
        Tt(this, "_shouldInitTelemetryClient");
        Tt(this, "_client");
        Tt(this, "_visitId", generateUUID());
        Tt(this, "_userState");
        Tt(this, "_isUserDataLoading", !0);
        Tt(this, "_eventsQueue", []);
        this._telemetryOptOut = X.telemetryOptOut,
        this._telemetryOptions = {
            ...X
        },
        this._shouldInitTelemetryClient = X.shouldInitTelemetryClient,
        this._appVersion = X.appVersion,
        this._client = isClient ? this.createClient() : void 0,
        this._userState = {
            locale: this._locale,
            region: "us",
            pd: "",
            client: TelemetryUserClientType.DESKTOP,
            sessionId: getSessionFromLocalStorage(),
            playerId: ""
        }
    }
    static getInstance(X) {
        return pi.instance || (pi.instance = new pi(X)),
        pi.instance
    }
    setUserState(X) {
        var J;
        this._userState = {
            ...this._userState,
            ...X
        },
        X.sessionId && (this.sessionId = X.sessionId),
        (J = this._client) == null || J.updateUserState(this._userState)
    }
    newVisitId() {
        this._visitId = generateUUID()
    }
    resetClient() {
        var X;
        this._client = void 0,
        this._eventsQueue = [],
        this._client = isClient ? this.createClient() : void 0,
        (X = this._client) == null || X.updateUserState(this._userState)
    }
    set sessionId(X) {
        this._userState.sessionId = X
    }
    get sessionId() {
        return this._userState.sessionId
    }
    get userState() {
        return this._userState
    }
    set visitId(X) {
        this._visitId = X
    }
    get visitId() {
        return this._visitId
    }
    set playerId(X) {
        this._userState.playerId = X
    }
    set isUserDataLoading(X) {
        if (this._isUserDataLoading = X,
        !this._isUserDataLoading)
            for (; this._eventsQueue.length; ) {
                const J = this._eventsQueue.shift();
                J == null || J()
            }
    }
    get isUserDataLoading() {
        return this._isUserDataLoading
    }
    get userStateOptionsLocale() {
        return this._locale
    }
    cleanUp() {
        var X;
        (X = this._client) == null || X.cleanUp()
    }
    newSessionId() {
        isClient && (this.sessionId = generateUUID(),
        sessionStorage.setItem(LOCAL_STORAGE_KEY.TELEMETRY_SESSION_ID, this.sessionId))
    }
    setTelemetryOptOut(X) {
        X !== this._telemetryOptOut && (this._telemetryOptOut = X,
        this.resetClient())
    }
    async pageView(X) {
        var J;
        return this.handleEvent((J = this._client) == null ? void 0 : J.pageView.bind(this._client, X))
    }
    async login(X) {
        var J;
        return this.handleEvent((J = this._client) == null ? void 0 : J.login.bind(this._client, X))
    }
    async loginError(X) {
        var J;
        return this.handleEvent((J = this._client) == null ? void 0 : J.loginError.bind(this._client, X))
    }
    async logout() {
        var X;
        return this.handleEvent((X = this._client) == null ? void 0 : X.logout.bind(this._client))
    }
    async unload() {
        var X;
        return this.handleEvent((X = this._client) == null ? void 0 : X.unload.bind(this._client))
    }
    async updateUserState(X) {
        var J;
        return this.handleEvent((J = this._client) == null ? void 0 : J.updateUserState.bind(this._client, X))
    }
    async settings(X) {
        var J;
        return this.handleEvent((J = this._client) == null ? void 0 : J.settings.bind(this._client, X))
    }
    async saveExperience(X) {
        var J;
        return this.handleEvent((J = this._client) == null ? void 0 : J.saveExperience.bind(this._client, X))
    }
    handleEvent(X) {
        if (X) {
            if (this._isUserDataLoading) {
                this._eventsQueue.push(X);
                return
            }
            return X()
        }
    }
    createClient() {
        const X = [];
        if (this._shouldInitTelemetryClient)
            try {
                X.push(new PINAdapter({
                    ...this._telemetryOptions,
                    locale: this.userStateOptionsLocale
                }))
            } catch {}
        return this._telemetryOptOut ? createCriticalEventsClient({
            adapters: X
        }) : createTelemetryClient({
            adapters: X
        })
    }
}
;
Tt(pi, "instance");
let TelemetryHelper = pi;
const telemetryHelper = TelemetryHelper.getInstance({
    telemetryOptOut: getTrustArcPreference() === TrustArcPreference.REQUIRED,
    appVersion: "1.0.1.0c",
    pinConfiguration: {
        pinTitleId: "bf6_webportal",
        pinEndpoint: "https://pin-river.data.ea.com/pinEvents",
        pinEventsQueueLength: 50,
        isDebugMode: !1,
        eventQueueDuration: 3e4
    },
    shouldInitTelemetryClient: !0
});
function getLanguageFromPath(V=document.location.pathname) {
    return SUPPORTED_LOCALES.find(J => {
        var ne;
        return J.toLowerCase() === ((ne = V.split("/")[2]) == null ? void 0 : ne.toLowerCase())
    }
    ) || ""
}
function isLanguageRTL() {
    const V = getLanguageFromPath().toLowerCase();
    return RTL_LOCALES.map(J => J.toLowerCase()).includes(V)
}
function getFontFallback(V) {
    const X = getLanguageFromPath().toLowerCase();
    return (V ? V + ", " : "") + (languageFontFallbacks[X] ? languageFontFallbacks[X] + ", " : "") + "sans-serif"
}
const getAbsolutePathWithLocale = (V, X) => {
    const J = getLanguageFromPath(X);
    return `/bf6${J ? `/${J.toLowerCase()}` : ""}${V}`
}
  , TelemetryContext = reactExports.createContext({
    telemetry: void 0
})
  , TelemetryProvider = ({player: V, children: X}) => {
    var J, ne, ue, ce;
    if (V) {
        const ge = (getLanguageFromPath() ?? LOCALE.ENGLISH_US).toLowerCase().split("-")[1];
        V != null && V.nucleusId ? (telemetryHelper.updateUserState({
            pd: `${V.nucleusId}`,
            personaId: `${V.personaId}`,
            locale: (getLanguageFromPath() ?? LOCALE.ENGLISH_US).toLowerCase(),
            region: ge,
            screenDimension: (J = window == null ? void 0 : window.visualViewport) != null && J.width && ((ne = window == null ? void 0 : window.visualViewport) != null && ne.height) ? {
                width: (ue = window == null ? void 0 : window.visualViewport) == null ? void 0 : ue.width,
                height: (ce = window == null ? void 0 : window.visualViewport) == null ? void 0 : ce.height
            } : void 0
        }),
        telemetryHelper.isUserDataLoading = !1,
        telemetryHelper.login({
            status: TelemetryLoginStatus.SUCCESS
        })) : (telemetryHelper.updateUserState({
            pd: void 0,
            personaId: void 0,
            locale: (getLanguageFromPath() || LOCALE.ENGLISH_US).toLowerCase(),
            region: ge
        }),
        telemetryHelper.isUserDataLoading = !0)
    }
    return jsxRuntimeExports.jsx(TelemetryContext.Provider, {
        value: {
            telemetry: telemetryHelper
        },
        children: X
    })
}
;
async function fetchTranslations(V, X, J) {
    if (!J) {
        const ne = new Error("Missing session!");
        throw ne.name = "Unauthenticated",
        ne
    }
    return await clients.localization.getTranslations({
        translationsQuery: {
            sidList: {
                sids: V
            }
        },
        locale: X
    }, new grpcWebClient_umdExports.grpc.Metadata({
        "x-gateway-session-id": J
    }))
}
const useTranslationsQuery = (V, X, J, ne) => {
    const ue = REROUTED_LOCALES.get(V)
      , {data: ce, isLoading: me} = useQuery({
        queryKey: [QUERY_KEY.TRANSLATIONS, ue ?? V, J],
        queryFn: () => fetchTranslations(X, ue ?? V, ne),
        enabled: !!ne && !!X.length,
        refetchOnWindowFocus: !1,
        staleTime: MS_1_HOUR,
        select: reactExports.useCallback(ge => ge.localizedTexts, [])
    });
    return [ce, me]
}
;
var blockly$1 = {
    exports: {}
}, browser$1 = {
    exports: {}
}, coreBrowser = {
    exports: {}
}, blockly = {
    exports: {}
}, blockly_compressed = {
    exports: {}
}, hasRequiredBlockly_compressed;
function requireBlockly_compressed() {
    return hasRequiredBlockly_compressed || (hasRequiredBlockly_compressed = 1,
    function(V, X) {
        (function(J, ne) {
            V.exports = ne()
        }
        )(commonjsGlobal, function() {
            var J = {}, ne, ue, ce, me, ge, Te, _e, Se, Ie, ye, $e, Ne, ve, ke, xe, we, Fe, je, Xe, ze, qe, Ze, et, it, at, rt, ft, St, Ye, We, nt, ct, Et, Ke, mt, lt, Qe, gt, Nt, Gt, Ht, Kt, Ot, kt, Xt, vt, Jt, Ct, Mt, nn, tn, mn, dn, Qt, on, zt, $t, Ut, An, yt, Dt, Bt, Wt, ut, Ge, st, ht, At, Ft, an, Sn, Rn, ts, yn, xn, En, wn, Qn, pr, ar, _t, Be, Je, ot, pt, xt, Vt, Pt, qt, rn, un, fn, On, Hn, Kn, er, Wn, tr, ms, fs, vr, _r, Hs, oo, zr, wo, Bo, Un, ur, io, Kr, nr, ns, Si, xa, Cp, bl, Ii, $l, vp, jc, Wc, xp, Np, Uo, Lp, Ol, Cl, Pp, Yc, Na, gs, Mp, Xc, vl, kp, zc, Dp, Kc, La, wp, Bp, ao, Jc, Es, Up, Fp, Hp, lo, qc, Vp, Gp, jp, Wp, Yp, Qc, Xp, zp, xl, Kp, Jp, Zc, Nl, Ll, qp, Ts, Qp, Zp, em, tm, nm, rm, sm, eu, co, Ri, tu, om, im, am, lm, cm, um, dm, hm, nu, pm, mm, fm, gm, Em, Tm, yi, ru, Am, _m, rs, Jn, Fo, Sm, su, Pl, Jr, ou, Ml, iu, au, Im, Rm, ym, lu, bm, cu, Pa, $m, Om, Cm, vm, Ma, uu, du, hu, xm, bi, pu, $i, mu, fu, gu, Oi, kl, Dl, Nm, ka, Eu, Tu, Au, _u, Su, Iu, Lm, Da, Ru, Ci, wl, ss, yu, bu, $u, Ou, Cu, vu, xu, vi, Pm, wa, Nu, Lu, Mm, Bl, Pu, km, Dm, wm, Bm, Um, xi, Mu, ku, Ni, Ul, Fm, Hm, Du, wu, Vs, Bu, Uu, Vm, Gm, jm, Wm, Gs, uo, Fl, Fu, Hl, Hu, ho, Ba, Vl, Gl, Ho, Vu, jl, Gu, rr, Ym, Li, po, Wl, Ur, Xm, zm, Km, Jm, ju, qm, Wu, Yl, Qm, Zm, ef, Yu, Xl, Xu, zl, tf, nf, rf, sf, gn, xr, mr, qn, As, Pi, ln, sr, zu, of, Kl, Ku, af, Ju, Jl, qu, Qu, lf, Zu, cf, ed, Ua, uf, df, hf, Mi, pf, td, nd, rd, sd, ql, od, Fa, id, ad, ld, cd, ud, dd, hd, pd, md, fd, gd, Ed, mf, ff, ki, Td, gf, Ql, Ad, _d, Sd, Id, Rd, yd, bd, $d, Zl, Ha, Od, Ef, Cd, vd, xd, Nd, Ld, Pd, Md, Tf, kd, Af, _f, Sf, If, Rf, yf, bf, $f, Of, Cf, vf, Tn;
            ne = function(Q, oe, pe, Ae) {
                if (!(Q instanceof Yt) && typeof Q != "string" || `${Q}`.trim() === "")
                    throw Error('Invalid type "' + Q + '". The type must be a non-empty string or a Blockly.registry.Type.');
                if (Q = `${Q}`.toLowerCase(),
                typeof oe != "string" || oe.trim() === "")
                    throw Error('Invalid name "' + oe + '". The name must be a non-empty string.');
                const Re = oe.toLowerCase();
                if (!pe)
                    throw Error("Can not register a null value");
                let Ue = mo[Q]
                  , tt = ec[Q];
                if (Ue || (Ue = mo[Q] = Object.create(null),
                tt = ec[Q] = Object.create(null)),
                ue(Q, pe),
                !Ae && Ue[Re])
                    throw Error('Name "' + Re + '" with type "' + Q + '" already registered.');
                Ue[Re] = pe,
                tt[Re] = oe
            }
            ,
            ue = function(Q, oe) {
                switch (Q) {
                case String(Yt.FIELD):
                    if (typeof oe.fromJson != "function")
                        throw Error('Type "' + Q + '" must have a fromJson function')
                }
            }
            ,
            ce = function(Q, oe) {
                Q = `${Q}`.toLowerCase(),
                oe = oe.toLowerCase();
                const pe = mo[Q];
                pe && pe[oe] ? (delete mo[Q][oe],
                delete ec[Q][oe]) : console.warn("Unable to unregister [" + oe + "][" + Q + "] from the registry.")
            }
            ,
            me = function(Q, oe, pe) {
                Q = `${Q}`.toLowerCase(),
                oe = oe.toLowerCase();
                const Ae = mo[Q];
                if (!Ae || !Ae[oe]) {
                    if (oe = "Unable to find [" + oe + "][" + Q + "] in the registry.",
                    pe)
                        throw Error(oe + " You must require or register a " + Q + " plugin.");
                    return console.warn(oe),
                    null
                }
                return Ae[oe]
            }
            ,
            ge = function(Q, oe) {
                return Q = `${Q}`.toLowerCase(),
                oe = oe.toLowerCase(),
                (Q = mo[Q]) ? !!Q[oe] : !1
            }
            ,
            Te = function(Q, oe, pe) {
                return me(Q, oe, pe)
            }
            ,
            _e = function(Q, oe, pe) {
                return me(Q, oe, pe)
            }
            ,
            Se = function(Q, oe, pe) {
                Q = `${Q}`.toLowerCase();
                var Ae = mo[Q];
                if (!Ae) {
                    if (Ae = `Unable to find [${Q}] in the registry.`,
                    pe)
                        throw Error(`${Ae} You must require or register a ${Q} plugin.`);
                    return console.warn(Ae),
                    null
                }
                if (!oe)
                    return Ae;
                Q = ec[Q],
                pe = Object.create(null);
                for (const Re of Object.keys(Ae))
                    pe[Q[Re]] = Ae[Re];
                return pe
            }
            ,
            Ie = function(Q, oe, pe) {
                return oe = oe.plugins[String(Q)] || js,
                typeof oe == "function" ? oe : Te(Q, oe, pe)
            }
            ,
            ye = function(Q) {
                return Va[Q] || null
            }
            ,
            $e = function() {
                const Q = [];
                for (const oe in Va)
                    Q.push(Va[oe]);
                return Q
            }
            ,
            Ne = function(Q) {
                Va[Q.id] = Q
            }
            ,
            ve = function(Q) {
                delete Va[Q.id]
            }
            ,
            ke = function() {
                return xf
            }
            ,
            xe = function(Q) {
                xf = Q
            }
            ,
            we = function() {
                return Nf
            }
            ,
            Fe = function(Q) {
                Nf = Q
            }
            ,
            je = function() {
                return Lf
            }
            ,
            Xe = function(Q) {
                Lf = Q
            }
            ,
            ze = function(Q) {
                for (; Q.options.parentWorkspace; )
                    Q = Q.options.parentWorkspace;
                const oe = Q.getParentSvg()
                  , pe = Q.getCachedParentSvgSize();
                var Ae = oe.parentElement;
                if (Ae instanceof HTMLElement) {
                    var Re = Ae.offsetWidth;
                    Ae = Ae.offsetHeight,
                    pe.width !== Re && (oe.setAttribute("width", Re + "px"),
                    Q.setCachedParentSvgSize(Re, null)),
                    pe.height !== Ae && (oe.setAttribute("height", Ae + "px"),
                    Q.setCachedParentSvgSize(null, Ae)),
                    Q.resize()
                }
            }
            ,
            qe = function(Q, oe) {
                const pe = Object.create(null)
                  , Ae = Q.getDescendants(!0);
                oe && (Q = Q.getNextBlock()) && (Q = Ae.indexOf(Q),
                Ae.splice(Q, Ae.length - Q));
                for (let Re = 0, Ue; Ue = Ae[Re]; Re++)
                    pe[Ue.type] ? pe[Ue.type]++ : pe[Ue.type] = 1;
                return pe
            }
            ,
            Ze = function(Q) {
                return function() {
                    this.jsonInit(Q)
                }
            }
            ,
            et = function(Q) {
                Pf.defineBlocksWithJsonArrayInternal(Q)
            }
            ,
            it = function(Q) {
                J.defineBlocks$$module$build$src$core$common(J.createBlockDefinitionsFromJsonArray$$module$build$src$core$common(Q))
            }
            ,
            J.createBlockDefinitionsFromJsonArray$$module$build$src$core$common = function(Q) {
                const oe = {};
                for (let pe = 0; pe < Q.length; pe++) {
                    const Ae = Q[pe];
                    if (!Ae) {
                        console.warn(`Block definition #${pe} in JSON array is ${Ae}. Skipping`);
                        continue
                    }
                    const Re = Ae.type;
                    Re ? oe[Re] = {
                        init: Ze(Ae)
                    } : console.warn(`Block definition #${pe} in JSON array is missing a type attribute. Skipping.`)
                }
                return oe
            }
            ,
            J.defineBlocks$$module$build$src$core$common = function(Q) {
                for (const oe of Object.keys(Q)) {
                    const pe = Q[oe];
                    oe in Nr && console.warn(`Block definiton "${oe}" overwrites previous definition.`),
                    Nr[oe] = pe
                }
            }
            ,
            at = function() {
                return "blockly-" + (QE++).toString(36)
            }
            ,
            rt = function() {
                return kf.genUid()
            }
            ,
            ft = function(Q) {
                wi = Q
            }
            ,
            St = function() {
                return wi
            }
            ,
            Ye = function(Q) {
                sc.fireInternal(Q)
            }
            ,
            We = function(Q) {
                if (Ke()) {
                    if (!Yo.length)
                        try {
                            requestAnimationFrame( () => {
                                setTimeout(nt, 0)
                            }
                            )
                        } catch {
                            setTimeout(nt, 0)
                        }
                    Yo.push(Q)
                }
            }
            ,
            nt = function() {
                var Q = ct(Yo, !0);
                Yo.length = 0;
                for (let pe = 0, Ae; Ae = Q[pe]; pe++)
                    if (Ae.workspaceId) {
                        var oe = ye(Ae.workspaceId);
                        oe && oe.fireChangeListener(Ae)
                    }
                Q = new Set(Q.map(pe => pe.workspaceId));
                for (const pe of Q) {
                    if (!pe || (Q = ye(pe),
                    !Q))
                        continue;
                    Q = Q.getUndoStack();
                    let Ae;
                    for (oe = Q.length; 0 < oe; oe--) {
                        const Re = Q[oe - 1];
                        if (Re.group === "")
                            break;
                        if (Ae === void 0)
                            Ae = Re.group;
                        else if (Re.group !== Ae)
                            break
                    }
                    Ae && oe != Q.length - 1 && (oe = Q.splice(oe, Q.length - oe),
                    oe = ct(oe, !0),
                    Q.push(...oe))
                }
            }
            ,
            ct = function(Q, oe) {
                Q = Q.slice(),
                oe || Q.reverse();
                const pe = []
                  , Ae = Object.create(null);
                for (let tt = 0, dt; dt = Q[tt]; tt++)
                    if (!dt.isNull()) {
                        var Re = [dt.isUiEvent ? nc : dt.type, dt.blockId, dt.workspaceId].join(" ")
                          , Ue = Ae[Re];
                        const wt = Ue ? Ue.event : null;
                        Ue ? dt.type === J.MOVE$$module$build$src$core$events$utils && Ue.index === tt - 1 ? (Re = dt,
                        wt.newParentId = Re.newParentId,
                        wt.newInputName = Re.newInputName,
                        wt.newCoordinate = Re.newCoordinate,
                        Re.reason && (wt.reason ? (Re = new Set(Re.reason.concat(wt.reason)),
                        wt.reason = Array.from(Re)) : wt.reason = Re.reason),
                        Ue.index = tt) : dt.type === J.CHANGE$$module$build$src$core$events$utils && dt.element === wt.element && dt.name === wt.name ? wt.newValue = dt.newValue : dt.type === Eo ? (Ue = dt,
                        wt.viewTop = Ue.viewTop,
                        wt.viewLeft = Ue.viewLeft,
                        wt.scale = Ue.scale,
                        wt.oldScale = Ue.oldScale) : (dt.type !== Xs || wt.type !== _s) && (Ae[Re] = {
                            event: dt,
                            index: tt
                        },
                        pe.push(dt)) : (Ae[Re] = {
                            event: dt,
                            index: tt
                        },
                        pe.push(dt))
                    }
                Q = pe.filter(function(tt) {
                    return !tt.isNull()
                }),
                oe || Q.reverse();
                for (let tt = 1, dt; dt = Q[tt]; tt++)
                    dt.type === J.CHANGE$$module$build$src$core$events$utils && dt.element === "mutation" && Q.unshift(Q.splice(tt, 1)[0]);
                return Q
            }
            ,
            Et = function() {
                for (let Q = 0, oe; oe = Yo[Q]; Q++)
                    oe.recordUndo = !1
            }
            ,
            J.disable$$module$build$src$core$events$utils = function() {
                tc++
            }
            ,
            J.enable$$module$build$src$core$events$utils = function() {
                tc--
            }
            ,
            Ke = function() {
                return tc === 0
            }
            ,
            J.getGroup$$module$build$src$core$events$utils = function() {
                return wd
            }
            ,
            J.setGroup$$module$build$src$core$events$utils = function(Q) {
                sc.setGroupInternal(Q)
            }
            ,
            mt = function(Q) {
                wd = typeof Q == "boolean" ? Q ? rt() : "" : Q
            }
            ,
            lt = function(Q) {
                const oe = [];
                Q = Q.getDescendants(!1);
                for (let pe = 0, Ae; Ae = Q[pe]; pe++)
                    oe[pe] = Ae.id;
                return oe
            }
            ,
            Qe = function(Q, oe) {
                const pe = gt(Q.type);
                if (!pe)
                    throw Error("Unknown event type.");
                return pe.fromJson(Q, oe)
            }
            ,
            gt = function(Q) {
                const oe = Te(Yt.EVENT, Q);
                if (!oe)
                    throw Error(`Event type ${Q} not found in registry.`);
                return oe
            }
            ,
            Nt = function(Q) {
                if ((Q.type === J.MOVE$$module$build$src$core$events$utils || Q.type === J.CREATE$$module$build$src$core$events$utils) && Q.workspaceId) {
                    var oe = ye(Q.workspaceId);
                    if (!Q.blockId)
                        throw Error("Encountered a blockEvent without a proper blockId");
                    if (Q = oe.getBlockById(Q.blockId)) {
                        const pe = wi;
                        try {
                            wi = !1;
                            const Ae = Q.getParent();
                            if (Ae && Ae.isEnabled()) {
                                const Re = Q.getDescendants(!1);
                                for (let Ue = 0, tt; tt = Re[Ue]; Ue++)
                                    tt.setEnabled(!0)
                            } else if ((Q.outputConnection || Q.previousConnection) && !oe.isDragging())
                                do
                                    Q.setEnabled(!1),
                                    Q = Q.getNextBlock();
                                while (Q)
                        } finally {
                            wi = pe
                        }
                    }
                }
            }
            ,
            Gt = function(Q, oe) {
                Ht(),
                ic = setTimeout(function() {
                    oe && oe.handleRightClick(Q)
                }, ZE)
            }
            ,
            Ht = function() {
                ic && (clearTimeout(ic),
                ic = 0)
            }
            ,
            Kt = function() {
                oc = null
            }
            ,
            Ot = function(Q) {
                return !Q.type.startsWith("pointer") || Q instanceof PointerEvent && Xt(Q)
            }
            ,
            kt = function(Q) {
                return `${Q.pointerId}`
            }
            ,
            Xt = function(Q) {
                const oe = kt(Q);
                return oc ? oc === oe : Q.type === "pointerdown" ? (oc = oe,
                !0) : !1
            }
            ,
            vt = function(Q, oe, pe, Ae, Re) {
                function Ue(dt) {
                    (Re || Ot(dt)) && (pe ? Ae.call(pe, dt) : Ae(dt))
                }
                const tt = [];
                if (oe in Xo)
                    for (let dt = 0; dt < Xo[oe].length; dt++) {
                        const wt = Xo[oe][dt];
                        Q.addEventListener(wt, Ue, !1),
                        tt.push([Q, wt, Ue])
                    }
                else
                    Q.addEventListener(oe, Ue, !1),
                    tt.push([Q, oe, Ue]);
                return tt
            }
            ,
            Jt = function(Q, oe, pe, Ae) {
                function Re(tt) {
                    pe ? Ae.call(pe, tt) : Ae(tt)
                }
                const Ue = [];
                if (oe in Xo)
                    for (let tt = 0; tt < Xo[oe].length; tt++) {
                        const dt = Xo[oe][tt];
                        Q.addEventListener(dt, Re, !1),
                        Ue.push([Q, dt, Re])
                    }
                else
                    Q.addEventListener(oe, Re, !1),
                    Ue.push([Q, oe, Re]);
                return Ue
            }
            ,
            Ct = function(Q) {
                const oe = Q[Q.length - 1][2];
                for (; Q.length; ) {
                    const [pe,Ae,Re] = Q.pop();
                    pe.removeEventListener(Ae, Re, !1)
                }
                return oe
            }
            ,
            Mt = function(Q) {
                if (Q.target instanceof HTMLElement) {
                    if (Q.target.isContentEditable || Q.target.getAttribute("data-is-text-input") === "true")
                        return !0;
                    if (Q.target instanceof HTMLInputElement)
                        return Q = Q.target,
                        Q.type === "text" || Q.type === "number" || Q.type === "email" || Q.type === "password" || Q.type === "search" || Q.type === "tel" || Q.type === "url";
                    if (Q.target instanceof HTMLTextAreaElement)
                        return !0
                }
                return !1
            }
            ,
            nn = function(Q) {
                return Q.ctrlKey && Gd ? !0 : Q.button === 2
            }
            ,
            tn = function(Q, oe, pe) {
                const Ae = oe.createSVGPoint();
                return Ae.x = Q.clientX,
                Ae.y = Q.clientY,
                pe || (pe = oe.getScreenCTM().inverse()),
                Ae.matrixTransform(pe)
            }
            ,
            mn = function(Q) {
                switch (Q.deltaMode) {
                default:
                    return {
                        x: Q.deltaX,
                        y: Q.deltaY
                    };
                case 1:
                    return {
                        x: Q.deltaX * Wf,
                        y: Q.deltaY * Wf
                    };
                case 2:
                    return {
                        x: Q.deltaX * Yf,
                        y: Q.deltaY * Yf
                    }
                }
            }
            ,
            dn = function(Q, oe) {
                return oe = Q.indexOf(oe),
                oe === -1 ? !1 : (Q.splice(oe, 1),
                !0)
            }
            ,
            Qt = function(Q) {
                if (Wd)
                    throw Error("CSS already injected");
                Yd += `
` + Q
            }
            ,
            on = function(Q, oe) {
                Wd || (Wd = !0,
                Q && (Q = oe.replace(/[\\/]$/, ""),
                oe = Yd.replace(/<<<PATH>>>/g, Q),
                Yd = "",
                Q = document.createElement("style"),
                Q.id = "blockly-common-style",
                oe = document.createTextNode(oe),
                Q.appendChild(oe),
                document.head.insertBefore(Q, document.head.firstChild)))
            }
            ,
            zt = function(Q, oe, pe, Ae) {
                Q = Q + " was deprecated in " + oe + " and will be deleted in " + pe + ".",
                Ae && (Q += `
Use ` + Ae + " instead."),
                console.warn(Q)
            }
            ,
            $t = function(Q, oe, pe) {
                Q = document.createElementNS(Ga, `${Q}`);
                for (const Ae in oe)
                    Q.setAttribute(Ae, `${oe[Ae]}`);
                return pe && pe.appendChild(Q),
                Q
            }
            ,
            Ut = function(Q, oe) {
                return oe = oe.split(" "),
                oe.every(pe => Q.classList.contains(pe)) ? !1 : (Q.classList.add(...oe),
                !0)
            }
            ,
            An = function(Q, oe) {
                Q.classList.remove(...oe.split(" "))
            }
            ,
            yt = function(Q, oe) {
                return oe = oe.split(" "),
                oe.every(pe => !Q.classList.contains(pe)) ? !1 : (Q.classList.remove(...oe),
                !0)
            }
            ,
            Dt = function(Q, oe) {
                return Q.classList.contains(oe)
            }
            ,
            Bt = function(Q) {
                return Q && Q.parentNode ? Q.parentNode.removeChild(Q) : null
            }
            ,
            Wt = function(Q, oe) {
                const pe = oe.nextSibling;
                if (oe = oe.parentNode,
                !oe)
                    throw Error("Reference node has no parent.");
                pe ? oe.insertBefore(Q, pe) : oe.appendChild(Q)
            }
            ,
            ut = function(Q, oe) {
                return zt("Blockly.utils.dom.containsNode", "version 10", "version 11", 'Use native "contains" DOM method'),
                Q.contains(oe)
            }
            ,
            Ge = function(Q, oe) {
                Q.style.transform = oe,
                Q.style["-webkit-transform"] = oe
            }
            ,
            st = function() {
                zd++,
                os || (os = Object.create(null))
            }
            ,
            ht = function() {
                zd--,
                zd || (os = null)
            }
            ,
            At = function(Q) {
                const oe = Q.textContent + `
` + Q.className.baseVal;
                let pe;
                if (os && (pe = os[oe]))
                    return pe;
                try {
                    pe = Q.getComputedTextLength()
                } catch {
                    return 8 * Q.textContent.length
                }
                return os && (os[oe] = pe),
                pe
            }
            ,
            Ft = function(Q, oe, pe, Ae) {
                return an(Q, oe + "pt", pe, Ae)
            }
            ,
            an = function(Q, oe, pe, Ae) {
                const Re = Q.textContent;
                Q = Re + `
` + Q.className.baseVal;
                var Ue;
                return os && (Ue = os[Q]) || (uc || (Ue = document.createElement("canvas"),
                Ue.className = "blocklyComputeCanvas",
                document.body.appendChild(Ue),
                uc = Ue.getContext("2d")),
                uc.font = pe + " " + oe + " " + Ae,
                Ue = Re ? uc.measureText(Re).width : 0,
                os && (os[Q] = Ue)),
                Ue
            }
            ,
            Sn = function(Q, oe, pe, Ae) {
                const Re = document.createElement("span");
                Re.style.font = pe + " " + oe + " " + Ae,
                Re.textContent = Q,
                Q = document.createElement("div"),
                Q.style.width = "1px",
                Q.style.height = "0",
                oe = document.createElement("div"),
                oe.style.display = "flex",
                oe.style.position = "fixed",
                oe.style.top = "0",
                oe.style.left = "0",
                oe.appendChild(Re),
                oe.appendChild(Q),
                document.body.appendChild(oe),
                pe = {
                    height: 0,
                    baseline: 0
                };
                try {
                    oe.style.alignItems = "baseline",
                    pe.baseline = Q.offsetTop - Re.offsetTop,
                    oe.style.alignItems = "flex-end",
                    pe.height = Q.offsetTop - Re.offsetTop
                } finally {
                    document.body.removeChild(oe)
                }
                return pe
            }
            ,
            Rn = function(Q) {
                return Kf.getSizeInternal(Q)
            }
            ,
            ts = function(Q) {
                if (xn(Q, "display") !== "none")
                    return yn(Q);
                const oe = Q.style
                  , pe = oe.display
                  , Ae = oe.visibility
                  , Re = oe.position;
                oe.visibility = "hidden",
                oe.position = "absolute",
                oe.display = "inline";
                const Ue = Q.offsetWidth;
                return Q = Q.offsetHeight,
                oe.display = pe,
                oe.position = Re,
                oe.visibility = Ae,
                new Yn(Ue,Q)
            }
            ,
            yn = function(Q) {
                return new Yn(Q.offsetWidth,Q.offsetHeight)
            }
            ,
            xn = function(Q, oe) {
                return Q = window.getComputedStyle(Q),
                Q[oe] || Q.getPropertyValue(oe)
            }
            ,
            En = function(Q) {
                const oe = new Zt(0,0);
                Q = Q.getBoundingClientRect();
                var pe = document.documentElement;
                return pe = new Zt(window.pageXOffset || pe.scrollLeft,window.pageYOffset || pe.scrollTop),
                oe.x = Q.left + pe.x,
                oe.y = Q.top + pe.y,
                oe
            }
            ,
            wn = function() {
                const Q = document.body
                  , oe = document.documentElement;
                return new Zt(Q.scrollLeft || oe.scrollLeft,Q.scrollTop || oe.scrollTop)
            }
            ,
            Qn = function(Q) {
                const oe = parseFloat(xn(Q, "borderLeftWidth"))
                  , pe = parseFloat(xn(Q, "borderRightWidth"))
                  , Ae = parseFloat(xn(Q, "borderTopWidth"));
                return Q = parseFloat(xn(Q, "borderBottomWidth")),
                new Vn(Ae,Q,oe,pe)
            }
            ,
            pr = function(Q, oe, pe) {
                Q = ar(Q, oe, pe),
                oe.scrollLeft = Q.x,
                oe.scrollTop = Q.y
            }
            ,
            ar = function(Q, oe, pe) {
                var Ae = En(Q)
                  , Re = En(oe)
                  , Ue = Qn(oe);
                const tt = Ae.x - Re.x - Ue.left;
                return Ae = Ae.y - Re.y - Ue.top,
                Re = yn(Q),
                Q = oe.clientWidth - Re.width,
                Re = oe.clientHeight - Re.height,
                Ue = oe.scrollLeft,
                oe = oe.scrollTop,
                pe ? (Ue += tt - Q / 2,
                oe += Ae - Re / 2) : (Ue += Math.min(tt, Math.max(tt - Q, 0)),
                oe += Math.min(Ae, Math.max(Ae - Re, 0))),
                new Zt(Ue,oe)
            }
            ,
            _t = function(Q) {
                const oe = new Zt(0,0);
                var pe = Q.x && Q.getAttribute("x");
                const Ae = Q.y && Q.getAttribute("y");
                return pe && (oe.x = parseInt(pe)),
                Ae && (oe.y = parseInt(Ae)),
                (pe = (pe = Q.getAttribute("transform")) && pe.match(Jf)) && (oe.x += Number(pe[1]),
                pe[3] && (oe.y += Number(pe[3]))),
                (Q = Q.getAttribute("style")) && -1 < Q.indexOf("translate") && (Q = Q.match(qf)) && (oe.x += Number(Q[1]),
                Q[3] && (oe.y += Number(Q[3]))),
                oe
            }
            ,
            Be = function(Q) {
                let oe = 0
                  , pe = 0;
                for (; Q; ) {
                    const Ae = _t(Q);
                    if (oe += Ae.x,
                    pe += Ae.y,
                    (" " + (Q.getAttribute("class") || "") + " ").indexOf(" injectionDiv ") !== -1)
                        break;
                    Q = Q.parentNode
                }
                return new Zt(oe,pe)
            }
            ,
            Je = function() {
                const Q = wn();
                return new Vn(Q.y,document.documentElement.clientHeight + Q.y,Q.x,document.documentElement.clientWidth + Q.x)
            }
            ,
            ot = function() {
                const Q = document.documentElement
                  , oe = window;
                return new Zt(oe.pageXOffset || Q.scrollLeft,oe.pageYOffset || Q.scrollTop)
            }
            ,
            pt = function(Q, oe) {
                var pe = oe.x;
                oe = oe.y;
                const Ae = Q.getInjectionDiv().getBoundingClientRect();
                return pe = new Zt(pe - Ae.left,oe - Ae.top),
                oe = Q.getOriginOffsetInPixels(),
                Zt.difference(pe, oe).scale(1 / Q.scale)
            }
            ,
            xt = function(Q, oe) {
                var pe = oe.scale(Q.scale);
                oe = pe.x,
                pe = pe.y;
                const Ae = Q.getInjectionDiv().getBoundingClientRect();
                return Q = Q.getOriginOffsetInPixels(),
                new Zt(oe + Ae.left + Q.x,pe + Ae.top + Q.y)
            }
            ,
            Vt = function(Q) {
                ({document: hc=hc, DOMParser: ja=ja, XMLSerializer: Wa=Wa} = Q),
                dc = new ja,
                Kd = new Wa
            }
            ,
            J.createElement$$module$build$src$core$utils$xml = function(Q) {
                return hc.createElementNS(Qf, Q)
            }
            ,
            J.createTextNode$$module$build$src$core$utils$xml = function(Q) {
                return hc.createTextNode(Q)
            }
            ,
            J.textToDom$$module$build$src$core$utils$xml = function(Q) {
                let oe = dc.parseFromString(Q, "text/xml");
                if (oe && oe.documentElement && !oe.getElementsByTagName("parsererror").length)
                    return oe.documentElement;
                if ((oe = dc.parseFromString(Q, "text/html")) && oe.body.firstChild && oe.body.firstChild.nodeName.toLowerCase() === "xml")
                    return oe.body.firstChild;
                throw Error(`DOMParser was unable to parse: ${Q}`)
            }
            ,
            Pt = function(Q) {
                return qt(Kd.serializeToString(Q))
            }
            ,
            qt = function(Q) {
                return Q.replace(rT, oe => `&#${oe.charCodeAt(0)};`)
            }
            ,
            rn = function(Q) {
                return Q ? ((Q instanceof Element || typeof Q == "string") && (Q = ms(Q),
                Q = er(Q)),
                un(Q),
                Q) : null
            }
            ,
            un = function(Q) {
                const oe = Q.kind;
                if (Q = Q.contents,
                oe && oe !== Zf && oe !== Jd)
                    throw Error("Invalid toolbox kind " + oe + ". Please supply either " + Zf + " or " + Jd);
                if (!Q)
                    throw Error("Toolbox must have a contents attribute.")
            }
            ,
            fn = function(Q) {
                return Q ? Q.contents ? Q.contents : Array.isArray(Q) && 0 < Q.length && !Q[0].nodeType ? Q : Wn(Q) : []
            }
            ,
            On = function(Q) {
                return eg.hasCategoriesInternal(Q)
            }
            ,
            Hn = function(Q) {
                if (!Q)
                    return !1;
                const oe = Q.kind;
                return oe ? oe === Jd : !!Q.contents.filter(function(pe) {
                    return pe.kind.toUpperCase() === "CATEGORY"
                }).length
            }
            ,
            Kn = function(Q) {
                return Q && Q.contents ? !!Q.contents.filter(function(oe) {
                    return oe.kind.toUpperCase() === "CATEGORY"
                }).length : !1
            }
            ,
            er = function(Q) {
                const oe = {
                    contents: Wn(Q)
                };
                return Q instanceof Node && tr(Q, oe),
                oe
            }
            ,
            Wn = function(Q) {
                const oe = [];
                let pe = Q.childNodes;
                pe || (pe = Q);
                for (let Ae = 0, Re; Re = pe[Ae]; Ae++) {
                    if (!Re.tagName)
                        continue;
                    Q = {};
                    const Ue = Re.tagName.toUpperCase();
                    Q.kind = Ue,
                    Ue === "BLOCK" ? Q.blockxml = Re : Re.childNodes && 0 < Re.childNodes.length && (Q.contents = Wn(Re)),
                    tr(Re, Q),
                    oe.push(Q)
                }
                return oe
            }
            ,
            tr = function(Q, oe) {
                for (let pe = 0; pe < Q.attributes.length; pe++) {
                    const Ae = Q.attributes[pe];
                    -1 < Ae.nodeName.indexOf("css-") ? (oe.cssconfig = oe.cssconfig || {},
                    oe.cssconfig[Ae.nodeName.replace("css-", "")] = Ae.value) : oe[Ae.nodeName] = Ae.value
                }
            }
            ,
            ms = function(Q) {
                let oe = null;
                if (Q)
                    if (typeof Q == "string") {
                        if (oe = J.textToDom$$module$build$src$core$utils$xml(Q),
                        oe.nodeName.toLowerCase() !== "xml")
                            throw TypeError("Toolbox should be an <xml> document.")
                    } else
                        Q instanceof Element && (oe = Q);
                return oe
            }
            ,
            fs = function(Q, oe, pe, Ae, Re, Ue) {
                const tt = Ue.scrollbar && Ue.scrollbar.canScrollVertically();
                return Q.horizontal === Xi.LEFT ? (pe = Re.absoluteMetrics.left + pe,
                tt && Ue.RTL && (pe += or.scrollbarThickness)) : (pe = Re.absoluteMetrics.left + Re.viewMetrics.width - oe.width - pe,
                tt && !Ue.RTL && (pe -= or.scrollbarThickness)),
                Q.vertical === qs.TOP ? Q = Re.absoluteMetrics.top + Ae : (Q = Re.absoluteMetrics.top + Re.viewMetrics.height - oe.height - Ae,
                Ue.scrollbar && Ue.scrollbar.canScrollHorizontally() && (Q -= or.scrollbarThickness)),
                new Vn(Q,Q + oe.height,pe,pe + oe.width)
            }
            ,
            vr = function(Q, oe) {
                return {
                    horizontal: oe.toolboxMetrics.position === In.LEFT || Q.horizontalLayout && !Q.RTL ? Xi.RIGHT : Xi.LEFT,
                    vertical: oe.toolboxMetrics.position === In.BOTTOM ? qs.TOP : qs.BOTTOM
                }
            }
            ,
            _r = function(Q, oe, pe, Ae) {
                const Re = Q.left
                  , Ue = Q.right - Q.left
                  , tt = Q.bottom - Q.top;
                for (let dt = 0; dt < Ae.length; dt++) {
                    const wt = Ae[dt];
                    Q.intersects(wt) && (Q = pe === So.UP ? wt.top - tt - oe : wt.bottom + oe,
                    Q = new Vn(Q,Q + tt,Re,Re + Ue),
                    dt = -1)
                }
                return Q
            }
            ,
            Hs = function(Q, oe) {
                ng(Q, oe)
            }
            ,
            oo = function(Q) {
                ng = Q
            }
            ,
            zr = function(Q, oe) {
                og.confirmInternal(Q, oe)
            }
            ,
            wo = function(Q, oe) {
                rg(Q, oe)
            }
            ,
            Bo = function(Q) {
                rg = Q
            }
            ,
            Un = function(Q, oe, pe) {
                sg(Q, oe, pe)
            }
            ,
            ur = function(Q) {
                sg = Q
            }
            ,
            io = function(Q) {
                return Q.getVariableModel !== void 0
            }
            ,
            Kr = function(Q) {
                return Q.getProcedureDef !== void 0
            }
            ,
            nr = function(Q) {
                return Q.getProcedureCall !== void 0 && Q.renameProcedure !== void 0
            }
            ,
            J.allUsedVarModels$$module$build$src$core$variables = function(Q) {
                Q = Q.getAllBlocks(!1);
                const oe = new Set;
                for (let pe = 0; pe < Q.length; pe++) {
                    const Ae = Q[pe].getVarModels();
                    if (Ae)
                        for (let Re = 0; Re < Ae.length; Re++) {
                            const Ue = Ae[Re];
                            Ue.getId() && oe.add(Ue)
                        }
                }
                return Array.from(oe.values())
            }
            ,
            J.allDeveloperVariables$$module$build$src$core$variables = function(Q) {
                Q = Q.getAllBlocks(!1);
                const oe = new Set;
                for (let Ae = 0, Re; Re = Q[Ae]; Ae++) {
                    var pe = Re.getDeveloperVariables;
                    if (pe) {
                        pe = pe();
                        for (let Ue = 0; Ue < pe.length; Ue++)
                            oe.add(pe[Ue])
                    }
                }
                return Array.from(oe.values())
            }
            ,
            ns = function(Q) {
                let oe = [];
                const pe = document.createElement("button");
                return pe.setAttribute("text", "%{BKY_NEW_VARIABLE}"),
                pe.setAttribute("callbackKey", "CREATE_VARIABLE"),
                Q.registerButtonCallback("CREATE_VARIABLE", function(Ae) {
                    Ii(Ae.getTargetWorkspace())
                }),
                oe.push(pe),
                Q = Si(Q),
                oe = oe.concat(Q)
            }
            ,
            Si = function(Q) {
                Q = Q.getVariablesOfType("");
                const oe = [];
                if (0 < Q.length) {
                    var pe = Q[Q.length - 1];
                    if (Nr.variables_set) {
                        var Ae = J.createElement$$module$build$src$core$utils$xml("block");
                        Ae.setAttribute("type", "variables_set"),
                        Ae.setAttribute("gap", Nr.math_change ? "8" : "24"),
                        Ae.appendChild(Uo(pe)),
                        oe.push(Ae)
                    }
                    if (Nr.math_change && (Ae = J.createElement$$module$build$src$core$utils$xml("block"),
                    Ae.setAttribute("type", "math_change"),
                    Ae.setAttribute("gap", Nr.variables_get ? "20" : "8"),
                    Ae.appendChild(Uo(pe)),
                    pe = J.textToDom$$module$build$src$core$utils$xml('<value name="DELTA"><shadow type="math_number"><field name="NUM">1</field></shadow></value>'),
                    Ae.appendChild(pe),
                    oe.push(Ae)),
                    Nr.variables_get) {
                        Q.sort(Xa.compareByName);
                        for (let Re = 0, Ue; Ue = Q[Re]; Re++)
                            pe = J.createElement$$module$build$src$core$utils$xml("block"),
                            pe.setAttribute("type", "variables_get"),
                            pe.setAttribute("gap", "8"),
                            pe.appendChild(Uo(Ue)),
                            oe.push(pe)
                    }
                }
                return oe
            }
            ,
            xa = function(Q) {
                return ag.generateUniqueNameInternal(Q)
            }
            ,
            Cp = function(Q) {
                return bl(eh.charAt(0), Q.getAllVariableNames())
            }
            ,
            bl = function(Q, oe) {
                if (!oe.length)
                    return Q;
                const pe = eh;
                let Ae = ""
                  , Re = pe.indexOf(Q);
                for (; ; ) {
                    let Ue = !1;
                    for (let tt = 0; tt < oe.length; tt++)
                        if (oe[tt].toLowerCase() === Q) {
                            Ue = !0;
                            break
                        }
                    if (!Ue)
                        break;
                    Re++,
                    Re === pe.length && (Re = 0,
                    Ae = `${Number(Ae) + 1}`),
                    Q = pe.charAt(Re) + Ae
                }
                return Q
            }
            ,
            Ii = function(Q, oe, pe) {
                function Ae(Ue) {
                    $l(J.Msg$$module$build$src$core$msg.NEW_VARIABLE_TITLE, Ue, function(tt) {
                        if (tt) {
                            var dt = jc(tt, Q);
                            if (dt) {
                                if (dt.type === Re)
                                    var wt = J.Msg$$module$build$src$core$msg.VARIABLE_ALREADY_EXISTS.replace("%1", dt.name);
                                else
                                    wt = J.Msg$$module$build$src$core$msg.VARIABLE_ALREADY_EXISTS_FOR_ANOTHER_TYPE,
                                    wt = wt.replace("%1", dt.name).replace("%2", dt.type);
                                Hs(wt, function() {
                                    Ae(tt)
                                })
                            } else
                                Q.createVariable(tt, Re),
                                oe && oe(tt)
                        } else
                            oe && oe(null)
                    })
                }
                const Re = pe || "";
                Ae("")
            }
            ,
            J.renameVariable$$module$build$src$core$variables = function(Q, oe, pe) {
                function Ae(Re) {
                    const Ue = J.Msg$$module$build$src$core$msg.RENAME_VARIABLE_TITLE.replace("%1", oe.name);
                    $l(Ue, Re, function(tt) {
                        if (tt) {
                            var dt = vp(tt, oe.type, Q)
                              , wt = Wc(oe.name, tt, Q);
                            if (dt || wt) {
                                var sn = "";
                                dt ? sn = J.Msg$$module$build$src$core$msg.VARIABLE_ALREADY_EXISTS_FOR_ANOTHER_TYPE.replace("%1", dt.name).replace("%2", dt.type) : wt && (sn = J.Msg$$module$build$src$core$msg.VARIABLE_ALREADY_EXISTS_FOR_A_PARAMETER.replace("%1", tt).replace("%2", wt)),
                                Hs(sn, function() {
                                    Ae(tt)
                                })
                            } else
                                Q.renameVariableById(oe.getId(), tt),
                                pe && pe(tt)
                        } else
                            pe && pe(null)
                    })
                }
                Ae("")
            }
            ,
            $l = function(Q, oe, pe) {
                Un(Q, oe, function(Ae) {
                    Ae && (Ae = Ae.replace(/[\s\xa0]+/g, " ").trim(),
                    Ae === J.Msg$$module$build$src$core$msg.RENAME_VARIABLE || Ae === J.Msg$$module$build$src$core$msg.NEW_VARIABLE) && (Ae = null),
                    pe(Ae)
                })
            }
            ,
            vp = function(Q, oe, pe) {
                pe = pe.getVariableMap().getAllVariables(),
                Q = Q.toLowerCase();
                for (let Ae = 0, Re; Re = pe[Ae]; Ae++)
                    if (Re.name.toLowerCase() === Q && Re.type !== oe)
                        return Re;
                return null
            }
            ,
            jc = function(Q, oe) {
                oe = oe.getVariableMap().getAllVariables(),
                Q = Q.toLowerCase();
                for (let pe = 0, Ae; Ae = oe[pe]; pe++)
                    if (Ae.name.toLowerCase() === Q)
                        return Ae;
                return null
            }
            ,
            Wc = function(Q, oe, pe) {
                return pe.getProcedureMap().getProcedures().length ? xp(Q, oe, pe) : Np(Q, oe, pe)
            }
            ,
            xp = function(Q, oe, pe) {
                Q = Q.toLowerCase(),
                oe = oe.toLowerCase(),
                pe = pe.getProcedureMap().getProcedures();
                for (const Re of pe) {
                    var Ae = Re.getParameters().filter(io).map(Ue => Ue.getVariableModel().name);
                    if (Ae && (pe = Ae.some(Ue => Ue.toLowerCase() === Q),
                    Ae = Ae.some(Ue => Ue.toLowerCase() === oe),
                    pe && Ae))
                        return Re.getName()
                }
                return null
            }
            ,
            Np = function(Q, oe, pe) {
                Q = Q.toLowerCase(),
                oe = oe.toLowerCase(),
                pe = pe.getAllBlocks(!1);
                for (const Re of pe) {
                    if (!Kr(Re))
                        continue;
                    pe = Re.getProcedureDef();
                    var Ae = pe[1];
                    const Ue = Ae.some(tt => tt.toLowerCase() === Q);
                    if (Ae = Ae.some(tt => tt.toLowerCase() === oe),
                    Ue && Ae)
                        return pe[0]
                }
                return null
            }
            ,
            Uo = function(Q) {
                const oe = J.createElement$$module$build$src$core$utils$xml("field");
                return oe.setAttribute("name", "VAR"),
                oe.setAttribute("id", Q.getId()),
                oe.setAttribute("variabletype", Q.type),
                Q = J.createTextNode$$module$build$src$core$utils$xml(Q.name),
                oe.appendChild(Q),
                oe
            }
            ,
            J.getOrCreateVariablePackage$$module$build$src$core$variables = function(Q, oe, pe, Ae) {
                let Re = J.getVariable$$module$build$src$core$variables(Q, oe, pe, Ae);
                return Re || (Re = Lp(Q, oe, pe, Ae)),
                Re
            }
            ,
            J.getVariable$$module$build$src$core$variables = function(Q, oe, pe, Ae) {
                const Re = Q.getPotentialVariableMap();
                let Ue = null;
                if (oe && (Ue = Q.getVariableById(oe),
                !Ue && Re && (Ue = Re.getVariableById(oe)),
                Ue))
                    return Ue;
                if (pe) {
                    if (Ae === void 0)
                        throw Error("Tried to look up a variable by name without a type");
                    Ue = Q.getVariable(pe, Ae),
                    !Ue && Re && (Ue = Re.getVariable(pe, Ae))
                }
                return Ue
            }
            ,
            Lp = function(Q, oe, pe, Ae) {
                const Re = Q.getPotentialVariableMap();
                return pe || (pe = xa(Q.isFlyout ? Q.targetWorkspace : Q)),
                Re ? Re.createVariable(pe, Ae, oe) : Q.createVariable(pe, Ae, oe)
            }
            ,
            Ol = function(Q, oe) {
                Q = Q.getAllVariables();
                const pe = [];
                if (oe.length !== Q.length)
                    for (let Ae = 0; Ae < Q.length; Ae++) {
                        const Re = Q[Ae];
                        oe.indexOf(Re) === -1 && pe.push(Re)
                    }
                return pe
            }
            ,
            Cl = function(Q, oe) {
                ne(Yt.PASTER, Q, oe)
            }
            ,
            Pp = function(Q) {
                ce(Yt.PASTER, Q)
            }
            ,
            Yc = function(Q) {
                return Xc(Q),
                Mp() ? (vl(),
                Promise.resolve()) : (zi || (zi = new Promise(oe => {
                    sh = oe,
                    lg = window.requestAnimationFrame( () => {
                        vl(),
                        oe()
                    }
                    )
                }
                )),
                zi)
            }
            ,
            Na = function() {
                return zi || Promise.resolve()
            }
            ,
            gs = function() {
                window.cancelAnimationFrame(lg),
                vl(),
                sh && sh()
            }
            ,
            Mp = function() {
                return Gf
            }
            ,
            Xc = function(Q) {
                rh.add(Q);
                const oe = Q.getParent();
                oe ? Xc(oe) : fc.add(Q)
            }
            ,
            vl = function() {
                var Q = new Set([...fc].map(pe => pe.workspace));
                const oe = [...fc].filter(kp);
                for (const pe of oe)
                    zc(pe);
                for (const pe of Q)
                    pe.resizeContents();
                for (const pe of oe)
                    Q = pe.getRelativeToSurfaceXY(),
                    pe.updateComponentLocations(Q);
                fc.clear(),
                rh = new Set,
                zi = null
            }
            ,
            kp = function(Q) {
                return !Q.isDisposed() && !Q.getParent()
            }
            ,
            zc = function(Q) {
                if (rh.has(Q)) {
                    for (const oe of Q.getChildren(!1))
                        zc(oe);
                    Q.renderEfficiently()
                }
            }
            ,
            Dp = function(Q, oe) {
                const pe = J.createElement$$module$build$src$core$utils$xml("xml");
                var Ae = Kc(J.allUsedVarModels$$module$build$src$core$variables(Q));
                Ae.hasChildNodes() && pe.appendChild(Ae),
                Ae = Q.getTopComments(!0);
                for (let Re = 0; Re < Ae.length; Re++)
                    pe.appendChild(Ae[Re].toXmlWithXY(oe));
                for (Q = Q.getTopBlocks(!0),
                Ae = 0; Ae < Q.length; Ae++)
                    pe.appendChild(La(Q[Ae], oe));
                return pe
            }
            ,
            Kc = function(Q) {
                const oe = J.createElement$$module$build$src$core$utils$xml("variables");
                for (let pe = 0; pe < Q.length; pe++) {
                    const Ae = Q[pe]
                      , Re = J.createElement$$module$build$src$core$utils$xml("variable");
                    Re.appendChild(J.createTextNode$$module$build$src$core$utils$xml(Ae.name)),
                    Ae.type && Re.setAttribute("type", Ae.type),
                    Re.id = Ae.getId(),
                    oe.appendChild(Re)
                }
                return oe
            }
            ,
            La = function(Q, oe) {
                if (Q.isInsertionMarker() && (Q = Q.getChildren(!1)[0],
                !Q))
                    return new DocumentFragment;
                let pe = 0;
                if (Q.workspace.RTL && (pe = Q.workspace.getWidth()),
                oe = ao(Q, oe),
                Zc(oe)) {
                    const Ae = Q.getRelativeToSurfaceXY();
                    oe.setAttribute("x", String(Math.round(Q.workspace.RTL ? pe - Ae.x : Ae.x))),
                    oe.setAttribute("y", String(Math.round(Ae.y)))
                }
                return oe
            }
            ,
            wp = function(Q) {
                if (Q.isSerializable()) {
                    const oe = J.createElement$$module$build$src$core$utils$xml("field");
                    return oe.setAttribute("name", Q.name || ""),
                    Q.toXml(oe)
                }
                return null
            }
            ,
            Bp = function(Q, oe) {
                for (let pe = 0; pe < Q.inputList.length; pe++) {
                    const Ae = Q.inputList[pe];
                    for (let Re = 0; Re < Ae.fieldRow.length; Re++) {
                        const Ue = wp(Ae.fieldRow[Re]);
                        Ue && oe.appendChild(Ue)
                    }
                }
            }
            ,
            ao = function(Q, oe) {
                if (Q.isInsertionMarker())
                    return (oe = Q.getChildren(!1)[0]) ? ao(oe) : new DocumentFragment;
                const pe = J.createElement$$module$build$src$core$utils$xml(Q.isShadow() ? "shadow" : "block");
                if (pe.setAttribute("type", Q.type),
                oe || (pe.id = Q.id),
                Q.mutationToDom) {
                    var Ae = Q.mutationToDom();
                    Ae && (Ae.hasChildNodes() || Ae.hasAttributes()) && pe.appendChild(Ae)
                }
                if (Bp(Q, pe),
                Ae = Q.getCommentText()) {
                    var Re = Q.getIcon(Lr.COMMENT)
                      , Ue = Re.getBubbleSize();
                    Re = Re.bubbleIsVisible();
                    var tt = J.createElement$$module$build$src$core$utils$xml("comment");
                    tt.appendChild(J.createTextNode$$module$build$src$core$utils$xml(Ae)),
                    tt.setAttribute("pinned", `${Re}`),
                    tt.setAttribute("h", String(Ue.height)),
                    tt.setAttribute("w", String(Ue.width)),
                    pe.appendChild(tt)
                }
                for (Q.data && (Ae = J.createElement$$module$build$src$core$utils$xml("data"),
                Ae.appendChild(J.createTextNode$$module$build$src$core$utils$xml(Q.data)),
                pe.appendChild(Ae)),
                Ae = 0; Ae < Q.inputList.length; Ae++) {
                    Ue = Q.inputList[Ae];
                    var dt = void 0;
                    if (Re = !0,
                    Ue.type !== J.inputTypes$$module$build$src$core$inputs$input_types.DUMMY && Ue.type !== J.inputTypes$$module$build$src$core$inputs$input_types.END_ROW) {
                        tt = Ue.connection.targetBlock(),
                        Ue.type === J.inputTypes$$module$build$src$core$inputs$input_types.VALUE ? dt = J.createElement$$module$build$src$core$utils$xml("value") : Ue.type === J.inputTypes$$module$build$src$core$inputs$input_types.STATEMENT && (dt = J.createElement$$module$build$src$core$utils$xml("statement"));
                        const sn = Ue.connection.getShadowDom();
                        !sn || tt && tt.isShadow() || dt.appendChild(Jc(sn, oe)),
                        tt && (tt = ao(tt, oe),
                        tt.nodeType === Js.ELEMENT_NODE && (dt.appendChild(tt),
                        Re = !1)),
                        dt.setAttribute("name", Ue.name),
                        Re || pe.appendChild(dt)
                    }
                }
                Q.inputsInline !== void 0 && Q.inputsInline !== Q.inputsInlineDefault && pe.setAttribute("inline", String(Q.inputsInline)),
                Q.isCollapsed() && pe.setAttribute("collapsed", "true"),
                Q.isEnabled() || pe.setAttribute("disabled", "true"),
                Q.isDeletable() || Q.isShadow() || pe.setAttribute("deletable", "false"),
                Q.isMovable() || Q.isShadow() || pe.setAttribute("movable", "false"),
                Q.isEditable() || pe.setAttribute("editable", "false"),
                dt = Q.getNextBlock();
                let wt;
                return dt && (Ae = ao(dt, oe),
                Ae.nodeType === Js.ELEMENT_NODE && (wt = J.createElement$$module$build$src$core$utils$xml("next"),
                wt.appendChild(Ae),
                pe.appendChild(wt))),
                Q = Q.nextConnection && Q.nextConnection.getShadowDom(),
                !Q || dt && dt.isShadow() || wt.appendChild(Jc(Q, oe)),
                pe
            }
            ,
            Jc = function(Q, oe) {
                let pe = Q = Q.cloneNode(!0), Ae;
                for (; pe; )
                    if (oe && pe.nodeName === "shadow" && pe.removeAttribute("id"),
                    pe.firstChild)
                        pe = pe.firstChild;
                    else {
                        for (; pe && !pe.nextSibling; ) {
                            Ae = pe,
                            pe = pe.parentNode;
                            let Re;
                            Ae.nodeType === Js.TEXT_NODE && Ae.data.trim() === "" && ((Re = pe) == null ? void 0 : Re.firstChild) !== Ae && Bt(Ae)
                        }
                        pe && (Ae = pe,
                        pe = pe.nextSibling,
                        Ae.nodeType === Js.TEXT_NODE && Ae.data.trim() === "" && Bt(Ae))
                    }
                return Q
            }
            ,
            Es = function(Q) {
                return Pt(Q).replace(/<(\w+)([^<]*)\/>/g, "<$1$2></$1>")
            }
            ,
            Up = function(Q) {
                Q = Es(Q).split("<");
                let oe = "";
                for (let pe = 1; pe < Q.length; pe++) {
                    const Ae = Q[pe];
                    Ae[0] === "/" && (oe = oe.substring(2)),
                    Q[pe] = oe + "<" + Ae,
                    Ae[0] !== "/" && Ae.slice(-2) !== "/>" && (oe += "  ")
                }
                return Q = Q.join(`
`),
                Q = Q.replace(/(<(\w+)\b[^>]*>[^\n]*)\n *<\/\2>/g, "$1</$2>"),
                Q.replace(/^\n/, "")
            }
            ,
            Fp = function(Q, oe) {
                return oe.setResizesEnabled(!1),
                oe.clear(),
                Q = J.domToWorkspace$$module$build$src$core$xml(Q, oe),
                oe.setResizesEnabled(!0),
                Q
            }
            ,
            J.domToWorkspace$$module$build$src$core$xml = function(Q, oe) {
                let pe = 0;
                oe.RTL && (pe = oe.getWidth());
                const Ae = [];
                st();
                const Re = J.getGroup$$module$build$src$core$events$utils();
                Re || J.setGroup$$module$build$src$core$events$utils(!0),
                oe.setResizesEnabled && oe.setResizesEnabled(!1);
                let Ue = !0;
                try {
                    for (let tt = 0, dt; dt = Q.childNodes[tt]; tt++) {
                        const wt = dt.nodeName.toLowerCase()
                          , sn = dt;
                        if (wt === "block" || wt === "shadow" && !St()) {
                            const zn = lo(sn, oe);
                            Ae.push(zn.id);
                            let jn;
                            const kr = parseInt((jn = sn.getAttribute("x")) != null ? jn : "10", 10);
                            let fa;
                            const ga = parseInt((fa = sn.getAttribute("y")) != null ? fa : "10", 10);
                            isNaN(kr) || isNaN(ga) || zn.moveBy(oe.RTL ? pe - kr : kr, ga, ["create"]),
                            Ue = !1
                        } else {
                            if (wt === "shadow")
                                throw TypeError("Shadow block cannot be a top-level block.");
                            if (wt === "comment")
                                oe.rendered ? Er.fromXmlRendered(sn, oe, pe) : ys.fromXml(sn, oe);
                            else if (wt === "variables") {
                                if (Ue)
                                    qc(sn, oe);
                                else
                                    throw Error("'variables' tag must exist once before block and shadow tag elements in the workspace XML, but it was found in another location.");
                                Ue = !1
                            }
                        }
                    }
                } finally {
                    J.setGroup$$module$build$src$core$events$utils(Re),
                    oe.setResizesEnabled && oe.setResizesEnabled(!0),
                    oe.rendered && gs(),
                    ht()
                }
                return Ye(new (gt(Wo))(oe)),
                Ae
            }
            ,
            Hp = function(Q, oe) {
                if (!oe.getBlocksBoundingBox)
                    return J.domToWorkspace$$module$build$src$core$xml(Q, oe);
                var pe = oe.getBlocksBoundingBox();
                if (Q = J.domToWorkspace$$module$build$src$core$xml(Q, oe),
                pe && pe.top !== pe.bottom) {
                    var Ae = pe.bottom;
                    pe = oe.RTL ? pe.right : pe.left;
                    var Re = 1 / 0;
                    let Ue = -1 / 0
                      , tt = 1 / 0;
                    for (let dt = 0; dt < Q.length; dt++) {
                        const wt = oe.getBlockById(Q[dt]).getRelativeToSurfaceXY();
                        wt.y < tt && (tt = wt.y),
                        wt.x < Re && (Re = wt.x),
                        wt.x > Ue && (Ue = wt.x)
                    }
                    for (Ae = Ae - tt + 10,
                    pe = oe.RTL ? pe - Ue : pe - Re,
                    Re = 0; Re < Q.length; Re++)
                        oe.getBlockById(Q[Re]).moveBy(pe, Ae, ["create"])
                }
                return Q
            }
            ,
            J.domToBlock$$module$build$src$core$xml = function(Q, oe) {
                return Q = lo(Q, oe),
                oe.rendered && gs(),
                Q
            }
            ,
            lo = function(Q, oe) {
                J.disable$$module$build$src$core$events$utils();
                var pe = oe.getAllVariables();
                let Ae;
                try {
                    if (Ae = xl(Q, oe),
                    oe.rendered) {
                        const Re = Ae
                          , Ue = Ae.getDescendants(!1);
                        Re.setConnectionTracking(!1);
                        for (let tt = Ue.length - 1; 0 <= tt; tt--)
                            Ue[tt].initSvg();
                        for (let tt = Ue.length - 1; 0 <= tt; tt--)
                            Ue[tt].queueRender();
                        setTimeout(function() {
                            Re.disposed || Re.setConnectionTracking(!0)
                        }, 1),
                        oe.resizeContents()
                    } else {
                        const Re = Ae.getDescendants(!1);
                        for (let Ue = Re.length - 1; 0 <= Ue; Ue--)
                            Re[Ue].initModel()
                    }
                } finally {
                    J.enable$$module$build$src$core$events$utils()
                }
                if (Ke()) {
                    for (Q = Ol(oe, pe),
                    oe = 0; oe < Q.length; oe++)
                        pe = Q[oe],
                        Ye(new (gt(go))(pe));
                    Ye(new (gt(J.CREATE$$module$build$src$core$events$utils))(Ae))
                }
                return Ae
            }
            ,
            qc = function(Q, oe) {
                for (let Ae = 0; Ae < Q.children.length; Ae++) {
                    var pe = Q.children[Ae];
                    const Re = pe.getAttribute("type")
                      , Ue = pe.getAttribute("id");
                    if (pe = pe.textContent,
                    !pe)
                        break;
                    oe.createVariable(pe, Re, Ue)
                }
            }
            ,
            Vp = function(Q) {
                const oe = {
                    mutation: [],
                    comment: [],
                    data: [],
                    field: [],
                    input: [],
                    next: []
                };
                for (let pe = 0; pe < Q.children.length; pe++) {
                    const Ae = Q.children[pe];
                    if (Ae.nodeType !== Js.TEXT_NODE)
                        switch (Ae.nodeName.toLowerCase()) {
                        case "mutation":
                            oe.mutation.push(Ae);
                            break;
                        case "comment":
                            oe.comment.push(Ae);
                            break;
                        case "data":
                            oe.data.push(Ae);
                            break;
                        case "title":
                        case "field":
                            oe.field.push(Ae);
                            break;
                        case "value":
                        case "statement":
                            oe.input.push(Ae);
                            break;
                        case "next":
                            oe.next.push(Ae);
                            break;
                        default:
                            console.warn("Ignoring unknown tag: " + Ae.nodeName)
                        }
                }
                return oe
            }
            ,
            Gp = function(Q, oe) {
                let pe = !1;
                for (let Ae = 0; Ae < Q.length; Ae++) {
                    const Re = Q[Ae];
                    oe.domToMutation && (oe.domToMutation(Re),
                    oe.initSvg && (pe = !0))
                }
                return pe
            }
            ,
            jp = function(Q, oe) {
                for (let Ae = 0; Ae < Q.length; Ae++) {
                    var pe = Q[Ae];
                    const Re = pe.textContent
                      , Ue = pe.getAttribute("pinned") === "true";
                    let tt;
                    const dt = parseInt((tt = pe.getAttribute("w")) != null ? tt : "50", 10);
                    let wt;
                    pe = parseInt((wt = pe.getAttribute("h")) != null ? wt : "50", 10),
                    oe.setCommentText(Re);
                    const sn = oe.getIcon(Lr.COMMENT);
                    isNaN(dt) || isNaN(pe) || sn.setBubbleSize(new Yn(dt,pe)),
                    sn.setBubbleVisible(Ue),
                    setTimeout( () => sn.setBubbleVisible(Ue), 1)
                }
            }
            ,
            Wp = function(Q, oe) {
                for (let pe = 0; pe < Q.length; pe++)
                    oe.data = Q[pe].textContent
            }
            ,
            Yp = function(Q, oe) {
                for (let pe = 0; pe < Q.length; pe++) {
                    const Ae = Q[pe]
                      , Re = Ae.getAttribute("name");
                    Re ? Kp(oe, Re, Ae) : console.warn(`Ignoring unnamed field in block ${oe.type}`)
                }
            }
            ,
            Qc = function(Q) {
                let oe = null
                  , pe = null;
                for (let Ae = 0; Ae < Q.childNodes.length; Ae++) {
                    const Re = Q.childNodes[Ae];
                    Zc(Re) && (Re.nodeName.toLowerCase() === "block" ? oe = Re : Re.nodeName.toLowerCase() === "shadow" && (pe = Re))
                }
                return {
                    childBlockElement: oe,
                    childShadowElement: pe
                }
            }
            ,
            Xp = function(Q, oe, pe, Ae) {
                for (let Ue = 0; Ue < Q.length; Ue++) {
                    var Re = Q[Ue];
                    const tt = Re.getAttribute("name")
                      , dt = tt ? pe.getInput(tt) : null;
                    if (!dt) {
                        console.warn("Ignoring non-existent input " + tt + " in block " + Ae);
                        break
                    }
                    if (Re = Qc(Re),
                    Re.childBlockElement) {
                        if (!dt.connection)
                            throw TypeError("Input connection does not exist.");
                        xl(Re.childBlockElement, oe, dt.connection, !1)
                    }
                    if (Re.childShadowElement) {
                        let wt;
                        (wt = dt.connection) == null || wt.setShadowDom(Re.childShadowElement)
                    }
                }
            }
            ,
            zp = function(Q, oe, pe) {
                for (let Ae = 0; Ae < Q.length; Ae++) {
                    const Re = Qc(Q[Ae]);
                    if (Re.childBlockElement) {
                        if (!pe.nextConnection)
                            throw TypeError("Next statement does not exist.");
                        if (pe.nextConnection.isConnected())
                            throw TypeError("Next statement is already connected.");
                        xl(Re.childBlockElement, oe, pe.nextConnection, !0)
                    }
                    Re.childShadowElement && pe.nextConnection && pe.nextConnection.setShadowDom(Re.childShadowElement)
                }
            }
            ,
            xl = function(Q, oe, pe, Ae) {
                var Re;
                const Ue = Q.getAttribute("type");
                if (!Ue)
                    throw TypeError("Block type unspecified: " + Q.outerHTML);
                var tt = (Re = Q.getAttribute("id")) != null ? Re : void 0;
                Re = oe.newBlock(Ue, tt),
                tt = Vp(Q);
                const dt = Gp(tt.mutation, Re);
                if (jp(tt.comment, Re),
                Wp(tt.data, Re),
                pe)
                    if (Ae)
                        if (Re.previousConnection)
                            pe.connect(Re.previousConnection);
                        else
                            throw TypeError("Next block does not have previous statement.");
                    else if (Re.outputConnection)
                        pe.connect(Re.outputConnection);
                    else if (Re.previousConnection)
                        pe.connect(Re.previousConnection);
                    else
                        throw TypeError("Child block does not have output or previous statement.");
                if (Yp(tt.field, Re),
                Xp(tt.input, oe, Re, Ue),
                zp(tt.next, oe, Re),
                dt && Re.initSvg(),
                (oe = Q.getAttribute("inline")) && Re.setInputsInline(oe === "true"),
                (oe = Q.getAttribute("disabled")) && Re.setEnabled(oe !== "true" && oe !== "disabled"),
                (oe = Q.getAttribute("deletable")) && Re.setDeletable(oe === "true"),
                (oe = Q.getAttribute("movable")) && Re.setMovable(oe === "true"),
                (oe = Q.getAttribute("editable")) && Re.setEditable(oe === "true"),
                (oe = Q.getAttribute("collapsed")) && Re.setCollapsed(oe === "true"),
                Q.nodeName.toLowerCase() === "shadow") {
                    for (Q = Re.getChildren(!1),
                    oe = 0; oe < Q.length; oe++)
                        if (!Q[oe].isShadow())
                            throw TypeError("Shadow block not allowed non-shadow child.");
                    if (Re.getVarModels().length)
                        throw TypeError("Shadow blocks cannot have variable references.");
                    Re.setShadow(!0)
                }
                return Re
            }
            ,
            Kp = function(Q, oe, pe) {
                const Ae = Q.getField(oe);
                Ae ? Ae.fromXml(pe) : console.warn("Ignoring non-existent field " + oe + " in block " + Q.type)
            }
            ,
            Jp = function(Q) {
                for (let oe = 0; oe < Q.childNodes.length; oe++) {
                    const pe = Q.childNodes[oe];
                    if (pe.nodeName.toLowerCase() === "next") {
                        Q.removeChild(pe);
                        break
                    }
                }
            }
            ,
            Zc = function(Q) {
                return Q.nodeType === Js.ELEMENT_NODE
            }
            ,
            Nl = function(Q) {
                return Q.saveState !== void 0 && Q.loadState !== void 0
            }
            ,
            Ll = function(Q, oe) {
                ne(Yt.SERIALIZER, Q, oe)
            }
            ,
            qp = function(Q) {
                ce(Yt.SERIALIZER, Q)
            }
            ,
            Ts = function(Q, {addCoordinates: oe=!1, addInputBlocks: pe=!0, addNextBlocks: Ae=!0, doFullSerialization: Re=!0, saveIds: Ue=!0}={}) {
                if (Q.isInsertionMarker())
                    return null;
                const tt = {
                    type: Q.type,
                    id: Ue ? Q.id : void 0
                };
                return oe && Zp(Q, tt),
                Qp(Q, tt),
                em(Q, tt, Re),
                tm(Q, tt, Re),
                nm(Q, tt, Re),
                pe && rm(Q, tt, Re, Ue),
                Ae && sm(Q, tt, Re, Ue),
                tt
            }
            ,
            Qp = function(Q, oe) {
                Q.isCollapsed() && (oe.collapsed = !0),
                Q.isEnabled() || (oe.enabled = !1),
                Q.isOwnDeletable() || (oe.deletable = !1),
                Q.isOwnMovable() || (oe.movable = !1),
                Q.isOwnEditable() || (oe.editable = !1),
                Q.inputsInline !== void 0 && Q.inputsInline !== Q.inputsInlineDefault && (oe.inline = Q.inputsInline),
                Q.data && (oe.data = Q.data)
            }
            ,
            Zp = function(Q, oe) {
                const pe = Q.workspace;
                Q = Q.getRelativeToSurfaceXY(),
                oe.x = Math.round(pe.RTL ? pe.getWidth() - Q.x : Q.x),
                oe.y = Math.round(Q.y)
            }
            ,
            em = function(Q, oe, pe) {
                Q.saveExtraState ? (Q = Q.saveExtraState(pe),
                Q !== null && (oe.extraState = Q)) : Q.mutationToDom && (Q = Q.mutationToDom(),
                Q !== null && (oe.extraState = Es(Q).replace(' xmlns="https://developers.google.com/blockly/xml"', "")))
            }
            ,
            tm = function(Q, oe, pe) {
                const Ae = Object.create(null);
                for (const Re of Q.getIcons())
                    Nl(Re) && (Q = Re.saveState(pe)) && (Ae[Re.getType().toString()] = Q);
                Object.keys(Ae).length && (oe.icons = Ae)
            }
            ,
            nm = function(Q, oe, pe) {
                const Ae = Object.create(null);
                for (let Re = 0; Re < Q.inputList.length; Re++) {
                    const Ue = Q.inputList[Re];
                    for (let tt = 0; tt < Ue.fieldRow.length; tt++) {
                        const dt = Ue.fieldRow[tt];
                        dt.isSerializable() && (Ae[dt.name] = dt.saveState(pe))
                    }
                }
                Object.keys(Ae).length && (oe.fields = Ae)
            }
            ,
            rm = function(Q, oe, pe, Ae) {
                const Re = Object.create(null);
                for (let Ue = 0; Ue < Q.inputList.length; Ue++) {
                    const tt = Q.inputList[Ue];
                    if (!tt.connection)
                        continue;
                    const dt = eu(tt.connection, pe, Ae);
                    dt && (Re[tt.name] = dt)
                }
                Object.keys(Re).length && (oe.inputs = Re)
            }
            ,
            sm = function(Q, oe, pe, Ae) {
                Q.nextConnection && (Q = eu(Q.nextConnection, pe, Ae)) && (oe.next = Q)
            }
            ,
            eu = function(Q, oe, pe) {
                const Ae = Q.getShadowState(!0);
                if (Q = Q.targetBlock(),
                !Ae && !Q)
                    return null;
                const Re = Object.create(null);
                return Ae && (Re.shadow = Ae),
                Q && !Q.isShadow() && (Re.block = Ts(Q, {
                    doFullSerialization: oe,
                    saveIds: pe
                })),
                Re
            }
            ,
            co = function(Q, oe, {recordUndo: pe=!1}={}) {
                return Q = Ri(Q, oe, {
                    recordUndo: pe
                }),
                oe.rendered && gs(),
                Q
            }
            ,
            Ri = function(Q, oe, {parentConnection: pe, isShadow: Ae=!1, recordUndo: Re=!1}={}) {
                const Ue = St();
                ft(Re),
                (Re = J.getGroup$$module$build$src$core$events$utils()) || J.setGroup$$module$build$src$core$events$utils(!0),
                J.disable$$module$build$src$core$events$utils();
                let tt;
                try {
                    tt = tu(Q, oe, {
                        parentConnection: pe,
                        isShadow: Ae
                    })
                } finally {
                    J.enable$$module$build$src$core$events$utils()
                }
                if (Ke() && Ye(new (gt(J.CREATE$$module$build$src$core$events$utils))(tt)),
                J.setGroup$$module$build$src$core$events$utils(Re),
                ft(Ue),
                oe.rendered) {
                    const dt = tt;
                    setTimeout( () => {
                        dt.disposed || dt.setConnectionTracking(!0)
                    }
                    , 1)
                }
                return tt
            }
            ,
            tu = function(Q, oe, {parentConnection: pe, isShadow: Ae=!1}={}) {
                if (!Q.type)
                    throw new cg(Q);
                const Re = oe.newBlock(Q.type, Q.id);
                return Re.setShadow(Ae),
                om(Re, Q),
                im(Re, Q),
                am(Re, Q),
                lm(pe, Re, Q),
                cm(Re, Q),
                um(Re, Q),
                dm(Re, Q),
                hm(Re, Q),
                pm(Re, oe.rendered),
                Re
            }
            ,
            om = function(Q, oe) {
                let pe = oe.x === void 0 ? 0 : oe.x;
                oe = oe.y === void 0 ? 0 : oe.y;
                const Ae = Q.workspace;
                pe = Ae.RTL ? Ae.getWidth() - pe : pe,
                Q.moveBy(pe, oe)
            }
            ,
            im = function(Q, oe) {
                oe.collapsed && Q.setCollapsed(!0),
                oe.deletable === !1 && Q.setDeletable(!1),
                oe.movable === !1 && Q.setMovable(!1),
                oe.editable === !1 && Q.setEditable(!1),
                oe.enabled === !1 && Q.setEnabled(!1),
                oe.inline !== void 0 && Q.setInputsInline(oe.inline),
                oe.data !== void 0 && (Q.data = oe.data)
            }
            ,
            am = function(Q, oe) {
                oe.extraState && (Q.loadExtraState ? Q.loadExtraState(oe.extraState) : Q.domToMutation && Q.domToMutation(J.textToDom$$module$build$src$core$utils$xml(oe.extraState)))
            }
            ,
            lm = function(Q, oe, pe) {
                if (Q) {
                    if (Q.getSourceBlock().isShadow() && !oe.isShadow())
                        throw new dg(pe);
                    if (Q.type === J.inputTypes$$module$build$src$core$inputs$input_types.VALUE) {
                        var Ae = oe.outputConnection;
                        if (!Ae)
                            throw new za("output",oe,pe)
                    } else if (Ae = oe.previousConnection,
                    !Ae)
                        throw new za("previous",oe,pe);
                    if (!Q.connect(Ae)) {
                        const Re = oe.workspace.connectionChecker;
                        throw new ug(Re.getErrorMessage(Re.canConnectWithReason(Ae, Q, !1), Ae, Q),Q.type === J.inputTypes$$module$build$src$core$inputs$input_types.VALUE ? "output connection" : "previous connection",oe,pe)
                    }
                }
            }
            ,
            cm = function(Q, oe) {
                if (oe.icons) {
                    var pe = Object.keys(oe.icons);
                    for (const Re of pe) {
                        pe = oe.icons[Re];
                        var Ae = Q.getIcon(Re);
                        if (!Ae) {
                            if (Ae = Te(Yt.ICON, Re, !1),
                            !Ae)
                                throw new hg(Re,Q,oe);
                            Ae = new Ae(Q),
                            Q.addIcon(Ae)
                        }
                        Nl(Ae) && Ae.loadState(pe)
                    }
                }
            }
            ,
            um = function(Q, oe) {
                if (oe.fields) {
                    var pe = Object.keys(oe.fields);
                    for (let Ae = 0; Ae < pe.length; Ae++) {
                        const Re = pe[Ae]
                          , Ue = oe.fields[Re]
                          , tt = Q.getField(Re);
                        tt ? tt.loadState(Ue) : console.warn(`Ignoring non-existant field ${Re} in block ${Q.type}`)
                    }
                }
            }
            ,
            dm = function(Q, oe) {
                if (oe.inputs) {
                    var pe = Object.keys(oe.inputs);
                    for (let Ae = 0; Ae < pe.length; Ae++) {
                        const Re = pe[Ae]
                          , Ue = Q.getInput(Re);
                        if (!Ue || !Ue.connection)
                            throw new za(Re,Q,oe);
                        nu(Ue.connection, oe.inputs[Re])
                    }
                }
            }
            ,
            hm = function(Q, oe) {
                if (oe.next) {
                    if (!Q.nextConnection)
                        throw new za("next",Q,oe);
                    nu(Q.nextConnection, oe.next)
                }
            }
            ,
            nu = function(Q, oe) {
                oe.shadow && Q.setShadowState(oe.shadow),
                oe.block && tu(oe.block, Q.getSourceBlock().workspace, {
                    parentConnection: Q
                })
            }
            ,
            pm = function(Q, oe) {
                if (oe) {
                    Q.setConnectionTracking(!1),
                    Q.initSvg(),
                    Q.queueRender();
                    for (const pe of Q.getIcons())
                        pe.onLocationChange(Q.getRelativeToSurfaceXY())
                } else
                    Q.initModel()
            }
            ,
            mm = function(Q) {
                const oe = Q.workspace
                  , pe = J.config$$module$build$src$core$config.snapRadius
                  , Ae = Q.getRelativeToSurfaceXY()
                  , Re = new Zt(0,0)
                  , Ue = oe.getAllBlocks(!1).filter(tt => tt.id != Q.id).map(tt => tt.getRelativeToSurfaceXY());
                for (; fm(Zt.sum(Ae, Re), Ue) || gm(Q, Re, pe); )
                    oe.RTL ? Re.translate(-pe, 2 * pe) : Re.translate(pe, 2 * pe);
                Q.moveTo(Zt.sum(Ae, Re))
            }
            ,
            fm = function(Q, oe) {
                return oe.some(pe => 1 >= Math.abs(pe.x - Q.x) && 1 >= Math.abs(pe.y - Q.y))
            }
            ,
            gm = function(Q, oe, pe) {
                return Q.getConnections_(!1).some(Ae => !!Ae.closest(pe, oe).connection)
            }
            ,
            Em = function(Q) {
                return zt("Blockly.clipboard.copy", "v11", "v12", "myCopyable.toCopyData()"),
                hh.copyInternal(Q)
            }
            ,
            Tm = function(Q) {
                const oe = Q.toCopyData();
                uh = oe;
                let pe;
                return dh = (pe = Q.workspace) != null ? pe : null,
                oe
            }
            ,
            yi = function(Q, oe, pe) {
                return Q && oe ? ru(Q, oe, pe) : uh && dh ? ru(uh, dh) : null
            }
            ,
            ru = function(Q, oe, pe) {
                let Ae;
                oe = (Ae = oe.getRootWorkspace()) != null ? Ae : oe;
                let Re, Ue;
                return (Ue = (Re = _e(Yt.PASTER, Q.paster, !1)) == null ? void 0 : Re.paste(Q, oe, pe)) != null ? Ue : null
            }
            ,
            Am = function(Q) {
                return zt("Blockly.clipboard.duplicate", "v11", "v12", "Blockly.clipboard.paste(myCopyable.toCopyData(), myWorkspace)"),
                hh.duplicateInternal(Q)
            }
            ,
            _m = function(Q) {
                const oe = Q.toCopyData();
                return oe ? yi(oe, Q.workspace) : null
            }
            ,
            rs = function(Q, oe) {
                Q.setAttribute(lT, oe)
            }
            ,
            Jn = function(Q, oe, pe) {
                Array.isArray(pe) && (pe = pe.join(" ")),
                Q.setAttribute(aT + oe, `${pe}`)
            }
            ,
            Fo = function() {
                return bs
            }
            ,
            Sm = function(Q) {
                if (bs = Q,
                Q === null) {
                    let oe;
                    (oe = document.querySelector("." + fh)) == null || oe.remove()
                }
            }
            ,
            su = function() {
                document.querySelector("." + fh) || (bs = document.createElement("div"),
                bs.className = fh,
                (je() || document.body).appendChild(bs))
            }
            ,
            Pl = function(Q, oe, pe) {
                Jr(),
                qi = Q,
                Ec = pe,
                (Q = bs) && (Q.style.direction = oe ? "rtl" : "ltr",
                Q.style.display = "block",
                oe = ke(),
                Qi = oe.getRenderer().getClassName(),
                Zi = oe.getTheme().getClassName(),
                Qi && Ut(Q, Qi),
                Zi && Ut(Q, Zi))
            }
            ,
            Jr = function() {
                if (ou()) {
                    qi = null;
                    var Q = bs;
                    Q && (Q.style.display = "none",
                    Q.style.left = "",
                    Q.style.top = "",
                    Ec && Ec(),
                    Ec = null,
                    Q.textContent = "",
                    Qi && (yt(Q, Qi),
                    Qi = ""),
                    Zi && (yt(Q, Zi),
                    Zi = ""),
                    ke().markFocused())
                }
            }
            ,
            ou = function() {
                return !!qi
            }
            ,
            Ml = function(Q) {
                qi === Q && Jr()
            }
            ,
            iu = function(Q, oe, pe) {
                bs.style.left = Q + "px",
                bs.style.top = oe + "px",
                bs.style.height = pe + "px"
            }
            ,
            au = function(Q, oe, pe, Ae) {
                const Re = Rm(Q, oe, pe);
                Q = Im(Q, oe, pe, Ae),
                0 > Re ? iu(Q, 0, pe.height + Re) : iu(Q, Re, pe.height)
            }
            ,
            Im = function(Q, oe, pe, Ae) {
                return Ae ? Math.min(Math.max(oe.right - pe.width, Q.left), Q.right - pe.width) : Math.max(Math.min(oe.left, Q.right - pe.width), Q.left)
            }
            ,
            Rm = function(Q, oe, pe) {
                return oe.bottom + pe.height >= Q.bottom ? oe.top - pe.height : oe.bottom
            }
            ,
            ym = function(Q) {
                return !(Q == null || !Q.repositionForWindowResize)
            }
            ,
            lu = function() {
                ym(qi) && qi.repositionForWindowResize() || Jr()
            }
            ,
            bm = function() {
                return Tc
            }
            ,
            cu = function(Q) {
                Tc = Q
            }
            ,
            Pa = function(Q, oe, pe) {
                if (Pl(Eg, pe, uu),
                oe.length) {
                    var Ae = $m(oe, pe);
                    Ac = Ae,
                    Om(Ae, Q, pe),
                    setTimeout(function() {
                        Ae.focus()
                    }, 1),
                    Tc = null
                } else
                    Ma()
            }
            ,
            $m = function(Q, oe) {
                const pe = new ph;
                pe.setRole(Mr.MENU);
                for (let Ae = 0; Ae < Q.length; Ae++) {
                    const Re = Q[Ae]
                      , Ue = new mh(Re.text);
                    Ue.setRightToLeft(oe),
                    Ue.setRole(Mr.MENUITEM),
                    pe.addChild(Ue),
                    Ue.setEnabled(Re.enabled),
                    Re.enabled && Ue.onAction(function() {
                        Ma(),
                        requestAnimationFrame( () => {
                            setTimeout( () => {
                                Re.callback(Re.scope)
                            }
                            , 0)
                        }
                        )
                    }, {})
                }
                return pe
            }
            ,
            Om = function(Q, oe, pe) {
                const Ae = Je();
                oe = new Vn(oe.clientY + Ae.top,oe.clientY + Ae.top,oe.clientX + Ae.left,oe.clientX + Ae.left),
                Cm(Q);
                const Re = Q.getSize();
                pe && (oe.left += Re.width,
                oe.right += Re.width,
                Ae.left += Re.width,
                Ae.right += Re.width),
                au(Ae, oe, Re, pe),
                Q.focus()
            }
            ,
            Cm = function(Q) {
                var oe = Fo();
                if (!oe)
                    throw Error("Attempting to create a context menu when widget div is null");
                oe = Q.render(oe),
                Ut(oe, "blocklyContextMenu"),
                vt(oe, "contextmenu", null, vm),
                Q.focus()
            }
            ,
            vm = function(Q) {
                Q.preventDefault(),
                Q.stopPropagation()
            }
            ,
            Ma = function() {
                Ml(Eg),
                Tc = null
            }
            ,
            uu = function() {
                Ac && (Ac.dispose(),
                Ac = null)
            }
            ,
            J.callbackFactory$$module$build$src$core$contextmenu = function(Q, oe) {
                return () => {
                    J.disable$$module$build$src$core$events$utils();
                    let pe;
                    try {
                        pe = oe instanceof Element ? lo(oe, Q.workspace) : Ri(oe, Q.workspace);
                        const Ae = Q.getRelativeToSurfaceXY();
                        Ae.x = Q.RTL ? Ae.x - J.config$$module$build$src$core$config.snapRadius : Ae.x + J.config$$module$build$src$core$config.snapRadius,
                        Ae.y += 2 * J.config$$module$build$src$core$config.snapRadius,
                        pe.moveBy(Ae.x, Ae.y)
                    } finally {
                        J.enable$$module$build$src$core$events$utils()
                    }
                    return Ke() && !pe.isShadow() && Ye(new (gt(J.CREATE$$module$build$src$core$events$utils))(pe)),
                    pe.select(),
                    pe
                }
            }
            ,
            du = function(Q) {
                return {
                    text: J.Msg$$module$build$src$core$msg.REMOVE_COMMENT,
                    enabled: !0,
                    callback: function() {
                        J.setGroup$$module$build$src$core$events$utils(!0),
                        Q.dispose(),
                        J.setGroup$$module$build$src$core$events$utils(!1)
                    }
                }
            }
            ,
            hu = function(Q) {
                return {
                    text: J.Msg$$module$build$src$core$msg.DUPLICATE_COMMENT,
                    enabled: !0,
                    callback: function() {
                        const oe = Q.toCopyData();
                        oe && yi(oe, Q.workspace)
                    }
                }
            }
            ,
            xm = function(Q, oe) {
                const pe = {
                    enabled: !0
                };
                return pe.text = J.Msg$$module$build$src$core$msg.ADD_COMMENT,
                pe.callback = function() {
                    const Ae = new Er(Q,J.Msg$$module$build$src$core$msg.WORKSPACE_COMMENT_DEFAULT_TEXT,Er.DEFAULT_SIZE,Er.DEFAULT_SIZE);
                    var Re = Q.getInjectionDiv().getBoundingClientRect();
                    Re = new Zt(oe.clientX - Re.left,oe.clientY - Re.top);
                    const Ue = Q.getOriginOffsetInPixels();
                    Re = Zt.difference(Re, Ue),
                    Re.scale(1 / Q.scale),
                    Ae.moveBy(Re.x, Re.y),
                    Q.rendered && (Ae.initSvg(),
                    Ae.render(),
                    Ae.select())
                }
                ,
                pe
            }
            ,
            bi = function(Q) {
                return Q * Math.PI / 180
            }
            ,
            pu = function(Q) {
                return 180 * Q / Math.PI
            }
            ,
            $i = function(Q, oe, pe) {
                if (pe < Q) {
                    const Ae = pe;
                    pe = Q,
                    Q = Ae
                }
                return Math.max(Q, Math.min(oe, pe))
            }
            ,
            mu = function() {
                document.querySelector(".blocklyDropDownDiv") || (Mn = document.createElement("div"),
                Mn.className = "blocklyDropDownDiv",
                (je() || document.body).appendChild(Mn),
                na = document.createElement("div"),
                na.className = "blocklyDropDownContent",
                Mn.appendChild(na),
                ni = document.createElement("div"),
                ni.className = "blocklyDropDownArrow",
                Mn.appendChild(ni),
                Mn.style.opacity = "0",
                Mn.style.transition = "transform " + Sc + "s, opacity " + Sc + "s",
                Mn.addEventListener("focusin", function() {
                    Ut(Mn, "blocklyFocused")
                }),
                Mn.addEventListener("focusout", function() {
                    yt(Mn, "blocklyFocused")
                }))
            }
            ,
            fu = function(Q) {
                Ah = Q
            }
            ,
            gu = function() {
                return Io
            }
            ,
            Oi = function() {
                return na
            }
            ,
            kl = function() {
                na.textContent = "",
                na.style.width = ""
            }
            ,
            Dl = function(Q, oe) {
                Mn.style.backgroundColor = Q,
                Mn.style.borderColor = oe
            }
            ,
            Nm = function(Q, oe, pe, Ae) {
                return Au(Eu(oe), Q, pe, Ae)
            }
            ,
            ka = function(Q, oe, pe) {
                return Ag = !0,
                Au(Tu(Q), Q, oe, pe)
            }
            ,
            Eu = function(Q) {
                var oe = Q.getSvgRoot();
                const pe = Q.workspace.scale
                  , Ae = Q.height * pe;
                return Q = Q.width * pe,
                oe = En(oe),
                new Vn(oe.y,oe.y + Ae,oe.x,oe.x + Q)
            }
            ,
            Tu = function(Q) {
                return Q = Q.getScaledBBox(),
                new Vn(Q.top,Q.bottom,Q.left,Q.right)
            }
            ,
            Au = function(Q, oe, pe, Ae) {
                const Re = Q.left + (Q.right - Q.left) / 2
                  , Ue = Q.bottom;
                Q = Q.top,
                Ae && (Q += Ae),
                Ae = oe.getSourceBlock();
                let tt = Ae.workspace;
                for (; tt.options.parentWorkspace; )
                    tt = tt.options.parentWorkspace;
                return fu(tt.getParentSvg().parentNode),
                _u(oe, Ae.RTL, Re, Ue, Re, Q, pe)
            }
            ,
            _u = function(Q, oe, pe, Ae, Re, Ue, tt) {
                return Io = Q,
                ti = tt || null,
                Mn.style.direction = oe ? "rtl" : "ltr",
                Q = ke(),
                ea = Q.getRenderer().getClassName(),
                ta = Q.getTheme().getClassName(),
                ea && Ut(Mn, ea),
                ta && Ut(Mn, ta),
                yu(pe, Ae, Re, Ue)
            }
            ,
            Su = function(Q, oe, pe, Ae) {
                return Q = Da(Q, pe.left, pe.right, Ae.width),
                {
                    initialX: Q.divX,
                    initialY: oe,
                    finalX: Q.divX,
                    finalY: oe + Eh,
                    arrowX: Q.arrowX,
                    arrowY: -(Qa / 2 + gh),
                    arrowAtTop: !0,
                    arrowVisible: !0
                }
            }
            ,
            Iu = function(Q, oe, pe, Ae) {
                return Q = Da(Q, pe.left, pe.right, Ae.width),
                {
                    initialX: Q.divX,
                    initialY: oe - Ae.height,
                    finalX: Q.divX,
                    finalY: oe - Ae.height - Eh,
                    arrowX: Q.arrowX,
                    arrowY: Ae.height - 2 * gh - Qa / 2,
                    arrowAtTop: !1,
                    arrowVisible: !0
                }
            }
            ,
            Lm = function(Q, oe, pe) {
                return Q = Da(Q, oe.left, oe.right, pe.width),
                {
                    initialX: Q.divX,
                    initialY: 0,
                    finalX: Q.divX,
                    finalY: 0,
                    arrowAtTop: null,
                    arrowX: null,
                    arrowY: null,
                    arrowVisible: !1
                }
            }
            ,
            Da = function(Q, oe, pe, Ae) {
                return oe = $i(oe, Q - Ae / 2, pe - Ae),
                Q = Q - Qa / 2 - oe,
                pe = Tg,
                Q = $i(pe, Q, Ae - pe - Qa),
                {
                    arrowX: Q,
                    divX: oe
                }
            }
            ,
            Ru = function() {
                return !!Io
            }
            ,
            Ci = function(Q, oe) {
                return Io === Q ? (oe ? ss() : wl(),
                !0) : !1
            }
            ,
            wl = function() {
                Mn.style.transform = "translate(0, 0)",
                Mn.style.opacity = "0",
                Th = setTimeout(function() {
                    ss()
                }, 1e3 * Sc),
                ti && (ti(),
                ti = null)
            }
            ,
            ss = function() {
                Ru() && (Th && clearTimeout(Th),
                Mn.style.transform = "",
                Mn.style.left = "",
                Mn.style.top = "",
                Mn.style.opacity = "0",
                Mn.style.display = "none",
                Mn.style.backgroundColor = "",
                Mn.style.borderColor = "",
                ti && (ti(),
                ti = null),
                kl(),
                Io = null,
                ea && (yt(Mn, ea),
                ea = ""),
                ta && (yt(Mn, ta),
                ta = ""),
                ke().markFocused())
            }
            ,
            yu = function(Q, oe, pe, Ae) {
                Q = _h.getPositionMetrics(Q, oe, pe, Ae),
                Q.arrowVisible ? (ni.style.display = "",
                ni.style.transform = "translate(" + Q.arrowX + "px," + Q.arrowY + "px) rotate(45deg)",
                ni.setAttribute("class", Q.arrowAtTop ? "blocklyDropDownArrow blocklyArrowTop" : "blocklyDropDownArrow blocklyArrowBottom")) : ni.style.display = "none",
                oe = Math.floor(Q.initialX),
                pe = Math.floor(Q.initialY),
                Ae = Math.floor(Q.finalX);
                const Re = Math.floor(Q.finalY);
                return Mn.style.left = oe + "px",
                Mn.style.top = pe + "px",
                Mn.style.display = "block",
                Mn.style.opacity = "1",
                Mn.style.transform = "translate(" + (Ae - oe) + "px," + (Re - pe) + "px)",
                !!Q.arrowAtTop
            }
            ,
            bu = function() {
                if (Io) {
                    var Q = Io.getSourceBlock();
                    Q = Ag ? Tu(Io) : Eu(Q);
                    const oe = Q.left + (Q.right - Q.left) / 2;
                    yu(oe, Q.bottom, oe, Q.top)
                } else
                    wl()
            }
            ,
            $u = function(Q) {
                if (!(100 < Q.getDescendants(!1).length)) {
                    var oe = Q.workspace
                      , pe = Q.getSvgRoot();
                    oe.getAudioManager().play("delete");
                    var Ae = oe.getSvgXY(pe);
                    pe = pe.cloneNode(!0),
                    pe.setAttribute("transform", "translate(" + Ae.x + "," + Ae.y + ")"),
                    oe.getParentSvg().appendChild(pe),
                    Ou(pe, {
                        x: Ae.x,
                        y: Ae.y,
                        width: Q.width,
                        height: Q.height
                    }, oe.RTL, new Date, oe.scale)
                }
            }
            ,
            Ou = function(Q, oe, pe, Ae, Re) {
                const Ue = (new Date().getTime() - Ae.getTime()) / 150;
                1 < Ue ? Bt(Q) : (Q.setAttribute("transform", "translate(" + (oe.x + (pe ? -1 : 1) * oe.width * Re / 2 * Ue) + "," + (oe.y + oe.height * Re * Ue) + ") scale(" + (1 - Ue) * Re + ")"),
                setTimeout(Ou, 10, Q, oe, pe, Ae, Re))
            }
            ,
            Cu = function(Q) {
                var oe = Q.workspace;
                const pe = oe.scale;
                if (oe.getAudioManager().play("click"),
                !(1 > pe)) {
                    var Ae = oe.getSvgXY(Q.getSvgRoot());
                    Q.outputConnection ? (Ae.x += (Q.RTL ? 3 : -3) * pe,
                    Ae.y += 13 * pe) : Q.previousConnection && (Ae.x += (Q.RTL ? -23 : 23) * pe,
                    Ae.y += 3 * pe);
                    var Re = $t(bt.CIRCLE, {
                        cx: Ae.x,
                        cy: Ae.y,
                        r: 0,
                        fill: "none",
                        stroke: "#888",
                        "stroke-width": 10
                    }, oe.getParentSvg());
                    Q = $t(bt.ANIMATE, {
                        id: "animationCircle",
                        begin: "indefinite",
                        attributeName: "r",
                        dur: "150ms",
                        from: 0,
                        to: 25 * pe
                    }, Re),
                    oe = $t(bt.ANIMATE, {
                        id: "animationOpacity",
                        begin: "indefinite",
                        attributeName: "opacity",
                        dur: "150ms",
                        from: 1,
                        to: 0
                    }, Re),
                    Q.beginElement(),
                    oe.beginElement(),
                    setTimeout( () => void Bt(Re), 150)
                }
            }
            ,
            vu = function(Q) {
                if (vi(),
                Q.workspace.getAudioManager().play("disconnect"),
                !(1 > Q.workspace.scale)) {
                    var oe = Q.getHeightWidth().height;
                    oe = Math.atan(10 / oe) / Math.PI * 180,
                    Q.RTL || (oe *= -1),
                    Za = Q,
                    xu(Q, oe, new Date)
                }
            }
            ,
            xu = function(Q, oe, pe) {
                const Ae = (new Date().getTime() - pe.getTime()) / 200;
                let Re = "";
                1 >= Ae && (Re = `skewX(${Math.round(Math.sin(Ae * Math.PI * 3) * (1 - Ae) * oe)})`,
                Ic = setTimeout(xu, 10, Q, oe, pe)),
                Q.getSvgRoot().setAttribute("transform", `${Q.getTranslation()} ${Re}`)
            }
            ,
            vi = function() {
                Za && (Ic && (clearTimeout(Ic),
                Ic = null),
                Za.getSvgRoot().setAttribute("transform", Za.getTranslation()),
                Za = null)
            }
            ,
            Pm = function(Q, oe) {
                return zt("Blockly.utils.string.startsWith()", "April 2022", "April 2023", "Use built-in string.startsWith"),
                Q.startsWith(oe)
            }
            ,
            wa = function(Q) {
                return Q.length ? Q.reduce(function(oe, pe) {
                    return oe.length < pe.length ? oe : pe
                }).length : 0
            }
            ,
            Nu = function(Q, oe) {
                if (!Q.length)
                    return 0;
                if (Q.length === 1)
                    return Q[0].length;
                let pe = 0;
                oe = oe || wa(Q);
                let Ae;
                for (Ae = 0; Ae < oe; Ae++) {
                    for (var Re = Q[0][Ae], Ue = 1; Ue < Q.length; Ue++)
                        if (Re !== Q[Ue][Ae])
                            return pe;
                    Re === " " && (pe = Ae + 1)
                }
                for (Re = 1; Re < Q.length; Re++)
                    if ((Ue = Q[Re][Ae]) && Ue !== " ")
                        return pe;
                return oe
            }
            ,
            Lu = function(Q, oe) {
                if (!Q.length)
                    return 0;
                if (Q.length === 1)
                    return Q[0].length;
                let pe = 0;
                oe = oe || wa(Q);
                let Ae;
                for (Ae = 0; Ae < oe; Ae++) {
                    for (var Re = Q[0].substr(-Ae - 1, 1), Ue = 1; Ue < Q.length; Ue++)
                        if (Re !== Q[Ue].substr(-Ae - 1, 1))
                            return pe;
                    Re === " " && (pe = Ae + 1)
                }
                for (Re = 1; Re < Q.length; Re++)
                    if ((Ue = Q[Re].charAt(Q[Re].length - Ae - 1)) && Ue !== " ")
                        return pe;
                return oe
            }
            ,
            J.wrap$$module$build$src$core$utils$string = function(Q, oe) {
                Q = Q.split(`
`);
                for (let pe = 0; pe < Q.length; pe++)
                    Q[pe] = Mm(Q[pe], oe);
                return Q.join(`
`)
            }
            ,
            Mm = function(Q, oe) {
                if (Q.length <= oe)
                    return Q;
                const pe = Q.trim().split(/\s+/);
                for (var Ae = 0; Ae < pe.length; Ae++)
                    pe[Ae].length > oe && (oe = pe[Ae].length);
                var Re = -1 / 0;
                let Ue, tt = 1;
                do {
                    Ae = Re,
                    Ue = Q,
                    Q = [],
                    Re = pe.length / tt;
                    let dt = 1;
                    for (let wt = 0; wt < pe.length - 1; wt++)
                        dt < (wt + 1.5) / Re ? (dt++,
                        Q[wt] = !0) : Q[wt] = !1;
                    Q = Pu(pe, Q, oe),
                    Re = Bl(pe, Q, oe),
                    Q = km(pe, Q),
                    tt++
                } while (Re > Ae);
                return Ue
            }
            ,
            Bl = function(Q, oe, pe) {
                const Ae = [0]
                  , Re = [];
                for (var Ue = 0; Ue < Q.length; Ue++)
                    Ae[Ae.length - 1] += Q[Ue].length,
                    oe[Ue] === !0 ? (Ae.push(0),
                    Re.push(Q[Ue].charAt(Q[Ue].length - 1))) : oe[Ue] === !1 && Ae[Ae.length - 1]++;
                for (Q = Math.max(...Ae),
                oe = 0,
                Ue = 0; Ue < Ae.length; Ue++)
                    oe -= 2 * Math.pow(Math.abs(pe - Ae[Ue]), 1.5),
                    oe -= Math.pow(Q - Ae[Ue], 1.5),
                    ".?!".indexOf(Re[Ue]) !== -1 ? oe += pe / 3 : ",;)]}".indexOf(Re[Ue]) !== -1 && (oe += pe / 4);
                return 1 < Ae.length && Ae[Ae.length - 1] <= Ae[Ae.length - 2] && (oe += .5),
                oe
            }
            ,
            Pu = function(Q, oe, pe) {
                let Ae = Bl(Q, oe, pe), Re;
                for (let Ue = 0; Ue < oe.length - 1; Ue++) {
                    if (oe[Ue] === oe[Ue + 1])
                        continue;
                    const tt = [].concat(oe);
                    tt[Ue] = !tt[Ue],
                    tt[Ue + 1] = !tt[Ue + 1];
                    const dt = Bl(Q, tt, pe);
                    dt > Ae && (Ae = dt,
                    Re = tt)
                }
                return Re ? Pu(Q, Re, pe) : oe
            }
            ,
            km = function(Q, oe) {
                const pe = [];
                for (let Ae = 0; Ae < Q.length; Ae++)
                    pe.push(Q[Ae]),
                    oe[Ae] !== void 0 && pe.push(oe[Ae] ? `
` : " ");
                return pe.join("")
            }
            ,
            J.isNumber$$module$build$src$core$utils$string = function(Q) {
                return /^\s*-?\d+(\.\d+)?\s*$/.test(Q)
            }
            ,
            Dm = function(Q) {
                Rc = Q
            }
            ,
            wm = function() {
                return Rc
            }
            ,
            Bm = function() {
                return tl
            }
            ,
            Um = function() {
                return cr
            }
            ,
            xi = function(Q) {
                if (Q = Mu(Q)) {
                    for (Q = Q.tooltip; typeof Q == "function"; )
                        Q = Q();
                    if (typeof Q != "string")
                        throw Error("Tooltip function must return a string.");
                    return Q
                }
                return ""
            }
            ,
            Mu = function(Q) {
                for (; Q && Q.tooltip; ) {
                    if (typeof Q.tooltip == "string" || typeof Q.tooltip == "function")
                        return Q;
                    Q = Q.tooltip
                }
                return null
            }
            ,
            ku = function() {
                document.querySelector(".blocklyTooltipDiv") || (cr = document.createElement("div"),
                cr.className = "blocklyTooltipDiv",
                (je() || document.body).appendChild(cr))
            }
            ,
            Ni = function(Q) {
                Q.mouseOverWrapper_ = Jt(Q, "pointerover", null, Fm),
                Q.mouseOutWrapper_ = Jt(Q, "pointerout", null, Hm),
                Q.addEventListener("pointermove", Du, !1)
            }
            ,
            Ul = function(Q) {
                Q && (Ct(Q.mouseOverWrapper_),
                Ct(Q.mouseOutWrapper_),
                Q.removeEventListener("pointermove", Du))
            }
            ,
            Fm = function(Q) {
                ra || (Q = Mu(Q.currentTarget),
                qr !== Q && (Vs(),
                nl = null,
                qr = Q),
                clearTimeout(yg))
            }
            ,
            Hm = function(Q) {
                ra || (yg = setTimeout(function() {
                    nl = qr = null,
                    Vs()
                }, 1),
                clearTimeout(oi),
                oi = 0)
            }
            ,
            Du = function(Q) {
                if (qr && qr.tooltip && !ra)
                    if (tl) {
                        const oe = bh - Q.pageX;
                        Q = $h - Q.pageY,
                        Math.sqrt(oe * oe + Q * Q) > bg && Vs()
                    } else
                        nl !== qr && (clearTimeout(oi),
                        bh = Q.pageX,
                        $h = Q.pageY,
                        oi = setTimeout(Wm, $g))
            }
            ,
            wu = function() {
                nl = qr = null,
                Vs()
            }
            ,
            Vs = function() {
                tl && (tl = !1,
                cr && (cr.style.display = "none")),
                oi && (clearTimeout(oi),
                oi = 0)
            }
            ,
            Bu = function() {
                Vs(),
                ra = !0
            }
            ,
            Uu = function() {
                ra = !1
            }
            ,
            Vm = function() {
                cr && qr && (typeof Rc == "function" ? Rc(cr, qr) : Gm())
            }
            ,
            Gm = function() {
                var Q = xi(qr);
                Q = J.wrap$$module$build$src$core$utils$string(Q, Rg),
                Q = Q.split(`
`);
                for (let oe = 0; oe < Q.length; oe++) {
                    const pe = document.createElement("div");
                    pe.appendChild(document.createTextNode(Q[oe])),
                    cr.appendChild(pe)
                }
            }
            ,
            jm = function(Q) {
                const oe = document.documentElement.clientWidth
                  , pe = document.documentElement.clientHeight;
                let Ae = bh;
                Ae = Q ? Ae - (Oh + cr.offsetWidth) : Ae + Oh;
                let Re = $h + Ch;
                return Re + cr.offsetHeight > pe + window.scrollY && (Re -= cr.offsetHeight + 2 * Ch),
                Q ? Ae = Math.max(yc - window.scrollX, Ae) : Ae + cr.offsetWidth > oe + window.scrollX - 2 * yc && (Ae = oe - cr.offsetWidth - 2 * yc),
                {
                    x: Ae,
                    y: Re
                }
            }
            ,
            Wm = function() {
                if (!ra && (nl = qr,
                cr)) {
                    cr.textContent = "",
                    Vm();
                    var Q = qr.RTL;
                    cr.style.direction = Q ? "rtl" : "ltr",
                    cr.style.display = "block",
                    tl = !0;
                    var {x: oe, y: pe} = jm(Q);
                    cr.style.left = oe + "px",
                    cr.style.top = pe + "px"
                }
            }
            ,
            Gs = function(Q, oe) {
                for (const pe in oe)
                    Q[pe] = oe[pe] !== null && typeof oe[pe] == "object" ? Gs(Q[pe] || Object.create(null), oe[pe]) : oe[pe];
                return Q
            }
            ,
            uo = function(Q) {
                return Q.bubbleIsVisible !== void 0 && Q.setBubbleVisible !== void 0
            }
            ,
            Fl = function() {
                return xh
            }
            ,
            Fu = function(Q) {
                xh = Q
            }
            ,
            Hl = function() {
                return Nh
            }
            ,
            Hu = function(Q) {
                Nh = Q
            }
            ,
            ho = function(Q) {
                Q = `${Q}`.toLowerCase().trim();
                var oe = vg[Q];
                if (oe || (oe = Q.substring(0, 2) === "0x" ? "#" + Q.substring(2) : Q,
                oe = oe[0] === "#" ? oe : "#" + oe,
                /^#[0-9a-f]{6}$/.test(oe)))
                    return oe;
                if (/^#[0-9a-f]{3}$/.test(oe))
                    return ["#", oe[1], oe[1], oe[2], oe[2], oe[3], oe[3]].join("");
                var pe = Q.match(/^(?:rgb)?\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/);
                return pe && (Q = Number(pe[1]),
                oe = Number(pe[2]),
                pe = Number(pe[3]),
                0 <= Q && 256 > Q && 0 <= oe && 256 > oe && 0 <= pe && 256 > pe) ? Ba(Q, oe, pe) : null
            }
            ,
            Ba = function(Q, oe, pe) {
                return oe = Q << 16 | oe << 8 | pe,
                16 > Q ? "#" + (16777216 | oe).toString(16).substr(1) : "#" + oe.toString(16)
            }
            ,
            Vl = function(Q) {
                return Q = ho(Q),
                Q ? (Q = parseInt(Q.substr(1), 16),
                [Q >> 16, Q >> 8 & 255, Q & 255]) : [0, 0, 0]
            }
            ,
            Gl = function(Q, oe, pe) {
                let Ae = 0
                  , Re = 0
                  , Ue = 0;
                if (oe === 0)
                    Ue = Re = Ae = pe;
                else {
                    const tt = Math.floor(Q / 60)
                      , dt = Q / 60 - tt;
                    Q = pe * (1 - oe);
                    const wt = pe * (1 - oe * dt);
                    switch (oe = pe * (1 - oe * (1 - dt)),
                    tt) {
                    case 1:
                        Ae = wt,
                        Re = pe,
                        Ue = Q;
                        break;
                    case 2:
                        Ae = Q,
                        Re = pe,
                        Ue = oe;
                        break;
                    case 3:
                        Ae = Q,
                        Re = wt,
                        Ue = pe;
                        break;
                    case 4:
                        Ae = oe,
                        Re = Q,
                        Ue = pe;
                        break;
                    case 5:
                        Ae = pe,
                        Re = Q,
                        Ue = wt;
                        break;
                    case 6:
                    case 0:
                        Ae = pe,
                        Re = oe,
                        Ue = Q
                    }
                }
                return Ba(Math.floor(Ae), Math.floor(Re), Math.floor(Ue))
            }
            ,
            Ho = function(Q, oe, pe) {
                return Q = ho(Q),
                !Q || (oe = ho(oe),
                !oe) ? null : (Q = Vl(Q),
                oe = Vl(oe),
                Ba(Math.round(oe[0] + pe * (Q[0] - oe[0])), Math.round(oe[1] + pe * (Q[1] - oe[1])), Math.round(oe[2] + pe * (Q[2] - oe[2]))))
            }
            ,
            Vu = function(Q) {
                return Gl(Q, xh, 255 * Nh)
            }
            ,
            jl = function(Q, oe, pe) {
                const Ae = [];
                var Re = Q.split("");
                Re.push("");
                var Ue = 0;
                Q = [];
                let tt = null;
                for (let sn = 0; sn < Re.length; sn++) {
                    var dt = Re[sn];
                    if (Ue === 0)
                        if (dt === "%")
                            (Ue = Q.join("")) && Ae.push(Ue),
                            Q.length = 0,
                            Ue = 1;
                        else if (pe && dt === `
`) {
                            const zn = Q.join("");
                            zn && Ae.push(zn),
                            Q.length = 0,
                            Ae.push(dt)
                        } else
                            Q.push(dt);
                    else if (Ue === 1)
                        dt === "%" ? (Q.push(dt),
                        Ue = 0) : oe && "0" <= dt && "9" >= dt ? (Ue = 2,
                        tt = dt,
                        (dt = Q.join("")) && Ae.push(dt),
                        Q.length = 0) : dt === "{" ? Ue = 3 : (Q.push("%", dt),
                        Ue = 0);
                    else if (Ue === 2)
                        if ("0" <= dt && "9" >= dt)
                            tt += dt;
                        else {
                            var wt = void 0;
                            Ae.push(parseInt((wt = tt) != null ? wt : "", 10)),
                            sn--,
                            Ue = 0
                        }
                    else
                        Ue === 3 && (dt === "" ? (Q.splice(0, 0, "%{"),
                        sn--,
                        Ue = 0) : dt !== "}" ? Q.push(dt) : (Ue = Q.join(""),
                        /[A-Z]\w*/i.test(Ue) ? (dt = Ue.toUpperCase(),
                        (dt = dt.startsWith("BKY_") ? dt.substring(4) : null) && dt in J.Msg$$module$build$src$core$msg ? (Ue = J.Msg$$module$build$src$core$msg[dt],
                        typeof Ue == "string" ? Array.prototype.push.apply(Ae, jl(Ue, oe, pe)) : oe ? Ae.push(`${Ue}`) : Ae.push(Ue)) : Ae.push("%{" + Ue + "}")) : Ae.push("%{" + Ue + "}"),
                        Ue = Q.length = 0))
                }
                for ((oe = Q.join("")) && Ae.push(oe),
                wt = [],
                Q.length = 0,
                Re = 0; Re < Ae.length; Re++)
                    typeof Ae[Re] != "string" || pe && Ae[Re] === `
` ? ((oe = Q.join("")) && wt.push(oe),
                    Q.length = 0,
                    wt.push(Ae[Re])) : Q.push(Ae[Re]);
                return (oe = Q.join("")) && wt.push(oe),
                Q.length = 0,
                wt
            }
            ,
            Gu = function(Q) {
                return jl(Q, !0, !0)
            }
            ,
            rr = function(Q) {
                return typeof Q != "string" ? Q : (Q = jl(Q, !1, !1),
                Q.length ? String(Q[0]) : "")
            }
            ,
            Ym = function(Q) {
                let oe = !0;
                const pe = J.Msg$$module$build$src$core$msg
                  , Ae = Q.match(/%{BKY_[A-Z]\w*}/gi);
                if (Ae)
                    for (let Re = 0; Re < Ae.length; Re++) {
                        const Ue = Ae[Re].toUpperCase();
                        pe[Ue.slice(6, -1)] === void 0 && (console.warn("No message string for " + Ae[Re] + " in " + Q),
                        oe = !1)
                    }
                return oe
            }
            ,
            Li = function(Q) {
                const oe = typeof Q == "string" ? rr(Q) : Q;
                var pe = Number(oe);
                if (!isNaN(pe) && 0 <= pe && 360 >= pe)
                    return {
                        hue: pe,
                        hex: Gl(pe, Fl(), 255 * Hl())
                    };
                if (pe = ho(oe))
                    return {
                        hue: null,
                        hex: pe
                    };
                throw pe = 'Invalid colour: "' + oe + '"',
                Q !== oe && (pe += ' (from "' + Q + '")'),
                Error(pe)
            }
            ,
            po = function(Q) {
                return Q.getProcedureModel !== void 0 && Q.doProcedureUpdate !== void 0 && Q.isProcedureDef !== void 0
            }
            ,
            Wl = function(Q) {
                return Q.startPublishing !== void 0 && Q.stopPublishing !== void 0
            }
            ,
            Ur = function(Q, oe) {
                ne(Yt.FIELD, Q, oe)
            }
            ,
            Xm = function(Q) {
                ce(Yt.FIELD, Q)
            }
            ,
            J.fromJson$$module$build$src$core$field_registry = function(Q) {
                return Ng.fromJsonInternal(Q)
            }
            ,
            zm = function(Q) {
                const oe = _e(Yt.FIELD, Q.type);
                if (oe) {
                    if (typeof oe.fromJson != "function")
                        throw new TypeError("returned Field was not a IRegistrableField");
                    return oe.fromJson(Q)
                }
                return console.warn("Blockly could not create a field of type " + Q.type + ". The field is probably not being registered. This could be because the file is not loaded, the field does not register itself (Issue #1584), or the registration is not being reached."),
                null
            }
            ,
            Km = function(Q) {
                let oe = !1;
                const pe = Q.map( ([tt,dt]) => typeof tt == "string" ? [rr(tt), dt] : (oe = !0,
                [tt.alt !== null ? Object.assign({}, tt, {
                    alt: rr(tt.alt)
                }) : Object.assign({}, tt), dt]));
                if (oe || 2 > Q.length)
                    return {
                        options: pe
                    };
                var Ae = pe.map( ([tt]) => tt)
                  , Re = wa(Ae);
                Q = Nu(Ae, Re);
                const Ue = Lu(Ae, Re);
                return !Q && !Ue || Re <= Q + Ue ? {
                    options: pe
                } : (Re = Q ? Ae[0].substring(0, Q - 1) : void 0,
                Ae = Ue ? Ae[0].substr(1 - Ue) : void 0,
                {
                    options: Jm(pe, Q, Ue),
                    prefix: Re,
                    suffix: Ae
                })
            }
            ,
            Jm = function(Q, oe, pe) {
                return Q.map( ([Ae,Re]) => [Ae.substring(oe, Ae.length - pe), Re])
            }
            ,
            ju = function(Q) {
                if (!Array.isArray(Q))
                    throw TypeError("FieldDropdown options must be an array.");
                if (!Q.length)
                    throw TypeError("FieldDropdown options must not be an empty array.");
                let oe = !1;
                for (let pe = 0; pe < Q.length; pe++) {
                    const Ae = Q[pe];
                    Array.isArray(Ae) ? typeof Ae[1] != "string" ? (oe = !0,
                    console.error("Invalid option[" + pe + "]: Each FieldDropdown option id must be a string. Found " + Ae[1] + " in: ", Ae)) : Ae[0] && typeof Ae[0] != "string" && typeof Ae[0].src != "string" && (oe = !0,
                    console.error("Invalid option[" + pe + "]: Each FieldDropdown option must have a string label or image description. Found" + Ae[0] + " in: ", Ae)) : (oe = !0,
                    console.error("Invalid option[" + pe + "]: Each FieldDropdown option must be an array. Found: ", Ae))
                }
                if (oe)
                    throw TypeError("Found invalid FieldDropdown options.")
            }
            ,
            J.register$$module$build$src$core$extensions = function(Q, oe) {
                if (typeof Q != "string" || Q.trim() === "")
                    throw Error('Error: Invalid extension name "' + Q + '"');
                if (sa[Q])
                    throw Error('Error: Extension "' + Q + '" is already registered.');
                if (typeof oe != "function")
                    throw Error('Error: Extension "' + Q + '" must be a function');
                sa[Q] = oe
            }
            ,
            J.registerMixin$$module$build$src$core$extensions = function(Q, oe) {
                if (!oe || typeof oe != "object")
                    throw Error('Error: Mixin "' + Q + '" must be a object');
                J.register$$module$build$src$core$extensions(Q, function() {
                    this.mixin(oe)
                })
            }
            ,
            J.registerMutator$$module$build$src$core$extensions = function(Q, oe, pe, Ae) {
                const Re = 'Error when registering mutator "' + Q + '": ';
                Xu(Re, oe);
                const Ue = Yu(oe, Re);
                if (pe && typeof pe != "function")
                    throw Error(Re + 'Extension "' + Q + '" is not a function');
                J.register$$module$build$src$core$extensions(Q, function() {
                    Ue && this.setMutator(new J.MutatorIcon$$module$build$src$core$icons$mutator_icon(Ae || [],this)),
                    this.mixin(oe),
                    pe && pe.apply(this)
                })
            }
            ,
            qm = function(Q) {
                Wu(Q) ? delete sa[Q] : console.warn('No extension mapping for name "' + Q + '" found to unregister')
            }
            ,
            Wu = function(Q) {
                return !!sa[Q]
            }
            ,
            Yl = function(Q, oe, pe) {
                const Ae = sa[Q];
                if (typeof Ae != "function")
                    throw Error('Error: Extension "' + Q + '" not found.');
                let Re;
                if (pe ? Qm(Q, oe) : Re = zl(oe),
                Ae.apply(oe),
                pe)
                    Xu('Error after applying mutator "' + Q + '": ', oe);
                else if (!tf(Re, oe))
                    throw Error('Error when applying extension "' + Q + '": mutation properties changed when applying a non-mutator extension.')
            }
            ,
            Qm = function(Q, oe) {
                if (zl(oe).length)
                    throw Error('Error: tried to apply mutation "' + Q + '" to a block that already has mutator functions.  Block id: ' + oe.id)
            }
            ,
            Zm = function(Q, oe) {
                return Xl(Q.mutationToDom, Q.domToMutation, oe + " mutationToDom/domToMutation")
            }
            ,
            ef = function(Q, oe) {
                return Xl(Q.saveExtraState, Q.loadExtraState, oe + " saveExtraState/loadExtraState")
            }
            ,
            Yu = function(Q, oe) {
                return Xl(Q.compose, Q.decompose, oe + " compose/decompose")
            }
            ,
            Xl = function(Q, oe, pe) {
                if (Q && oe) {
                    if (typeof Q != "function" || typeof oe != "function")
                        throw Error(pe + " must be a function");
                    return !0
                }
                if (!Q && !oe)
                    return !1;
                throw Error(pe + "Must have both or neither functions")
            }
            ,
            Xu = function(Q, oe) {
                const pe = Zm(oe, Q)
                  , Ae = ef(oe, Q);
                if (!pe && !Ae)
                    throw Error(Q + "Mutations must contain either XML hooks, or JSON hooks, or both");
                Yu(oe, Q)
            }
            ,
            zl = function(Q) {
                const oe = [];
                return Q.domToMutation !== void 0 && oe.push(Q.domToMutation),
                Q.mutationToDom !== void 0 && oe.push(Q.mutationToDom),
                Q.saveExtraState !== void 0 && oe.push(Q.saveExtraState),
                Q.loadExtraState !== void 0 && oe.push(Q.loadExtraState),
                Q.compose !== void 0 && oe.push(Q.compose),
                Q.decompose !== void 0 && oe.push(Q.decompose),
                oe
            }
            ,
            tf = function(Q, oe) {
                if (oe = zl(oe),
                oe.length !== Q.length)
                    return !1;
                for (let pe = 0; pe < oe.length; pe++)
                    if (Q[pe] !== oe[pe])
                        return !1;
                return !0
            }
            ,
            nf = function(Q) {
                if (typeof document != "object")
                    throw Error("runAfterPageLoad() requires browser document.");
                if (document.readyState === "complete")
                    Q();
                else {
                    const oe = setInterval(function() {
                        document.readyState === "complete" && (clearInterval(oe),
                        Q())
                    }, 10)
                }
            }
            ,
            J.buildTooltipForDropdown$$module$build$src$core$extensions = function(Q, oe) {
                const pe = [];
                return function() {
                    pe.indexOf(this.type) === -1 && (rf(this, Q, oe),
                    pe.push(this.type)),
                    this.setTooltip((function() {
                        const Ae = String(this.getFieldValue(Q));
                        return rr(oe[Ae])
                    }
                    ).bind(this))
                }
            }
            ,
            rf = function(Q, oe, pe) {
                var Ae = Q.getField(oe);
                if (Ae instanceof Cs && !Ae.isOptionListDynamic()) {
                    Ae = Ae.getOptions();
                    for (const [,Re] of Ae)
                        pe[Re] === void 0 && console.warn(`No tooltip mapping for value ${Re} of field ${oe} of block type ${Q.type}.`)
                }
            }
            ,
            J.buildTooltipWithFieldText$$module$build$src$core$extensions = function(Q, oe) {
                return function() {
                    this.setTooltip((function() {
                        const pe = this.getField(oe);
                        return rr(Q).replace("%1", pe ? pe.getText() : "")
                    }
                    ).bind(this))
                }
            }
            ,
            sf = function() {
                const Q = this.tooltip;
                this.setTooltip((function() {
                    const oe = this.getParent();
                    return oe && oe.getInputsInline() && oe.tooltip || Q
                }
                ).bind(this))
            }
            ,
            gn = function(Q, oe) {
                return " " + Q + "," + oe + " "
            }
            ,
            xr = function(Q, oe) {
                return " " + Q + oe.join("")
            }
            ,
            mr = function(Q, oe) {
                return " M " + Q + "," + oe + " "
            }
            ,
            qn = function(Q, oe) {
                return " m " + Q + "," + oe + " "
            }
            ,
            As = function(Q, oe) {
                return " l " + Q + "," + oe + " "
            }
            ,
            Pi = function(Q) {
                return " l" + Q.join("")
            }
            ,
            ln = function(Q, oe) {
                return " " + Q + " " + oe + " "
            }
            ,
            sr = function(Q, oe, pe, Ae) {
                return Q + " " + pe + " " + pe + " " + oe + Ae
            }
            ,
            zu = function(Q, oe) {
                ne(Yt.ICON, Q.toString(), oe)
            }
            ,
            of = function(Q) {
                ce(Yt.ICON, Q)
            }
            ,
            Kl = function(Q) {
                const oe = Q.getProcedureMap().getProcedures().filter(Ae => !Ae.getReturnTypes()).map(Ae => [Ae.getName(), Ae.getParameters().map(Re => Re.getName()), !1]);
                Q.getBlocksByType("procedures_defnoreturn", !1).forEach(Ae => {
                    !po(Ae) && Kr(Ae) && oe.push(Ae.getProcedureDef())
                }
                );
                const pe = Q.getProcedureMap().getProcedures().filter(Ae => !!Ae.getReturnTypes()).map(Ae => [Ae.getName(), Ae.getParameters().map(Re => Re.getName()), !0]);
                return Q.getBlocksByType("procedures_defreturn", !1).forEach(Ae => {
                    !po(Ae) && Kr(Ae) && pe.push(Ae.getProcedureDef())
                }
                ),
                oe.sort(Ku),
                pe.sort(Ku),
                [oe, pe]
            }
            ,
            Ku = function(Q, oe) {
                return Q[0].localeCompare(oe[0], void 0, {
                    sensitivity: "base"
                })
            }
            ,
            J.findLegalName$$module$build$src$core$procedures = function(Q, oe) {
                if (oe.isInFlyout)
                    return Q;
                for (Q = Q || J.Msg$$module$build$src$core$msg.UNNAMED_KEY || "unnamed"; !af(Q, oe.workspace, oe); ) {
                    const pe = Q.match(/^(.*?)(\d+)$/);
                    Q = pe ? pe[1] + (parseInt(pe[2]) + 1) : Q + "2"
                }
                return Q
            }
            ,
            af = function(Q, oe, pe) {
                return !Ju(Q, oe, pe)
            }
            ,
            Ju = function(Q, oe, pe) {
                for (const Ae of oe.getAllBlocks(!1))
                    if (Ae !== pe && Kr(Ae) && J.Names$$module$build$src$core$names.equals(Ae.getProcedureDef()[0], Q))
                        return !0;
                pe = pe && po(pe) ? pe == null ? void 0 : pe.getProcedureModel() : void 0;
                for (const Ae of oe.getProcedureMap().getProcedures())
                    if (Ae !== pe && J.Names$$module$build$src$core$names.equals(Ae.getName(), Q))
                        return !0;
                return !1
            }
            ,
            J.rename$$module$build$src$core$procedures = function(Q) {
                var oe = this.getSourceBlock();
                if (!oe)
                    throw new Gn;
                Q = Q.trim();
                const pe = J.findLegalName$$module$build$src$core$procedures(Q, oe);
                po(oe) && !oe.isInsertionMarker() && oe.getProcedureModel().setName(pe);
                const Ae = this.getValue();
                if (Ae !== Q && Ae !== pe)
                    for (Q = oe.workspace.getAllBlocks(!1),
                    oe = 0; oe < Q.length; oe++) {
                        const Re = Q[oe];
                        Re.renameProcedure && Re.renameProcedure(Ae, pe)
                    }
                return pe
            }
            ,
            Jl = function(Q) {
                function oe(Ue, tt) {
                    for (let wt = 0; wt < Ue.length; wt++) {
                        var dt = Ue[wt][0];
                        const sn = Ue[wt][1]
                          , zn = J.createElement$$module$build$src$core$utils$xml("block");
                        zn.setAttribute("type", tt),
                        zn.setAttribute("gap", "16");
                        const jn = J.createElement$$module$build$src$core$utils$xml("mutation");
                        for (jn.setAttribute("name", dt),
                        zn.appendChild(jn),
                        dt = 0; dt < sn.length; dt++) {
                            const kr = J.createElement$$module$build$src$core$utils$xml("arg");
                            kr.setAttribute("name", sn[dt]),
                            jn.appendChild(kr)
                        }
                        pe.push(zn)
                    }
                }
                const pe = [];
                if (Nr.procedures_defnoreturn) {
                    var Ae = J.createElement$$module$build$src$core$utils$xml("block");
                    Ae.setAttribute("type", "procedures_defnoreturn"),
                    Ae.setAttribute("gap", "16");
                    var Re = J.createElement$$module$build$src$core$utils$xml("field");
                    Re.setAttribute("name", "NAME"),
                    Re.appendChild(J.createTextNode$$module$build$src$core$utils$xml(J.Msg$$module$build$src$core$msg.PROCEDURES_DEFNORETURN_PROCEDURE)),
                    Ae.appendChild(Re),
                    pe.push(Ae)
                }
                return Nr.procedures_defreturn && (Ae = J.createElement$$module$build$src$core$utils$xml("block"),
                Ae.setAttribute("type", "procedures_defreturn"),
                Ae.setAttribute("gap", "16"),
                Re = J.createElement$$module$build$src$core$utils$xml("field"),
                Re.setAttribute("name", "NAME"),
                Re.appendChild(J.createTextNode$$module$build$src$core$utils$xml(J.Msg$$module$build$src$core$msg.PROCEDURES_DEFRETURN_PROCEDURE)),
                Ae.appendChild(Re),
                pe.push(Ae)),
                Nr.procedures_ifreturn && (Ae = J.createElement$$module$build$src$core$utils$xml("block"),
                Ae.setAttribute("type", "procedures_ifreturn"),
                Ae.setAttribute("gap", "16"),
                pe.push(Ae)),
                pe.length && pe[pe.length - 1].setAttribute("gap", "24"),
                Q = Kl(Q),
                oe(Q[0], "procedures_callnoreturn"),
                oe(Q[1], "procedures_callreturn"),
                pe
            }
            ,
            qu = function(Q) {
                var oe = []
                  , pe = Q.getBlocksByType("procedures_mutatorarg", !1);
                for (let Ue = 0, tt; tt = pe[Ue]; Ue++)
                    oe.push(tt.getFieldValue("NAME"));
                pe = J.createElement$$module$build$src$core$utils$xml("xml");
                const Ae = J.createElement$$module$build$src$core$utils$xml("block");
                Ae.setAttribute("type", "procedures_mutatorarg");
                const Re = J.createElement$$module$build$src$core$utils$xml("field");
                Re.setAttribute("name", "NAME"),
                oe = bl(J.DEFAULT_ARG$$module$build$src$core$procedures, oe),
                oe = J.createTextNode$$module$build$src$core$utils$xml(oe),
                Re.appendChild(oe),
                Ae.appendChild(Re),
                pe.appendChild(Ae),
                Q.updateToolbox(pe)
            }
            ,
            Qu = function(Q) {
                if (Q.type === _s && Q.bubbleType === "mutator" && Q.isOpen && Q.blockId) {
                    Q = ye(Q.workspaceId).getBlockById(Q.blockId);
                    var oe = Q.type;
                    (oe === "procedures_defnoreturn" || oe === "procedures_defreturn") && (Q = Q.getIcon(J.MutatorIcon$$module$build$src$core$icons$mutator_icon.TYPE).getWorkspace(),
                    qu(Q),
                    Q.addChangeListener(lf))
                }
            }
            ,
            lf = function(Q) {
                (Q.type === J.CREATE$$module$build$src$core$events$utils || Q.type === J.DELETE$$module$build$src$core$events$utils || Q.type === J.CHANGE$$module$build$src$core$events$utils || Q.type === fo) && (Q = ye(Q.workspaceId),
                qu(Q))
            }
            ,
            Zu = function(Q, oe) {
                return oe.getAllBlocks(!1).filter(pe => cf(pe, Q) || nr(pe) && J.Names$$module$build$src$core$names.equals(pe.getProcedureCall(), Q))
            }
            ,
            cf = function(Q, oe) {
                return po(Q) && !Q.isProcedureDef() && Q.getProcedureModel() && J.Names$$module$build$src$core$names.equals(Q.getProcedureModel().getName(), oe)
            }
            ,
            J.mutateCallers$$module$build$src$core$procedures = function(Q) {
                const oe = St();
                var pe = Q.getProcedureDef()[0];
                const Ae = Q.mutationToDom(!0);
                Q = Zu(pe, Q.workspace);
                for (let Ue = 0, tt; tt = Q[Ue]; Ue++) {
                    pe = (pe = tt.mutationToDom()) && Pt(pe),
                    tt.domToMutation && tt.domToMutation(Ae);
                    var Re = tt.mutationToDom();
                    Re = Re && Pt(Re),
                    pe !== Re && (ft(!1),
                    Ye(new (gt(J.CHANGE$$module$build$src$core$events$utils))(tt,"mutation",null,pe,Re)),
                    ft(oe))
                }
            }
            ,
            J.getDefinition$$module$build$src$core$procedures = function(Q, oe) {
                for (const pe of oe.getAllBlocks(!1))
                    if (po(pe) && pe.isProcedureDef() && J.Names$$module$build$src$core$names.equals(pe.getProcedureModel().getName(), Q) || Kr(pe) && J.Names$$module$build$src$core$names.equals(pe.getProcedureDef()[0], Q))
                        return pe;
                return null
            }
            ,
            ed = function(Q) {
                return Q.isDynamic
            }
            ,
            Ua = function(Q) {
                let oe = Q.outputConnection;
                return (!oe || Q.previousConnection && Q.previousConnection.isConnected()) && (oe = Q.previousConnection),
                oe
            }
            ,
            uf = function(Q, oe) {
                if (!Q || !oe)
                    throw Error("Cannot connect null connections.");
                Q.targetConnection = oe,
                oe.targetConnection = Q
            }
            ,
            df = function(Q, oe) {
                let pe = null;
                oe = oe.outputConnection;
                const Ae = oe == null ? void 0 : oe.getConnectionChecker();
                for (let Re = 0, Ue; Ue = Q.inputList[Re]; Re++) {
                    const tt = Ue.connection;
                    let dt;
                    if (tt && ((dt = Ae) != null && dt.canConnect(oe, tt, !1))) {
                        if (pe)
                            return null;
                        pe = tt
                    }
                }
                return pe
            }
            ,
            hf = function(Q, oe) {
                let pe;
                for (; pe = df(Q, oe); )
                    if (Q = pe.targetBlock(),
                    !Q || Q.isShadow())
                        return pe;
                return null
            }
            ,
            Mi = function(Q, oe) {
                ne(Yt.RENDERER, Q, oe)
            }
            ,
            pf = function(Q) {
                ce(Yt.RENDERER, Q)
            }
            ,
            td = function(Q, oe, pe) {
                return Q = new (Te(Yt.RENDERER, Q))(Q),
                Q.init(oe, pe),
                Q
            }
            ,
            nd = function(Q) {
                Ii(Q.getTargetWorkspace(), void 0, "String")
            }
            ,
            rd = function(Q) {
                Ii(Q.getTargetWorkspace(), void 0, "Number")
            }
            ,
            sd = function(Q) {
                Ii(Q.getTargetWorkspace(), void 0, "Colour")
            }
            ,
            ql = function(Q) {
                let oe = []
                  , pe = document.createElement("button");
                return pe.setAttribute("text", J.Msg$$module$build$src$core$msg.NEW_STRING_VARIABLE),
                pe.setAttribute("callbackKey", "CREATE_VARIABLE_STRING"),
                oe.push(pe),
                pe = document.createElement("button"),
                pe.setAttribute("text", J.Msg$$module$build$src$core$msg.NEW_NUMBER_VARIABLE),
                pe.setAttribute("callbackKey", "CREATE_VARIABLE_NUMBER"),
                oe.push(pe),
                pe = document.createElement("button"),
                pe.setAttribute("text", J.Msg$$module$build$src$core$msg.NEW_COLOUR_VARIABLE),
                pe.setAttribute("callbackKey", "CREATE_VARIABLE_COLOUR"),
                oe.push(pe),
                Q.registerButtonCallback("CREATE_VARIABLE_STRING", nd),
                Q.registerButtonCallback("CREATE_VARIABLE_NUMBER", rd),
                Q.registerButtonCallback("CREATE_VARIABLE_COLOUR", sd),
                Q = od(Q),
                oe = oe.concat(Q)
            }
            ,
            od = function(Q) {
                Q = Q.getAllVariables();
                const oe = [];
                if (0 < Q.length) {
                    if (Nr.variables_set_dynamic) {
                        var pe = Q[Q.length - 1];
                        const Ae = J.createElement$$module$build$src$core$utils$xml("block");
                        Ae.setAttribute("type", "variables_set_dynamic"),
                        Ae.setAttribute("gap", "24"),
                        Ae.appendChild(Uo(pe)),
                        oe.push(Ae)
                    }
                    if (Nr.variables_get_dynamic) {
                        Q.sort(Xa.compareByName);
                        for (let Ae = 0, Re; Re = Q[Ae]; Ae++)
                            pe = J.createElement$$module$build$src$core$utils$xml("block"),
                            pe.setAttribute("type", "variables_get_dynamic"),
                            pe.setAttribute("gap", "8"),
                            pe.appendChild(Uo(Re)),
                            oe.push(pe)
                    }
                }
                return oe
            }
            ,
            Fa = function(Q) {
                return Q.toCopyData !== void 0
            }
            ,
            id = function() {
                Dn.registry.register({
                    name: Ps.ESCAPE,
                    preconditionFn(Q) {
                        return !Q.options.readOnly
                    },
                    callback(Q) {
                        return Q.hideChaff(),
                        !0
                    },
                    keyCodes: [bn.ESC]
                })
            }
            ,
            ad = function() {
                Dn.registry.register({
                    name: Ps.DELETE,
                    preconditionFn(Q) {
                        const oe = we();
                        return !Q.options.readOnly && oe != null && oe.isDeletable()
                    },
                    callback(Q, oe) {
                        return oe.preventDefault(),
                        Qs.inProgress() ? !1 : (we().checkAndDelete(),
                        !0)
                    },
                    keyCodes: [bn.DELETE, bn.BACKSPACE]
                })
            }
            ,
            ld = function() {
                const Q = Dn.registry.createSerializedKey(bn.C, [bn.CTRL])
                  , oe = Dn.registry.createSerializedKey(bn.C, [bn.ALT])
                  , pe = Dn.registry.createSerializedKey(bn.C, [bn.META]);
                Dn.registry.register({
                    name: Ps.COPY,
                    preconditionFn(Ae) {
                        const Re = we();
                        return !Ae.options.readOnly && !Qs.inProgress() && Re != null && Re.isDeletable() && Re.isMovable() && Fa(Re)
                    },
                    callback(Ae, Re) {
                        return Re.preventDefault(),
                        Ae.hideChaff(),
                        Re = we(),
                        !Re || !Fa(Re) ? !1 : (ml = Re.toCopyData(),
                        wc = Ae,
                        !!ml)
                    },
                    keyCodes: [Q, oe, pe]
                })
            }
            ,
            cd = function() {
                const Q = Dn.registry.createSerializedKey(bn.X, [bn.CTRL])
                  , oe = Dn.registry.createSerializedKey(bn.X, [bn.ALT])
                  , pe = Dn.registry.createSerializedKey(bn.X, [bn.META]);
                Dn.registry.register({
                    name: Ps.CUT,
                    preconditionFn(Ae) {
                        const Re = we();
                        return !Ae.options.readOnly && !Qs.inProgress() && Re != null && Re instanceof Ls && Re.isDeletable() && Re.isMovable() && !Re.workspace.isFlyout
                    },
                    callback(Ae) {
                        const Re = we();
                        return !Re || !Fa(Re) ? !1 : (ml = Re.toCopyData(),
                        wc = Ae,
                        Re.checkAndDelete(),
                        !0)
                    },
                    keyCodes: [Q, oe, pe]
                })
            }
            ,
            ud = function() {
                const Q = Dn.registry.createSerializedKey(bn.V, [bn.CTRL])
                  , oe = Dn.registry.createSerializedKey(bn.V, [bn.ALT])
                  , pe = Dn.registry.createSerializedKey(bn.V, [bn.META]);
                Dn.registry.register({
                    name: Ps.PASTE,
                    preconditionFn(Ae) {
                        return !Ae.options.readOnly && !Qs.inProgress()
                    },
                    callback() {
                        return ml && wc ? !!yi(ml, wc) : !1
                    },
                    keyCodes: [Q, oe, pe]
                })
            }
            ,
            dd = function() {
                const Q = Dn.registry.createSerializedKey(bn.Z, [bn.CTRL])
                  , oe = Dn.registry.createSerializedKey(bn.Z, [bn.ALT])
                  , pe = Dn.registry.createSerializedKey(bn.Z, [bn.META]);
                Dn.registry.register({
                    name: Ps.UNDO,
                    preconditionFn(Ae) {
                        return !Ae.options.readOnly && !Qs.inProgress()
                    },
                    callback(Ae) {
                        return Ae.hideChaff(),
                        Ae.undo(!1),
                        !0
                    },
                    keyCodes: [Q, oe, pe]
                })
            }
            ,
            hd = function() {
                const Q = Dn.registry.createSerializedKey(bn.Z, [bn.SHIFT, bn.CTRL])
                  , oe = Dn.registry.createSerializedKey(bn.Z, [bn.SHIFT, bn.ALT])
                  , pe = Dn.registry.createSerializedKey(bn.Z, [bn.SHIFT, bn.META])
                  , Ae = Dn.registry.createSerializedKey(bn.Y, [bn.CTRL]);
                Dn.registry.register({
                    name: Ps.REDO,
                    preconditionFn(Re) {
                        return !Qs.inProgress() && !Re.options.readOnly
                    },
                    callback(Re) {
                        return Re.hideChaff(),
                        Re.undo(!0),
                        !0
                    },
                    keyCodes: [Q, oe, pe, Ae]
                })
            }
            ,
            pd = function() {
                id(),
                ad(),
                ld(),
                cd(),
                ud(),
                dd(),
                hd()
            }
            ,
            md = function(Q) {
                const oe = {
                    id: Q.getId(),
                    name: Q.getName(),
                    returnTypes: Q.getReturnTypes()
                };
                return Q.getParameters().length && (oe.parameters = Q.getParameters().map(pe => fd(pe))),
                oe
            }
            ,
            fd = function(Q) {
                const oe = {
                    id: Q.getId(),
                    name: Q.getName()
                };
                return Q.getTypes().length && (oe.types = Q.getTypes()),
                oe
            }
            ,
            gd = function(Q, oe, pe, Ae) {
                if (Q = new Q(Ae,pe.name,pe.id).setReturnTypes(pe.returnTypes),
                !pe.parameters)
                    return Q;
                for (const [Re,Ue] of pe.parameters.entries())
                    Q.insertParameter(Ed(oe, Ue, Ae), Re);
                return Q
            }
            ,
            Ed = function(Q, oe, pe) {
                return Q = new Q(pe,oe.name,oe.id),
                oe.types && Q.setTypes(oe.types),
                Q
            }
            ,
            mf = function(Q) {
                const oe = Object.create(null)
                  , pe = Se(Yt.SERIALIZER, !0);
                for (const Ae in pe) {
                    let Re;
                    const Ue = (Re = pe[Ae]) == null ? void 0 : Re.save(Q);
                    Ue && (oe[Ae] = Ue)
                }
                return oe
            }
            ,
            ff = function(Q, oe, {recordUndo: pe=!1}={}) {
                var Ae = Se(Yt.SERIALIZER, !0);
                if (Ae) {
                    Ae = Object.entries(Ae).sort( (Ue, tt) => tt[1].priority - Ue[1].priority);
                    var Re = St();
                    ft(pe),
                    (pe = J.getGroup$$module$build$src$core$events$utils()) || J.setGroup$$module$build$src$core$events$utils(!0),
                    st(),
                    oe instanceof cs && oe.setResizesEnabled(!1);
                    for (const [,Ue] of Ae.reverse()) {
                        let tt;
                        (tt = Ue) == null || tt.clear(oe)
                    }
                    for (let[Ue,tt] of Ae.reverse())
                        if (Q[Ue]) {
                            let dt;
                            (dt = tt) == null || dt.load(Q[Ue], oe)
                        }
                    oe instanceof cs && oe.setResizesEnabled(!0),
                    ht(),
                    Ye(new (gt(Wo))(oe)),
                    J.setGroup$$module$build$src$core$events$utils(pe),
                    ft(Re)
                }
            }
            ,
            ki = function(Q, oe, pe) {
                const Ae = pe.getBoundingRectangle()
                  , Re = Ae.right - Ae.left
                  , Ue = $i(oe.top, Ae.top, oe.top + oe.height - (Ae.bottom - Ae.top)) - Ae.top;
                let tt = oe.left;
                return oe = oe.left + oe.width - Re,
                Q.RTL ? tt = Math.min(oe, tt) : oe = Math.max(tt, oe),
                (Q = $i(tt, Ae.left, oe) - Ae.left) || Ue ? (pe.moveBy(Q, Ue, ["inbounds"]),
                !0) : !1
            }
            ,
            Td = function(Q) {
                return oe => {
                    var pe = Q.getMetricsManager();
                    if (pe.hasFixedEdges() && !Q.isDragging()) {
                        var Ae;
                        if (rc.indexOf((Ae = oe.type) != null ? Ae : "") !== -1) {
                            Ae = pe.getScrollMetrics(!0);
                            const Re = gf(Q, oe);
                            Re && (pe = J.getGroup$$module$build$src$core$events$utils() || !1,
                            J.setGroup$$module$build$src$core$events$utils(oe.group),
                            ki(Q, Ae, Re) && !oe.group && console.warn("Moved object in bounds but there was no event group. This may break undo."),
                            J.setGroup$$module$build$src$core$events$utils(pe))
                        } else
                            oe.type === Eo && oe.scale && oe.oldScale && oe.scale > oe.oldScale && Ql(Q)
                    }
                }
            }
            ,
            gf = function(Q, oe) {
                let pe = null;
                switch (oe.type) {
                case J.CREATE$$module$build$src$core$events$utils:
                case J.MOVE$$module$build$src$core$events$utils:
                    (pe = Q.getBlockById(oe.blockId)) && (pe = pe.getRootBlock());
                    break;
                case To:
                case Ss:
                    pe = Q.getCommentById(oe.commentId)
                }
                return pe
            }
            ,
            Ql = function(Q) {
                var oe = Q.getMetricsManager();
                if (oe.hasFixedEdges() && !Q.isDragging()) {
                    oe = oe.getScrollMetrics(!0);
                    var pe = Q.getTopBoundedElements();
                    for (let Ae = 0, Re; Re = pe[Ae]; Ae++)
                        ki(Q, oe, Re)
                }
            }
            ,
            Ad = function(Q, oe) {
                const pe = [];
                for (const Ae of Q.getIcons())
                    (!uo(Ae) || Ae.bubbleIsVisible()) && (pe.push({
                        location: oe,
                        icon: Ae
                    }),
                    Ae.onLocationChange(oe));
                for (const Ae of Q.getChildren(!1))
                    pe.push(...Ad(Ae, Zt.sum(oe, Ae.relativeCoords)));
                return pe
            }
            ,
            _d = function() {
                Ln.registry.register({
                    displayText() {
                        return J.Msg$$module$build$src$core$msg.UNDO
                    },
                    preconditionFn(Q) {
                        return 0 < Q.workspace.getUndoStack().length ? "enabled" : "disabled"
                    },
                    callback(Q) {
                        Q.workspace.undo(!1)
                    },
                    scopeType: Ln.ScopeType.WORKSPACE,
                    id: "undoWorkspace",
                    weight: 1
                })
            }
            ,
            Sd = function() {
                Ln.registry.register({
                    displayText() {
                        return J.Msg$$module$build$src$core$msg.REDO
                    },
                    preconditionFn(Q) {
                        return 0 < Q.workspace.getRedoStack().length ? "enabled" : "disabled"
                    },
                    callback(Q) {
                        Q.workspace.undo(!0)
                    },
                    scopeType: Ln.ScopeType.WORKSPACE,
                    id: "redoWorkspace",
                    weight: 2
                })
            }
            ,
            Id = function() {
                Ln.registry.register({
                    displayText() {
                        return J.Msg$$module$build$src$core$msg.CLEAN_UP
                    },
                    preconditionFn(Q) {
                        return Q.workspace.isMovable() ? 1 < Q.workspace.getTopBlocks(!1).length ? "enabled" : "disabled" : "hidden"
                    },
                    callback(Q) {
                        Q.workspace.cleanUp()
                    },
                    scopeType: Ln.ScopeType.WORKSPACE,
                    id: "cleanWorkspace",
                    weight: 3
                })
            }
            ,
            Rd = function(Q, oe) {
                function pe(Ue) {
                    Re--,
                    Ue.setCollapsed(Q),
                    Re === 0 && J.setGroup$$module$build$src$core$events$utils(!1)
                }
                let Ae = 0
                  , Re = 0;
                J.setGroup$$module$build$src$core$events$utils(!0);
                for (let Ue = 0; Ue < oe.length; Ue++) {
                    let tt = oe[Ue];
                    for (; tt; )
                        Re++,
                        setTimeout(pe.bind(null, tt), Ae),
                        tt = tt.getNextBlock(),
                        Ae += 10
                }
            }
            ,
            yd = function() {
                Ln.registry.register({
                    displayText() {
                        return J.Msg$$module$build$src$core$msg.COLLAPSE_ALL
                    },
                    preconditionFn(Q) {
                        if (Q.workspace.options.collapse) {
                            Q = Q.workspace.getTopBlocks(!1);
                            for (let oe = 0; oe < Q.length; oe++) {
                                let pe = Q[oe];
                                for (; pe; ) {
                                    if (!pe.isCollapsed())
                                        return "enabled";
                                    pe = pe.getNextBlock()
                                }
                            }
                            return "disabled"
                        }
                        return "hidden"
                    },
                    callback(Q) {
                        Rd(!0, Q.workspace.getTopBlocks(!0))
                    },
                    scopeType: Ln.ScopeType.WORKSPACE,
                    id: "collapseWorkspace",
                    weight: 4
                })
            }
            ,
            bd = function() {
                Ln.registry.register({
                    displayText() {
                        return J.Msg$$module$build$src$core$msg.EXPAND_ALL
                    },
                    preconditionFn(Q) {
                        if (Q.workspace.options.collapse) {
                            Q = Q.workspace.getTopBlocks(!1);
                            for (let oe = 0; oe < Q.length; oe++) {
                                let pe = Q[oe];
                                for (; pe; ) {
                                    if (pe.isCollapsed())
                                        return "enabled";
                                    pe = pe.getNextBlock()
                                }
                            }
                            return "disabled"
                        }
                        return "hidden"
                    },
                    callback(Q) {
                        Rd(!1, Q.workspace.getTopBlocks(!0))
                    },
                    scopeType: Ln.ScopeType.WORKSPACE,
                    id: "expandWorkspace",
                    weight: 5
                })
            }
            ,
            $d = function(Q, oe) {
                if (Q.isDeletable())
                    Array.prototype.push.apply(oe, Q.getDescendants(!1));
                else {
                    Q = Q.getChildren(!1);
                    for (let pe = 0; pe < Q.length; pe++)
                        $d(Q[pe], oe)
                }
            }
            ,
            Zl = function(Q) {
                const oe = [];
                Q = Q.getTopBlocks(!0);
                for (let pe = 0; pe < Q.length; pe++)
                    $d(Q[pe], oe);
                return oe
            }
            ,
            Ha = function(Q, oe) {
                oe ? J.setGroup$$module$build$src$core$events$utils(oe) : (J.setGroup$$module$build$src$core$events$utils(!0),
                oe = J.getGroup$$module$build$src$core$events$utils());
                const pe = Q.shift();
                pe && (pe.isDeadOrDying() ? Ha(Q, oe) : (pe.dispose(!1, !0),
                setTimeout(Ha, 10, Q, oe))),
                J.setGroup$$module$build$src$core$events$utils(!1)
            }
            ,
            Od = function() {
                Ln.registry.register({
                    displayText(Q) {
                        return Q.workspace ? (Q = Zl(Q.workspace).length,
                        Q === 1 ? J.Msg$$module$build$src$core$msg.DELETE_BLOCK : J.Msg$$module$build$src$core$msg.DELETE_X_BLOCKS.replace("%1", `${Q}`)) : ""
                    },
                    preconditionFn(Q) {
                        return Q.workspace && 0 < Zl(Q.workspace).length ? "enabled" : "disabled"
                    },
                    callback(Q) {
                        if (Q.workspace) {
                            Q.workspace.cancelCurrentGesture();
                            var oe = Zl(Q.workspace);
                            2 > oe.length ? Ha(oe) : zr(J.Msg$$module$build$src$core$msg.DELETE_ALL_BLOCKS.replace("%1", String(oe.length)), function(pe) {
                                pe && Ha(oe)
                            })
                        }
                    },
                    scopeType: Ln.ScopeType.WORKSPACE,
                    id: "workspaceDelete",
                    weight: 6
                })
            }
            ,
            Ef = function() {
                _d(),
                Sd(),
                Id(),
                yd(),
                bd(),
                Od()
            }
            ,
            Cd = function() {
                Ln.registry.register({
                    displayText() {
                        return J.Msg$$module$build$src$core$msg.DUPLICATE_BLOCK
                    },
                    preconditionFn(Q) {
                        return Q = Q.block,
                        !Q.isInFlyout && Q.isDeletable() && Q.isMovable() ? Q.isDuplicatable() ? "enabled" : "disabled" : "hidden"
                    },
                    callback(Q) {
                        if (Q.block) {
                            var oe = Q.block.toCopyData();
                            oe && yi(oe, Q.block.workspace)
                        }
                    },
                    scopeType: Ln.ScopeType.BLOCK,
                    id: "blockDuplicate",
                    weight: 1
                })
            }
            ,
            vd = function() {
                Ln.registry.register({
                    displayText(Q) {
                        return Q.block.hasIcon(Rr.TYPE) ? J.Msg$$module$build$src$core$msg.REMOVE_COMMENT : J.Msg$$module$build$src$core$msg.ADD_COMMENT
                    },
                    preconditionFn(Q) {
                        return Q = Q.block,
                        !Q.isInFlyout && Q.workspace.options.comments && !Q.isCollapsed() && Q.isEditable() ? "enabled" : "hidden"
                    },
                    callback(Q) {
                        Q = Q.block,
                        Q.hasIcon(Rr.TYPE) ? Q.setCommentText(null) : Q.setCommentText("")
                    },
                    scopeType: Ln.ScopeType.BLOCK,
                    id: "blockComment",
                    weight: 2
                })
            }
            ,
            xd = function() {
                Ln.registry.register({
                    displayText(Q) {
                        return Q.block.getInputsInline() ? J.Msg$$module$build$src$core$msg.EXTERNAL_INPUTS : J.Msg$$module$build$src$core$msg.INLINE_INPUTS
                    },
                    preconditionFn(Q) {
                        if (Q = Q.block,
                        !Q.isInFlyout && Q.isMovable() && !Q.isCollapsed()) {
                            for (let oe = 1; oe < Q.inputList.length; oe++)
                                if (!(Q.inputList[oe - 1]instanceof Uc || Q.inputList[oe]instanceof Uc))
                                    return "enabled"
                        }
                        return "hidden"
                    },
                    callback(Q) {
                        Q.block.setInputsInline(!Q.block.getInputsInline())
                    },
                    scopeType: Ln.ScopeType.BLOCK,
                    id: "blockInline",
                    weight: 3
                })
            }
            ,
            Nd = function() {
                Ln.registry.register({
                    displayText(Q) {
                        return Q.block.isCollapsed() ? J.Msg$$module$build$src$core$msg.EXPAND_BLOCK : J.Msg$$module$build$src$core$msg.COLLAPSE_BLOCK
                    },
                    preconditionFn(Q) {
                        return Q = Q.block,
                        !Q.isInFlyout && Q.isMovable() && Q.workspace.options.collapse ? "enabled" : "hidden"
                    },
                    callback(Q) {
                        Q.block.setCollapsed(!Q.block.isCollapsed())
                    },
                    scopeType: Ln.ScopeType.BLOCK,
                    id: "blockCollapseExpand",
                    weight: 4
                })
            }
            ,
            Ld = function() {
                Ln.registry.register({
                    displayText(Q) {
                        return Q.block.isEnabled() ? J.Msg$$module$build$src$core$msg.DISABLE_BLOCK : J.Msg$$module$build$src$core$msg.ENABLE_BLOCK
                    },
                    preconditionFn(Q) {
                        return Q = Q.block,
                        !Q.isInFlyout && Q.workspace.options.disable && Q.isEditable() ? Q.getInheritedDisabled() ? "disabled" : "enabled" : "hidden"
                    },
                    callback(Q) {
                        Q = Q.block;
                        const oe = J.getGroup$$module$build$src$core$events$utils();
                        oe || J.setGroup$$module$build$src$core$events$utils(!0),
                        Q.setEnabled(!Q.isEnabled()),
                        J.setGroup$$module$build$src$core$events$utils(oe)
                    },
                    scopeType: Ln.ScopeType.BLOCK,
                    id: "blockDisable",
                    weight: 5
                })
            }
            ,
            Pd = function() {
                Ln.registry.register({
                    displayText(Q) {
                        var oe = Q.block;
                        return Q = oe.getDescendants(!1).length,
                        (oe = oe.getNextBlock()) && (Q -= oe.getDescendants(!1).length),
                        Q === 1 ? J.Msg$$module$build$src$core$msg.DELETE_BLOCK : J.Msg$$module$build$src$core$msg.DELETE_X_BLOCKS.replace("%1", `${Q}`)
                    },
                    preconditionFn(Q) {
                        return !Q.block.isInFlyout && Q.block.isDeletable() ? "enabled" : "hidden"
                    },
                    callback(Q) {
                        Q.block && Q.block.checkAndDelete()
                    },
                    scopeType: Ln.ScopeType.BLOCK,
                    id: "blockDelete",
                    weight: 6
                })
            }
            ,
            Md = function() {
                Ln.registry.register({
                    displayText() {
                        return J.Msg$$module$build$src$core$msg.HELP
                    },
                    preconditionFn(Q) {
                        return Q = Q.block,
                        (typeof Q.helpUrl == "function" ? Q.helpUrl() : Q.helpUrl) ? "enabled" : "hidden"
                    },
                    callback(Q) {
                        Q.block.showHelp()
                    },
                    scopeType: Ln.ScopeType.BLOCK,
                    id: "blockHelp",
                    weight: 7
                })
            }
            ,
            Tf = function() {
                Cd(),
                vd(),
                xd(),
                Nd(),
                Ld(),
                Pd(),
                Md()
            }
            ,
            kd = function() {
                Ef(),
                Tf()
            }
            ,
            Af = function(Q, oe) {
                var pe = null;
                pe = typeof Q == "string" ? document.getElementById(Q) || document.querySelector(Q) : Q;
                let Ae;
                if (!document.contains(pe) && document !== ((Ae = pe) == null ? void 0 : Ae.ownerDocument))
                    throw Error("Error: container is not in current document");
                Q = new Qr(oe || {}),
                oe = document.createElement("div"),
                oe.className = "injectionDiv",
                oe.tabIndex = 0,
                Jn(oe, Xn.LABEL, J.Msg$$module$build$src$core$msg.WORKSPACE_ARIA_LABEL),
                pe.appendChild(oe),
                pe = _f(oe, Q);
                const Re = Sf(oe, pe, Q);
                return If(Re),
                xe(Re),
                ze(Re),
                oe.addEventListener("focusin", function() {
                    xe(Re)
                }),
                Re
            }
            ,
            _f = function(Q, oe) {
                Q.setAttribute("dir", "LTR"),
                on(oe.hasCss, oe.pathToMedia),
                Q = $t(bt.SVG, {
                    xmlns: Ga,
                    "xmlns:html": Rs,
                    "xmlns:xlink": Fr,
                    version: "1.1",
                    class: "blocklySvg",
                    tabindex: "0"
                }, Q);
                const pe = $t(bt.DEFS, {}, Q)
                  , Ae = String(Math.random()).substring(2);
                return oe.gridPattern = vh.createDom(Ae, oe.gridOptions, pe),
                Q
            }
            ,
            Sf = function(Q, oe, pe) {
                pe.parentWorkspace = null,
                pe = new cs(pe);
                const Ae = pe.options;
                pe.scale = Ae.zoomOptions.startScale,
                oe.appendChild(pe.createDom("blocklyMainBackground", Q));
                var Re = pe.getRenderer().getClassName();
                return Re && Ut(Q, Re),
                (Re = pe.getTheme().getClassName()) && Ut(Q, Re),
                !Ae.hasCategories && Ae.languageTree && (Q = pe.addFlyout(bt.SVG),
                Wt(Q, oe)),
                Ae.hasTrashcan && pe.addTrashcan(),
                Ae.zoomOptions && Ae.zoomOptions.controls && pe.addZoomControls(),
                pe.getThemeManager().subscribe(oe, "workspaceBackgroundColour", "background-color"),
                pe.translate(0, 0),
                pe.addChangeListener(Td(pe)),
                ze(pe),
                su(),
                mu(),
                ku(),
                pe
            }
            ,
            If = function(Q) {
                const oe = Q.options;
                var pe = Q.getParentSvg();
                if (vt(pe.parentNode, "contextmenu", null, function(Ae) {
                    Mt(Ae) || Ae.preventDefault()
                }),
                pe = vt(window, "resize", null, function() {
                    Vs(),
                    Q.hideComponents(!0),
                    bu(),
                    lu(),
                    ze(Q),
                    Ql(Q)
                }),
                Q.setResizeHandlerWrapper(pe),
                yf(),
                oe.languageTree) {
                    pe = Q.getToolbox();
                    const Ae = Q.getFlyout(!0);
                    pe ? pe.init() : Ae && (Ae.init(Q),
                    Ae.show(oe.languageTree),
                    typeof Ae.scrollToStart == "function" && Ae.scrollToStart())
                }
                oe.hasTrashcan && Q.trashcan.init(),
                oe.zoomOptions && oe.zoomOptions.controls && Q.zoomControls_.init(),
                oe.moveOptions && oe.moveOptions.scrollbars ? (Q.scrollbar = new tp(Q,oe.moveOptions.scrollbars === !0 || !!oe.moveOptions.scrollbars.horizontal,oe.moveOptions.scrollbars === !0 || !!oe.moveOptions.scrollbars.vertical,"blocklyMainWorkspaceScrollbar"),
                Q.scrollbar.resize()) : Q.setMetrics({
                    x: .5,
                    y: .5
                }),
                oe.hasSounds && bf(oe.pathToMedia, Q)
            }
            ,
            Rf = function(Q) {
                const oe = ke();
                oe && !(Mt(Q) || oe.rendered && !oe.isVisible()) && Dn.registry.onKeyDown(oe, Q)
            }
            ,
            yf = function() {
                TE || (vt(document, "scroll", null, function() {
                    const Q = $e();
                    for (let oe = 0, pe; pe = Q[oe]; oe++)
                        pe instanceof cs && pe.updateInverseScreenCTM()
                }),
                vt(document, "keydown", null, Rf),
                Jt(document, "touchend", null, Ht),
                Jt(document, "touchcancel", null, Ht),
                Wi && vt(window, "orientationchange", document, function() {
                    ze(ke())
                })),
                TE = !0
            }
            ,
            bf = function(Q, oe) {
                function pe() {
                    for (; Re.length; ) {
                        const Ue = Re.pop();
                        Ue && Ct(Ue)
                    }
                    Ae.preload()
                }
                const Ae = oe.getAudioManager();
                Ae.load([Q + "click.mp3", Q + "click.wav", Q + "click.ogg"], "click"),
                Ae.load([Q + "disconnect.wav", Q + "disconnect.mp3", Q + "disconnect.ogg"], "disconnect"),
                Ae.load([Q + "delete.mp3", Q + "delete.ogg", Q + "delete.wav"], "delete");
                const Re = [];
                Re.push(vt(document, "pointermove", null, pe, !0)),
                Re.push(vt(document, "touchstart", null, pe, !0))
            }
            ,
            $f = function(Q) {
                return Q.getType !== void 0 && Q.initView !== void 0 && Q.dispose !== void 0 && Q.getWeight !== void 0 && Q.getSize !== void 0 && Q.applyColour !== void 0 && Q.hideForInsertionMarker !== void 0 && Q.updateEditable !== void 0 && Q.updateCollapsed !== void 0 && Q.isShownWhenCollapsed !== void 0 && Q.setOffsetInBlock !== void 0 && Q.onLocationChange !== void 0 && Q.onClick !== void 0
            }
            ,
            Of = function(Q) {
                return Q.paste !== void 0
            }
            ,
            Cf = function(Q) {
                return Q.isSelectable()
            }
            ,
            vf = function(Q) {
                ke().hideChaff(Q)
            }
            ,
            Tn = Tn || {},
            Tn.scope = {},
            Tn.ASSUME_ES5 = !1,
            Tn.ASSUME_NO_NATIVE_MAP = !1,
            Tn.ASSUME_NO_NATIVE_SET = !1,
            Tn.SIMPLE_FROUND_POLYFILL = !1,
            Tn.ISOLATE_POLYFILLS = !1,
            Tn.FORCE_POLYFILL_PROMISE = !1,
            Tn.FORCE_POLYFILL_PROMISE_WHEN_NO_UNHANDLED_REJECTION = !1,
            Tn.defineProperty = Tn.ASSUME_ES5 || typeof Object.defineProperties == "function" ? Object.defineProperty : function(Q, oe, pe) {
                return Q == Array.prototype || Q == Object.prototype || (Q[oe] = pe.value),
                Q
            }
            ,
            Tn.getGlobal = function(Q) {
                Q = [typeof globalThis == "object" && globalThis, Q, typeof window == "object" && window, typeof self == "object" && self, typeof commonjsGlobal == "object" && commonjsGlobal];
                for (var oe = 0; oe < Q.length; ++oe) {
                    var pe = Q[oe];
                    if (pe && pe.Math == Math)
                        return pe
                }
                throw Error("Cannot find global object")
            }
            ,
            Tn.global = Tn.getGlobal(this),
            Tn.IS_SYMBOL_NATIVE = typeof Symbol == "function" && typeof Symbol("x") == "symbol",
            Tn.TRUST_ES6_POLYFILLS = !Tn.ISOLATE_POLYFILLS || Tn.IS_SYMBOL_NATIVE,
            Tn.polyfills = {},
            Tn.propertyToPolyfillSymbol = {},
            Tn.POLYFILL_PREFIX = "$jscp$",
            Tn.polyfill = function(Q, oe, pe, Ae) {
                oe && (Tn.ISOLATE_POLYFILLS ? Tn.polyfillIsolated(Q, oe, pe, Ae) : Tn.polyfillUnisolated(Q, oe, pe, Ae))
            }
            ,
            Tn.polyfillUnisolated = function(Q, oe, pe, Ae) {
                for (pe = Tn.global,
                Q = Q.split("."),
                Ae = 0; Ae < Q.length - 1; Ae++) {
                    var Re = Q[Ae];
                    if (!(Re in pe))
                        return;
                    pe = pe[Re]
                }
                Q = Q[Q.length - 1],
                Ae = pe[Q],
                oe = oe(Ae),
                oe != Ae && oe != null && Tn.defineProperty(pe, Q, {
                    configurable: !0,
                    writable: !0,
                    value: oe
                })
            }
            ,
            Tn.polyfillIsolated = function(Q, oe, pe, Ae) {
                var Re = Q.split(".");
                Q = Re.length === 1,
                Ae = Re[0],
                Ae = !Q && Ae in Tn.polyfills ? Tn.polyfills : Tn.global;
                for (var Ue = 0; Ue < Re.length - 1; Ue++) {
                    var tt = Re[Ue];
                    if (!(tt in Ae))
                        return;
                    Ae = Ae[tt]
                }
                Re = Re[Re.length - 1],
                pe = Tn.IS_SYMBOL_NATIVE && pe === "es6" ? Ae[Re] : null,
                oe = oe(pe),
                oe != null && (Q ? Tn.defineProperty(Tn.polyfills, Re, {
                    configurable: !0,
                    writable: !0,
                    value: oe
                }) : oe !== pe && (Tn.propertyToPolyfillSymbol[Re] === void 0 && (pe = 1e9 * Math.random() >>> 0,
                Tn.propertyToPolyfillSymbol[Re] = Tn.IS_SYMBOL_NATIVE ? Tn.global.Symbol(Re) : Tn.POLYFILL_PREFIX + pe + "$" + Re),
                Tn.defineProperty(Ae, Tn.propertyToPolyfillSymbol[Re], {
                    configurable: !0,
                    writable: !0,
                    value: oe
                })))
            }
            ,
            Tn.polyfill("globalThis", function(Q) {
                return Q || Tn.global
            }, "es_2020", "es3"),
            Tn.arrayIteratorImpl = function(Q) {
                var oe = 0;
                return function() {
                    return oe < Q.length ? {
                        done: !1,
                        value: Q[oe++]
                    } : {
                        done: !0
                    }
                }
            }
            ,
            Tn.arrayIterator = function(Q) {
                return {
                    next: Tn.arrayIteratorImpl(Q)
                }
            }
            ,
            Tn.initSymbol = function() {}
            ,
            Tn.iteratorPrototype = function(Q) {
                return Q = {
                    next: Q
                },
                Q[Symbol.iterator] = function() {
                    return this
                }
                ,
                Q
            }
            ,
            Tn.iteratorFromArray = function(Q, oe) {
                Q instanceof String && (Q += "");
                var pe = 0
                  , Ae = !1
                  , Re = {
                    next: function() {
                        if (!Ae && pe < Q.length) {
                            var Ue = pe++;
                            return {
                                value: oe(Ue, Q[Ue]),
                                done: !1
                            }
                        }
                        return Ae = !0,
                        {
                            done: !0,
                            value: void 0
                        }
                    }
                };
                return Re[Symbol.iterator] = function() {
                    return Re
                }
                ,
                Re
            }
            ,
            Tn.polyfill("Array.prototype.values", function(Q) {
                return Q || function() {
                    return Tn.iteratorFromArray(this, function(oe, pe) {
                        return pe
                    })
                }
            }, "es8", "es3"),
            Tn.polyfill("Array.prototype.flat", function(Q) {
                return Q || function(oe) {
                    oe = oe === void 0 ? 1 : oe;
                    var pe = [];
                    return Array.prototype.forEach.call(this, function(Ae) {
                        Array.isArray(Ae) && 0 < oe ? (Ae = Array.prototype.flat.call(Ae, oe - 1),
                        pe.push.apply(pe, Ae)) : pe.push(Ae)
                    }),
                    pe
                }
            }, "es9", "es5"),
            Tn.owns = function(Q, oe) {
                return Object.prototype.hasOwnProperty.call(Q, oe)
            }
            ,
            Tn.polyfill("Object.entries", function(Q) {
                return Q || function(oe) {
                    var pe = [], Ae;
                    for (Ae in oe)
                        Tn.owns(oe, Ae) && pe.push([Ae, oe[Ae]]);
                    return pe
                }
            }, "es8", "es3"),
            Tn.polyfill("Object.values", function(Q) {
                return Q || function(oe) {
                    var pe = [], Ae;
                    for (Ae in oe)
                        Tn.owns(oe, Ae) && pe.push(oe[Ae]);
                    return pe
                }
            }, "es8", "es3");
            var mo = Object.create(null)
              , qE = {
                typeMap: mo
            }
              , ec = Object.create(null)
              , js = "default"
              , Yt = class {
                constructor(Q) {
                    this.name = Q
                }
                toString() {
                    return this.name
                }
            }
            ;
            Yt.CONNECTION_CHECKER = new Yt("connectionChecker"),
            Yt.CURSOR = new Yt("cursor"),
            Yt.EVENT = new Yt("event"),
            Yt.FIELD = new Yt("field"),
            Yt.INPUT = new Yt("input"),
            Yt.RENDERER = new Yt("renderer"),
            Yt.TOOLBOX = new Yt("toolbox"),
            Yt.THEME = new Yt("theme"),
            Yt.TOOLBOX_ITEM = new Yt("toolboxItem"),
            Yt.FLYOUTS_VERTICAL_TOOLBOX = new Yt("flyoutsVerticalToolbox"),
            Yt.FLYOUTS_HORIZONTAL_TOOLBOX = new Yt("flyoutsHorizontalToolbox"),
            Yt.METRICS_MANAGER = new Yt("metricsManager"),
            Yt.BLOCK_DRAGGER = new Yt("blockDragger"),
            Yt.SERIALIZER = new Yt("serializer"),
            Yt.ICON = new Yt("icon"),
            Yt.PASTER = new Yt("paster");
            var Ws = {
                DEFAULT: js,
                TEST_ONLY: qE
            };
            Ws.Type = Yt,
            Ws.getAllItems = Se,
            Ws.getClass = Te,
            Ws.getClassFromOptions = Ie,
            Ws.getObject = _e,
            Ws.hasItem = ge,
            Ws.register = ne,
            Ws.unregister = ce;
            var Nr = Object.create(null), Va = Object.create(null), xf, Nf = null, Lf, Di = [], Pf = {
                defineBlocksWithJsonArrayInternal: it
            }, fr = {
                TEST_ONLY: Pf
            };
            fr.createBlockDefinitionsFromJsonArray = J.createBlockDefinitionsFromJsonArray$$module$build$src$core$common,
            fr.defineBlocks = J.defineBlocks$$module$build$src$core$common,
            fr.defineBlocksWithJsonArray = et,
            fr.draggingConnections = Di,
            fr.getAllWorkspaces = $e,
            fr.getBlockTypeCounts = qe,
            fr.getMainWorkspace = ke,
            fr.getParentContainer = je,
            fr.getSelected = we,
            fr.getWorkspaceById = ye,
            fr.registerWorkspace = Ne,
            fr.setMainWorkspace = xe,
            fr.setParentContainer = Xe,
            fr.setSelected = Fe,
            fr.svgResize = ze,
            fr.unregisterWorkpace = ve;
            var Mf = "!#$%()*+,-./:;=?@[]^_`{|}~ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
              , kf = {
                genUid: () => {
                    const Q = Mf.length
                      , oe = [];
                    for (let pe = 0; 20 > pe; pe++)
                        oe[pe] = Mf.charAt(Math.random() * Q);
                    return oe.join("")
                }
            }
              , QE = 0
              , Dd = {
                TEST_ONLY: kf
            };
            Dd.genUid = rt,
            Dd.getNextUniqueId = at;
            var wd, wi, tc, fo, go, Vo, Bi, nc, Go, Ys, Xs, Ui, _s, Fi, Hi, Vi, Eo, To, jo, Gi, Ss, Wo, rc, Yo, sc, Sr;
            wd = "",
            wi = !0,
            tc = 0,
            J.CREATE$$module$build$src$core$events$utils = "create",
            J.CREATE$$module$build$src$core$events$utils,
            J.DELETE$$module$build$src$core$events$utils = "delete",
            J.DELETE$$module$build$src$core$events$utils,
            J.CHANGE$$module$build$src$core$events$utils = "change",
            J.CHANGE$$module$build$src$core$events$utils,
            fo = "block_field_intermediate_change",
            J.MOVE$$module$build$src$core$events$utils = "move",
            J.MOVE$$module$build$src$core$events$utils,
            go = "var_create",
            Vo = "var_delete",
            Bi = "var_rename",
            nc = "ui",
            Go = "drag",
            Ys = "selected",
            Xs = "click",
            Ui = "marker_move",
            _s = "bubble_open",
            Fi = "trashcan_open",
            Hi = "toolbox_item_select",
            Vi = "theme_change",
            Eo = "viewport_change",
            To = "comment_create",
            jo = "comment_delete",
            Gi = "comment_change",
            Ss = "comment_move",
            Wo = "finished_loading",
            rc = [J.CREATE$$module$build$src$core$events$utils, J.MOVE$$module$build$src$core$events$utils, To, Ss],
            Yo = [],
            sc = {
                FIRE_QUEUE: Yo,
                fireNow: nt,
                fireInternal: We,
                setGroupInternal: mt
            },
            Sr = {
                BLOCK_CHANGE: J.CHANGE$$module$build$src$core$events$utils,
                BLOCK_CREATE: J.CREATE$$module$build$src$core$events$utils,
                BLOCK_DELETE: J.DELETE$$module$build$src$core$events$utils,
                BLOCK_DRAG: Go,
                BLOCK_FIELD_INTERMEDIATE_CHANGE: fo,
                BLOCK_MOVE: J.MOVE$$module$build$src$core$events$utils,
                BUBBLE_OPEN: _s,
                BUMP_EVENTS: rc,
                CHANGE: J.CHANGE$$module$build$src$core$events$utils,
                CLICK: Xs,
                COMMENT_CHANGE: Gi,
                COMMENT_CREATE: To,
                COMMENT_DELETE: jo,
                COMMENT_MOVE: Ss,
                CREATE: J.CREATE$$module$build$src$core$events$utils,
                DELETE: J.DELETE$$module$build$src$core$events$utils,
                FINISHED_LOADING: Wo,
                MARKER_MOVE: Ui,
                MOVE: J.MOVE$$module$build$src$core$events$utils,
                SELECTED: Ys,
                TEST_ONLY: sc,
                THEME_CHANGE: Vi,
                TOOLBOX_ITEM_SELECT: Hi,
                TRASHCAN_OPEN: Fi,
                UI: nc,
                VAR_CREATE: go,
                VAR_DELETE: Vo,
                VAR_RENAME: Bi,
                VIEWPORT_CHANGE: Eo
            },
            Sr.clearPendingUndo = Et,
            Sr.disable = J.disable$$module$build$src$core$events$utils,
            Sr.disableOrphans = Nt,
            Sr.enable = J.enable$$module$build$src$core$events$utils,
            Sr.filter = ct,
            Sr.fire = Ye,
            Sr.fromJson = Qe,
            Sr.get = gt,
            Sr.getDescendantIds = lt,
            Sr.getGroup = J.getGroup$$module$build$src$core$events$utils,
            Sr.getRecordUndo = St,
            Sr.isEnabled = Ke,
            Sr.setGroup = J.setGroup$$module$build$src$core$events$utils,
            Sr.setRecordUndo = ft;
            var ji = class {
                constructor() {
                    this.workspaceId = void 0,
                    this.isUiEvent = !1,
                    this.type = "",
                    this.group = J.getGroup$$module$build$src$core$events$utils(),
                    this.recordUndo = St()
                }
                toJson() {
                    return {
                        type: this.type,
                        group: this.group
                    }
                }
                static fromJson(Q, oe, pe) {
                    return pe.isBlank = !1,
                    pe.group = Q.group || "",
                    pe.workspaceId = oe.id,
                    pe
                }
                isNull() {
                    return !1
                }
                run(Q) {}
                getEventWorkspace_() {
                    let Q;
                    if (this.workspaceId && (Q = ye(this.workspaceId)),
                    !Q)
                        throw Error("Workspace is null. Event must have been generated from real Blockly events.");
                    return Q
                }
            }
            , Is = class extends ji {
                constructor(Q) {
                    super(),
                    this.recordUndo = !1,
                    this.isUiEvent = !0,
                    this.isBlank = typeof Q > "u",
                    this.workspaceId = Q || ""
                }
            }
            , Bd = class extends Is {
                constructor(Q, oe, pe) {
                    oe = Q ? Q.workspace.id : oe,
                    oe === null && (oe = void 0),
                    super(oe),
                    this.type = Xs,
                    this.blockId = Q ? Q.id : void 0,
                    this.targetType = pe
                }
                toJson() {
                    const Q = super.toJson();
                    if (!this.targetType)
                        throw Error("The click target type is undefined. Either pass a block to the constructor, or call fromJson");
                    return Q.targetType = this.targetType,
                    Q.blockId = this.blockId,
                    Q
                }
                static fromJson(Q, oe, pe) {
                    return oe = super.fromJson(Q, oe, pe ?? new Bd),
                    oe.targetType = Q.targetType,
                    oe.blockId = Q.blockId,
                    oe
                }
            }
            , Ud;
            (function(Q) {
                Q.BLOCK = "block",
                Q.WORKSPACE = "workspace",
                Q.ZOOM_CONTROLS = "zoom_controls"
            }
            )(Ud || (Ud = {})),
            ne(Yt.EVENT, Xs, Bd);
            var ZE = 750
              , Df = "ontouchstart"in globalThis || !!(globalThis.document && document.documentElement && "ontouchstart"in document.documentElement) || !(!globalThis.navigator || !globalThis.navigator.maxTouchPoints && !globalThis.navigator.msMaxTouchPoints)
              , oc = null
              , Xo = {
                mousedown: ["pointerdown"],
                mouseenter: ["pointerenter"],
                mouseleave: ["pointerleave"],
                mousemove: ["pointermove"],
                mouseout: ["pointerout"],
                mouseover: ["pointerover"],
                mouseup: ["pointerup", "pointercancel"],
                touchend: ["pointerup"],
                touchcancel: ["pointercancel"]
            }
              , ic = 0
              , zo = {
                TOUCH_ENABLED: Df,
                TOUCH_MAP: Xo
            };
            zo.checkTouchIdentifier = Xt,
            zo.clearTouchIdentifier = Kt,
            zo.getTouchIdentifierFromEvent = kt,
            zo.longStart = Gt,
            zo.longStop = Ht,
            zo.shouldHandleEvent = Ot;
            var Fd, wf, Bf, Uf, ac, lc, Hd, Ff, Hf, Vf;
            (function(Q) {
                function oe(Ae) {
                    return pe.indexOf(Ae.toUpperCase()) !== -1
                }
                Fd = Q;
                const pe = Fd.toUpperCase();
                wf = oe("JavaFX"),
                Bf = oe("WebKit"),
                Uf = oe("Gecko") && !Bf,
                ac = oe("Android"),
                Q = globalThis.navigator && globalThis.navigator.maxTouchPoints,
                lc = oe("iPad") || oe("Macintosh") && 0 < Q,
                Hd = oe("iPhone") && !lc,
                Ff = oe("Macintosh"),
                Hf = lc || ac && !oe("Mobile") || oe("Silk"),
                Vf = !Hf && (Hd || ac)
            }
            )(globalThis.navigator && globalThis.navigator.userAgent || "");
            var eT = Fd
              , Gf = wf
              , Vd = Uf
              , cc = ac
              , Wi = lc
              , jf = Hd
              , Gd = Ff
              , jd = Vf
              , tT = {
                ANDROID: cc,
                GECKO: Vd,
                IPAD: Wi,
                IPHONE: jf,
                JavaFx: Gf,
                MAC: Gd,
                MOBILE: jd,
                raw: eT
            }
              , Wf = 40
              , Yf = 125
              , zs = {};
            zs.bind = Jt,
            zs.conditionalBind = vt,
            zs.getScrollDeltaPixels = mn,
            zs.isRightButton = nn,
            zs.isTargetInput = Mt,
            zs.mouseToSvg = tn,
            zs.unbind = Ct;
            var Xf = {};
            Xf.removeElem = dn;
            var Ks = class {
                constructor(Q) {
                    this.name_ = Q
                }
                toString() {
                    return this.name_
                }
            }
            ;
            Ks.POSITIONABLE = new Ks("positionable"),
            Ks.DRAG_TARGET = new Ks("drag_target"),
            Ks.DELETE_AREA = new Ks("delete_area"),
            Ks.AUTOHIDEABLE = new Ks("autohideable");
            var dr = class {
                constructor() {
                    this.componentData = new Map,
                    this.capabilityToComponentIds = new Map
                }
                addComponent(Q, oe) {
                    const pe = Q.component.id;
                    if (!oe && this.componentData.has(pe)) {
                        var Ae;
                        throw Error('Plugin "' + pe + '" with capabilities "' + ((Ae = this.componentData.get(pe)) == null ? void 0 : Ae.capabilities) + '" already added.')
                    }
                    for (this.componentData.set(pe, Q),
                    oe = [],
                    Ae = 0; Ae < Q.capabilities.length; Ae++) {
                        const Re = String(Q.capabilities[Ae]).toLowerCase();
                        if (oe.push(Re),
                        this.capabilityToComponentIds.has(Re)) {
                            let Ue;
                            (Ue = this.capabilityToComponentIds.get(Re)) == null || Ue.push(pe)
                        } else
                            this.capabilityToComponentIds.set(Re, [pe])
                    }
                    this.componentData.get(pe).capabilities = oe
                }
                removeComponent(Q) {
                    const oe = this.componentData.get(Q);
                    if (oe) {
                        for (let pe = 0; pe < oe.capabilities.length; pe++) {
                            const Ae = String(oe.capabilities[pe]).toLowerCase();
                            dn(this.capabilityToComponentIds.get(Ae), Q)
                        }
                        this.componentData.delete(Q)
                    }
                }
                addCapability(Q, oe) {
                    if (!this.getComponent(Q))
                        throw Error('Cannot add capability, "' + oe + '". Plugin "' + Q + '" has not been added to the ComponentManager');
                    if (this.hasCapability(Q, oe))
                        console.warn('Plugin "' + Q + 'already has capability "' + oe + '"');
                    else {
                        oe = `${oe}`.toLowerCase();
                        var pe;
                        (pe = this.componentData.get(Q)) == null || pe.capabilities.push(oe);
                        var Ae;
                        (Ae = this.capabilityToComponentIds.get(oe)) == null || Ae.push(Q)
                    }
                }
                removeCapability(Q, oe) {
                    if (!this.getComponent(Q))
                        throw Error('Cannot remove capability, "' + oe + '". Plugin "' + Q + '" has not been added to the ComponentManager');
                    this.hasCapability(Q, oe) ? (oe = `${oe}`.toLowerCase(),
                    dn(this.componentData.get(Q).capabilities, oe),
                    dn(this.capabilityToComponentIds.get(oe), Q)) : console.warn('Plugin "' + Q + `doesn't have capability "` + oe + '" to remove')
                }
                hasCapability(Q, oe) {
                    return oe = `${oe}`.toLowerCase(),
                    this.componentData.has(Q) && this.componentData.get(Q).capabilities.indexOf(oe) !== -1
                }
                getComponent(Q) {
                    let oe;
                    return (oe = this.componentData.get(Q)) == null ? void 0 : oe.component
                }
                getComponents(Q, oe) {
                    if (Q = `${Q}`.toLowerCase(),
                    Q = this.capabilityToComponentIds.get(Q),
                    !Q)
                        return [];
                    const pe = [];
                    if (oe) {
                        const Ae = [];
                        Q.forEach(Re => {
                            Ae.push(this.componentData.get(Re))
                        }
                        ),
                        Ae.sort(function(Re, Ue) {
                            return Re.weight - Ue.weight
                        }),
                        Ae.forEach(function(Re) {
                            pe.push(Re.component)
                        })
                    } else
                        Q.forEach(Ae => {
                            pe.push(this.componentData.get(Ae).component)
                        }
                        );
                    return pe
                }
            }
            ;
            dr.Capability = Ks;
            var Wd = !1
              , Yd = `
.blocklySvg {
  background-color: #fff;
  outline: none;
  overflow: hidden;  /* IE overflows by default. */
  position: absolute;
  display: block;
}

.blocklyWidgetDiv {
  display: none;
  position: absolute;
  z-index: 99999;  /* big value for bootstrap3 compatibility */
}

.injectionDiv {
  height: 100%;
  position: relative;
  overflow: hidden;  /* So blocks in drag surface disappear at edges */
  touch-action: none;
}

.blocklyNonSelectable {
  user-select: none;
  -ms-user-select: none;
  -webkit-user-select: none;
}

.blocklyBlockCanvas.blocklyCanvasTransitioning,
.blocklyBubbleCanvas.blocklyCanvasTransitioning {
  transition: transform .5s;
}

.blocklyTooltipDiv {
  background-color: #ffffc7;
  border: 1px solid #ddc;
  box-shadow: 4px 4px 20px 1px rgba(0,0,0,.15);
  color: #000;
  display: none;
  font: 9pt sans-serif;
  opacity: .9;
  padding: 2px;
  position: absolute;
  z-index: 100000;  /* big value for bootstrap3 compatibility */
}

.blocklyDropDownDiv {
  position: absolute;
  left: 0;
  top: 0;
  z-index: 1000;
  display: none;
  border: 1px solid;
  border-color: #dadce0;
  background-color: #fff;
  border-radius: 2px;
  padding: 4px;
  box-shadow: 0 0 3px 1px rgba(0,0,0,.3);
}

.blocklyDropDownDiv.blocklyFocused {
  box-shadow: 0 0 6px 1px rgba(0,0,0,.3);
}

.blocklyDropDownContent {
  max-height: 300px;  /* @todo: spec for maximum height. */
  overflow: auto;
  overflow-x: hidden;
  position: relative;
}

.blocklyDropDownArrow {
  position: absolute;
  left: 0;
  top: 0;
  width: 16px;
  height: 16px;
  z-index: -1;
  background-color: inherit;
  border-color: inherit;
}

.blocklyDropDownButton {
  display: inline-block;
  float: left;
  padding: 0;
  margin: 4px;
  border-radius: 4px;
  outline: none;
  border: 1px solid;
  transition: box-shadow .1s;
  cursor: pointer;
}

.blocklyArrowTop {
  border-top: 1px solid;
  border-left: 1px solid;
  border-top-left-radius: 4px;
  border-color: inherit;
}

.blocklyArrowBottom {
  border-bottom: 1px solid;
  border-right: 1px solid;
  border-bottom-right-radius: 4px;
  border-color: inherit;
}

.blocklyResizeSE {
  cursor: se-resize;
  fill: #aaa;
}

.blocklyResizeSW {
  cursor: sw-resize;
  fill: #aaa;
}

.blocklyResizeLine {
  stroke: #515A5A;
  stroke-width: 1;
}

.blocklyHighlightedConnectionPath {
  fill: none;
  stroke: #fc3;
  stroke-width: 4px;
}

.blocklyPathLight {
  fill: none;
  stroke-linecap: round;
  stroke-width: 1;
}

.blocklySelected>.blocklyPathLight {
  display: none;
}

.blocklyDraggable {
  cursor: grab;
  cursor: -webkit-grab;
}

.blocklyDragging {
  cursor: grabbing;
  cursor: -webkit-grabbing;
}

  /* Changes cursor on mouse down. Not effective in Firefox because of
     https://bugzilla.mozilla.org/show_bug.cgi?id=771241 */
.blocklyDraggable:active {
  cursor: grabbing;
  cursor: -webkit-grabbing;
}

.blocklyDragging.blocklyDraggingDelete {
  cursor: url("<<<PATH>>>/handdelete.cur"), auto;
}

.blocklyDragging>.blocklyPath,
.blocklyDragging>.blocklyPathLight {
  fill-opacity: .8;
  stroke-opacity: .8;
}

.blocklyDragging>.blocklyPathDark {
  display: none;
}

.blocklyDisabled>.blocklyPath {
  fill-opacity: .5;
  stroke-opacity: .5;
}

.blocklyDisabled>.blocklyPathLight,
.blocklyDisabled>.blocklyPathDark {
  display: none;
}

.blocklyInsertionMarker>.blocklyPath,
.blocklyInsertionMarker>.blocklyPathLight,
.blocklyInsertionMarker>.blocklyPathDark {
  fill-opacity: .2;
  stroke: none;
}

.blocklyMultilineText {
  font-family: monospace;
}

.blocklyNonEditableText>text {
  pointer-events: none;
}

.blocklyFlyout {
  position: absolute;
  z-index: 20;
}

.blocklyText text {
  cursor: default;
}

/*
  Don't allow users to select text.  It gets annoying when trying to
  drag a block and selected text moves instead.
*/
.blocklySvg text {
  user-select: none;
  -ms-user-select: none;
  -webkit-user-select: none;
  cursor: inherit;
}

.blocklyHidden {
  display: none;
}

.blocklyFieldDropdown:not(.blocklyHidden) {
  display: block;
}

.blocklyIconGroup {
  cursor: default;
}

.blocklyIconGroup:not(:hover),
.blocklyIconGroupReadonly {
  opacity: .6;
}

.blocklyIconShape {
  fill: #00f;
  stroke: #fff;
  stroke-width: 1px;
}

.blocklyIconSymbol {
  fill: #fff;
}

.blocklyMinimalBody {
  margin: 0;
  padding: 0;
}

.blocklyHtmlInput {
  border: none;
  border-radius: 4px;
  height: 100%;
  margin: 0;
  outline: none;
  padding: 0;
  width: 100%;
  text-align: center;
  display: block;
  box-sizing: border-box;
}

/* Remove the increase and decrease arrows on the field number editor */
input.blocklyHtmlInput[type=number]::-webkit-inner-spin-button,
input.blocklyHtmlInput[type=number]::-webkit-outer-spin-button {
  -webkit-appearance: none;
  margin: 0;
}

input[type=number] {
  -moz-appearance: textfield;
}

.blocklyMainBackground {
  stroke-width: 1;
  stroke: #c6c6c6;  /* Equates to #ddd due to border being off-pixel. */
}

.blocklyMutatorBackground {
  fill: #fff;
  stroke: #ddd;
  stroke-width: 1;
}

.blocklyFlyoutBackground {
  fill: #ddd;
  fill-opacity: .8;
}

.blocklyMainWorkspaceScrollbar {
  z-index: 20;
}

.blocklyFlyoutScrollbar {
  z-index: 30;
}

.blocklyScrollbarHorizontal,
.blocklyScrollbarVertical {
  position: absolute;
  outline: none;
}

.blocklyScrollbarBackground {
  opacity: 0;
}

.blocklyScrollbarHandle {
  fill: #ccc;
}

.blocklyScrollbarBackground:hover+.blocklyScrollbarHandle,
.blocklyScrollbarHandle:hover {
  fill: #bbb;
}

/* Darken flyout scrollbars due to being on a grey background. */
/* By contrast, workspace scrollbars are on a white background. */
.blocklyFlyout .blocklyScrollbarHandle {
  fill: #bbb;
}

.blocklyFlyout .blocklyScrollbarBackground:hover+.blocklyScrollbarHandle,
.blocklyFlyout .blocklyScrollbarHandle:hover {
  fill: #aaa;
}

.blocklyInvalidInput {
  background: #faa;
}

.blocklyVerticalMarker {
  stroke-width: 3px;
  fill: rgba(255,255,255,.5);
  pointer-events: none;
}

.blocklyComputeCanvas {
  position: absolute;
  width: 0;
  height: 0;
}

.blocklyNoPointerEvents {
  pointer-events: none;
}

.blocklyContextMenu {
  border-radius: 4px;
  max-height: 100%;
}

.blocklyDropdownMenu {
  border-radius: 2px;
  padding: 0 !important;
}

.blocklyDropdownMenu .blocklyMenuItem {
  /* 28px on the left for icon or checkbox. */
  padding-left: 28px;
}

/* BiDi override for the resting state. */
.blocklyDropdownMenu .blocklyMenuItemRtl {
  /* Flip left/right padding for BiDi. */
  padding-left: 5px;
  padding-right: 28px;
}

.blocklyWidgetDiv .blocklyMenu {
  background: #fff;
  border: 1px solid transparent;
  box-shadow: 0 0 3px 1px rgba(0,0,0,.3);
  font: normal 13px Arial, sans-serif;
  margin: 0;
  outline: none;
  padding: 4px 0;
  position: absolute;
  overflow-y: auto;
  overflow-x: hidden;
  max-height: 100%;
  z-index: 20000;  /* Arbitrary, but some apps depend on it... */
}

.blocklyWidgetDiv .blocklyMenu.blocklyFocused {
  box-shadow: 0 0 6px 1px rgba(0,0,0,.3);
}

.blocklyDropDownDiv .blocklyMenu {
  background: inherit;  /* Compatibility with gapi, reset from goog-menu */
  border: inherit;  /* Compatibility with gapi, reset from goog-menu */
  font: normal 13px "Helvetica Neue", Helvetica, sans-serif;
  outline: none;
  position: relative;  /* Compatibility with gapi, reset from goog-menu */
  z-index: 20000;  /* Arbitrary, but some apps depend on it... */
}

/* State: resting. */
.blocklyMenuItem {
  border: none;
  color: #000;
  cursor: pointer;
  list-style: none;
  margin: 0;
  /* 7em on the right for shortcut. */
  min-width: 7em;
  padding: 6px 15px;
  white-space: nowrap;
}

/* State: disabled. */
.blocklyMenuItemDisabled {
  color: #ccc;
  cursor: inherit;
}

/* State: hover. */
.blocklyMenuItemHighlight {
  background-color: rgba(0,0,0,.1);
}

/* State: selected/checked. */
.blocklyMenuItemCheckbox {
  height: 16px;
  position: absolute;
  width: 16px;
}

.blocklyMenuItemSelected .blocklyMenuItemCheckbox {
  background: url(<<<PATH>>>/sprites.png) no-repeat -48px -16px;
  float: left;
  margin-left: -24px;
  position: static;  /* Scroll with the menu. */
}

.blocklyMenuItemRtl .blocklyMenuItemCheckbox {
  float: right;
  margin-right: -24px;
}

.blocklyBlockDragSurface {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  overflow: visible !important;
  z-index: 80;
  pointer-events: none;
}
`
              , Xd = {};
            Xd.inject = on,
            Xd.register = Qt;
            var Zt = class {
                constructor(Q, oe) {
                    this.x = Q,
                    this.y = oe
                }
                clone() {
                    return new Zt(this.x,this.y)
                }
                scale(Q) {
                    return this.x *= Q,
                    this.y *= Q,
                    this
                }
                translate(Q, oe) {
                    return this.x += Q,
                    this.y += oe,
                    this
                }
                static equals(Q, oe) {
                    return Q === oe ? !0 : Q && oe ? Q.x === oe.x && Q.y === oe.y : !1
                }
                static distance(Q, oe) {
                    const pe = Q.x - oe.x;
                    return Q = Q.y - oe.y,
                    Math.sqrt(pe * pe + Q * Q)
                }
                static magnitude(Q) {
                    return Math.sqrt(Q.x * Q.x + Q.y * Q.y)
                }
                static difference(Q, oe) {
                    return new Zt(Q.x - oe.x,Q.y - oe.y)
                }
                static sum(Q, oe) {
                    return new Zt(Q.x + oe.x,Q.y + oe.y)
                }
            }
              , zf = {};
            zf.warn = zt;
            var Ga = "http://www.w3.org/2000/svg", Rs = "http://www.w3.org/1999/xhtml", Fr = "http://www.w3.org/1999/xlink", Js;
            (function(Q) {
                Q[Q.ELEMENT_NODE = 1] = "ELEMENT_NODE",
                Q[Q.TEXT_NODE = 3] = "TEXT_NODE",
                Q[Q.COMMENT_NODE = 8] = "COMMENT_NODE"
            }
            )(Js || (Js = {}));
            var os = null
              , zd = 0
              , uc = null
              , hr = {
                HTML_NS: Rs
            };
            hr.NodeType = Js,
            hr.SVG_NS = Ga,
            hr.XLINK_NS = Fr,
            hr.addClass = Ut,
            hr.containsNode = ut,
            hr.createSvgElement = $t,
            hr.getFastTextWidth = Ft,
            hr.getFastTextWidthWithSizeString = an,
            hr.getTextWidth = At,
            hr.hasClass = Dt,
            hr.insertAfter = Wt,
            hr.measureFontMetrics = Sn,
            hr.removeClass = yt,
            hr.removeClasses = An,
            hr.removeNode = Bt,
            hr.setCssTransform = Ge,
            hr.startTextWidthCache = st,
            hr.stopTextWidthCache = ht;
            var bt = class {
                constructor(Q) {
                    this.tagName = Q
                }
                toString() {
                    return this.tagName
                }
            }
            ;
            bt.ANIMATE = new bt("animate"),
            bt.CIRCLE = new bt("circle"),
            bt.CLIPPATH = new bt("clipPath"),
            bt.DEFS = new bt("defs"),
            bt.FECOMPOSITE = new bt("feComposite"),
            bt.FECOMPONENTTRANSFER = new bt("feComponentTransfer"),
            bt.FEFLOOD = new bt("feFlood"),
            bt.FEFUNCA = new bt("feFuncA"),
            bt.FEGAUSSIANBLUR = new bt("feGaussianBlur"),
            bt.FEPOINTLIGHT = new bt("fePointLight"),
            bt.FESPECULARLIGHTING = new bt("feSpecularLighting"),
            bt.FILTER = new bt("filter"),
            bt.FOREIGNOBJECT = new bt("foreignObject"),
            bt.G = new bt("g"),
            bt.IMAGE = new bt("image"),
            bt.LINE = new bt("line"),
            bt.PATH = new bt("path"),
            bt.PATTERN = new bt("pattern"),
            bt.POLYGON = new bt("polygon"),
            bt.RECT = new bt("rect"),
            bt.SVG = new bt("svg"),
            bt.TEXT = new bt("text"),
            bt.TSPAN = new bt("tspan");
            var Vn = class {
                constructor(Q, oe, pe, Ae) {
                    this.top = Q,
                    this.bottom = oe,
                    this.left = pe,
                    this.right = Ae
                }
                getHeight() {
                    return this.bottom - this.top
                }
                getWidth() {
                    return this.right - this.left
                }
                contains(Q, oe) {
                    return Q >= this.left && Q <= this.right && oe >= this.top && oe <= this.bottom
                }
                intersects(Q) {
                    return !(this.left > Q.right || this.right < Q.left || this.top > Q.bottom || this.bottom < Q.top)
                }
            }
              , Yn = class {
                constructor(Q, oe) {
                    this.width = Q,
                    this.height = oe
                }
                static equals(Q, oe) {
                    return Q === oe ? !0 : Q && oe ? Q.width === oe.width && Q.height === oe.height : !1
                }
            }
              , Kf = {
                getSizeInternal: ts
            }
              , Ao = {
                TEST_ONLY: Kf
            };
            Ao.getBorderBox = Qn,
            Ao.getComputedStyle = xn,
            Ao.getContainerOffsetToScrollInto = ar,
            Ao.getPageOffset = En,
            Ao.getSize = Rn,
            Ao.getViewportPageOffset = wn,
            Ao.scrollIntoContainerView = pr;
            var Jf = /translate\(\s*([-+\d.e]+)([ ,]\s*([-+\d.e]+)\s*)?/
              , qf = /transform:\s*translate(?:3d)?\(\s*([-+\d.e]+)\s*px([ ,]\s*([-+\d.e]+)\s*px)?/
              , nT = {
                XY_REGEX: Jf,
                XY_STYLE_REGEX: qf
            }
              , Ko = {
                TEST_ONLY: nT
            };
            Ko.getDocumentScroll = ot,
            Ko.getInjectionDivXY = Be,
            Ko.getRelativeXY = _t,
            Ko.getViewportBBox = Je,
            Ko.screenToWsCoordinates = pt,
            Ko.wsToScreenCoordinates = xt;
            var or = class {
                constructor(Q, oe, pe, Ae, Re) {
                    this.workspace = Q,
                    this.horizontal = oe,
                    this.oldHostMetrics = null,
                    this.ratio = 1,
                    this.origin = new Zt(0,0),
                    this.startDragHandle = this.handlePosition = this.handleLength = this.scrollbarLength = this.startDragMouse = 0,
                    this.containerVisible = this.isHandleVisible = !0,
                    this.position = new Zt(0,0),
                    this.onMouseMoveWrapper_ = this.onMouseUpWrapper_ = null,
                    this.pair = pe || !1,
                    this.margin = Re !== void 0 ? Re : or.DEFAULT_SCROLLBAR_MARGIN,
                    Q = "blocklyScrollbar" + (this.horizontal ? "Horizontal" : "Vertical"),
                    Ae && (Q += " " + Ae),
                    this.outerSvg = $t(bt.SVG, {
                        class: Q
                    }),
                    Ae = $t(bt.G, {}, this.outerSvg),
                    this.svgBackground = $t(bt.RECT, {
                        class: "blocklyScrollbarBackground"
                    }, Ae),
                    Q = Math.floor((or.scrollbarThickness - 5) / 2),
                    this.svgHandle = $t(bt.RECT, {
                        class: "blocklyScrollbarHandle",
                        rx: Q,
                        ry: Q
                    }, Ae),
                    this.workspace.getThemeManager().subscribe(this.svgHandle, "scrollbarColour", "fill"),
                    this.workspace.getThemeManager().subscribe(this.svgHandle, "scrollbarOpacity", "fill-opacity"),
                    Wt(this.outerSvg, this.workspace.getParentSvg()),
                    this.setInitialThickness(),
                    oe ? (this.lengthAttribute_ = "width",
                    this.positionAttribute_ = "x") : (this.lengthAttribute_ = "height",
                    this.positionAttribute_ = "y"),
                    this.onMouseDownBarWrapper_ = vt(this.svgBackground, "pointerdown", this, this.onMouseDownBar),
                    this.onMouseDownHandleWrapper_ = vt(this.svgHandle, "pointerdown", this, this.onMouseDownHandle)
                }
                setInitialThickness() {
                    const Q = or.scrollbarThickness;
                    this.horizontal ? (this.svgBackground.setAttribute("height", String(Q)),
                    this.outerSvg.setAttribute("height", String(Q)),
                    this.svgHandle.setAttribute("height", String(Q - 5)),
                    this.svgHandle.setAttribute("y", "2.5")) : (this.svgBackground.setAttribute("width", String(Q)),
                    this.outerSvg.setAttribute("width", String(Q)),
                    this.svgHandle.setAttribute("width", String(Q - 5)),
                    this.svgHandle.setAttribute("x", "2.5"))
                }
                dispose() {
                    this.cleanUp(),
                    Ct(this.onMouseDownBarWrapper_),
                    Ct(this.onMouseDownHandleWrapper_),
                    Bt(this.outerSvg),
                    this.workspace.getThemeManager().unsubscribe(this.svgHandle)
                }
                constrainHandleLength(Q) {
                    return Q = 0 >= Q || isNaN(Q) ? 0 : Math.min(Q, this.scrollbarLength)
                }
                setHandleLength(Q) {
                    this.handleLength = Q,
                    this.svgHandle.setAttribute(this.lengthAttribute_, String(this.handleLength))
                }
                constrainHandlePosition(Q) {
                    return Q = 0 >= Q || isNaN(Q) ? 0 : Math.min(Q, this.scrollbarLength - this.handleLength)
                }
                setHandlePosition(Q) {
                    this.handlePosition = Q,
                    this.svgHandle.setAttribute(this.positionAttribute_, String(this.handlePosition))
                }
                setScrollbarLength(Q) {
                    this.scrollbarLength = Q,
                    this.outerSvg.setAttribute(this.lengthAttribute_, String(this.scrollbarLength)),
                    this.svgBackground.setAttribute(this.lengthAttribute_, String(this.scrollbarLength))
                }
                setPosition(Q, oe) {
                    this.position.x = Q,
                    this.position.y = oe,
                    Ge(this.outerSvg, "translate(" + (this.position.x + this.origin.x) + "px," + (this.position.y + this.origin.y) + "px)")
                }
                resize(Q) {
                    !Q && (Q = this.workspace.getMetrics(),
                    !Q) || this.oldHostMetrics && or.metricsAreEquivalent(Q, this.oldHostMetrics) || (this.horizontal ? this.resizeHorizontal(Q) : this.resizeVertical(Q),
                    this.oldHostMetrics = Q,
                    this.updateMetrics())
                }
                requiresViewResize(Q) {
                    return this.oldHostMetrics ? this.oldHostMetrics.viewWidth !== Q.viewWidth || this.oldHostMetrics.viewHeight !== Q.viewHeight || this.oldHostMetrics.absoluteLeft !== Q.absoluteLeft || this.oldHostMetrics.absoluteTop !== Q.absoluteTop : !0
                }
                resizeHorizontal(Q) {
                    this.requiresViewResize(Q) ? this.resizeViewHorizontal(Q) : this.resizeContentHorizontal(Q)
                }
                resizeViewHorizontal(Q) {
                    var oe = Q.viewWidth - 2 * this.margin;
                    this.pair && (oe -= or.scrollbarThickness),
                    this.setScrollbarLength(Math.max(0, oe)),
                    oe = Q.absoluteLeft + this.margin,
                    this.pair && this.workspace.RTL && (oe += or.scrollbarThickness),
                    this.setPosition(oe, Q.absoluteTop + Q.viewHeight - or.scrollbarThickness - this.margin),
                    this.resizeContentHorizontal(Q)
                }
                resizeContentHorizontal(Q) {
                    if (Q.viewWidth >= Q.scrollWidth)
                        this.setHandleLength(this.scrollbarLength),
                        this.setHandlePosition(0),
                        this.pair || this.setVisible(!1);
                    else {
                        this.pair || this.setVisible(!0);
                        var oe = this.scrollbarLength * Q.viewWidth / Q.scrollWidth;
                        oe = this.constrainHandleLength(oe),
                        this.setHandleLength(oe),
                        oe = Q.scrollWidth - Q.viewWidth;
                        var pe = this.scrollbarLength - this.handleLength;
                        Q = (Q.viewLeft - Q.scrollLeft) / oe * pe,
                        Q = this.constrainHandlePosition(Q),
                        this.setHandlePosition(Q),
                        this.ratio = pe / oe
                    }
                }
                resizeVertical(Q) {
                    this.requiresViewResize(Q) ? this.resizeViewVertical(Q) : this.resizeContentVertical(Q)
                }
                resizeViewVertical(Q) {
                    let oe = Q.viewHeight - 2 * this.margin;
                    this.pair && (oe -= or.scrollbarThickness),
                    this.setScrollbarLength(Math.max(0, oe)),
                    this.setPosition(this.workspace.RTL ? Q.absoluteLeft + this.margin : Q.absoluteLeft + Q.viewWidth - or.scrollbarThickness - this.margin, Q.absoluteTop + this.margin),
                    this.resizeContentVertical(Q)
                }
                resizeContentVertical(Q) {
                    if (Q.viewHeight >= Q.scrollHeight)
                        this.setHandleLength(this.scrollbarLength),
                        this.setHandlePosition(0),
                        this.pair || this.setVisible(!1);
                    else {
                        this.pair || this.setVisible(!0);
                        var oe = this.scrollbarLength * Q.viewHeight / Q.scrollHeight;
                        oe = this.constrainHandleLength(oe),
                        this.setHandleLength(oe),
                        oe = Q.scrollHeight - Q.viewHeight;
                        var pe = this.scrollbarLength - this.handleLength;
                        Q = (Q.viewTop - Q.scrollTop) / oe * pe,
                        Q = this.constrainHandlePosition(Q),
                        this.setHandlePosition(Q),
                        this.ratio = pe / oe
                    }
                }
                isVisible() {
                    return this.isHandleVisible
                }
                setContainerVisible(Q) {
                    const oe = Q !== this.containerVisible;
                    this.containerVisible = Q,
                    oe && this.updateDisplay_()
                }
                setVisible(Q) {
                    if (this.pair)
                        throw Error("Unable to toggle visibility of paired scrollbars.");
                    this.setVisibleInternal(Q)
                }
                setVisibleInternal(Q) {
                    const oe = Q !== this.isVisible();
                    this.isHandleVisible = Q,
                    oe && this.updateDisplay_()
                }
                updateDisplay_() {
                    this.containerVisible && this.isVisible() ? this.outerSvg.setAttribute("display", "block") : this.outerSvg.setAttribute("display", "none")
                }
                onMouseDownBar(Q) {
                    if (this.workspace.markFocused(),
                    Kt(),
                    this.cleanUp(),
                    nn(Q))
                        Q.stopPropagation();
                    else {
                        var oe = tn(Q, this.workspace.getParentSvg(), this.workspace.getInverseScreenCTM());
                        oe = this.horizontal ? oe.x : oe.y;
                        var pe = Be(this.svgHandle);
                        pe = this.horizontal ? pe.x : pe.y;
                        var Ae = this.handlePosition
                          , Re = .95 * this.handleLength;
                        oe <= pe ? Ae -= Re : oe >= pe + this.handleLength && (Ae += Re),
                        this.setHandlePosition(this.constrainHandlePosition(Ae)),
                        this.updateMetrics(),
                        Q.stopPropagation(),
                        Q.preventDefault()
                    }
                }
                onMouseDownHandle(Q) {
                    this.workspace.markFocused(),
                    this.cleanUp(),
                    nn(Q) ? Q.stopPropagation() : (this.startDragHandle = this.handlePosition,
                    this.startDragMouse = this.horizontal ? Q.clientX : Q.clientY,
                    this.onMouseUpWrapper_ = vt(document, "pointerup", this, this.onMouseUpHandle),
                    this.onMouseMoveWrapper_ = vt(document, "pointermove", this, this.onMouseMoveHandle),
                    Q.stopPropagation(),
                    Q.preventDefault())
                }
                onMouseMoveHandle(Q) {
                    this.setHandlePosition(this.constrainHandlePosition(this.startDragHandle + ((this.horizontal ? Q.clientX : Q.clientY) - this.startDragMouse))),
                    this.updateMetrics()
                }
                onMouseUpHandle() {
                    Kt(),
                    this.cleanUp()
                }
                cleanUp() {
                    this.workspace.hideChaff(!0),
                    this.onMouseUpWrapper_ && (Ct(this.onMouseUpWrapper_),
                    this.onMouseUpWrapper_ = null),
                    this.onMouseMoveWrapper_ && (Ct(this.onMouseMoveWrapper_),
                    this.onMouseMoveWrapper_ = null)
                }
                getRatio_() {
                    let Q = this.handlePosition / (this.scrollbarLength - this.handleLength);
                    return isNaN(Q) && (Q = 0),
                    Q
                }
                updateMetrics() {
                    const Q = this.getRatio_();
                    this.horizontal ? this.workspace.setMetrics({
                        x: Q
                    }) : this.workspace.setMetrics({
                        y: Q
                    })
                }
                set(Q, oe) {
                    this.setHandlePosition(this.constrainHandlePosition(Q * this.ratio)),
                    (oe || oe === void 0) && this.updateMetrics()
                }
                setOrigin(Q, oe) {
                    this.origin = new Zt(Q,oe)
                }
                static metricsAreEquivalent(Q, oe) {
                    return Q.viewWidth === oe.viewWidth && Q.viewHeight === oe.viewHeight && Q.viewLeft === oe.viewLeft && Q.viewTop === oe.viewTop && Q.absoluteTop === oe.absoluteTop && Q.absoluteLeft === oe.absoluteLeft && Q.scrollWidth === oe.scrollWidth && Q.scrollHeight === oe.scrollHeight && Q.scrollLeft === oe.scrollLeft && Q.scrollTop === oe.scrollTop
                }
            }
            ;
            or.scrollbarThickness = Df ? 25 : 15,
            or.DEFAULT_SCROLLBAR_MARGIN = .5;
            var dc = {
                parseFromString: function() {
                    throw Error("DOMParser was not found in the global scope and was not properly injected using injectDependencies")
                }
            }
              , Kd = {
                serializeToString: function() {
                    throw Error("XMLSerializer was not foundin the global scope and was not properly injected using injectDependencies")
                }
            }
              , {document: hc, DOMParser: ja, XMLSerializer: Wa} = globalThis;
            ja && (dc = new ja),
            Wa && (Kd = new Wa);
            var Qf = "https://developers.google.com/blockly/xml"
              , rT = /[\x00-\x09\x0B\x0C\x0E-\x1F]/g
              , Yi = {
                NAME_SPACE: Qf
            };
            Yi.createElement = J.createElement$$module$build$src$core$utils$xml,
            Yi.createTextNode = J.createTextNode$$module$build$src$core$utils$xml,
            Yi.domToText = Pt,
            Yi.injectDependencies = Vt,
            Yi.textToDom = J.textToDom$$module$build$src$core$utils$xml;
            var Jd = "categoryToolbox", Zf = "flyoutToolbox", In;
            (function(Q) {
                Q[Q.TOP = 0] = "TOP",
                Q[Q.BOTTOM = 1] = "BOTTOM",
                Q[Q.LEFT = 2] = "LEFT",
                Q[Q.RIGHT = 3] = "RIGHT"
            }
            )(In || (In = {}));
            var eg = {
                hasCategoriesInternal: Hn
            }
              , _o = {};
            _o.Position = In,
            _o.TEST_ONLY = eg,
            _o.convertFlyoutDefToJsonArray = fn,
            _o.convertToolboxDefToJson = rn,
            _o.hasCategories = On,
            _o.isCategoryCollapsible = Kn,
            _o.parseToolboxTree = ms;
            var qs;
            (function(Q) {
                Q[Q.TOP = 0] = "TOP",
                Q[Q.BOTTOM = 1] = "BOTTOM"
            }
            )(qs || (qs = {}));
            var Xi;
            (function(Q) {
                Q[Q.LEFT = 0] = "LEFT",
                Q[Q.RIGHT = 1] = "RIGHT"
            }
            )(Xi || (Xi = {}));
            var So;
            (function(Q) {
                Q[Q.UP = 0] = "UP",
                Q[Q.DOWN = 1] = "DOWN"
            }
            )(So || (So = {}));
            var Jo = {};
            Jo.bumpDirection = So,
            Jo.bumpPositionRect = _r,
            Jo.getCornerOppositeToolbox = vr,
            Jo.getStartPositionRect = fs,
            Jo.horizontalPosition = Xi,
            Jo.verticalPosition = qs;
            var Ir = {
                width: 96,
                height: 124,
                url: "sprites.png"
            }
              , tg = class {
                constructor(Q) {
                    this.workspace = Q,
                    this.id = "zoomControls",
                    this.boundEvents = [],
                    this.zoomResetGroup = this.zoomOutGroup = this.zoomInGroup = null,
                    this.HEIGHT = this.WIDTH = 32,
                    this.SMALL_SPACING = 2,
                    this.LARGE_SPACING = 11,
                    this.MARGIN_HORIZONTAL = this.MARGIN_VERTICAL = 20,
                    this.svgGroup = null,
                    this.top = this.left = 0,
                    this.initialized = !1
                }
                createDom() {
                    this.svgGroup = $t(bt.G, {});
                    const Q = String(Math.random()).substring(2);
                    return this.createZoomOutSvg(Q),
                    this.createZoomInSvg(Q),
                    this.workspace.isMovable() && this.createZoomResetSvg(Q),
                    this.svgGroup
                }
                init() {
                    this.workspace.getComponentManager().addComponent({
                        component: this,
                        weight: 2,
                        capabilities: [dr.Capability.POSITIONABLE]
                    }),
                    this.initialized = !0
                }
                dispose() {
                    this.workspace.getComponentManager().removeComponent("zoomControls"),
                    this.svgGroup && Bt(this.svgGroup);
                    for (const Q of this.boundEvents)
                        Ct(Q);
                    this.boundEvents.length = 0
                }
                getBoundingRectangle() {
                    let Q = this.SMALL_SPACING + 2 * this.HEIGHT;
                    return this.zoomResetGroup && (Q += this.LARGE_SPACING + this.HEIGHT),
                    new Vn(this.top,this.top + Q,this.left,this.left + this.WIDTH)
                }
                position(Q, oe) {
                    if (this.initialized) {
                        var pe = vr(this.workspace, Q)
                          , Ae = this.SMALL_SPACING + 2 * this.HEIGHT;
                        if (this.zoomResetGroup && (Ae += this.LARGE_SPACING + this.HEIGHT),
                        Q = fs(pe, new Yn(this.WIDTH,Ae), this.MARGIN_HORIZONTAL, this.MARGIN_VERTICAL, Q, this.workspace),
                        pe = pe.vertical,
                        oe = _r(Q, this.MARGIN_VERTICAL, pe === qs.TOP ? So.DOWN : So.UP, oe),
                        pe === qs.TOP) {
                            var Re = this.SMALL_SPACING + this.HEIGHT, Ue;
                            (Ue = this.zoomInGroup) == null || Ue.setAttribute("transform", "translate(0, " + Re + ")"),
                            this.zoomResetGroup && this.zoomResetGroup.setAttribute("transform", "translate(0, " + (Re + this.LARGE_SPACING + this.HEIGHT) + ")")
                        } else {
                            Ue = this.zoomResetGroup ? this.LARGE_SPACING + this.HEIGHT : 0;
                            let dt;
                            (dt = this.zoomInGroup) == null || dt.setAttribute("transform", "translate(0, " + Ue + ")"),
                            Ue = Ue + this.SMALL_SPACING + this.HEIGHT,
                            (Re = this.zoomOutGroup) == null || Re.setAttribute("transform", "translate(0, " + Ue + ")")
                        }
                        this.top = oe.top,
                        this.left = oe.left;
                        var tt;
                        (tt = this.svgGroup) == null || tt.setAttribute("transform", "translate(" + this.left + "," + this.top + ")")
                    }
                }
                createZoomOutSvg(Q) {
                    this.zoomOutGroup = $t(bt.G, {
                        class: "blocklyZoom blocklyZoomOut"
                    }, this.svgGroup);
                    const oe = $t(bt.CLIPPATH, {
                        id: "blocklyZoomoutClipPath" + Q
                    }, this.zoomOutGroup);
                    $t(bt.RECT, {
                        width: 32,
                        height: 32
                    }, oe),
                    $t(bt.IMAGE, {
                        width: Ir.width,
                        height: Ir.height,
                        x: -64,
                        y: -92,
                        "clip-path": "url(#blocklyZoomoutClipPath" + Q + ")"
                    }, this.zoomOutGroup).setAttributeNS(Fr, "xlink:href", this.workspace.options.pathToMedia + Ir.url),
                    this.boundEvents.push(vt(this.zoomOutGroup, "pointerdown", null, this.zoom.bind(this, -1)))
                }
                createZoomInSvg(Q) {
                    this.zoomInGroup = $t(bt.G, {
                        class: "blocklyZoom blocklyZoomIn"
                    }, this.svgGroup);
                    const oe = $t(bt.CLIPPATH, {
                        id: "blocklyZoominClipPath" + Q
                    }, this.zoomInGroup);
                    $t(bt.RECT, {
                        width: 32,
                        height: 32
                    }, oe),
                    $t(bt.IMAGE, {
                        width: Ir.width,
                        height: Ir.height,
                        x: -32,
                        y: -92,
                        "clip-path": "url(#blocklyZoominClipPath" + Q + ")"
                    }, this.zoomInGroup).setAttributeNS(Fr, "xlink:href", this.workspace.options.pathToMedia + Ir.url),
                    this.boundEvents.push(vt(this.zoomInGroup, "pointerdown", null, this.zoom.bind(this, 1)))
                }
                zoom(Q, oe) {
                    this.workspace.markFocused(),
                    this.workspace.zoomCenter(Q),
                    this.fireZoomEvent(),
                    Kt(),
                    oe.stopPropagation(),
                    oe.preventDefault()
                }
                createZoomResetSvg(Q) {
                    this.zoomResetGroup = $t(bt.G, {
                        class: "blocklyZoom blocklyZoomReset"
                    }, this.svgGroup);
                    const oe = $t(bt.CLIPPATH, {
                        id: "blocklyZoomresetClipPath" + Q
                    }, this.zoomResetGroup);
                    $t(bt.RECT, {
                        width: 32,
                        height: 32
                    }, oe),
                    $t(bt.IMAGE, {
                        width: Ir.width,
                        height: Ir.height,
                        y: -92,
                        "clip-path": "url(#blocklyZoomresetClipPath" + Q + ")"
                    }, this.zoomResetGroup).setAttributeNS(Fr, "xlink:href", this.workspace.options.pathToMedia + Ir.url),
                    this.boundEvents.push(vt(this.zoomResetGroup, "pointerdown", null, this.resetZoom.bind(this)))
                }
                resetZoom(Q) {
                    this.workspace.markFocused();
                    const oe = Math.log(this.workspace.options.zoomOptions.startScale / this.workspace.scale) / Math.log(this.workspace.options.zoomOptions.scaleSpeed);
                    this.workspace.beginCanvasTransition(),
                    this.workspace.zoomCenter(oe),
                    this.workspace.scrollCenter(),
                    setTimeout(this.workspace.endCanvasTransition.bind(this.workspace), 500),
                    this.fireZoomEvent(),
                    Kt(),
                    Q.stopPropagation(),
                    Q.preventDefault()
                }
                fireZoomEvent() {
                    const Q = new (gt(Xs))(null,this.workspace.id,"zoom_controls");
                    Ye(Q)
                }
            }
            ;
            Qt(`
.blocklyZoom>image, .blocklyZoom>svg>image {
  opacity: .4;
}

.blocklyZoom>image:hover, .blocklyZoom>svg>image:hover {
  opacity: .6;
}

.blocklyZoom>image:active, .blocklyZoom>svg>image:active {
  opacity: .8;
}
`);
            var Lr = class {
                constructor(Q) {
                    this.name = Q
                }
                toString() {
                    return this.name
                }
                equals(Q) {
                    return this.name === Q.toString()
                }
            }
            ;
            Lr.MUTATOR = new Lr("mutator"),
            Lr.WARNING = new Lr("warning"),
            Lr.COMMENT = new Lr("comment"),
            function(Q) {
                Q[Q.VALUE = 1] = "VALUE",
                Q[Q.STATEMENT = 3] = "STATEMENT",
                Q[Q.DUMMY = 5] = "DUMMY",
                Q[Q.CUSTOM = 6] = "CUSTOM",
                Q[Q.END_ROW = 7] = "END_ROW"
            }(J.inputTypes$$module$build$src$core$inputs$input_types || (J.inputTypes$$module$build$src$core$inputs$input_types = {})),
            J.inputTypes$$module$build$src$core$inputs$input_types;
            var ng = function(Q, oe) {
                window.alert(Q),
                oe && oe()
            }
              , rg = function(Q, oe) {
                oe(window.confirm(Q))
            }
              , sg = function(Q, oe, pe) {
                pe(window.prompt(Q, oe))
            }
              , og = {
                confirmInternal: wo
            }
              , qo = {
                TEST_ONLY: og
            };
            qo.alert = Hs,
            qo.confirm = zr,
            qo.prompt = Un,
            qo.setAlert = oo,
            qo.setConfirm = Bo,
            qo.setPrompt = ur;
            var qd, ig;
            J.Msg$$module$build$src$core$msg = Object.create(null),
            qd = function(Q) {
                Object.keys(Q).forEach(function(oe) {
                    J.Msg$$module$build$src$core$msg[oe] = Q[oe]
                })
            }
            ,
            ig = {
                Msg: J.Msg$$module$build$src$core$msg,
                setLocale: qd
            };
            var Ya = class extends ji {
                constructor(Q) {
                    super(),
                    this.isBlank = typeof Q > "u",
                    Q && (this.varId = Q.getId(),
                    this.workspaceId = Q.workspace.id)
                }
                toJson() {
                    const Q = super.toJson();
                    if (!this.varId)
                        throw Error("The var ID is undefined. Either pass a variable to the constructor, or call fromJson");
                    return Q.varId = this.varId,
                    Q
                }
                static fromJson(Q, oe, pe) {
                    return oe = super.fromJson(Q, oe, pe ?? new Ya),
                    oe.varId = Q.varId,
                    oe
                }
            }
              , Qd = class extends Ya {
                constructor(Q) {
                    super(Q),
                    this.type = go,
                    Q && (this.varType = Q.type,
                    this.varName = Q.name)
                }
                toJson() {
                    const Q = super.toJson();
                    if (this.varType === void 0)
                        throw Error("The var type is undefined. Either pass a variable to the constructor, or call fromJson");
                    if (!this.varName)
                        throw Error("The var name is undefined. Either pass a variable to the constructor, or call fromJson");
                    return Q.varType = this.varType,
                    Q.varName = this.varName,
                    Q
                }
                static fromJson(Q, oe, pe) {
                    return oe = super.fromJson(Q, oe, pe ?? new Qd),
                    oe.varType = Q.varType,
                    oe.varName = Q.varName,
                    oe
                }
                run(Q) {
                    const oe = this.getEventWorkspace_();
                    if (!this.varId)
                        throw Error("The var ID is undefined. Either pass a variable to the constructor, or call fromJson");
                    if (!this.varName)
                        throw Error("The var name is undefined. Either pass a variable to the constructor, or call fromJson");
                    Q ? oe.createVariable(this.varName, this.varType, this.varId) : oe.deleteVariableById(this.varId)
                }
            }
            ;
            ne(Yt.EVENT, go, Qd);
            var Xa = class {
                constructor(Q, oe, pe, Ae) {
                    this.workspace = Q,
                    this.name = oe,
                    this.type = pe || "",
                    this.id_ = Ae || rt()
                }
                getId() {
                    return this.id_
                }
                static compareByName(Q, oe) {
                    return Q.name.localeCompare(oe.name, void 0, {
                        sensitivity: "base"
                    })
                }
            }
              , Zd = "VARIABLE"
              , eh = "ijkmnopqrstuvwxyzabcdefgh"
              , ag = {
                generateUniqueNameInternal: Cp
            }
              , gr = {
                CATEGORY_NAME: Zd,
                TEST_ONLY: ag,
                VAR_LETTER_OPTIONS: eh
            };
            gr.allDeveloperVariables = J.allDeveloperVariables$$module$build$src$core$variables,
            gr.allUsedVarModels = J.allUsedVarModels$$module$build$src$core$variables,
            gr.createVariableButtonHandler = Ii,
            gr.flyoutCategory = ns,
            gr.flyoutCategoryBlocks = Si,
            gr.generateUniqueName = xa,
            gr.generateUniqueNameFromOptions = bl,
            gr.generateVariableFieldDom = Uo,
            gr.getAddedVariables = Ol,
            gr.getOrCreateVariablePackage = J.getOrCreateVariablePackage$$module$build$src$core$variables,
            gr.getVariable = J.getVariable$$module$build$src$core$variables,
            gr.nameUsedWithAnyType = jc,
            gr.nameUsedWithConflictingParam = Wc,
            gr.promptName = $l,
            gr.renameVariable = J.renameVariable$$module$build$src$core$variables;
            var ys = class {
                constructor(Q, oe, pe, Ae, Re) {
                    this.workspace = Q,
                    this.editable = this.movable = this.deletable = !0,
                    this.disposed_ = !1,
                    this.isComment = !0,
                    this.id = Re && !Q.getCommentById(Re) ? Re : rt(),
                    Q.addTopComment(this),
                    this.xy_ = new Zt(0,0),
                    this.height_ = pe,
                    this.width_ = Ae,
                    this.RTL = Q.RTL,
                    this.content_ = oe,
                    ys.fireCreateEvent(this)
                }
                dispose() {
                    this.disposed_ || (Ke() && Ye(new (gt(jo))(this)),
                    this.workspace.removeTopComment(this),
                    this.disposed_ = !0)
                }
                getHeight() {
                    return this.height_
                }
                setHeight(Q) {
                    this.height_ = Q
                }
                getWidth() {
                    return this.width_
                }
                setWidth(Q) {
                    this.width_ = Q
                }
                getRelativeToSurfaceXY() {
                    return new Zt(this.xy_.x,this.xy_.y)
                }
                moveBy(Q, oe) {
                    const pe = new (gt(Ss))(this);
                    this.xy_.translate(Q, oe),
                    pe.recordNew(),
                    Ye(pe)
                }
                isDeletable() {
                    return this.deletable && !(this.workspace && this.workspace.options.readOnly)
                }
                setDeletable(Q) {
                    this.deletable = Q
                }
                isMovable() {
                    return this.movable && !(this.workspace && this.workspace.options.readOnly)
                }
                setMovable(Q) {
                    this.movable = Q
                }
                isEditable() {
                    return this.editable && !(this.workspace && this.workspace.options.readOnly)
                }
                setEditable(Q) {
                    this.editable = Q
                }
                getContent() {
                    return this.content_
                }
                setContent(Q) {
                    this.content_ !== Q && (Ye(new (gt(Gi))(this,this.content_,Q)),
                    this.content_ = Q)
                }
                toXmlWithXY(Q) {
                    return Q = this.toXml(Q),
                    Q.setAttribute("x", String(Math.round(this.xy_.x))),
                    Q.setAttribute("y", String(Math.round(this.xy_.y))),
                    Q.setAttribute("h", String(this.height_)),
                    Q.setAttribute("w", String(this.width_)),
                    Q
                }
                toXml(Q) {
                    const oe = J.createElement$$module$build$src$core$utils$xml("comment");
                    return Q || (oe.id = this.id),
                    oe.textContent = this.getContent(),
                    oe
                }
                static fireCreateEvent(Q) {
                    if (Ke()) {
                        const oe = J.getGroup$$module$build$src$core$events$utils();
                        oe || J.setGroup$$module$build$src$core$events$utils(!0);
                        try {
                            Ye(new (gt(To))(Q))
                        } finally {
                            J.setGroup$$module$build$src$core$events$utils(oe)
                        }
                    }
                }
                static fromXml(Q, oe) {
                    var pe = ys.parseAttributes(Q);
                    return oe = new ys(oe,pe.content,pe.h,pe.w,pe.id),
                    pe = Q.getAttribute("x"),
                    Q = Q.getAttribute("y"),
                    pe = pe ? parseInt(pe, 10) : NaN,
                    Q = Q ? parseInt(Q, 10) : NaN,
                    isNaN(pe) || isNaN(Q) || oe.moveBy(pe, Q),
                    ys.fireCreateEvent(oe),
                    oe
                }
                static parseAttributes(Q) {
                    const oe = Q.getAttribute("h")
                      , pe = Q.getAttribute("w")
                      , Ae = Q.getAttribute("x")
                      , Re = Q.getAttribute("y")
                      , Ue = Q.getAttribute("id");
                    if (!Ue)
                        throw Error("No ID present in XML comment definition.");
                    let tt;
                    return {
                        id: Ue,
                        h: oe ? parseInt(oe) : 100,
                        w: pe ? parseInt(pe) : 100,
                        x: Ae ? parseInt(Ae) : NaN,
                        y: Re ? parseInt(Re) : NaN,
                        content: (tt = Q.textContent) != null ? tt : ""
                    }
                }
            }
              , th = class extends Is {
                constructor(Q, oe, pe) {
                    super(pe),
                    this.type = Ys,
                    this.oldElementId = Q ?? void 0,
                    this.newElementId = oe ?? void 0
                }
                toJson() {
                    const Q = super.toJson();
                    return Q.oldElementId = this.oldElementId,
                    Q.newElementId = this.newElementId,
                    Q
                }
                static fromJson(Q, oe, pe) {
                    return oe = super.fromJson(Q, oe, pe ?? new th),
                    oe.oldElementId = Q.oldElementId,
                    oe.newElementId = Q.newElementId,
                    oe
                }
            }
            ;
            ne(Yt.EVENT, Ys, th);
            var nh = {};
            nh.register = Cl,
            nh.unregister = Pp;
            var pc = class {
                paste(Q, oe, pe) {
                    const Ae = Q.commentState;
                    if (pe)
                        Ae.setAttribute("x", `${pe.x}`),
                        Ae.setAttribute("y", `${pe.y}`);
                    else {
                        var Re;
                        pe = parseInt((Re = Ae.getAttribute("x")) != null ? Re : "0") + 50;
                        let Ue;
                        Re = parseInt((Ue = Ae.getAttribute("y")) != null ? Ue : "0") + 50,
                        Ae.setAttribute("x", `${pe}`),
                        Ae.setAttribute("y", `${Re}`)
                    }
                    return Er.fromXmlRendered(Q.commentState, oe)
                }
            }
            ;
            pc.TYPE = "workspace-comment",
            Cl(pc.TYPE, new pc);
            var lr = 8
              , mc = 3
              , sT = 2
              , Er = class extends ys {
                constructor(Q, oe, pe, Ae, Re) {
                    super(Q, oe, pe, Ae, Re),
                    this.onMouseMoveWrapper = this.onMouseUpWrapper = null,
                    this.eventsInit = !1,
                    this.deleteIconBorder = this.deleteGroup = this.resizeGroup = this.foreignObject = this.svgHandleTarget = this.svgRectTarget = this.textarea = null,
                    this.rendered = this.autoLayout = this.focused = !1,
                    this.svgGroup = $t(bt.G, {
                        class: "blocklyComment"
                    }),
                    this.workspace = Q,
                    this.svgRect_ = $t(bt.RECT, {
                        class: "blocklyCommentRect",
                        x: 0,
                        y: 0,
                        rx: mc,
                        ry: mc
                    }),
                    this.svgGroup.appendChild(this.svgRect_),
                    this.render()
                }
                dispose() {
                    this.disposed_ || (we() === this && (this.unselect(),
                    this.workspace.cancelCurrentGesture()),
                    Ke() && Ye(new (gt(jo))(this)),
                    Bt(this.svgGroup),
                    J.disable$$module$build$src$core$events$utils(),
                    super.dispose(),
                    J.enable$$module$build$src$core$events$utils())
                }
                initSvg(Q) {
                    if (!this.workspace.rendered)
                        throw TypeError("Workspace is headless.");
                    this.workspace.options.readOnly || this.eventsInit || (vt(this.svgRectTarget, "pointerdown", this, this.pathMouseDown),
                    vt(this.svgHandleTarget, "pointerdown", this, this.pathMouseDown)),
                    this.eventsInit = !0,
                    this.updateMovable(),
                    this.getSvgRoot().parentNode || this.workspace.getBubbleCanvas().appendChild(this.getSvgRoot()),
                    !Q && this.textarea && this.textarea.select()
                }
                pathMouseDown(Q) {
                    const oe = this.workspace.getGesture(Q);
                    oe && oe.handleBubbleStart(Q, this)
                }
                showContextMenu(Q) {
                    throw Error("The implementation of showContextMenu should be monkey-patched in by blockly.ts")
                }
                select() {
                    if (we() !== this) {
                        var Q = null;
                        if (we()) {
                            Q = we().id,
                            J.disable$$module$build$src$core$events$utils();
                            try {
                                we().unselect()
                            } finally {
                                J.enable$$module$build$src$core$events$utils()
                            }
                        }
                        Q = new (gt(Ys))(Q,this.id,this.workspace.id),
                        Ye(Q),
                        Fe(this),
                        this.addSelect()
                    }
                }
                unselect() {
                    if (we() === this) {
                        var Q = new (gt(Ys))(this.id,null,this.workspace.id);
                        Ye(Q),
                        Fe(null),
                        this.removeSelect(),
                        this.blurFocus()
                    }
                }
                addSelect() {
                    Ut(this.svgGroup, "blocklySelected"),
                    this.setFocus()
                }
                removeSelect() {
                    Ut(this.svgGroup, "blocklySelected"),
                    this.blurFocus()
                }
                addFocus() {
                    Ut(this.svgGroup, "blocklyFocused")
                }
                removeFocus() {
                    yt(this.svgGroup, "blocklyFocused")
                }
                getRelativeToSurfaceXY() {
                    const Q = this.workspace.getLayerManager();
                    if (!Q)
                        throw Error("Cannot calculate position because the workspace has not been appended");
                    let oe = 0
                      , pe = 0
                      , Ae = this.getSvgRoot();
                    if (Ae)
                        do {
                            const Re = _t(Ae);
                            oe += Re.x,
                            pe += Re.y,
                            Ae = Ae.parentNode
                        } while (Ae && !Q.hasLayer(Ae) && Ae !== null);
                    return this.xy_ = new Zt(oe,pe)
                }
                moveBy(Q, oe) {
                    const pe = new (gt(Ss))(this)
                      , Ae = this.getRelativeToSurfaceXY();
                    this.translate(Ae.x + Q, Ae.y + oe),
                    this.xy_ = new Zt(Ae.x + Q,Ae.y + oe),
                    pe.recordNew(),
                    Ye(pe),
                    this.workspace.resizeContents()
                }
                translate(Q, oe) {
                    this.xy_ = new Zt(Q,oe),
                    this.getSvgRoot().setAttribute("transform", "translate(" + Q + "," + oe + ")")
                }
                moveDuringDrag(Q) {
                    Q = `translate(${Q.x}, ${Q.y})`,
                    this.getSvgRoot().setAttribute("transform", Q)
                }
                moveTo(Q, oe) {
                    this.translate(Q, oe)
                }
                clearTransformAttributes() {
                    this.getSvgRoot().removeAttribute("transform")
                }
                getBoundingRectangle() {
                    var Q = this.getRelativeToSurfaceXY();
                    const oe = this.getHeightWidth()
                      , pe = Q.y
                      , Ae = Q.y + oe.height;
                    let Re;
                    return this.RTL ? (Re = Q.x - oe.width,
                    Q = Q.x) : (Re = Q.x,
                    Q = Q.x + oe.width),
                    new Vn(pe,Ae,Re,Q)
                }
                updateMovable() {
                    this.isMovable() ? Ut(this.svgGroup, "blocklyDraggable") : yt(this.svgGroup, "blocklyDraggable")
                }
                setMovable(Q) {
                    super.setMovable(Q),
                    this.updateMovable()
                }
                setEditable(Q) {
                    super.setEditable(Q),
                    this.textarea && (this.textarea.readOnly = !Q)
                }
                setDragging(Q) {
                    Q ? Ut(this.getSvgRoot(), "blocklyDragging") : yt(this.getSvgRoot(), "blocklyDragging")
                }
                getSvgRoot() {
                    return this.svgGroup
                }
                getContent() {
                    return this.textarea ? this.textarea.value : this.content_
                }
                setContent(Q) {
                    super.setContent(Q),
                    this.textarea && (this.textarea.value = Q)
                }
                setDeleteStyle(Q) {
                    Q ? Ut(this.svgGroup, "blocklyDraggingDelete") : yt(this.svgGroup, "blocklyDraggingDelete")
                }
                setAutoLayout(Q) {}
                toXmlWithXY(Q) {
                    let oe = 0;
                    this.workspace.RTL && (oe = this.workspace.getWidth()),
                    Q = this.toXml(Q);
                    const pe = this.getRelativeToSurfaceXY();
                    return Q.setAttribute("x", String(Math.round(this.workspace.RTL ? oe - pe.x : pe.x))),
                    Q.setAttribute("y", String(Math.round(pe.y))),
                    Q.setAttribute("h", String(this.getHeight())),
                    Q.setAttribute("w", String(this.getWidth())),
                    Q
                }
                toCopyData() {
                    return {
                        paster: pc.TYPE,
                        commentState: this.toXmlWithXY()
                    }
                }
                getHeightWidth() {
                    return {
                        width: this.getWidth(),
                        height: this.getHeight()
                    }
                }
                render() {
                    if (!this.rendered) {
                        var Q = this.getHeightWidth()
                          , oe = this.createEditor();
                        this.svgGroup.appendChild(oe),
                        this.svgHandleTarget = $t(bt.RECT, {
                            class: "blocklyCommentHandleTarget",
                            x: 0,
                            y: 0
                        }),
                        this.svgGroup.appendChild(this.svgHandleTarget),
                        this.svgRectTarget = $t(bt.RECT, {
                            class: "blocklyCommentTarget",
                            x: 0,
                            y: 0,
                            rx: mc,
                            ry: mc
                        }),
                        this.svgGroup.appendChild(this.svgRectTarget),
                        this.addResizeDom(),
                        this.isDeletable() && this.addDeleteDom(),
                        this.setSize(Q.width, Q.height),
                        this.textarea.value = this.content_,
                        this.rendered = !0,
                        this.resizeGroup && vt(this.resizeGroup, "pointerdown", this, this.resizeMouseDown),
                        this.isDeletable() && (vt(this.deleteGroup, "pointerdown", this, this.deleteMouseDown),
                        vt(this.deleteGroup, "pointerout", this, this.deleteMouseOut),
                        vt(this.deleteGroup, "pointerup", this, this.deleteMouseUp))
                    }
                }
                createEditor() {
                    this.foreignObject = $t(bt.FOREIGNOBJECT, {
                        x: 0,
                        y: Er.TOP_OFFSET,
                        class: "blocklyCommentForeignObject"
                    });
                    const Q = document.createElementNS(Rs, "body");
                    Q.setAttribute("xmlns", Rs),
                    Q.className = "blocklyMinimalBody";
                    const oe = document.createElementNS(Rs, "textarea");
                    return oe.className = "blocklyCommentTextarea",
                    oe.setAttribute("dir", this.RTL ? "RTL" : "LTR"),
                    oe.readOnly = !this.isEditable(),
                    Q.appendChild(oe),
                    this.textarea = oe,
                    this.foreignObject.appendChild(Q),
                    vt(oe, "wheel", this, function(pe) {
                        pe.stopPropagation()
                    }),
                    vt(oe, "change", this, function(pe) {
                        this.setContent(oe.value)
                    }),
                    this.foreignObject
                }
                addResizeDom() {
                    this.resizeGroup = $t(bt.G, {
                        class: this.RTL ? "blocklyResizeSW" : "blocklyResizeSE"
                    }, this.svgGroup),
                    $t(bt.POLYGON, {
                        points: `0,${lr} ${lr},${lr} ${lr},0`
                    }, this.resizeGroup),
                    $t(bt.LINE, {
                        class: "blocklyResizeLine",
                        x1: lr / 3,
                        y1: lr - 1,
                        x2: lr - 1,
                        y2: lr / 3
                    }, this.resizeGroup),
                    $t(bt.LINE, {
                        class: "blocklyResizeLine",
                        x1: 2 * lr / 3,
                        y1: lr - 1,
                        x2: lr - 1,
                        y2: 2 * lr / 3
                    }, this.resizeGroup)
                }
                addDeleteDom() {
                    this.deleteGroup = $t(bt.G, {
                        class: "blocklyCommentDeleteIcon"
                    }, this.svgGroup),
                    this.deleteIconBorder = $t(bt.CIRCLE, {
                        class: "blocklyDeleteIconShape",
                        r: "7",
                        cx: "7.5",
                        cy: "7.5"
                    }, this.deleteGroup),
                    $t(bt.LINE, {
                        x1: "5",
                        y1: "10",
                        x2: "10",
                        y2: "5",
                        stroke: "#fff",
                        "stroke-width": "2"
                    }, this.deleteGroup),
                    $t(bt.LINE, {
                        x1: "5",
                        y1: "5",
                        x2: "10",
                        y2: "10",
                        stroke: "#fff",
                        "stroke-width": "2"
                    }, this.deleteGroup)
                }
                resizeMouseDown(Q) {
                    this.unbindDragEvents(),
                    nn(Q) || (this.workspace.startDrag(Q, new Zt(this.workspace.RTL ? -this.width_ : this.width_,this.height_)),
                    this.onMouseUpWrapper = vt(document, "pointerup", this, this.resizeMouseUp),
                    this.onMouseMoveWrapper = vt(document, "pointermove", this, this.resizeMouseMove),
                    this.workspace.hideChaff()),
                    Q.stopPropagation()
                }
                deleteMouseDown(Q) {
                    this.deleteIconBorder && Ut(this.deleteIconBorder, "blocklyDeleteIconHighlighted"),
                    Q.stopPropagation()
                }
                deleteMouseOut(Q) {
                    this.deleteIconBorder && yt(this.deleteIconBorder, "blocklyDeleteIconHighlighted")
                }
                deleteMouseUp(Q) {
                    this.dispose(),
                    Q.stopPropagation()
                }
                unbindDragEvents() {
                    this.onMouseUpWrapper && (Ct(this.onMouseUpWrapper),
                    this.onMouseUpWrapper = null),
                    this.onMouseMoveWrapper && (Ct(this.onMouseMoveWrapper),
                    this.onMouseMoveWrapper = null)
                }
                resizeMouseUp(Q) {
                    Kt(),
                    this.unbindDragEvents()
                }
                resizeMouseMove(Q) {
                    this.autoLayout = !1,
                    Q = this.workspace.moveDrag(Q),
                    this.setSize(this.RTL ? -Q.x : Q.x, Q.y)
                }
                resizeComment() {
                    const Q = this.getHeightWidth()
                      , oe = Er.TOP_OFFSET
                      , pe = 2 * sT;
                    let Ae;
                    (Ae = this.foreignObject) == null || Ae.setAttribute("width", String(Q.width));
                    let Re;
                    if ((Re = this.foreignObject) == null || Re.setAttribute("height", String(Q.height - oe)),
                    this.RTL) {
                        let Ue;
                        (Ue = this.foreignObject) == null || Ue.setAttribute("x", String(-Q.width))
                    }
                    this.textarea && (this.textarea.style.width = Q.width - pe + "px",
                    this.textarea.style.height = Q.height - pe - oe + "px")
                }
                setSize(Q, oe) {
                    Q = Math.max(Q, 45),
                    oe = Math.max(oe, 20 + Er.TOP_OFFSET),
                    this.width_ = Q,
                    this.height_ = oe,
                    this.svgRect_.setAttribute("width", `${Q}`),
                    this.svgRect_.setAttribute("height", `${oe}`);
                    let pe;
                    (pe = this.svgRectTarget) == null || pe.setAttribute("width", `${Q}`);
                    let Ae;
                    (Ae = this.svgRectTarget) == null || Ae.setAttribute("height", `${oe}`);
                    let Re;
                    (Re = this.svgHandleTarget) == null || Re.setAttribute("width", `${Q}`);
                    let Ue;
                    if ((Ue = this.svgHandleTarget) == null || Ue.setAttribute("height", String(Er.TOP_OFFSET)),
                    this.RTL) {
                        this.svgRect_.setAttribute("transform", "scale(-1 1)");
                        let tt;
                        (tt = this.svgRectTarget) == null || tt.setAttribute("transform", "scale(-1 1)")
                    }
                    if (this.resizeGroup)
                        if (this.RTL) {
                            this.resizeGroup.setAttribute("transform", "translate(" + (-Q + lr) + "," + (oe - lr) + ") scale(-1 1)");
                            let tt;
                            (tt = this.deleteGroup) == null || tt.setAttribute("transform", "translate(" + (-Q + lr) + "," + -lr + ") scale(-1 1)")
                        } else {
                            this.resizeGroup.setAttribute("transform", "translate(" + (Q - lr) + "," + (oe - lr) + ")");
                            let tt;
                            (tt = this.deleteGroup) == null || tt.setAttribute("transform", "translate(" + (Q - lr) + "," + -lr + ")")
                        }
                    this.resizeComment()
                }
                setFocus() {
                    this.focused = !0,
                    setTimeout( () => {
                        this.disposed_ || (this.textarea.focus(),
                        this.addFocus(),
                        this.svgRectTarget && Ut(this.svgRectTarget, "blocklyCommentTargetFocused"),
                        this.svgHandleTarget && Ut(this.svgHandleTarget, "blocklyCommentHandleTargetFocused"))
                    }
                    , 0)
                }
                blurFocus() {
                    this.focused = !1,
                    setTimeout( () => {
                        this.disposed_ || (this.textarea.blur(),
                        this.removeFocus(),
                        this.svgRectTarget && yt(this.svgRectTarget, "blocklyCommentTargetFocused"),
                        this.svgHandleTarget && yt(this.svgHandleTarget, "blocklyCommentHandleTargetFocused"))
                    }
                    , 0)
                }
                static fromXmlRendered(Q, oe, pe) {
                    J.disable$$module$build$src$core$events$utils();
                    let Ae;
                    try {
                        const Re = ys.parseAttributes(Q);
                        if (Ae = new Er(oe,Re.content,Re.h,Re.w,Re.id),
                        oe.rendered && (Ae.initSvg(!0),
                        Ae.render()),
                        !isNaN(Re.x) && !isNaN(Re.y))
                            if (oe.RTL) {
                                const Ue = pe || oe.getWidth();
                                Ae.moveBy(Ue - Re.x, Re.y)
                            } else
                                Ae.moveBy(Re.x, Re.y)
                    } finally {
                        J.enable$$module$build$src$core$events$utils()
                    }
                    return ys.fireCreateEvent(Ae),
                    Ae
                }
            }
            ;
            Er.DEFAULT_SIZE = 100,
            Er.TOP_OFFSET = 10,
            Qt(`
.blocklyCommentForeignObject {
  position: relative;
  z-index: 0;
}

.blocklyCommentRect {
  fill: #E7DE8E;
  stroke: #bcA903;
  stroke-width: 1px;
}

.blocklyCommentTarget {
  fill: transparent;
  stroke: #bcA903;
}

.blocklyCommentTargetFocused {
  fill: none;
}

.blocklyCommentHandleTarget {
  fill: none;
}

.blocklyCommentHandleTargetFocused {
  fill: transparent;
}

.blocklyFocused>.blocklyCommentRect {
  fill: #B9B272;
  stroke: #B9B272;
}

.blocklySelected>.blocklyCommentTarget {
  stroke: #fc3;
  stroke-width: 3px;
}

.blocklyCommentDeleteIcon {
  cursor: pointer;
  fill: #000;
  display: none;
}

.blocklySelected > .blocklyCommentDeleteIcon {
  display: block;
}

.blocklyDeleteIconShape {
  fill: #000;
  stroke: #000;
  stroke-width: 1px;
}

.blocklyDeleteIconShape.blocklyDeleteIconHighlighted {
  stroke: #fc3;
}
`);
            var fc = new Set
              , rh = new WeakSet
              , zi = null
              , sh = null
              , lg = 0
              , gc = {};
            gc.finishQueuedRenders = Na,
            gc.queueRender = Yc,
            gc.triggerQueuedRenders = gs;
            var Pr = {};
            Pr.appendDomToWorkspace = Hp,
            Pr.blockToDom = ao,
            Pr.blockToDomWithXY = La,
            Pr.clearWorkspaceAndLoadFromXml = Fp,
            Pr.deleteNext = Jp,
            Pr.domToBlock = J.domToBlock$$module$build$src$core$xml,
            Pr.domToBlockInternal = lo,
            Pr.domToPrettyText = Up,
            Pr.domToText = Es,
            Pr.domToVariables = qc,
            Pr.domToWorkspace = J.domToWorkspace$$module$build$src$core$xml,
            Pr.variablesToDom = Kc,
            Pr.workspaceToDom = Dp;
            var Ki = class extends Error {
            }
              , cg = class extends Ki {
                constructor(Q) {
                    super("Expected to find a 'type' property, defining the block type"),
                    this.state = Q
                }
            }
              , za = class extends Ki {
                constructor(Q, oe, pe) {
                    super(`The block ${oe.toDevString()} is missing a(n) ${Q}
connection`),
                    this.block = oe,
                    this.state = pe
                }
            }
              , ug = class extends Ki {
                constructor(Q, oe, pe, Ae) {
                    super(`The block ${pe.toDevString()} could not connect its
${oe} to its parent, because: ${Q}`),
                    this.childBlock = pe,
                    this.childState = Ae
                }
            }
              , dg = class extends Ki {
                constructor(Q) {
                    super(`Encountered a real block which is defined as a child of a shadow
block. It is an invariant of Blockly that shadow blocks only have shadow
children`),
                    this.state = Q
                }
            }
              , hg = class extends Ki {
                constructor(Q, oe, pe) {
                    super(`Cannot add an icon of type '${Q}' to the block ${oe.toDevString()}, because there is no icon registered with type '${Q}'. Make sure that all of your icons have been registered.`),
                    this.block = oe,
                    this.state = pe
                }
            }
              , Qo = {};
            Qo.BadConnectionCheck = ug,
            Qo.DeserializationError = Ki,
            Qo.MissingBlockType = cg,
            Qo.MissingConnection = za,
            Qo.RealChildOfShadow = dg,
            Qo.UnregisteredIcon = hg;
            var pg = 100
              , mg = 75
              , fg = 50
              , oT = {
                BLOCKS: fg,
                PROCEDURES: mg,
                VARIABLES: pg
            }
              , oh = {};
            oh.register = Ll,
            oh.unregister = qp;
            var gg = class {
                constructor() {
                    this.priority = fg
                }
                save(Q) {
                    const oe = [];
                    for (const pe of Q.getTopBlocks(!1))
                        (Q = Ts(pe, {
                            addCoordinates: !0,
                            doFullSerialization: !1
                        })) && oe.push(Q);
                    return oe.length ? {
                        languageVersion: 0,
                        blocks: oe
                    } : null
                }
                load(Q, oe) {
                    Q = Q.blocks;
                    for (const pe of Q)
                        co(pe, oe, {
                            recordUndo: St()
                        })
                }
                clear(Q) {
                    for (const oe of Q.getTopBlocks(!1))
                        oe.dispose(!1)
                }
            }
            ;
            Ll("blocks", new gg);
            var Ka = {};
            Ka.BlockSerializer = gg,
            Ka.append = co,
            Ka.appendInternal = Ri,
            Ka.save = Ts;
            var Zo = class extends ji {
                constructor(Q) {
                    super(),
                    this.isBlank = !Q,
                    Q && (this.blockId = Q.id,
                    this.workspaceId = Q.workspace.id)
                }
                toJson() {
                    const Q = super.toJson();
                    if (!this.blockId)
                        throw Error("The block ID is undefined. Either pass a block to the constructor, or call fromJson");
                    return Q.blockId = this.blockId,
                    Q
                }
                static fromJson(Q, oe, pe) {
                    return oe = super.fromJson(Q, oe, pe ?? new Zo),
                    oe.blockId = Q.blockId,
                    oe
                }
            }
              , ih = class extends Zo {
                constructor(Q) {
                    super(Q),
                    this.type = J.CREATE$$module$build$src$core$events$utils,
                    Q && (Q.isShadow() && (this.recordUndo = !1),
                    this.xml = La(Q),
                    this.ids = lt(Q),
                    this.json = Ts(Q, {
                        addCoordinates: !0
                    }))
                }
                toJson() {
                    const Q = super.toJson();
                    if (!this.xml)
                        throw Error("The block XML is undefined. Either pass a block to the constructor, or call fromJson");
                    if (!this.ids)
                        throw Error("The block IDs are undefined. Either pass a block to the constructor, or call fromJson");
                    if (!this.json)
                        throw Error("The block JSON is undefined. Either pass a block to the constructor, or call fromJson");
                    return Q.xml = Es(this.xml),
                    Q.ids = this.ids,
                    Q.json = this.json,
                    this.recordUndo || (Q.recordUndo = this.recordUndo),
                    Q
                }
                static fromJson(Q, oe, pe) {
                    return oe = super.fromJson(Q, oe, pe ?? new ih),
                    oe.xml = J.textToDom$$module$build$src$core$utils$xml(Q.xml),
                    oe.ids = Q.ids,
                    oe.json = Q.json,
                    Q.recordUndo !== void 0 && (oe.recordUndo = Q.recordUndo),
                    oe
                }
                run(Q) {
                    const oe = this.getEventWorkspace_();
                    if (!this.json)
                        throw Error("The block JSON is undefined. Either pass a block to the constructor, or call fromJson");
                    if (!this.ids)
                        throw Error("The block IDs are undefined. Either pass a block to the constructor, or call fromJson");
                    if (!iT(oe, this.ids))
                        if (Q)
                            co(this.json, oe);
                        else
                            for (Q = 0; Q < this.ids.length; Q++) {
                                const pe = this.ids[Q]
                                  , Ae = oe.getBlockById(pe);
                                Ae ? Ae.dispose(!1) : pe === this.blockId && console.warn("Can't uncreate non-existent block: " + pe)
                            }
                }
            }
              , iT = function(Q, oe) {
                return oe.map(pe => Q.getBlockById(pe)).filter(pe => pe && pe.isShadow()).length === oe.length
            };
            ne(Yt.EVENT, J.CREATE$$module$build$src$core$events$utils, ih);
            var ah = class extends Is {
                constructor(Q, oe) {
                    super(oe),
                    this.type = Vi,
                    this.themeName = Q
                }
                toJson() {
                    const Q = super.toJson();
                    if (!this.themeName)
                        throw Error("The theme name is undefined. Either pass a theme name to the constructor, or call fromJson");
                    return Q.themeName = this.themeName,
                    Q
                }
                static fromJson(Q, oe, pe) {
                    return oe = super.fromJson(Q, oe, pe ?? new ah),
                    oe.themeName = Q.themeName,
                    oe
                }
            }
            ;
            ne(Yt.EVENT, Vi, ah);
            var lh = class extends Is {
                constructor(Q, oe, pe, Ae, Re) {
                    super(Ae),
                    this.type = Eo,
                    this.viewTop = Q,
                    this.viewLeft = oe,
                    this.scale = pe,
                    this.oldScale = Re
                }
                toJson() {
                    const Q = super.toJson();
                    if (this.viewTop === void 0)
                        throw Error("The view top is undefined. Either pass a value to the constructor, or call fromJson");
                    if (this.viewLeft === void 0)
                        throw Error("The view left is undefined. Either pass a value to the constructor, or call fromJson");
                    if (this.scale === void 0)
                        throw Error("The scale is undefined. Either pass a value to the constructor, or call fromJson");
                    if (this.oldScale === void 0)
                        throw Error("The old scale is undefined. Either pass a value to the constructor, or call fromJson");
                    return Q.viewTop = this.viewTop,
                    Q.viewLeft = this.viewLeft,
                    Q.scale = this.scale,
                    Q.oldScale = this.oldScale,
                    Q
                }
                static fromJson(Q, oe, pe) {
                    return oe = super.fromJson(Q, oe, pe ?? new lh),
                    oe.viewTop = Q.viewTop,
                    oe.viewLeft = Q.viewLeft,
                    oe.scale = Q.scale,
                    oe.oldScale = Q.oldScale,
                    oe
                }
            }
            ;
            ne(Yt.EVENT, Eo, lh);
            var ch;
            ch = 28,
            J.config$$module$build$src$core$config = {
                dragRadius: 5,
                flyoutDragRadius: 10,
                snapRadius: ch,
                connectingSnapRadius: ch,
                currentConnectionPreference: 8,
                bumpDelay: 250
            },
            J.config$$module$build$src$core$config;
            var pn;
            (function(Q) {
                Q[Q.INPUT_VALUE = 1] = "INPUT_VALUE",
                Q[Q.OUTPUT_VALUE = 2] = "OUTPUT_VALUE",
                Q[Q.NEXT_STATEMENT = 3] = "NEXT_STATEMENT",
                Q[Q.PREVIOUS_STATEMENT = 4] = "PREVIOUS_STATEMENT"
            }
            )(pn || (pn = {}));
            var Ji = class {
                constructor(Q) {
                    this.connectionChecker = Q,
                    this.connections = []
                }
                addConnection(Q, oe) {
                    oe = this.calculateIndexForYPos(oe),
                    this.connections.splice(oe, 0, Q)
                }
                findIndexOfConnection(Q, oe) {
                    if (!this.connections.length)
                        return -1;
                    const pe = this.calculateIndexForYPos(oe);
                    if (pe >= this.connections.length)
                        return -1;
                    oe = Q.y;
                    let Ae = pe;
                    for (; 0 <= Ae && this.connections[Ae].y === oe; ) {
                        if (this.connections[Ae] === Q)
                            return Ae;
                        Ae--
                    }
                    for (Ae = pe; Ae < this.connections.length && this.connections[Ae].y === oe; ) {
                        if (this.connections[Ae] === Q)
                            return Ae;
                        Ae++
                    }
                    return -1
                }
                calculateIndexForYPos(Q) {
                    if (!this.connections.length)
                        return 0;
                    let oe = 0
                      , pe = this.connections.length;
                    for (; oe < pe; ) {
                        const Ae = Math.floor((oe + pe) / 2);
                        if (this.connections[Ae].y < Q)
                            oe = Ae + 1;
                        else if (this.connections[Ae].y > Q)
                            pe = Ae;
                        else {
                            oe = Ae;
                            break
                        }
                    }
                    return oe
                }
                removeConnection(Q, oe) {
                    if (Q = this.findIndexOfConnection(Q, oe),
                    Q === -1)
                        throw Error("Unable to find connection in connectionDB.");
                    this.connections.splice(Q, 1)
                }
                getNeighbours(Q, oe) {
                    function pe(sn) {
                        const zn = Re - Ae[sn].x
                          , jn = Ue - Ae[sn].y;
                        return Math.sqrt(zn * zn + jn * jn) <= oe && wt.push(Ae[sn]),
                        jn < oe
                    }
                    const Ae = this.connections
                      , Re = Q.x
                      , Ue = Q.y;
                    Q = 0;
                    let tt = Ae.length - 2
                      , dt = tt;
                    for (; Q < dt; )
                        Ae[dt].y < Ue ? Q = dt : tt = dt,
                        dt = Math.floor((Q + tt) / 2);
                    const wt = [];
                    if (tt = Q = dt,
                    Ae.length) {
                        for (; 0 <= Q && pe(Q); )
                            Q--;
                        do
                            tt++;
                        while (tt < Ae.length && pe(tt))
                    }
                    return wt
                }
                isInYRange(Q, oe, pe) {
                    return Math.abs(this.connections[Q].y - oe) <= pe
                }
                searchForClosest(Q, oe, pe) {
                    if (!this.connections.length)
                        return {
                            connection: null,
                            radius: oe
                        };
                    const Ae = Q.y
                      , Re = Q.x;
                    Q.x = Re + pe.x,
                    Q.y = Ae + pe.y;
                    var Ue = this.calculateIndexForYPos(Q.y);
                    pe = null;
                    let tt = oe, dt, wt = Ue - 1;
                    for (; 0 <= wt && this.isInYRange(wt, Q.y, oe); )
                        dt = this.connections[wt],
                        this.connectionChecker.canConnect(Q, dt, !0, tt) && (pe = dt,
                        tt = dt.distanceFrom(Q)),
                        wt--;
                    for (; Ue < this.connections.length && this.isInYRange(Ue, Q.y, oe); )
                        dt = this.connections[Ue],
                        this.connectionChecker.canConnect(Q, dt, !0, tt) && (pe = dt,
                        tt = dt.distanceFrom(Q)),
                        Ue++;
                    return Q.x = Re,
                    Q.y = Ae,
                    {
                        connection: pe,
                        radius: tt
                    }
                }
                static init(Q) {
                    const oe = [];
                    return oe[pn.INPUT_VALUE] = new Ji(Q),
                    oe[pn.OUTPUT_VALUE] = new Ji(Q),
                    oe[pn.NEXT_STATEMENT] = new Ji(Q),
                    oe[pn.PREVIOUS_STATEMENT] = new Ji(Q),
                    oe
                }
            }
              , Ja = class {
                paste(Q, oe, pe) {
                    if (!oe.isCapacityAvailable(Q.typeCounts))
                        return null;
                    pe && (Q.blockState.x = pe.x,
                    Q.blockState.y = pe.y),
                    J.disable$$module$build$src$core$events$utils();
                    let Ae;
                    try {
                        Ae = co(Q.blockState, oe),
                        mm(Ae)
                    } finally {
                        J.enable$$module$build$src$core$events$utils()
                    }
                    return Ae && (Ke() && !Ae.isShadow() && Ye(new (gt(J.CREATE$$module$build$src$core$events$utils))(Ae)),
                    Ae.select(),
                    Ae)
                }
            }
            ;
            Ja.TYPE = "block",
            Cl(Ja.TYPE, new Ja);
            var uh = null
              , dh = null
              , hh = {
                duplicateInternal: _m,
                copyInternal: Tm
            }
              , ei = {};
            ei.BlockPaster = Ja,
            ei.TEST_ONLY = hh,
            ei.copy = Em,
            ei.duplicate = Am,
            ei.paste = yi,
            ei.registry = nh;
            var aT = "aria-", lT = "role", Mr;
            (function(Q) {
                Q.GRID = "grid",
                Q.GRIDCELL = "gridcell",
                Q.GROUP = "group",
                Q.LISTBOX = "listbox",
                Q.MENU = "menu",
                Q.MENUITEM = "menuitem",
                Q.MENUITEMCHECKBOX = "menuitemcheckbox",
                Q.OPTION = "option",
                Q.PRESENTATION = "presentation",
                Q.ROW = "row",
                Q.TREE = "tree",
                Q.TREEITEM = "treeitem"
            }
            )(Mr || (Mr = {}));
            var Xn;
            (function(Q) {
                Q.ACTIVEDESCENDANT = "activedescendant",
                Q.COLCOUNT = "colcount",
                Q.DISABLED = "disabled",
                Q.EXPANDED = "expanded",
                Q.INVALID = "invalid",
                Q.LABEL = "label",
                Q.LABELLEDBY = "labelledby",
                Q.LEVEL = "level",
                Q.ORIENTATION = "orientation",
                Q.POSINSET = "posinset",
                Q.ROWCOUNT = "rowcount",
                Q.SELECTED = "selected",
                Q.SETSIZE = "setsize",
                Q.VALUEMAX = "valuemax",
                Q.VALUEMIN = "valuemin"
            }
            )(Xn || (Xn = {}));
            var qa = {};
            qa.Role = Mr,
            qa.State = Xn,
            qa.setRole = rs,
            qa.setState = Jn;
            var ph = class {
                constructor() {
                    this.menuItems = [],
                    this.roleName = this.element = this.onKeyDownHandler = this.mouseLeaveHandler = this.mouseEnterHandler = this.clickHandler = this.mouseOverHandler = this.highlightedItem = this.openingCoords = null
                }
                addChild(Q) {
                    this.menuItems.push(Q)
                }
                render(Q) {
                    const oe = document.createElement("div");
                    oe.className = "blocklyMenu goog-menu blocklyNonSelectable",
                    oe.tabIndex = 0,
                    this.roleName && rs(oe, this.roleName),
                    this.element = oe;
                    for (let pe = 0, Ae; Ae = this.menuItems[pe]; pe++)
                        oe.appendChild(Ae.createDom());
                    return this.mouseOverHandler = vt(oe, "pointerover", this, this.handleMouseOver, !0),
                    this.clickHandler = vt(oe, "pointerup", this, this.handleClick, !0),
                    this.mouseEnterHandler = vt(oe, "pointerenter", this, this.handleMouseEnter, !0),
                    this.mouseLeaveHandler = vt(oe, "pointerleave", this, this.handleMouseLeave, !0),
                    this.onKeyDownHandler = vt(oe, "keydown", this, this.handleKeyEvent),
                    Q.appendChild(oe),
                    oe
                }
                getElement() {
                    return this.element
                }
                focus() {
                    const Q = this.getElement();
                    Q && (Q.focus({
                        preventScroll: !0
                    }),
                    Ut(Q, "blocklyFocused"))
                }
                blur() {
                    const Q = this.getElement();
                    Q && (Q.blur(),
                    yt(Q, "blocklyFocused"))
                }
                setRole(Q) {
                    this.roleName = Q
                }
                dispose() {
                    this.mouseOverHandler && (Ct(this.mouseOverHandler),
                    this.mouseOverHandler = null),
                    this.clickHandler && (Ct(this.clickHandler),
                    this.clickHandler = null),
                    this.mouseEnterHandler && (Ct(this.mouseEnterHandler),
                    this.mouseEnterHandler = null),
                    this.mouseLeaveHandler && (Ct(this.mouseLeaveHandler),
                    this.mouseLeaveHandler = null),
                    this.onKeyDownHandler && (Ct(this.onKeyDownHandler),
                    this.onKeyDownHandler = null);
                    for (let Q = 0, oe; oe = this.menuItems[Q]; Q++)
                        oe.dispose();
                    this.element = null
                }
                getMenuItem(Q) {
                    const oe = this.getElement();
                    for (; Q && Q !== oe; ) {
                        if (Q.classList.contains("blocklyMenuItem")) {
                            for (let pe = 0, Ae; Ae = this.menuItems[pe]; pe++)
                                if (Ae.getElement() === Q)
                                    return Ae
                        }
                        Q = Q.parentElement
                    }
                    return null
                }
                setHighlighted(Q) {
                    var oe = this.highlightedItem;
                    oe && (oe.setHighlighted(!1),
                    this.highlightedItem = null),
                    Q && (Q.setHighlighted(!0),
                    this.highlightedItem = Q,
                    oe = this.getElement(),
                    pr(Q.getElement(), oe),
                    Jn(oe, Xn.ACTIVEDESCENDANT, Q.getId()))
                }
                highlightNext() {
                    const Q = this.highlightedItem ? this.menuItems.indexOf(this.highlightedItem) : -1;
                    this.highlightHelper(Q, 1)
                }
                highlightPrevious() {
                    const Q = this.highlightedItem ? this.menuItems.indexOf(this.highlightedItem) : -1;
                    this.highlightHelper(0 > Q ? this.menuItems.length : Q, -1)
                }
                highlightFirst() {
                    this.highlightHelper(-1, 1)
                }
                highlightLast() {
                    this.highlightHelper(this.menuItems.length, -1)
                }
                highlightHelper(Q, oe) {
                    Q += oe;
                    let pe;
                    for (; pe = this.menuItems[Q]; ) {
                        if (pe.isEnabled()) {
                            this.setHighlighted(pe);
                            break
                        }
                        Q += oe
                    }
                }
                handleMouseOver(Q) {
                    (Q = this.getMenuItem(Q.target)) && (Q.isEnabled() ? this.highlightedItem !== Q && this.setHighlighted(Q) : this.setHighlighted(null))
                }
                handleClick(Q) {
                    const oe = this.openingCoords;
                    if (this.openingCoords = null,
                    oe && typeof Q.clientX == "number") {
                        const pe = new Zt(Q.clientX,Q.clientY);
                        if (1 > Zt.distance(oe, pe))
                            return
                    }
                    (Q = this.getMenuItem(Q.target)) && Q.performAction()
                }
                handleMouseEnter(Q) {
                    this.focus()
                }
                handleMouseLeave(Q) {
                    this.getElement() && (this.blur(),
                    this.setHighlighted(null))
                }
                handleKeyEvent(Q) {
                    if (this.menuItems.length && !(Q.shiftKey || Q.ctrlKey || Q.metaKey || Q.altKey)) {
                        var oe = this.highlightedItem;
                        switch (Q.key) {
                        case "Enter":
                        case " ":
                            oe && oe.performAction();
                            break;
                        case "ArrowUp":
                            this.highlightPrevious();
                            break;
                        case "ArrowDown":
                            this.highlightNext();
                            break;
                        case "PageUp":
                        case "Home":
                            this.highlightFirst();
                            break;
                        case "PageDown":
                        case "End":
                            this.highlightLast();
                            break;
                        default:
                            return
                        }
                        Q.preventDefault(),
                        Q.stopPropagation()
                    }
                }
                getSize() {
                    const Q = this.getElement()
                      , oe = Rn(Q);
                    return oe.height = Q.scrollHeight,
                    oe
                }
            }
            , mh = class {
                constructor(Q, oe) {
                    this.content = Q,
                    this.opt_value = oe,
                    this.enabled = !0,
                    this.element = null,
                    this.rightToLeft = !1,
                    this.roleName = null,
                    this.highlight = this.checked = this.checkable = !1,
                    this.actionHandler = null
                }
                createDom() {
                    const Q = document.createElement("div");
                    Q.id = at(),
                    this.element = Q,
                    Q.className = "blocklyMenuItem goog-menuitem " + (this.enabled ? "" : "blocklyMenuItemDisabled goog-menuitem-disabled ") + (this.checked ? "blocklyMenuItemSelected goog-option-selected " : "") + (this.highlight ? "blocklyMenuItemHighlight goog-menuitem-highlight " : "") + (this.rightToLeft ? "blocklyMenuItemRtl goog-menuitem-rtl " : "");
                    const oe = document.createElement("div");
                    if (oe.className = "blocklyMenuItemContent goog-menuitem-content",
                    this.checkable) {
                        var pe = document.createElement("div");
                        pe.className = "blocklyMenuItemCheckbox goog-menuitem-checkbox",
                        oe.appendChild(pe)
                    }
                    return pe = this.content,
                    typeof this.content == "string" && (pe = document.createTextNode(this.content)),
                    oe.appendChild(pe),
                    Q.appendChild(oe),
                    this.roleName && rs(Q, this.roleName),
                    Jn(Q, Xn.SELECTED, this.checkable && this.checked || !1),
                    Jn(Q, Xn.DISABLED, !this.enabled),
                    Q
                }
                dispose() {
                    this.element = null
                }
                getElement() {
                    return this.element
                }
                getId() {
                    return this.element.id
                }
                getValue() {
                    let Q;
                    return (Q = this.opt_value) != null ? Q : null
                }
                setRightToLeft(Q) {
                    this.rightToLeft = Q
                }
                setRole(Q) {
                    this.roleName = Q
                }
                setCheckable(Q) {
                    this.checkable = Q
                }
                setChecked(Q) {
                    this.checked = Q
                }
                setHighlighted(Q) {
                    this.highlight = Q;
                    const oe = this.getElement();
                    oe && this.isEnabled() && (Q ? (Ut(oe, "blocklyMenuItemHighlight"),
                    Ut(oe, "goog-menuitem-highlight")) : (yt(oe, "blocklyMenuItemHighlight"),
                    yt(oe, "goog-menuitem-highlight")))
                }
                isEnabled() {
                    return this.enabled
                }
                setEnabled(Q) {
                    this.enabled = Q
                }
                performAction() {
                    this.isEnabled() && this.actionHandler && this.actionHandler(this)
                }
                onAction(Q, oe) {
                    this.actionHandler = Q.bind(oe)
                }
            }
            , qi = null, Ec = null, fh = "blocklyWidgetDiv", Qi = "", Zi = "", bs, $s = {};
            $s.createDom = su,
            $s.getDiv = Fo,
            $s.hide = Jr,
            $s.hideIfOwner = Ml,
            $s.isVisible = ou,
            $s.positionWithAnchor = au,
            $s.repositionForWindowResize = lu,
            $s.show = Pl,
            $s.testOnly_setDiv = Sm;
            var Tc = null
              , Eg = {}
              , Ac = null
              , Os = {};
            Os.callbackFactory = J.callbackFactory$$module$build$src$core$contextmenu,
            Os.commentDeleteOption = du,
            Os.commentDuplicateOption = hu,
            Os.dispose = uu,
            Os.getCurrentBlock = bm,
            Os.hide = Ma,
            Os.setCurrentBlock = cu,
            Os.show = Pa,
            Os.workspaceCommentOption = xm;
            var Ln = class {
                constructor() {
                    this.registry_ = new Map,
                    this.reset()
                }
                reset() {
                    this.registry_.clear()
                }
                register(Q) {
                    if (this.registry_.has(Q.id))
                        throw Error('Menu item with ID "' + Q.id + '" is already registered.');
                    this.registry_.set(Q.id, Q)
                }
                unregister(Q) {
                    if (!this.registry_.has(Q))
                        throw Error('Menu item with ID "' + Q + '" not found.');
                    this.registry_.delete(Q)
                }
                getItem(Q) {
                    let oe;
                    return (oe = this.registry_.get(Q)) != null ? oe : null
                }
                getContextMenuOptions(Q, oe) {
                    const pe = [];
                    for (const Re of this.registry_.values())
                        if (Q === Re.scopeType) {
                            var Ae = Re.preconditionFn(oe);
                            Ae !== "hidden" && (Ae = {
                                text: typeof Re.displayText == "function" ? Re.displayText(oe) : Re.displayText,
                                enabled: Ae === "enabled",
                                callback: Re.callback,
                                scope: oe,
                                weight: Re.weight
                            },
                            pe.push(Ae))
                        }
                    return pe.sort(function(Re, Ue) {
                        return Re.weight - Ue.weight
                    }),
                    pe
                }
            }
            ;
            (function(Q) {
                var oe = Q.ScopeType || (Q.ScopeType = {});
                oe.BLOCK = "block",
                oe.WORKSPACE = "workspace",
                Q.registry = new Q
            }
            )(Ln || (Ln = {})),
            Ln.ScopeType;
            var _c = {};
            _c.clamp = $i,
            _c.toDegrees = pu,
            _c.toRadians = bi;
            var Qa = 16, gh = 1, Tg = 12, Eh = 16, Sc = .25, Th = null, ti = null, ea = "", ta = "", Mn, na, ni, Ah = null, Io = null, Ag = null, _h = {
                getBoundsInfo: function() {
                    const Q = En(Ah)
                      , oe = Rn(Ah);
                    return {
                        left: Q.x,
                        right: Q.x + oe.width,
                        top: Q.y,
                        bottom: Q.y + oe.height,
                        width: oe.width,
                        height: oe.height
                    }
                },
                getPositionMetrics: function(Q, oe, pe, Ae) {
                    const Re = _h.getBoundsInfo()
                      , Ue = Rn(Mn);
                    return oe + Ue.height < Re.bottom ? Su(Q, oe, Re, Ue) : Ae - Ue.height > Re.top ? Iu(pe, Ae, Re, Ue) : oe + Ue.height < document.documentElement.clientHeight ? Su(Q, oe, Re, Ue) : Ae - Ue.height > document.documentElement.clientTop ? Iu(pe, Ae, Re, Ue) : Lm(Q, Re, Ue)
                }
            }, Tr = {
                ANIMATION_TIME: Sc,
                ARROW_HORIZONTAL_PADDING: Tg,
                ARROW_SIZE: Qa,
                BORDER_SIZE: gh,
                PADDING_Y: Eh,
                TEST_ONLY: _h
            };
            Tr.clearContent = kl,
            Tr.createDom = mu,
            Tr.getContentDiv = Oi,
            Tr.getOwner = gu,
            Tr.getPositionX = Da,
            Tr.hide = wl,
            Tr.hideIfOwner = Ci,
            Tr.hideWithoutAnimation = ss,
            Tr.isVisible = Ru,
            Tr.repositionForWindowResize = bu,
            Tr.setBoundsElement = fu,
            Tr.setColour = Dl,
            Tr.show = _u,
            Tr.showPositionedByBlock = Nm,
            Tr.showPositionedByField = ka;
            var Ic = null
              , Za = null
              , el = {};
            el.connectionUiEffect = Cu,
            el.disconnectUiEffect = vu,
            el.disconnectUiStop = vi,
            el.disposeUiEffect = $u;
            var Sh = 50
              , Ih = 100
              , _g = class {
                constructor(Q, oe) {
                    this.bubble = Q,
                    this.workspace = oe,
                    this.dragTarget_ = null,
                    this.wouldDeleteBubble_ = !1,
                    this.startXY_ = this.bubble.getRelativeToSurfaceXY()
                }
                startBubbleDrag() {
                    J.getGroup$$module$build$src$core$events$utils() || J.setGroup$$module$build$src$core$events$utils(!0),
                    this.workspace.setResizesEnabled(!1),
                    this.bubble.setAutoLayout && this.bubble.setAutoLayout(!1);
                    let Q;
                    (Q = this.workspace.getLayerManager()) == null || Q.moveToDragLayer(this.bubble),
                    this.bubble.setDragging && this.bubble.setDragging(!0)
                }
                dragBubble(Q, oe) {
                    oe = this.pixelsToWorkspaceUnits_(oe),
                    oe = Zt.sum(this.startXY_, oe),
                    this.bubble.moveDuringDrag(oe),
                    oe = this.dragTarget_,
                    this.dragTarget_ = this.workspace.getDragTarget(Q),
                    Q = this.wouldDeleteBubble_,
                    this.wouldDeleteBubble_ = this.shouldDelete_(this.dragTarget_),
                    Q !== this.wouldDeleteBubble_ && this.updateCursorDuringBubbleDrag_(),
                    this.dragTarget_ !== oe && (oe && oe.onDragExit(this.bubble),
                    this.dragTarget_ && this.dragTarget_.onDragEnter(this.bubble)),
                    this.dragTarget_ && this.dragTarget_.onDragOver(this.bubble)
                }
                shouldDelete_(Q) {
                    return Q && this.workspace.getComponentManager().hasCapability(Q.id, dr.Capability.DELETE_AREA) ? Q.wouldDelete(this.bubble, !1) : !1
                }
                updateCursorDuringBubbleDrag_() {
                    this.bubble.setDeleteStyle(this.wouldDeleteBubble_)
                }
                endBubbleDrag(Q, oe) {
                    if (this.dragBubble(Q, oe),
                    this.dragTarget_ && this.dragTarget_.shouldPreventMove(this.bubble) ? Q = this.startXY_ : (Q = this.pixelsToWorkspaceUnits_(oe),
                    Q = Zt.sum(this.startXY_, Q)),
                    this.bubble.moveTo(Q.x, Q.y),
                    this.dragTarget_ && this.dragTarget_.onDrop(this.bubble),
                    this.wouldDeleteBubble_)
                        this.fireMoveEvent_(),
                        this.bubble.dispose();
                    else {
                        if (this.bubble.setDragging) {
                            this.bubble.setDragging(!1);
                            let pe;
                            (pe = this.workspace.getLayerManager()) == null || pe.moveOffDragLayer(this.bubble, Ih)
                        }
                        this.fireMoveEvent_()
                    }
                    this.workspace.setResizesEnabled(!0),
                    J.setGroup$$module$build$src$core$events$utils(!1)
                }
                fireMoveEvent_() {
                    if (this.bubble instanceof Er) {
                        const Q = new (gt(Ss))(this.bubble);
                        Q.setOldCoordinate(this.startXY_),
                        Q.recordNew(),
                        Ye(Q)
                    }
                }
                pixelsToWorkspaceUnits_(Q) {
                    return Q = new Zt(Q.x / this.workspace.scale,Q.y / this.workspace.scale),
                    this.workspace.isMutator && Q.scale(1 / this.workspace.options.parentWorkspace.scale),
                    Q
                }
            }
              , Sg = 30
              , Ig = !0
              , ri = [];
            ri[pn.INPUT_VALUE] = pn.OUTPUT_VALUE,
            ri[pn.OUTPUT_VALUE] = pn.INPUT_VALUE,
            ri[pn.NEXT_STATEMENT] = pn.PREVIOUS_STATEMENT,
            ri[pn.PREVIOUS_STATEMENT] = pn.NEXT_STATEMENT;
            var Rh = "RENAME_VARIABLE_ID"
              , yh = "DELETE_VARIABLE_ID"
              , si = {};
            si.commonWordPrefix = Nu,
            si.commonWordSuffix = Lu,
            si.isNumber = J.isNumber$$module$build$src$core$utils$string,
            si.shortestStringLength = wa,
            si.startsWith = Pm,
            si.wrap = J.wrap$$module$build$src$core$utils$string;
            var Rc = void 0
              , tl = !1
              , ra = !1
              , Rg = 50
              , yg = 0
              , oi = 0
              , bh = 0
              , $h = 0
              , qr = null
              , nl = null
              , Oh = 0
              , Ch = 10
              , bg = 10
              , $g = 750
              , yc = 5
              , cr = null
              , Hr = {
                HOVER_MS: $g,
                LIMIT: Rg,
                MARGINS: yc,
                OFFSET_X: Oh,
                OFFSET_Y: Ch,
                RADIUS_OK: bg
            };
            Hr.bindMouseEvents = Ni,
            Hr.block = Bu,
            Hr.createDom = ku,
            Hr.dispose = wu,
            Hr.getCustomTooltip = wm,
            Hr.getDiv = Um,
            Hr.getTooltipOfObject = xi,
            Hr.hide = Vs,
            Hr.isVisible = Bm,
            Hr.setCustomTooltip = Dm,
            Hr.unbindMouseEvents = Ul,
            Hr.unblock = Uu;
            var Og = class {
                constructor(Q) {
                    this.workspace = Q,
                    this.horizontalScrollEnabled_ = this.workspace.isMovableHorizontally(),
                    this.verticalScrollEnabled_ = this.workspace.isMovableVertically(),
                    this.startScrollXY_ = new Zt(Q.scrollX,Q.scrollY)
                }
                dispose() {
                    this.workspace = null
                }
                startDrag() {
                    we() && we().unselect()
                }
                endDrag(Q) {
                    this.drag(Q)
                }
                drag(Q) {
                    if (Q = Zt.sum(this.startScrollXY_, Q),
                    this.horizontalScrollEnabled_ && this.verticalScrollEnabled_)
                        this.workspace.scroll(Q.x, Q.y);
                    else if (this.horizontalScrollEnabled_)
                        this.workspace.scroll(Q.x, this.workspace.scrollY);
                    else if (this.verticalScrollEnabled_)
                        this.workspace.scroll(this.workspace.scrollX, Q.y);
                    else
                        throw new TypeError("Invalid state.")
                }
            }
              , cT = 5
              , uT = 6
              , Qs = class {
                constructor(Q, oe) {
                    this.creatorWorkspace = oe,
                    this.mouseDownXY = new Zt(0,0),
                    this.startWorkspace_ = this.targetBlock = this.startBlock = this.startIcon = this.startField = this.startBubble = null,
                    this.hasExceededDragRadius = !1,
                    this.boundEvents = [],
                    this.flyout = this.workspaceDragger = this.blockDragger = this.bubbleDragger = null,
                    this.isMultiTouch_ = this.isEnding_ = this.gestureHasStarted = this.calledUpdateIsDragging = !1,
                    this.cachedPoints = new Map,
                    this.startDistance = this.previousScale = 0,
                    this.currentDropdownOwner = this.isPinchZoomEnabled = null,
                    this.mostRecentEvent = Q,
                    this.currentDragDeltaXY = new Zt(0,0),
                    this.healStack = !Ig
                }
                dispose() {
                    Kt(),
                    Uu(),
                    this.creatorWorkspace.clearGesture();
                    for (const Q of this.boundEvents)
                        Ct(Q);
                    this.boundEvents.length = 0,
                    this.blockDragger && this.blockDragger.dispose(),
                    this.workspaceDragger && this.workspaceDragger.dispose()
                }
                updateFromEvent(Q) {
                    const oe = new Zt(Q.clientX,Q.clientY);
                    this.updateDragDelta(oe) && (this.updateIsDragging(),
                    Ht()),
                    this.mostRecentEvent = Q
                }
                updateDragDelta(Q) {
                    return this.currentDragDeltaXY = Zt.difference(Q, this.mouseDownXY),
                    this.hasExceededDragRadius ? !1 : this.hasExceededDragRadius = Zt.magnitude(this.currentDragDeltaXY) > (this.flyout ? J.config$$module$build$src$core$config.flyoutDragRadius : J.config$$module$build$src$core$config.dragRadius)
                }
                updateIsDraggingFromFlyout() {
                    let Q;
                    if (!this.targetBlock || (Q = this.flyout) == null || !Q.isBlockCreatable(this.targetBlock))
                        return !1;
                    if (!this.flyout.targetWorkspace)
                        throw Error(`Cannot update dragging from the flyout because the ' +
          'flyout's target workspace is undefined`);
                    return !this.flyout.isScrollable() || this.flyout.isDragTowardWorkspace(this.currentDragDeltaXY) ? (this.startWorkspace_ = this.flyout.targetWorkspace,
                    this.startWorkspace_.updateScreenCalculationsIfScrolled(),
                    J.getGroup$$module$build$src$core$events$utils() || J.setGroup$$module$build$src$core$events$utils(!0),
                    this.startBlock = null,
                    this.targetBlock = this.flyout.createBlock(this.targetBlock),
                    this.targetBlock.select(),
                    !0) : !1
                }
                updateIsDraggingBubble() {
                    return this.startBubble ? (this.startDraggingBubble(),
                    !0) : !1
                }
                updateIsDraggingBlock() {
                    if (!this.targetBlock)
                        return !1;
                    if (this.flyout) {
                        if (this.updateIsDraggingFromFlyout())
                            return this.startDraggingBlock(),
                            !0
                    } else if (this.targetBlock.isMovable())
                        return this.startDraggingBlock(),
                        !0;
                    return !1
                }
                updateIsDraggingWorkspace() {
                    if (!this.startWorkspace_)
                        throw Error("Cannot update dragging the workspace because the start workspace is undefined");
                    (this.flyout ? this.flyout.isScrollable() : this.startWorkspace_ && this.startWorkspace_.isDraggable()) && (this.workspaceDragger = new Og(this.startWorkspace_),
                    this.workspaceDragger.startDrag())
                }
                updateIsDragging() {
                    if (this.calledUpdateIsDragging)
                        throw Error("updateIsDragging_ should only be called once per gesture.");
                    this.calledUpdateIsDragging = !0,
                    this.updateIsDraggingBubble() || this.updateIsDraggingBlock() || this.updateIsDraggingWorkspace()
                }
                startDraggingBlock() {
                    this.blockDragger = new (Ie(Yt.BLOCK_DRAGGER, this.creatorWorkspace.options, !0))(this.targetBlock,this.startWorkspace_),
                    this.blockDragger.startDrag(this.currentDragDeltaXY, this.healStack),
                    this.blockDragger.drag(this.mostRecentEvent, this.currentDragDeltaXY)
                }
                startDraggingBubble() {
                    if (!this.startBubble)
                        throw Error("Cannot update dragging the bubble because the start bubble is undefined");
                    if (!this.startWorkspace_)
                        throw Error("Cannot update dragging the bubble because the start workspace is undefined");
                    this.bubbleDragger = new _g(this.startBubble,this.startWorkspace_),
                    this.bubbleDragger.startBubbleDrag(),
                    this.bubbleDragger.dragBubble(this.mostRecentEvent, this.currentDragDeltaXY)
                }
                doStart(Q) {
                    if (!this.startWorkspace_)
                        throw Error("Cannot start the touch gesture becauase the start workspace is undefined");
                    this.isPinchZoomEnabled = this.startWorkspace_.options.zoomOptions && this.startWorkspace_.options.zoomOptions.pinch,
                    Mt(Q) ? this.cancel() : (this.gestureHasStarted = !0,
                    vi(),
                    this.startWorkspace_.updateScreenCalculationsIfScrolled(),
                    this.startWorkspace_.isMutator && this.startWorkspace_.resize(),
                    this.currentDropdownOwner = gu(),
                    this.startWorkspace_.hideChaff(!!this.flyout),
                    this.startWorkspace_.markFocused(),
                    this.mostRecentEvent = Q,
                    Bu(),
                    this.targetBlock && this.targetBlock.select(),
                    nn(Q) ? this.handleRightClick(Q) : (Q.type.toLowerCase() === "pointerdown" && Q.pointerType !== "mouse" && Gt(Q, this),
                    this.mouseDownXY = new Zt(Q.clientX,Q.clientY),
                    this.healStack = Q.altKey || Q.ctrlKey || Q.metaKey,
                    this.bindMouseEvents(Q),
                    this.isEnding_ || this.handleTouchStart(Q)))
                }
                bindMouseEvents(Q) {
                    this.boundEvents.push(vt(document, "pointerdown", null, this.handleStart.bind(this), !0)),
                    this.boundEvents.push(vt(document, "pointermove", null, this.handleMove.bind(this), !0)),
                    this.boundEvents.push(vt(document, "pointerup", null, this.handleUp.bind(this), !0)),
                    Q.preventDefault(),
                    Q.stopPropagation()
                }
                handleStart(Q) {
                    this.isDragging() || (this.handleTouchStart(Q),
                    this.isMultiTouch() && Ht())
                }
                handleMove(Q) {
                    this.isDragging() && Ot(Q) || !this.isMultiTouch() ? (this.updateFromEvent(Q),
                    this.workspaceDragger ? this.workspaceDragger.drag(this.currentDragDeltaXY) : this.blockDragger ? this.blockDragger.drag(this.mostRecentEvent, this.currentDragDeltaXY) : this.bubbleDragger && this.bubbleDragger.dragBubble(this.mostRecentEvent, this.currentDragDeltaXY),
                    Q.preventDefault(),
                    Q.stopPropagation()) : this.isMultiTouch() && (this.handleTouchMove(Q),
                    Ht())
                }
                handleUp(Q) {
                    if (this.isDragging() || this.handleTouchEnd(Q),
                    !this.isMultiTouch() || this.isDragging()) {
                        if (!Ot(Q))
                            return;
                        if (this.updateFromEvent(Q),
                        Ht(),
                        this.isEnding_) {
                            console.log("Trying to end a gesture recursively.");
                            return
                        }
                        this.isEnding_ = !0,
                        this.bubbleDragger ? this.bubbleDragger.endBubbleDrag(Q, this.currentDragDeltaXY) : this.blockDragger ? this.blockDragger.endDrag(Q, this.currentDragDeltaXY) : this.workspaceDragger ? this.workspaceDragger.endDrag(this.currentDragDeltaXY) : this.isBubbleClick() ? this.doBubbleClick() : this.isFieldClick() ? this.doFieldClick() : this.isIconClick() ? this.doIconClick() : this.isBlockClick() ? this.doBlockClick() : this.isWorkspaceClick() && this.doWorkspaceClick(Q)
                    }
                    Q.preventDefault(),
                    Q.stopPropagation(),
                    this.dispose()
                }
                handleTouchStart(Q) {
                    var oe = kt(Q);
                    this.cachedPoints.set(oe, this.getTouchPoint(Q));
                    var pe = Array.from(this.cachedPoints.keys());
                    pe.length === 2 && (oe = this.cachedPoints.get(pe[0]),
                    pe = this.cachedPoints.get(pe[1]),
                    this.startDistance = Zt.distance(oe, pe),
                    this.isMultiTouch_ = !0,
                    Q.preventDefault())
                }
                handleTouchMove(Q) {
                    const oe = kt(Q);
                    this.cachedPoints.set(oe, this.getTouchPoint(Q)),
                    this.isPinchZoomEnabled && this.cachedPoints.size === 2 ? this.handlePinch(Q) : this.handleMove(Q)
                }
                handlePinch(Q) {
                    var oe = Array.from(this.cachedPoints.keys())
                      , pe = this.cachedPoints.get(oe[0]);
                    if (oe = this.cachedPoints.get(oe[1]),
                    pe = Zt.distance(pe, oe) / this.startDistance,
                    0 < this.previousScale && 1 / 0 > this.previousScale) {
                        if (oe = pe - this.previousScale,
                        oe = 0 < oe ? oe * cT : oe * uT,
                        !this.startWorkspace_)
                            throw Error("Cannot handle a pinch because the start workspace is undefined");
                        const Ae = this.startWorkspace_
                          , Re = tn(Q, Ae.getParentSvg(), Ae.getInverseScreenCTM());
                        Ae.zoom(Re.x, Re.y, oe)
                    }
                    this.previousScale = pe,
                    Q.preventDefault()
                }
                handleTouchEnd(Q) {
                    Q = kt(Q),
                    this.cachedPoints.has(Q) && this.cachedPoints.delete(Q),
                    2 > this.cachedPoints.size && (this.cachedPoints.clear(),
                    this.previousScale = 0)
                }
                getTouchPoint(Q) {
                    return this.startWorkspace_ ? new Zt(Q.pageX,Q.pageY) : null
                }
                isMultiTouch() {
                    return this.isMultiTouch_
                }
                cancel() {
                    this.isEnding_ || (Ht(),
                    this.bubbleDragger ? this.bubbleDragger.endBubbleDrag(this.mostRecentEvent, this.currentDragDeltaXY) : this.blockDragger ? this.blockDragger.endDrag(this.mostRecentEvent, this.currentDragDeltaXY) : this.workspaceDragger && this.workspaceDragger.endDrag(this.currentDragDeltaXY),
                    this.dispose())
                }
                handleRightClick(Q) {
                    this.targetBlock ? (this.bringBlockToFront(),
                    this.targetBlock.workspace.hideChaff(!!this.flyout),
                    this.targetBlock.showContextMenu(Q)) : this.startBubble ? this.startBubble.showContextMenu(Q) : this.startWorkspace_ && !this.flyout && (this.startWorkspace_.hideChaff(),
                    this.startWorkspace_.showContextMenu(Q)),
                    Q.preventDefault(),
                    Q.stopPropagation(),
                    this.dispose()
                }
                handleWsStart(Q, oe) {
                    if (this.gestureHasStarted)
                        throw Error("Tried to call gesture.handleWsStart, but the gesture had already been started.");
                    this.setStartWorkspace(oe),
                    this.mostRecentEvent = Q,
                    this.doStart(Q)
                }
                fireWorkspaceClick(Q) {
                    Ye(new (gt(Xs))(null,Q.id,"workspace"))
                }
                handleFlyoutStart(Q, oe) {
                    if (this.gestureHasStarted)
                        throw Error("Tried to call gesture.handleFlyoutStart, but the gesture had already been started.");
                    this.setStartFlyout(oe),
                    this.handleWsStart(Q, oe.getWorkspace())
                }
                handleBlockStart(Q, oe) {
                    if (this.gestureHasStarted)
                        throw Error("Tried to call gesture.handleBlockStart, but the gesture had already been started.");
                    this.setStartBlock(oe),
                    this.mostRecentEvent = Q
                }
                handleBubbleStart(Q, oe) {
                    if (this.gestureHasStarted)
                        throw Error("Tried to call gesture.handleBubbleStart, but the gesture had already been started.");
                    this.setStartBubble(oe),
                    this.mostRecentEvent = Q
                }
                doBubbleClick() {
                    this.startBubble instanceof Er && (this.startBubble.setFocus(),
                    this.startBubble.select())
                }
                doFieldClick() {
                    if (!this.startField)
                        throw Error("Cannot do a field click because the start field is undefined");
                    this.currentDropdownOwner !== this.startField && this.startField.showEditor(this.mostRecentEvent),
                    this.bringBlockToFront()
                }
                doIconClick() {
                    if (!this.startIcon)
                        throw Error("Cannot do an icon click because the start icon is undefined");
                    this.bringBlockToFront(),
                    this.startIcon.onClick()
                }
                doBlockClick() {
                    if (this.flyout && this.flyout.autoClose) {
                        if (!this.targetBlock)
                            throw Error("Cannot do a block click because the target block is undefined");
                        this.targetBlock.isEnabled() && (J.getGroup$$module$build$src$core$events$utils() || J.setGroup$$module$build$src$core$events$utils(!0),
                        this.flyout.createBlock(this.targetBlock).scheduleSnapAndBump())
                    } else {
                        if (!this.startWorkspace_)
                            throw Error("Cannot do a block click because the start workspace is undefined");
                        const Q = new (gt(Xs))(this.startBlock,this.startWorkspace_.id,"block");
                        Ye(Q)
                    }
                    this.bringBlockToFront(),
                    J.setGroup$$module$build$src$core$events$utils(!1)
                }
                doWorkspaceClick(Q) {
                    Q = this.creatorWorkspace,
                    we() && we().unselect(),
                    this.fireWorkspaceClick(this.startWorkspace_ || Q)
                }
                bringBlockToFront() {
                    this.targetBlock && !this.flyout && this.targetBlock.bringToFront()
                }
                setStartField(Q) {
                    if (this.gestureHasStarted)
                        throw Error("Tried to call gesture.setStartField, but the gesture had already been started.");
                    this.startField || (this.startField = Q)
                }
                setStartIcon(Q) {
                    if (this.gestureHasStarted)
                        throw Error("Tried to call gesture.setStartIcon, but the gesture had already been started.");
                    this.startIcon || (this.startIcon = Q)
                }
                setStartBubble(Q) {
                    this.startBubble || (this.startBubble = Q)
                }
                setStartBlock(Q) {
                    this.startBlock || this.startBubble || (this.startBlock = Q,
                    Q.isInFlyout && Q !== Q.getRootBlock() ? this.setTargetBlock(Q.getRootBlock()) : this.setTargetBlock(Q))
                }
                setTargetBlock(Q) {
                    Q.isShadow() ? this.setTargetBlock(Q.getParent()) : this.targetBlock = Q
                }
                setStartWorkspace(Q) {
                    this.startWorkspace_ || (this.startWorkspace_ = Q)
                }
                setStartFlyout(Q) {
                    this.flyout || (this.flyout = Q)
                }
                isBubbleClick() {
                    return !!this.startBubble && !this.hasExceededDragRadius
                }
                isBlockClick() {
                    return !!this.startBlock && !this.hasExceededDragRadius && !this.isFieldClick() && !this.isIconClick()
                }
                isFieldClick() {
                    return this.startField ? this.startField.isClickable() && !this.hasExceededDragRadius && (!this.flyout || this.startField.isClickableInFlyout(this.flyout.autoClose)) : !1
                }
                isIconClick() {
                    if (!this.startIcon)
                        return !1;
                    const Q = !this.flyout || !this.startIcon.isClickableInFlyout || this.startIcon.isClickableInFlyout(this.flyout.autoClose);
                    return !this.hasExceededDragRadius && Q
                }
                isWorkspaceClick() {
                    return !this.startBlock && !this.startBubble && !this.startField && !this.hasExceededDragRadius
                }
                isDragging() {
                    return !!this.workspaceDragger || !!this.blockDragger || !!this.bubbleDragger
                }
                hasStarted() {
                    return this.gestureHasStarted
                }
                getInsertionMarkers() {
                    return this.blockDragger ? this.blockDragger.getInsertionMarkers() : []
                }
                getCurrentDragger() {
                    let Q, oe;
                    return (oe = (Q = this.blockDragger) != null ? Q : this.workspaceDragger) != null ? oe : this.bubbleDragger
                }
                static inProgress() {
                    const Q = $e();
                    for (let oe = 0, pe; pe = Q[oe]; oe++)
                        if (pe.currentGesture_)
                            return !0;
                    return !1
                }
            }
              , vh = class {
                constructor(Q, oe) {
                    this.pattern = Q;
                    let pe;
                    this.spacing = (pe = oe.spacing) != null ? pe : 0;
                    let Ae;
                    this.length = (Ae = oe.length) != null ? Ae : 1,
                    this.line2 = (this.line1 = Q.firstChild) && this.line1.nextSibling;
                    let Re;
                    this.snapToGrid = (Re = oe.snap) != null ? Re : !1
                }
                shouldSnap() {
                    return this.snapToGrid
                }
                getSpacing() {
                    return this.spacing
                }
                getPatternId() {
                    return this.pattern.id
                }
                update(Q) {
                    var oe = this.spacing * Q;
                    this.pattern.setAttribute("width", `${oe}`),
                    this.pattern.setAttribute("height", `${oe}`),
                    oe = Math.floor(this.spacing / 2) + .5;
                    let pe = oe - this.length / 2
                      , Ae = oe + this.length / 2;
                    oe *= Q,
                    pe *= Q,
                    Ae *= Q,
                    this.setLineAttributes(this.line1, Q, pe, Ae, oe, oe),
                    this.setLineAttributes(this.line2, Q, oe, oe, pe, Ae)
                }
                setLineAttributes(Q, oe, pe, Ae, Re, Ue) {
                    Q && (Q.setAttribute("stroke-width", `${oe}`),
                    Q.setAttribute("x1", `${pe}`),
                    Q.setAttribute("y1", `${Re}`),
                    Q.setAttribute("x2", `${Ae}`),
                    Q.setAttribute("y2", `${Ue}`))
                }
                moveTo(Q, oe) {
                    this.pattern.setAttribute("x", `${Q}`),
                    this.pattern.setAttribute("y", `${oe}`)
                }
                static createDom(Q, oe, pe) {
                    Q = $t(bt.PATTERN, {
                        id: "blocklyGridPattern" + Q,
                        patternUnits: "userSpaceOnUse"
                    }, pe);
                    let Ae, Re;
                    if (0 < ((Ae = oe.length) != null ? Ae : 1) && 0 < ((Re = oe.spacing) != null ? Re : 0)) {
                        $t(bt.LINE, {
                            stroke: oe.colour
                        }, Q);
                        let Ue;
                        (Ue = oe.length) != null && Ue && $t(bt.LINE, {
                            stroke: oe.colour
                        }, Q)
                    } else
                        $t(bt.LINE, {}, Q);
                    return Q
                }
            }
              , rl = class {
                constructor(Q) {
                    this.workspace = Q,
                    this.cursorSvg_ = this.cursor_ = null,
                    this.markers = new Map,
                    this.markerSvg_ = null
                }
                registerMarker(Q, oe) {
                    this.markers.has(Q) && this.unregisterMarker(Q),
                    oe.setDrawer(this.workspace.getRenderer().makeMarkerDrawer(this.workspace, oe)),
                    this.setMarkerSvg(oe.getDrawer().createDom()),
                    this.markers.set(Q, oe)
                }
                unregisterMarker(Q) {
                    const oe = this.markers.get(Q);
                    if (oe)
                        oe.dispose(),
                        this.markers.delete(Q);
                    else
                        throw Error("Marker with ID " + Q + " does not exist. Can only unregister markers that exist.")
                }
                getCursor() {
                    return this.cursor_
                }
                getMarker(Q) {
                    return this.markers.get(Q) || null
                }
                setCursor(Q) {
                    this.cursor_ && this.cursor_.getDrawer() && this.cursor_.getDrawer().dispose(),
                    (this.cursor_ = Q) && (Q = this.workspace.getRenderer().makeMarkerDrawer(this.workspace, this.cursor_),
                    this.cursor_.setDrawer(Q),
                    this.setCursorSvg(this.cursor_.getDrawer().createDom()))
                }
                setCursorSvg(Q) {
                    Q ? (this.workspace.getBlockCanvas().appendChild(Q),
                    this.cursorSvg_ = Q) : this.cursorSvg_ = null
                }
                setMarkerSvg(Q) {
                    Q ? this.workspace.getBlockCanvas() && (this.cursorSvg_ ? this.workspace.getBlockCanvas().insertBefore(Q, this.cursorSvg_) : this.workspace.getBlockCanvas().appendChild(Q)) : this.markerSvg_ = null
                }
                updateMarkers() {
                    this.workspace.keyboardAccessibilityMode && this.cursorSvg_ && this.workspace.getCursor().draw()
                }
                dispose() {
                    const Q = Object.keys(this.markers);
                    for (let oe = 0, pe; pe = Q[oe]; oe++)
                        this.unregisterMarker(pe);
                    this.markers.clear(),
                    this.cursor_ && (this.cursor_.dispose(),
                    this.cursor_ = null)
                }
            }
            ;
            rl.LOCAL_MARKER = "local_marker_1";
            var Cg = {};
            Cg.deepMerge = Gs;
            var ii = class {
                constructor(Q, oe, pe, Ae) {
                    this.name = Q,
                    this.startHats = !1,
                    this.blockStyles = oe || Object.create(null),
                    this.categoryStyles = pe || Object.create(null),
                    this.componentStyles = Ae || Object.create(null),
                    this.fontStyle = Object.create(null),
                    ne(Yt.THEME, Q, this, !0)
                }
                getClassName() {
                    return this.name + "-theme"
                }
                setBlockStyle(Q, oe) {
                    this.blockStyles[Q] = oe
                }
                setCategoryStyle(Q, oe) {
                    this.categoryStyles[Q] = oe
                }
                getComponentStyle(Q) {
                    if (Q = this.componentStyles[Q],
                    !Q)
                        return null;
                    if (typeof Q == "string") {
                        const oe = this.getComponentStyle(Q);
                        if (oe)
                            return oe
                    }
                    return `${Q}`
                }
                setComponentStyle(Q, oe) {
                    this.componentStyles[Q] = oe
                }
                setFontStyle(Q) {
                    this.fontStyle = Q
                }
                setStartHats(Q) {
                    this.startHats = Q
                }
                static defineTheme(Q, oe) {
                    Q = Q.toLowerCase();
                    const pe = new ii(Q);
                    let Ae = oe.base;
                    if (Ae) {
                        if (typeof Ae == "string") {
                            let Re;
                            Ae = (Re = _e(Yt.THEME, Ae)) != null ? Re : void 0
                        }
                        Ae instanceof ii && (Gs(pe, Ae),
                        pe.name = Q)
                    }
                    return Gs(pe.blockStyles, oe.blockStyles),
                    Gs(pe.categoryStyles, oe.categoryStyles),
                    Gs(pe.componentStyles, oe.componentStyles),
                    Gs(pe.fontStyle, oe.fontStyle),
                    oe.startHats !== null && (pe.startHats = oe.startHats),
                    pe
                }
            }
              , dT = {
                colour_blocks: {
                    colourPrimary: "20"
                },
                list_blocks: {
                    colourPrimary: "260"
                },
                logic_blocks: {
                    colourPrimary: "210"
                },
                loop_blocks: {
                    colourPrimary: "120"
                },
                math_blocks: {
                    colourPrimary: "230"
                },
                procedure_blocks: {
                    colourPrimary: "290"
                },
                text_blocks: {
                    colourPrimary: "160"
                },
                variable_blocks: {
                    colourPrimary: "330"
                },
                variable_dynamic_blocks: {
                    colourPrimary: "310"
                },
                hat_blocks: {
                    colourPrimary: "330",
                    hat: "cap"
                }
            }
              , hT = {
                colour_category: {
                    colour: "20"
                },
                list_category: {
                    colour: "260"
                },
                logic_category: {
                    colour: "210"
                },
                loop_category: {
                    colour: "120"
                },
                math_category: {
                    colour: "230"
                },
                procedure_category: {
                    colour: "290"
                },
                text_category: {
                    colour: "160"
                },
                variable_category: {
                    colour: "330"
                },
                variable_dynamic_category: {
                    colour: "310"
                }
            }
              , bc = new ii("classic",dT,hT)
              , Qr = class {
                constructor(Q) {
                    this.gridPattern = null,
                    this.getMetrics = this.setMetrics = void 0;
                    let oe = null
                      , pe = !1;
                    var Ae = !1
                      , Re = !1
                      , Ue = !1
                      , tt = !1
                      , dt = !1;
                    const wt = !!Q.readOnly;
                    if (!wt) {
                        var sn;
                        oe = rn((sn = Q.toolbox) != null ? sn : null),
                        pe = On(oe),
                        Ae = Q.trashcan,
                        Ae = Ae === void 0 ? pe : Ae,
                        Re = Q.collapse,
                        Re = Re === void 0 ? pe : Re,
                        Ue = Q.comments,
                        Ue = Ue === void 0 ? pe : Ue,
                        tt = Q.disable,
                        tt = tt === void 0 ? pe : tt,
                        dt = Q.sounds,
                        dt = dt === void 0 ? !0 : dt
                    }
                    sn = Q.maxTrashcanContents,
                    Ae ? sn === void 0 && (sn = 32) : sn = 0;
                    const zn = !!Q.rtl;
                    let jn = Q.horizontalLayout;
                    jn === void 0 && (jn = !1);
                    var kr = Q.toolboxPosition !== "end";
                    kr = jn ? kr ? In.TOP : In.BOTTOM : kr === zn ? In.RIGHT : In.LEFT;
                    let fa = Q.css;
                    fa === void 0 && (fa = !0);
                    let ga = "https://blockly-demo.appspot.com/static/media/";
                    Q.media ? ga = Q.media.endsWith("/") ? Q.media : Q.media + "/" : "path"in Q && (zt("path", "Nov 2014", "Jul 2023", "media"),
                    ga = Q.path + "media/");
                    const kE = Q.oneBasedIndex
                      , KT = Q.renderer || "geras"
                      , JT = Q.plugins || {};
                    let Tp = Q.modalInputs;
                    Tp === void 0 && (Tp = !0),
                    this.RTL = zn,
                    this.oneBasedIndex = kE === void 0 ? !0 : kE,
                    this.collapse = Re,
                    this.comments = Ue,
                    this.disable = tt,
                    this.readOnly = wt,
                    this.maxBlocks = Q.maxBlocks || 1 / 0;
                    let DE;
                    this.maxInstances = (DE = Q.maxInstances) != null ? DE : null,
                    this.modalInputs = Tp,
                    this.pathToMedia = ga,
                    this.hasCategories = pe,
                    this.moveOptions = Qr.parseMoveOptions_(Q, pe),
                    this.hasScrollbars = !!this.moveOptions.scrollbars,
                    this.hasTrashcan = Ae,
                    this.maxTrashcanContents = sn,
                    this.hasSounds = dt,
                    this.hasCss = fa,
                    this.horizontalLayout = jn,
                    this.languageTree = oe,
                    this.gridOptions = Qr.parseGridOptions_(Q),
                    this.zoomOptions = Qr.parseZoomOptions_(Q),
                    this.toolboxPosition = kr,
                    this.theme = Qr.parseThemeOptions_(Q),
                    this.renderer = KT;
                    let wE;
                    this.rendererOverrides = (wE = Q.rendererOverrides) != null ? wE : null;
                    let BE;
                    this.parentWorkspace = (BE = Q.parentWorkspace) != null ? BE : null,
                    this.plugins = JT
                }
                static parseMoveOptions_(Q, oe) {
                    const pe = Q.move || {}
                      , Ae = {};
                    return pe.scrollbars === void 0 && Q.scrollbars === void 0 ? Ae.scrollbars = oe : typeof pe.scrollbars == "object" ? (Ae.scrollbars = {
                        horizontal: !!pe.scrollbars.horizontal,
                        vertical: !!pe.scrollbars.vertical
                    },
                    Ae.scrollbars.horizontal && Ae.scrollbars.vertical ? Ae.scrollbars = !0 : Ae.scrollbars.horizontal || Ae.scrollbars.vertical || (Ae.scrollbars = !1)) : Ae.scrollbars = !!pe.scrollbars || !!Q.scrollbars,
                    Ae.wheel = Ae.scrollbars && pe.wheel !== void 0 ? !!pe.wheel : typeof Ae.scrollbars == "object",
                    Ae.drag = Ae.scrollbars ? pe.drag === void 0 ? !0 : !!pe.drag : !1,
                    Ae
                }
                static parseZoomOptions_(Q) {
                    Q = Q.zoom || {};
                    const oe = {};
                    return oe.controls = Q.controls === void 0 ? !1 : !!Q.controls,
                    oe.wheel = Q.wheel === void 0 ? !1 : !!Q.wheel,
                    oe.startScale = Q.startScale === void 0 ? 1 : Number(Q.startScale),
                    oe.maxScale = Q.maxScale === void 0 ? 3 : Number(Q.maxScale),
                    oe.minScale = Q.minScale === void 0 ? .3 : Number(Q.minScale),
                    oe.scaleSpeed = Q.scaleSpeed === void 0 ? 1.2 : Number(Q.scaleSpeed),
                    oe.pinch = Q.pinch === void 0 ? oe.wheel || oe.controls : !!Q.pinch,
                    oe
                }
                static parseGridOptions_(Q) {
                    Q = Q.grid || {};
                    const oe = {};
                    return oe.spacing = Number(Q.spacing) || 0,
                    oe.colour = Q.colour || "#888",
                    oe.length = Q.length === void 0 ? 1 : Number(Q.length),
                    oe.snap = 0 < oe.spacing && !!Q.snap,
                    oe
                }
                static parseThemeOptions_(Q) {
                    return Q = Q.theme || bc,
                    typeof Q == "string" ? _e(Yt.THEME, Q) : Q instanceof ii ? Q : ii.defineTheme(Q.name || "builtin" + at(), Q)
                }
            }
              , ai = class extends Zo {
                constructor(Q, oe, pe, Ae, Re) {
                    super(Q),
                    this.type = J.CHANGE$$module$build$src$core$events$utils,
                    Q && (this.element = oe,
                    this.name = pe || void 0,
                    this.oldValue = Ae,
                    this.newValue = Re)
                }
                toJson() {
                    const Q = super.toJson();
                    if (!this.element)
                        throw Error("The changed element is undefined. Either pass an element to the constructor, or call fromJson");
                    return Q.element = this.element,
                    Q.name = this.name,
                    Q.oldValue = this.oldValue,
                    Q.newValue = this.newValue,
                    Q
                }
                static fromJson(Q, oe, pe) {
                    return oe = super.fromJson(Q, oe, pe ?? new ai),
                    oe.element = Q.element,
                    oe.name = Q.name,
                    oe.oldValue = Q.oldValue,
                    oe.newValue = Q.newValue,
                    oe
                }
                isNull() {
                    return this.oldValue === this.newValue
                }
                run(Q) {
                    var oe = this.getEventWorkspace_();
                    if (!this.blockId)
                        throw Error("The block ID is undefined. Either pass a block to the constructor, or call fromJson");
                    if (oe = oe.getBlockById(this.blockId),
                    !oe)
                        throw Error("The associated block is undefined. Either pass a block to the constructor, or call fromJson");
                    var pe = oe.getIcon(Lr.MUTATOR);
                    switch (pe && uo(pe) && pe.bubbleIsVisible() && pe.setBubbleVisible(!1),
                    Q = Q ? this.newValue : this.oldValue,
                    this.element) {
                    case "field":
                        (oe = oe.getField(this.name)) ? oe.setValue(Q) : console.warn("Can't set non-existent field: " + this.name);
                        break;
                    case "comment":
                        oe.setCommentText(Q || null);
                        break;
                    case "collapsed":
                        oe.setCollapsed(!!Q);
                        break;
                    case "disabled":
                        oe.setEnabled(!Q);
                        break;
                    case "inline":
                        oe.setInputsInline(!!Q);
                        break;
                    case "mutation":
                        pe = ai.getExtraBlockState_(oe),
                        oe.loadExtraState ? oe.loadExtraState(JSON.parse(Q || "{}")) : oe.domToMutation && oe.domToMutation(J.textToDom$$module$build$src$core$utils$xml(Q || "<mutation/>")),
                        Ye(new ai(oe,"mutation",null,pe,Q));
                        break;
                    default:
                        console.warn("Unknown change type: " + this.element)
                    }
                }
                static getExtraBlockState_(Q) {
                    return Q.saveExtraState ? (Q = Q.saveExtraState(!0)) ? JSON.stringify(Q) : "" : Q.mutationToDom && (Q = Q.mutationToDom()) ? Es(Q) : ""
                }
            }
            ;
            ne(Yt.EVENT, J.CHANGE$$module$build$src$core$events$utils, ai);
            var xh = .45
              , Nh = .65
              , vg = {
                aqua: "#00ffff",
                black: "#000000",
                blue: "#0000ff",
                fuchsia: "#ff00ff",
                gray: "#808080",
                green: "#008000",
                lime: "#00ff00",
                maroon: "#800000",
                navy: "#000080",
                olive: "#808000",
                purple: "#800080",
                red: "#ff0000",
                silver: "#c0c0c0",
                teal: "#008080",
                white: "#ffffff",
                yellow: "#ffff00"
            }
              , Zr = {};
            Zr.blend = Ho,
            Zr.getHsvSaturation = Fl,
            Zr.getHsvValue = Hl,
            Zr.hexToRgb = Vl,
            Zr.hsvToHex = Gl,
            Zr.hueToHex = Vu,
            Zr.names = vg,
            Zr.parse = ho,
            Zr.rgbToHex = Ba,
            Zr.setHsvSaturation = Fu,
            Zr.setHsvValue = Hu;
            var sl = {};
            sl.checkMessageReferences = Ym,
            sl.parseBlockColour = Li,
            sl.replaceMessageReferences = rr,
            sl.tokenizeInterpolation = Gu;
            var vn = class {
                constructor(Q, oe, pe) {
                    this.DEFAULT_VALUE = null,
                    this.name = void 0,
                    this.constants_ = this.mouseDownWrapper_ = this.textContent_ = this.textElement_ = this.borderRect_ = this.fieldGroup_ = this.markerSvg_ = this.cursorSvg_ = this.tooltip_ = this.validator_ = null,
                    this.disposed = !1,
                    this.maxDisplayLength = 50,
                    this.sourceBlock_ = null,
                    this.enabled_ = this.visible_ = this.isDirty_ = !0,
                    this.suffixField = this.prefixField = this.clickTarget_ = null,
                    this.EDITABLE = !0,
                    this.SERIALIZABLE = !1,
                    this.CURSOR = "",
                    this.value_ = "DEFAULT_VALUE"in new.target.prototype ? new.target.prototype.DEFAULT_VALUE : this.DEFAULT_VALUE,
                    this.size_ = new Yn(0,0),
                    Q !== vn.SKIP_SETUP && (pe && this.configure_(pe),
                    this.setValue(Q),
                    oe && this.setValidator(oe))
                }
                configure_(Q) {
                    Q.tooltip && this.setTooltip(rr(Q.tooltip))
                }
                setSourceBlock(Q) {
                    if (this.sourceBlock_)
                        throw Error("Field already bound to a block");
                    this.sourceBlock_ = Q
                }
                getConstants() {
                    return !this.constants_ && this.sourceBlock_ && !this.sourceBlock_.isDeadOrDying() && this.sourceBlock_.workspace.rendered && (this.constants_ = this.sourceBlock_.workspace.getRenderer().getConstants()),
                    this.constants_
                }
                getSourceBlock() {
                    return this.sourceBlock_
                }
                init() {
                    this.fieldGroup_ || (this.fieldGroup_ = $t(bt.G, {}),
                    this.isVisible() || (this.fieldGroup_.style.display = "none"),
                    this.sourceBlock_.getSvgRoot().appendChild(this.fieldGroup_),
                    this.initView(),
                    this.updateEditable(),
                    this.setTooltip(this.tooltip_),
                    this.bindEvents_(),
                    this.initModel())
                }
                initView() {
                    this.createBorderRect_(),
                    this.createTextElement_()
                }
                initModel() {}
                isFullBlockField() {
                    return !this.borderRect_
                }
                createBorderRect_() {
                    this.borderRect_ = $t(bt.RECT, {
                        rx: this.getConstants().FIELD_BORDER_RECT_RADIUS,
                        ry: this.getConstants().FIELD_BORDER_RECT_RADIUS,
                        x: 0,
                        y: 0,
                        height: this.size_.height,
                        width: this.size_.width,
                        class: "blocklyFieldRect"
                    }, this.fieldGroup_)
                }
                createTextElement_() {
                    this.textElement_ = $t(bt.TEXT, {
                        class: "blocklyText"
                    }, this.fieldGroup_),
                    this.getConstants().FIELD_TEXT_BASELINE_CENTER && this.textElement_.setAttribute("dominant-baseline", "central"),
                    this.textContent_ = document.createTextNode(""),
                    this.textElement_.appendChild(this.textContent_)
                }
                bindEvents_() {
                    const Q = this.getClickTarget_();
                    if (!Q)
                        throw Error("A click target has not been set.");
                    Ni(Q),
                    this.mouseDownWrapper_ = vt(Q, "pointerdown", this, this.onMouseDown_)
                }
                fromXml(Q) {
                    this.setValue(Q.textContent)
                }
                toXml(Q) {
                    return Q.textContent = this.getValue(),
                    Q
                }
                saveState(Q) {
                    return Q = this.saveLegacyState(vn),
                    Q !== null ? Q : this.getValue()
                }
                loadState(Q) {
                    this.loadLegacyState(vn, Q) || this.setValue(Q)
                }
                saveLegacyState(Q) {
                    return Q.prototype.saveState === this.saveState && Q.prototype.toXml !== this.toXml ? (Q = J.createElement$$module$build$src$core$utils$xml("field"),
                    Q.setAttribute("name", this.name || ""),
                    Pt(this.toXml(Q)).replace(' xmlns="https://developers.google.com/blockly/xml"', "")) : null
                }
                loadLegacyState(Q, oe) {
                    return Q.prototype.loadState === this.loadState && Q.prototype.fromXml !== this.fromXml ? (this.fromXml(J.textToDom$$module$build$src$core$utils$xml(oe)),
                    !0) : !1
                }
                dispose() {
                    Ci(this),
                    Ml(this);
                    let Q;
                    (Q = this.getSourceBlock()) != null && Q.isDeadOrDying() || Bt(this.fieldGroup_),
                    this.disposed = !0
                }
                updateEditable() {
                    const Q = this.fieldGroup_
                      , oe = this.getSourceBlock();
                    this.EDITABLE && Q && oe && (this.enabled_ && oe.isEditable() ? (Ut(Q, "blocklyEditableText"),
                    yt(Q, "blocklyNonEditableText"),
                    Q.style.cursor = this.CURSOR) : (Ut(Q, "blocklyNonEditableText"),
                    yt(Q, "blocklyEditableText"),
                    Q.style.cursor = ""))
                }
                setEnabled(Q) {
                    this.enabled_ = Q,
                    this.updateEditable()
                }
                isEnabled() {
                    return this.enabled_
                }
                isClickable() {
                    return this.enabled_ && !!this.sourceBlock_ && this.sourceBlock_.isEditable() && this.showEditor_ !== vn.prototype.showEditor_
                }
                isClickableInFlyout(Q) {
                    return !Q
                }
                isCurrentlyEditable() {
                    return this.enabled_ && this.EDITABLE && !!this.sourceBlock_ && this.sourceBlock_.isEditable()
                }
                isSerializable() {
                    let Q = !1;
                    return this.name && (this.SERIALIZABLE ? Q = !0 : this.EDITABLE && (console.warn("Detected an editable field that was not serializable. Please define SERIALIZABLE property as true on all editable custom fields. Proceeding with serialization."),
                    Q = !0)),
                    Q
                }
                isVisible() {
                    return this.visible_
                }
                setVisible(Q) {
                    if (this.visible_ !== Q) {
                        this.visible_ = Q;
                        var oe = this.fieldGroup_;
                        oe && (oe.style.display = Q ? "block" : "none")
                    }
                }
                setValidator(Q) {
                    this.validator_ = Q
                }
                getValidator() {
                    return this.validator_
                }
                getSvgRoot() {
                    return this.fieldGroup_
                }
                getBorderRect() {
                    if (!this.borderRect_)
                        throw Error(`The border rectangle is ${this.borderRect_}.`);
                    return this.borderRect_
                }
                getTextElement() {
                    if (!this.textElement_)
                        throw Error(`The text element is ${this.textElement_}.`);
                    return this.textElement_
                }
                getTextContent() {
                    if (!this.textContent_)
                        throw Error(`The text content is ${this.textContent_}.`);
                    return this.textContent_
                }
                applyColour() {}
                render_() {
                    this.textContent_ && (this.textContent_.nodeValue = this.getDisplayText_()),
                    this.updateSize_()
                }
                showEditor(Q) {
                    this.isClickable() && this.showEditor_(Q)
                }
                showEditor_(Q) {}
                repositionForWindowResize() {
                    return !1
                }
                updateSize_(Q) {
                    const oe = this.getConstants();
                    Q = Q !== void 0 ? Q : this.isFullBlockField() ? 0 : this.getConstants().FIELD_BORDER_RECT_X_PADDING;
                    let pe = 2 * Q
                      , Ae = oe.FIELD_TEXT_HEIGHT
                      , Re = 0;
                    this.textElement_ && (Re = Ft(this.textElement_, oe.FIELD_TEXT_FONTSIZE, oe.FIELD_TEXT_FONTWEIGHT, oe.FIELD_TEXT_FONTFAMILY),
                    pe += Re),
                    this.isFullBlockField() || (Ae = Math.max(Ae, oe.FIELD_BORDER_RECT_HEIGHT)),
                    this.size_.height = Ae,
                    this.size_.width = pe,
                    this.positionTextElement_(Q, Re),
                    this.positionBorderRect_()
                }
                positionTextElement_(Q, oe) {
                    if (this.textElement_) {
                        var pe = this.getConstants(), Ae = this.size_.height / 2, Re;
                        this.textElement_.setAttribute("x", String((Re = this.getSourceBlock()) != null && Re.RTL ? this.size_.width - oe - Q : Q)),
                        this.textElement_.setAttribute("y", String(pe.FIELD_TEXT_BASELINE_CENTER ? Ae : Ae - pe.FIELD_TEXT_HEIGHT / 2 + pe.FIELD_TEXT_BASELINE))
                    }
                }
                positionBorderRect_() {
                    this.borderRect_ && (this.borderRect_.setAttribute("width", String(this.size_.width)),
                    this.borderRect_.setAttribute("height", String(this.size_.height)),
                    this.borderRect_.setAttribute("rx", String(this.getConstants().FIELD_BORDER_RECT_RADIUS)),
                    this.borderRect_.setAttribute("ry", String(this.getConstants().FIELD_BORDER_RECT_RADIUS)))
                }
                getSize() {
                    return this.isVisible() ? (this.isDirty_ ? (this.render_(),
                    this.isDirty_ = !1) : this.visible_ && this.size_.width === 0 && (this.render_(),
                    this.size_.width !== 0 && console.warn("Deprecated use of setting size_.width to 0 to rerender a field. Set field.isDirty_ to true instead.")),
                    this.size_) : new Yn(0,0)
                }
                getScaledBBox() {
                    let Q;
                    var oe = this.getSourceBlock();
                    if (!oe)
                        throw new Gn;
                    if (this.isFullBlockField()) {
                        var pe = this.sourceBlock_.getHeightWidth();
                        const Ae = oe.workspace.scale;
                        Q = this.getAbsoluteXY_(),
                        oe = (pe.width + 1) * Ae,
                        pe = (pe.height + 1) * Ae,
                        Vd ? (Q.x += 1.5 * Ae,
                        Q.y += 1.5 * Ae) : (Q.x -= .5 * Ae,
                        Q.y -= .5 * Ae)
                    } else
                        pe = this.borderRect_.getBoundingClientRect(),
                        Q = En(this.borderRect_),
                        oe = pe.width,
                        pe = pe.height;
                    return new Vn(Q.y,Q.y + pe,Q.x,Q.x + oe)
                }
                onLocationChange(Q) {}
                getDisplayText_() {
                    let Q = this.getText();
                    return Q ? (Q.length > this.maxDisplayLength && (Q = Q.substring(0, this.maxDisplayLength - 2) + "…"),
                    Q = Q.replace(/\s/g, vn.NBSP),
                    this.sourceBlock_ && this.sourceBlock_.RTL && (Q += "‏"),
                    Q) : vn.NBSP
                }
                getText() {
                    const Q = this.getText_();
                    return String(Q !== null ? Q : this.getValue())
                }
                getText_() {
                    return null
                }
                markDirty() {
                    this.isDirty_ = !0,
                    this.constants_ = null
                }
                forceRerender() {
                    this.isDirty_ = !0,
                    this.sourceBlock_ && this.sourceBlock_.rendered && (this.sourceBlock_.queueRender(),
                    this.sourceBlock_.bumpNeighbours())
                }
                setValue(Q, oe=!0) {
                    if (Q !== null) {
                        var pe = this.doClassValidation_(Q);
                        if (Q = this.processValidation_(Q, pe),
                        !(Q instanceof Error)) {
                            var Ae;
                            pe = (Ae = this.getValidator()) == null ? void 0 : Ae.call(this, Q),
                            Ae = this.processValidation_(Q, pe),
                            Ae instanceof Error || (Q = this.sourceBlock_,
                            Q && Q.disposed || (pe = this.getValue(),
                            pe === Ae ? this.doValueUpdate_(Ae) : (this.doValueUpdate_(Ae),
                            oe && Q && Ke() && Ye(new (gt(J.CHANGE$$module$build$src$core$events$utils))(Q,"field",this.name || null,pe,Ae)),
                            this.isDirty_ && this.forceRerender())))
                        }
                    }
                }
                processValidation_(Q, oe) {
                    return oe === null ? (this.doValueInvalid_(Q),
                    this.isDirty_ && this.forceRerender(),
                    Error()) : oe === void 0 ? Q : oe
                }
                getValue() {
                    return this.value_
                }
                doClassValidation_(Q) {
                    return Q ?? null
                }
                doValueUpdate_(Q) {
                    this.value_ = Q,
                    this.isDirty_ = !0
                }
                doValueInvalid_(Q) {}
                onMouseDown_(Q) {
                    this.sourceBlock_ && !this.sourceBlock_.isDeadOrDying() && (Q = this.sourceBlock_.workspace.getGesture(Q)) && Q.setStartField(this)
                }
                setTooltip(Q) {
                    Q || Q === "" || (Q = this.sourceBlock_);
                    const oe = this.getClickTarget_();
                    oe ? oe.tooltip = Q : this.tooltip_ = Q
                }
                getTooltip() {
                    const Q = this.getClickTarget_();
                    return xi(Q || {
                        tooltip: this.tooltip_
                    })
                }
                getClickTarget_() {
                    return this.clickTarget_ || this.getSvgRoot()
                }
                getAbsoluteXY_() {
                    return En(this.getClickTarget_())
                }
                referencesVariables() {
                    return !1
                }
                refreshVariableName() {}
                getParentInput() {
                    let Q = null;
                    const oe = this.getSourceBlock();
                    if (!oe)
                        throw new Gn;
                    const pe = oe.inputList;
                    for (let Ae = 0; Ae < oe.inputList.length; Ae++) {
                        const Re = pe[Ae]
                          , Ue = Re.fieldRow;
                        for (let tt = 0; tt < Ue.length; tt++)
                            if (Ue[tt] === this) {
                                Q = Re;
                                break
                            }
                    }
                    return Q
                }
                getFlipRtl() {
                    return !1
                }
                isTabNavigable() {
                    return !1
                }
                onShortcut(Q) {
                    return !1
                }
                setCursorSvg(Q) {
                    if (Q) {
                        if (!this.fieldGroup_)
                            throw Error(`The field group is ${this.fieldGroup_}.`);
                        this.fieldGroup_.appendChild(Q),
                        this.cursorSvg_ = Q
                    } else
                        this.cursorSvg_ = null
                }
                setMarkerSvg(Q) {
                    if (Q) {
                        if (!this.fieldGroup_)
                            throw Error(`The field group is ${this.fieldGroup_}.`);
                        this.fieldGroup_.appendChild(Q),
                        this.markerSvg_ = Q
                    } else
                        this.markerSvg_ = null
                }
                updateMarkers_() {
                    var Q = this.getSourceBlock();
                    if (!Q)
                        throw new Gn;
                    Q = Q.workspace,
                    Q.keyboardAccessibilityMode && this.cursorSvg_ && Q.getCursor().draw(),
                    Q.keyboardAccessibilityMode && this.markerSvg_ && Q.getMarker(rl.LOCAL_MARKER).draw()
                }
            }
            ;
            vn.NBSP = " ",
            vn.SKIP_SETUP = Symbol("SKIP_SETUP");
            var Gn = class extends Error {
                constructor() {
                    super("The field has not yet been attached to its input. Call appendField to attach it.")
                }
            }
            ;
            J.Names$$module$build$src$core$names = class {
                constructor(Q, oe) {
                    this.db = new Map,
                    this.dbReverse = new Set,
                    this.variableMap = null,
                    this.variablePrefix = oe || "",
                    this.reservedWords = new Set(Q ? Q.split(",") : [])
                }
                reset() {
                    this.db.clear(),
                    this.dbReverse.clear(),
                    this.variableMap = null
                }
                setVariableMap(Q) {
                    this.variableMap = Q
                }
                getNameForUserVariable(Q) {
                    return this.variableMap ? (Q = this.variableMap.getVariableById(Q)) ? Q.name : null : (console.warn(`Deprecated call to Names.prototype.getName without defining a variable map. To fix, add the following code in your generator's init() function:
Blockly.YourGeneratorName.nameDB_.setVariableMap(workspace.getVariableMap());`),
                    null)
                }
                populateVariables(Q) {
                    Q = J.allUsedVarModels$$module$build$src$core$variables(Q);
                    for (let oe = 0; oe < Q.length; oe++)
                        this.getName(Q[oe].getId(), J.NameType$$module$build$src$core$names.VARIABLE)
                }
                populateProcedures(Q) {
                    throw Error("The implementation of populateProcedures should be monkey-patched in by blockly.ts")
                }
                getName(Q, oe) {
                    let pe = Q;
                    oe === J.NameType$$module$build$src$core$names.VARIABLE && (Q = this.getNameForUserVariable(Q)) && (pe = Q),
                    Q = pe.toLowerCase();
                    const Ae = oe === J.NameType$$module$build$src$core$names.VARIABLE || oe === J.NameType$$module$build$src$core$names.DEVELOPER_VARIABLE ? this.variablePrefix : "";
                    this.db.has(oe) || this.db.set(oe, new Map);
                    const Re = this.db.get(oe);
                    return Re.has(Q) ? Ae + Re.get(Q) : (oe = this.getDistinctName(pe, oe),
                    Re.set(Q, oe.substr(Ae.length)),
                    oe)
                }
                getUserNames(Q) {
                    let oe;
                    return (Q = (oe = this.db.get(Q)) == null ? void 0 : oe.keys()) ? Array.from(Q) : []
                }
                getDistinctName(Q, oe) {
                    Q = this.safeName(Q);
                    let pe = null, Ae, Re;
                    for (; this.dbReverse.has(Q + ((Ae = pe) != null ? Ae : "")) || this.reservedWords.has(Q + ((Re = pe) != null ? Re : "")); )
                        pe = pe ? pe + 1 : 2;
                    let Ue;
                    return Q += (Ue = pe) != null ? Ue : "",
                    this.dbReverse.add(Q),
                    (oe === J.NameType$$module$build$src$core$names.VARIABLE || oe === J.NameType$$module$build$src$core$names.DEVELOPER_VARIABLE ? this.variablePrefix : "") + Q
                }
                safeName(Q) {
                    return Q ? (Q = encodeURI(Q.replace(/ /g, "_")).replace(/[^\w]/g, "_"),
                    "0123456789".indexOf(Q[0]) !== -1 && (Q = "my_" + Q)) : Q = J.Msg$$module$build$src$core$msg.UNNAMED_KEY || "unnamed",
                    Q
                }
                static equals(Q, oe) {
                    return Q.toLowerCase() === oe.toLowerCase()
                }
            }
            ,
            function(Q) {
                Q = Q.NameType || (Q.NameType = {}),
                Q.DEVELOPER_VARIABLE = "DEVELOPER_VARIABLE",
                Q.VARIABLE = "VARIABLE",
                Q.PROCEDURE = "PROCEDURE"
            }(J.Names$$module$build$src$core$names || (J.Names$$module$build$src$core$names = {})),
            J.NameType$$module$build$src$core$names = J.Names$$module$build$src$core$names.NameType,
            J.Names$$module$build$src$core$names.DEVELOPER_VARIABLE_TYPE = J.NameType$$module$build$src$core$names.DEVELOPER_VARIABLE,
            J.NameType$$module$build$src$core$names,
            J.Names$$module$build$src$core$names;
            var xg = class extends Map {
                constructor() {
                    super()
                }
                set(Q, oe) {
                    return this.get(Q) === oe ? this : (super.set(Q, oe),
                    Wl(oe) && oe.startPublishing(),
                    this)
                }
                delete(Q) {
                    const oe = this.get(Q);
                    return Q = super.delete(Q),
                    Q && (Wl(oe) && oe.stopPublishing(),
                    Q)
                }
                clear() {
                    if (this.size)
                        for (const Q of this.keys())
                            this.delete(Q)
                }
                add(Q) {
                    return this.set(Q.getId(), Q)
                }
                getProcedures() {
                    return [...this.values()]
                }
            }
              , $c = class {
                constructor(Q) {
                    this.sourceBlock = Q,
                    this.offsetInBlock = new Zt(0,0),
                    this.workspaceLocation = new Zt(0,0),
                    this.svgRoot = null,
                    this.tooltip = Q
                }
                getType() {
                    throw Error("Icons must implement getType")
                }
                initView(Q) {
                    if (!this.svgRoot) {
                        var oe = this.sourceBlock;
                        this.svgRoot = $t(bt.G, {
                            class: "blocklyIconGroup"
                        }),
                        oe.getSvgRoot().appendChild(this.svgRoot),
                        this.updateSvgRootOffset(),
                        vt(this.svgRoot, "pointerdown", this, Q),
                        this.svgRoot.tooltip = this,
                        Ni(this.svgRoot)
                    }
                }
                dispose() {
                    Ul(this.svgRoot),
                    Bt(this.svgRoot)
                }
                getWeight() {
                    return -1
                }
                getSize() {
                    return new Yn(0,0)
                }
                setTooltip(Q) {
                    this.tooltip = Q ?? this.sourceBlock
                }
                getTooltip() {
                    return this.tooltip
                }
                applyColour() {}
                updateEditable() {}
                updateCollapsed() {
                    this.svgRoot && (this.sourceBlock.isCollapsed() ? this.svgRoot.style.display = "none" : this.svgRoot.style.display = "block",
                    uo(this) && this.setBubbleVisible(!1))
                }
                hideForInsertionMarker() {
                    this.svgRoot && (this.svgRoot.style.display = "none")
                }
                isShownWhenCollapsed() {
                    return !1
                }
                setOffsetInBlock(Q) {
                    this.offsetInBlock = Q,
                    this.updateSvgRootOffset()
                }
                updateSvgRootOffset() {
                    let Q;
                    (Q = this.svgRoot) == null || Q.setAttribute("transform", `translate(${this.offsetInBlock.x}, ${this.offsetInBlock.y})`)
                }
                onLocationChange(Q) {
                    this.workspaceLocation = Zt.sum(Q, this.offsetInBlock)
                }
                onClick() {}
                isClickableInFlyout(Q) {
                    return !0
                }
                setVisible(Q) {
                    zt("setVisible", "v10", "v11", "setBubbleVisible"),
                    uo(this) && this.setBubbleVisible(Q)
                }
            }
              , Ng = {
                fromJsonInternal: zm
            }
              , Oc = {
                TEST_ONLY: Ng
            };
            Oc.fromJson = J.fromJson$$module$build$src$core$field_registry,
            Oc.register = Ur,
            Oc.unregister = Xm;
            var Cs = class extends vn {
                constructor(Q, oe, pe) {
                    super(vn.SKIP_SETUP),
                    this.svgArrow = this.arrow = this.imageElement = this.menu_ = this.selectedMenuItem = null,
                    this.SERIALIZABLE = !0,
                    this.CURSOR = "default",
                    this.clickTarget_ = this.suffixField = this.prefixField = this.generatedOptions = null,
                    Q !== vn.SKIP_SETUP && (Array.isArray(Q) ? (ju(Q),
                    Q = Km(Q),
                    this.menuGenerator_ = Q.options,
                    this.prefixField = Q.prefix || null,
                    this.suffixField = Q.suffix || null) : this.menuGenerator_ = Q,
                    this.selectedOption = this.getOptions(!1)[0],
                    pe && this.configure_(pe),
                    this.setValue(this.selectedOption[1]),
                    oe && this.setValidator(oe))
                }
                fromXml(Q) {
                    this.isOptionListDynamic() && this.getOptions(!1),
                    this.setValue(Q.textContent)
                }
                loadState(Q) {
                    this.loadLegacyState(Cs, Q) || (this.isOptionListDynamic() && this.getOptions(!1),
                    this.setValue(Q))
                }
                initView() {
                    this.shouldAddBorderRect_() ? this.createBorderRect_() : this.clickTarget_ = this.sourceBlock_.getSvgRoot(),
                    this.createTextElement_(),
                    this.imageElement = $t(bt.IMAGE, {}, this.fieldGroup_),
                    this.getConstants().FIELD_DROPDOWN_SVG_ARROW ? this.createSVGArrow_() : this.createTextArrow_(),
                    this.borderRect_ && Ut(this.borderRect_, "blocklyDropdownRect")
                }
                shouldAddBorderRect_() {
                    let Q;
                    return !this.getConstants().FIELD_DROPDOWN_NO_BORDER_RECT_SHADOW || this.getConstants().FIELD_DROPDOWN_NO_BORDER_RECT_SHADOW && !((Q = this.getSourceBlock()) != null && Q.isShadow())
                }
                createTextArrow_() {
                    this.arrow = $t(bt.TSPAN, {}, this.textElement_);
                    let Q;
                    this.arrow.appendChild(document.createTextNode((Q = this.getSourceBlock()) != null && Q.RTL ? Cs.ARROW_CHAR + " " : " " + Cs.ARROW_CHAR));
                    let oe;
                    (oe = this.getSourceBlock()) != null && oe.RTL ? this.getTextElement().insertBefore(this.arrow, this.textContent_) : this.getTextElement().appendChild(this.arrow)
                }
                createSVGArrow_() {
                    this.svgArrow = $t(bt.IMAGE, {
                        height: this.getConstants().FIELD_DROPDOWN_SVG_ARROW_SIZE + "px",
                        width: this.getConstants().FIELD_DROPDOWN_SVG_ARROW_SIZE + "px"
                    }, this.fieldGroup_),
                    this.svgArrow.setAttributeNS(Fr, "xlink:href", this.getConstants().FIELD_DROPDOWN_SVG_ARROW_DATAURI)
                }
                showEditor_(Q) {
                    var oe = this.getSourceBlock();
                    if (!oe)
                        throw new Gn;
                    this.dropdownCreate(),
                    this.menu_.openingCoords = Q && typeof Q.clientX == "number" ? new Zt(Q.clientX,Q.clientY) : null,
                    kl(),
                    Q = this.menu_.render(Oi()),
                    Ut(Q, "blocklyDropdownMenu"),
                    this.getConstants().FIELD_DROPDOWN_COLOURED_DIV && (oe = oe.getColour(),
                    Dl(oe, this.sourceBlock_.style.colourTertiary)),
                    ka(this, this.dropdownDispose_.bind(this)),
                    this.menu_.focus(),
                    this.selectedMenuItem && (this.menu_.setHighlighted(this.selectedMenuItem),
                    pr(this.selectedMenuItem.getElement(), Oi(), !0)),
                    this.applyColour()
                }
                dropdownCreate() {
                    const Q = this.getSourceBlock();
                    if (!Q)
                        throw new Gn;
                    const oe = new ph;
                    oe.setRole(Mr.LISTBOX),
                    this.menu_ = oe;
                    const pe = this.getOptions(!1);
                    this.selectedMenuItem = null;
                    for (let Re = 0; Re < pe.length; Re++) {
                        const [Ue,tt] = pe[Re];
                        if (typeof Ue == "object") {
                            var Ae = new Image(Ue.width,Ue.height);
                            Ae.src = Ue.src,
                            Ae.alt = Ue.alt || ""
                        } else
                            Ae = Ue;
                        Ae = new mh(Ae,tt),
                        Ae.setRole(Mr.OPTION),
                        Ae.setRightToLeft(Q.RTL),
                        Ae.setCheckable(!0),
                        oe.addChild(Ae),
                        Ae.setChecked(tt === this.value_),
                        tt === this.value_ && (this.selectedMenuItem = Ae),
                        Ae.onAction(this.handleMenuActionEvent, this)
                    }
                }
                dropdownDispose_() {
                    this.menu_ && this.menu_.dispose(),
                    this.selectedMenuItem = this.menu_ = null,
                    this.applyColour()
                }
                handleMenuActionEvent(Q) {
                    Ci(this, !0),
                    this.onItemSelected_(this.menu_, Q)
                }
                onItemSelected_(Q, oe) {
                    this.setValue(oe.getValue())
                }
                isOptionListDynamic() {
                    return typeof this.menuGenerator_ == "function"
                }
                getOptions(Q) {
                    if (!this.menuGenerator_)
                        throw TypeError("A menu generator was never defined.");
                    return Array.isArray(this.menuGenerator_) ? this.menuGenerator_ : Q && this.generatedOptions ? this.generatedOptions : (this.generatedOptions = this.menuGenerator_(),
                    ju(this.generatedOptions),
                    this.generatedOptions)
                }
                doClassValidation_(Q) {
                    return this.getOptions(!0).some(oe => oe[1] === Q) ? Q : (this.sourceBlock_ && console.warn("Cannot set the dropdown's value to an unavailable option. Block type: " + this.sourceBlock_.type + ", Field name: " + this.name + ", Value: " + Q),
                    null)
                }
                doValueUpdate_(Q) {
                    super.doValueUpdate_(Q),
                    Q = this.getOptions(!0);
                    for (let oe = 0, pe; pe = Q[oe]; oe++)
                        pe[1] === this.value_ && (this.selectedOption = pe)
                }
                applyColour() {
                    const Q = this.sourceBlock_.style;
                    this.borderRect_ && (this.borderRect_.setAttribute("stroke", Q.colourTertiary),
                    this.menu_ ? this.borderRect_.setAttribute("fill", Q.colourTertiary) : this.borderRect_.setAttribute("fill", "transparent")),
                    this.sourceBlock_ && this.arrow && (this.sourceBlock_.isShadow() ? this.arrow.style.fill = Q.colourSecondary : this.arrow.style.fill = Q.colourPrimary)
                }
                render_() {
                    this.getTextContent().nodeValue = "",
                    this.imageElement.style.display = "none";
                    const Q = this.selectedOption && this.selectedOption[0];
                    Q && typeof Q == "object" ? this.renderSelectedImage(Q) : this.renderSelectedText(),
                    this.positionBorderRect_()
                }
                renderSelectedImage(Q) {
                    const oe = this.getSourceBlock();
                    if (!oe)
                        throw new Gn;
                    this.imageElement.style.display = "",
                    this.imageElement.setAttributeNS(Fr, "xlink:href", Q.src),
                    this.imageElement.setAttribute("height", String(Q.height)),
                    this.imageElement.setAttribute("width", String(Q.width));
                    const pe = Number(Q.height);
                    Q = Number(Q.width);
                    var Ae = !!this.borderRect_;
                    const Re = Math.max(Ae ? this.getConstants().FIELD_DROPDOWN_BORDER_RECT_HEIGHT : 0, pe + mT);
                    Ae = Ae ? this.getConstants().FIELD_BORDER_RECT_X_PADDING : 0;
                    let Ue;
                    Ue = this.svgArrow ? this.positionSVGArrow(Q + Ae, Re / 2 - this.getConstants().FIELD_DROPDOWN_SVG_ARROW_SIZE / 2) : Ft(this.arrow, this.getConstants().FIELD_TEXT_FONTSIZE, this.getConstants().FIELD_TEXT_FONTWEIGHT, this.getConstants().FIELD_TEXT_FONTFAMILY),
                    this.size_.width = Q + Ue + 2 * Ae,
                    this.size_.height = Re;
                    let tt = 0;
                    oe.RTL ? this.imageElement.setAttribute("x", `${Ae + Ue}`) : (tt = Q + Ue,
                    this.getTextElement().setAttribute("text-anchor", "end"),
                    this.imageElement.setAttribute("x", `${Ae}`)),
                    this.imageElement.setAttribute("y", String(Re / 2 - pe / 2)),
                    this.positionTextElement_(tt + Ae, Q + Ue)
                }
                renderSelectedText() {
                    this.getTextContent().nodeValue = this.getDisplayText_();
                    var Q = this.getTextElement();
                    Ut(Q, "blocklyDropdownText"),
                    Q.setAttribute("text-anchor", "start");
                    var oe = !!this.borderRect_;
                    Q = Math.max(oe ? this.getConstants().FIELD_DROPDOWN_BORDER_RECT_HEIGHT : 0, this.getConstants().FIELD_TEXT_HEIGHT);
                    const pe = Ft(this.getTextElement(), this.getConstants().FIELD_TEXT_FONTSIZE, this.getConstants().FIELD_TEXT_FONTWEIGHT, this.getConstants().FIELD_TEXT_FONTFAMILY);
                    oe = oe ? this.getConstants().FIELD_BORDER_RECT_X_PADDING : 0;
                    let Ae = 0;
                    this.svgArrow && (Ae = this.positionSVGArrow(pe + oe, Q / 2 - this.getConstants().FIELD_DROPDOWN_SVG_ARROW_SIZE / 2)),
                    this.size_.width = pe + Ae + 2 * oe,
                    this.size_.height = Q,
                    this.positionTextElement_(oe, pe)
                }
                positionSVGArrow(Q, oe) {
                    if (!this.svgArrow)
                        return 0;
                    const pe = this.getSourceBlock();
                    if (!pe)
                        throw new Gn;
                    const Ae = this.borderRect_ ? this.getConstants().FIELD_BORDER_RECT_X_PADDING : 0
                      , Re = this.getConstants().FIELD_DROPDOWN_SVG_ARROW_PADDING
                      , Ue = this.getConstants().FIELD_DROPDOWN_SVG_ARROW_SIZE;
                    return this.svgArrow.setAttribute("transform", "translate(" + (pe.RTL ? Ae : Q + Re) + "," + oe + ")"),
                    Ue + Re
                }
                getText_() {
                    if (!this.selectedOption)
                        return null;
                    const Q = this.selectedOption[0];
                    return typeof Q == "object" ? Q.alt : Q
                }
                static fromJson(Q) {
                    if (!Q.options)
                        throw Error("options are required for the dropdown field. The options property must be assigned an array of [humanReadableValue, languageNeutralValue] tuples.");
                    return new this(Q.options,void 0,Q)
                }
            }
            ;
            Cs.CHECKMARK_OVERHANG = 25,
            Cs.MAX_MENU_HEIGHT_VH = .45,
            Cs.ARROW_CHAR = "▾";
            var pT = 5
              , mT = 2 * pT;
            Ur("field_dropdown", Cs);
            var Vr, kn = class {
                constructor(Q, oe, pe) {
                    this.workspace = Q,
                    this.anchor = oe,
                    this.ownerRect = pe,
                    this.size = new Yn(0,0),
                    this.colour = "#ffffff",
                    this.disposed = !1,
                    this.relativeLeft = this.relativeTop = 0,
                    this.svgRoot = $t(bt.G, {}, Q.getBubbleCanvas()),
                    Q = $t(bt.G, {
                        filter: `url(#${this.workspace.getRenderer().getConstants().embossFilterId})`
                    }, this.svgRoot),
                    this.tail = $t(bt.PATH, {}, Q),
                    this.background = $t(bt.RECT, {
                        class: "blocklyDraggable",
                        x: 0,
                        y: 0,
                        rx: Vr.BORDER_WIDTH,
                        ry: Vr.BORDER_WIDTH
                    }, Q),
                    this.contentContainer = $t(bt.G, {}, this.svgRoot),
                    vt(this.background, "pointerdown", this, this.onMouseDown)
                }
                dispose() {
                    Bt(this.svgRoot),
                    this.disposed = !0
                }
                setAnchorLocation(Q, oe=!1) {
                    this.anchor = Q,
                    oe ? this.positionByRect(this.ownerRect) : this.positionRelativeToAnchor(),
                    this.renderTail()
                }
                setPositionRelativeToAnchor(Q, oe) {
                    this.relativeLeft = Q,
                    this.relativeTop = oe,
                    this.positionRelativeToAnchor(),
                    this.renderTail()
                }
                getSize() {
                    return this.size
                }
                setSize(Q, oe=!1) {
                    Q.width = Math.max(Q.width, Vr.MIN_SIZE),
                    Q.height = Math.max(Q.height, Vr.MIN_SIZE),
                    this.size = Q,
                    this.background.setAttribute("width", `${Q.width}`),
                    this.background.setAttribute("height", `${Q.height}`),
                    oe ? this.positionByRect(this.ownerRect) : this.positionRelativeToAnchor(),
                    this.renderTail()
                }
                getColour() {
                    return this.colour
                }
                setColour(Q) {
                    this.colour = Q,
                    this.tail.setAttribute("fill", Q),
                    this.background.setAttribute("fill", Q)
                }
                onMouseDown(Q) {
                    let oe;
                    (oe = this.workspace.getGesture(Q)) == null || oe.handleBubbleStart(Q, this)
                }
                positionRelativeToAnchor() {
                    let Q = this.anchor.x;
                    Q = this.workspace.RTL ? Q - (this.relativeLeft + this.size.width) : Q + this.relativeLeft,
                    this.moveTo(Q, this.relativeTop + this.anchor.y)
                }
                moveTo(Q, oe) {
                    this.svgRoot.setAttribute("transform", `translate(${Q}, ${oe})`)
                }
                positionByRect(Q=new Vn(0,0,0,0)) {
                    var oe = this.workspace.getMetricsManager().getViewMetrics(!0)
                      , pe = this.getOptimalRelativeLeft(oe)
                      , Ae = this.getOptimalRelativeTop(oe);
                    const Re = {
                        x: pe,
                        y: -this.size.height - this.workspace.getRenderer().getConstants().MIN_BLOCK_HEIGHT
                    }
                      , Ue = {
                        x: -this.size.width - 30,
                        y: Ae
                    };
                    Ae = {
                        x: Q.getWidth(),
                        y: Ae
                    };
                    var tt = {
                        x: pe,
                        y: Q.getHeight()
                    };
                    pe = Q.getWidth() < Q.getHeight() ? Ae : tt,
                    Q = Q.getWidth() < Q.getHeight() ? tt : Ae,
                    Ae = this.getOverlap(Re, oe),
                    tt = this.getOverlap(Ue, oe);
                    const dt = this.getOverlap(pe, oe);
                    oe = this.getOverlap(Q, oe),
                    oe = Math.max(Ae, tt, dt, oe),
                    Ae === oe ? (this.relativeLeft = Re.x,
                    this.relativeTop = Re.y) : tt === oe ? (this.relativeLeft = Ue.x,
                    this.relativeTop = Ue.y) : dt === oe ? (this.relativeLeft = pe.x,
                    this.relativeTop = pe.y) : (this.relativeLeft = Q.x,
                    this.relativeTop = Q.y),
                    this.positionRelativeToAnchor()
                }
                getOverlap(Q, oe) {
                    var pe = this.workspace.RTL ? this.anchor.x - Q.x - this.size.width : Q.x + this.anchor.x;
                    return Q = Q.y + this.anchor.y,
                    Math.max(0, Math.min(1, (Math.min(pe + this.size.width, oe.left + oe.width) - Math.max(pe, oe.left)) * (Math.min(Q + this.size.height, oe.top + oe.height) - Math.max(Q, oe.top)) / (this.size.width * this.size.height)))
                }
                getOptimalRelativeLeft(Q) {
                    let oe = -this.size.width / 4;
                    if (this.size.width > Q.width)
                        return oe;
                    if (Q = this.getWorkspaceViewRect(Q),
                    this.workspace.RTL) {
                        var pe = this.anchor.x - oe;
                        pe - this.size.width < Q.left ? oe = -(Q.left - this.anchor.x + this.size.width) : pe > Q.right && (oe = -(Q.right - this.anchor.x))
                    } else {
                        pe = oe + this.anchor.x;
                        const Ae = pe + this.size.width;
                        pe < Q.left ? oe = Q.left - this.anchor.x : Ae > Q.right && (oe = Q.right - this.anchor.x - this.size.width)
                    }
                    return oe
                }
                getOptimalRelativeTop(Q) {
                    let oe = -this.size.height / 4;
                    if (this.size.height > Q.height)
                        return oe;
                    const pe = this.anchor.y + oe
                      , Ae = pe + this.size.height;
                    return Q = this.getWorkspaceViewRect(Q),
                    pe < Q.top ? oe = Q.top - this.anchor.y : Ae > Q.bottom && (oe = Q.bottom - this.anchor.y - this.size.height),
                    oe
                }
                getWorkspaceViewRect(Q) {
                    const oe = Q.top;
                    let pe = Q.top + Q.height
                      , Ae = Q.left;
                    return Q = Q.left + Q.width,
                    pe -= this.getScrollbarThickness(),
                    this.workspace.RTL ? Ae -= this.getScrollbarThickness() : Q -= this.getScrollbarThickness(),
                    new Vn(oe,pe,Ae,Q)
                }
                getScrollbarThickness() {
                    return or.scrollbarThickness / this.workspace.scale
                }
                renderTail() {
                    const Q = [];
                    var oe = this.size.width / 2
                      , pe = this.size.height / 2
                      , Ae = -this.relativeLeft
                      , Re = -this.relativeTop;
                    if (oe === Ae && pe === Re)
                        Q.push("M " + oe + "," + pe);
                    else {
                        Re -= pe,
                        Ae -= oe,
                        this.workspace.RTL && (Ae *= -1);
                        var Ue = Math.sqrt(Re * Re + Ae * Ae)
                          , tt = Math.acos(Ae / Ue);
                        0 > Re && (tt = 2 * Math.PI - tt);
                        var dt = tt + Math.PI / 2;
                        dt > 2 * Math.PI && (dt -= 2 * Math.PI);
                        var wt = Math.sin(dt);
                        const zn = Math.cos(dt);
                        let jn = (this.size.width + this.size.height) / Vr.TAIL_THICKNESS;
                        jn = Math.min(jn, this.size.width, this.size.height) / 4,
                        dt = 1 - Vr.ANCHOR_RADIUS / Ue,
                        Ae = oe + dt * Ae,
                        Re = pe + dt * Re,
                        dt = oe + jn * zn;
                        const kr = pe + jn * wt;
                        oe -= jn * zn,
                        pe -= jn * wt,
                        wt = bi(this.workspace.RTL ? -Vr.TAIL_ANGLE : Vr.TAIL_ANGLE),
                        wt = tt + wt,
                        wt > 2 * Math.PI && (wt -= 2 * Math.PI),
                        tt = Math.sin(wt) * Ue / Vr.TAIL_BEND,
                        Ue = Math.cos(wt) * Ue / Vr.TAIL_BEND,
                        Q.push("M" + dt + "," + kr),
                        Q.push("C" + (dt + Ue) + "," + (kr + tt) + " " + Ae + "," + Re + " " + Ae + "," + Re),
                        Q.push("C" + Ae + "," + Re + " " + (oe + Ue) + "," + (pe + tt) + " " + oe + "," + pe)
                    }
                    Q.push("z");
                    let sn;
                    (sn = this.tail) == null || sn.setAttribute("d", Q.join(" "))
                }
                bringToFront() {
                    let Q;
                    const oe = (Q = this.svgRoot) == null ? void 0 : Q.parentNode;
                    return this.svgRoot && (oe == null ? void 0 : oe.lastChild) !== this.svgRoot ? (oe == null || oe.appendChild(this.svgRoot),
                    !0) : !1
                }
                getRelativeToSurfaceXY() {
                    return new Zt(this.workspace.RTL ? -this.relativeLeft + this.anchor.x - this.size.width : this.anchor.x + this.relativeLeft,this.anchor.y + this.relativeTop)
                }
                getSvgRoot() {
                    return this.svgRoot
                }
                moveDuringDrag(Q) {
                    this.moveTo(Q.x, Q.y),
                    this.relativeLeft = this.workspace.RTL ? this.anchor.x - Q.x - this.size.width : Q.x - this.anchor.x,
                    this.relativeTop = Q.y - this.anchor.y,
                    this.renderTail()
                }
                setDragging(Q) {}
                setDeleteStyle(Q) {}
                isDeletable() {
                    return !1
                }
                showContextMenu(Q) {}
            }
            ;
            Vr = kn,
            kn.BORDER_WIDTH = 6,
            kn.DOUBLE_BORDER = 2 * Vr.BORDER_WIDTH,
            kn.MIN_SIZE = Vr.DOUBLE_BORDER,
            kn.TAIL_THICKNESS = 1,
            kn.TAIL_ANGLE = 20,
            kn.TAIL_BEND = 4,
            kn.ANCHOR_RADIUS = 8;
            var Zs = class extends kn {
                constructor(Q, oe, pe, Ae) {
                    super(oe, pe, Ae),
                    this.workspace = oe,
                    this.anchor = pe,
                    this.ownerRect = Ae,
                    this.autoLayout = !0,
                    oe = new Qr(Q),
                    this.validateWorkspaceOptions(oe),
                    this.svgDialog = $t(bt.SVG, {
                        x: kn.BORDER_WIDTH,
                        y: kn.BORDER_WIDTH
                    }, this.contentContainer),
                    Q.parentWorkspace = this.workspace,
                    this.miniWorkspace = this.newWorkspaceSvg(new Qr(Q)),
                    this.miniWorkspace.internalIsMutator = !0,
                    Q = this.miniWorkspace.createDom("blocklyMutatorBackground"),
                    this.svgDialog.appendChild(Q),
                    oe.languageTree && (Q.insertBefore(this.miniWorkspace.addFlyout(bt.G), this.miniWorkspace.getCanvas()),
                    Q = this.miniWorkspace.getFlyout(),
                    Q == null || Q.init(this.miniWorkspace),
                    Q == null || Q.show(oe.languageTree)),
                    this.miniWorkspace.addChangeListener(this.onWorkspaceChange.bind(this));
                    let Re, Ue;
                    (Re = this.miniWorkspace.getFlyout()) == null || (Ue = Re.getWorkspace()) == null || Ue.addChangeListener(this.onWorkspaceChange.bind(this)),
                    this.updateBubbleSize()
                }
                dispose() {
                    this.miniWorkspace.dispose(),
                    super.dispose()
                }
                getWorkspace() {
                    return this.miniWorkspace
                }
                addWorkspaceChangeListener(Q) {
                    this.miniWorkspace.addChangeListener(Q)
                }
                validateWorkspaceOptions(Q) {
                    if (Q.hasCategories)
                        throw Error("The miniworkspace bubble does not support toolboxes with categories");
                    if (Q.hasTrashcan)
                        throw Error("The miniworkspace bubble does not support trashcans");
                    if (Q.zoomOptions.controls || Q.zoomOptions.wheel || Q.zoomOptions.pinch)
                        throw Error("The miniworkspace bubble does not support zooming");
                    if (Q.moveOptions.scrollbars || Q.moveOptions.wheel || Q.moveOptions.drag)
                        throw Error("The miniworkspace bubble does not scrolling/moving the workspace");
                    if (Q.horizontalLayout)
                        throw Error("The miniworkspace bubble does not support horizontal layouts")
                }
                onWorkspaceChange() {
                    this.bumpBlocksIntoBounds(),
                    this.updateBubbleSize()
                }
                bumpBlocksIntoBounds() {
                    if (!this.miniWorkspace.isDragging())
                        for (const Q of this.miniWorkspace.getTopBlocks(!1)) {
                            const oe = Q.getRelativeToSurfaceXY();
                            if (20 > oe.y && Q.moveBy(0, 20 - oe.y),
                            Q.RTL) {
                                let pe = -20;
                                const Ae = this.miniWorkspace.getFlyout();
                                Ae && (pe -= Ae.getWidth()),
                                oe.x > pe && Q.moveBy(pe - oe.x, 0)
                            } else
                                20 > oe.x && Q.moveBy(20 - oe.x, 0)
                        }
                }
                updateBubbleSize() {
                    if (!this.miniWorkspace.isDragging()) {
                        var Q = this.getSize()
                          , oe = this.calculateWorkspaceSize();
                        Math.abs(Q.width - oe.width) < Zs.MINIMUM_VIEW_CHANGE && Math.abs(Q.height - oe.height) < Zs.MINIMUM_VIEW_CHANGE || (this.svgDialog.setAttribute("width", `${oe.width}px`),
                        this.svgDialog.setAttribute("height", `${oe.height}px`),
                        this.miniWorkspace.setCachedParentSvgSize(oe.width, oe.height),
                        this.miniWorkspace.RTL && this.miniWorkspace.getCanvas().setAttribute("transform", `translate(${oe.width}, 0)`),
                        this.setSize(new Yn(oe.width + kn.DOUBLE_BORDER,oe.height + kn.DOUBLE_BORDER), this.autoLayout),
                        this.miniWorkspace.resize(),
                        this.miniWorkspace.recordDragTargets())
                    }
                }
                calculateWorkspaceSize() {
                    var Q = this.miniWorkspace.getCanvas().getBBox();
                    let oe = Q.width + Zs.MARGIN;
                    Q = Q.height + Zs.MARGIN;
                    const pe = this.miniWorkspace.getFlyout();
                    if (pe) {
                        const Ae = pe.getWorkspace().getMetricsManager().getScrollMetrics();
                        Q = Math.max(Q, Ae.height + 20),
                        oe += pe.getWidth()
                    }
                    return new Yn(oe,Q)
                }
                updateBlockStyles() {
                    for (var Q of this.miniWorkspace.getAllBlocks(!1))
                        Q.setStyle(Q.getStyleName());
                    let oe;
                    if (Q = (oe = this.miniWorkspace.getFlyout()) == null ? void 0 : oe.getWorkspace())
                        for (const pe of Q.getAllBlocks(!1))
                            pe.setStyle(pe.getStyleName())
                }
                moveDuringDrag(Q) {
                    super.moveDuringDrag(Q),
                    this.autoLayout = !1
                }
                moveTo(Q, oe) {
                    super.moveTo(Q, oe),
                    this.miniWorkspace.recordDragTargets()
                }
                newWorkspaceSvg(Q) {
                    throw Error("The implementation of newWorkspaceSvg should be monkey-patched in by blockly.ts")
                }
            }
            ;
            Zs.MINIMUM_VIEW_CHANGE = 10,
            Zs.MARGIN = 3 * kn.DOUBLE_BORDER;
            var Cc, vc;
            Cc = 17,
            vc = 16,
            J.MutatorIcon$$module$build$src$core$icons$mutator_icon = class extends $c {
                constructor(Q, oe) {
                    super(oe),
                    this.flyoutBlockTypes = Q,
                    this.sourceBlock = oe,
                    this.saveConnectionsListener = this.updateWorkspacePid = this.rootBlock = this.miniWorkspaceBubble = null
                }
                getType() {
                    return J.MutatorIcon$$module$build$src$core$icons$mutator_icon.TYPE
                }
                initView(Q) {
                    this.svgRoot || (super.initView(Q),
                    $t(bt.RECT, {
                        class: "blocklyIconShape",
                        rx: "4",
                        ry: "4",
                        height: "16",
                        width: "16"
                    }, this.svgRoot),
                    $t(bt.PATH, {
                        class: "blocklyIconSymbol",
                        d: "m4.203,7.296 0,1.368 -0.92,0.677 -0.11,0.41 0.9,1.559 0.41,0.11 1.043,-0.457 1.187,0.683 0.127,1.134 0.3,0.3 1.8,0 0.3,-0.299 0.127,-1.138 1.185,-0.682 1.046,0.458 0.409,-0.11 0.9,-1.559 -0.11,-0.41 -0.92,-0.677 0,-1.366 0.92,-0.677 0.11,-0.41 -0.9,-1.559 -0.409,-0.109 -1.046,0.458 -1.185,-0.682 -0.127,-1.138 -0.3,-0.299 -1.8,0 -0.3,0.3 -0.126,1.135 -1.187,0.682 -1.043,-0.457 -0.41,0.11 -0.899,1.559 0.108,0.409z"
                    }, this.svgRoot),
                    $t(bt.CIRCLE, {
                        class: "blocklyIconShape",
                        r: "2.7",
                        cx: "8",
                        cy: "8"
                    }, this.svgRoot),
                    Ut(this.svgRoot, "blockly-icon-mutator"))
                }
                dispose() {
                    super.dispose();
                    let Q;
                    (Q = this.miniWorkspaceBubble) == null || Q.dispose()
                }
                getWeight() {
                    return J.MutatorIcon$$module$build$src$core$icons$mutator_icon.WEIGHT
                }
                getSize() {
                    return new Yn(Cc,Cc)
                }
                applyColour() {
                    super.applyColour();
                    let Q;
                    (Q = this.miniWorkspaceBubble) == null || Q.setColour(this.sourceBlock.style.colourPrimary);
                    let oe;
                    (oe = this.miniWorkspaceBubble) == null || oe.updateBlockStyles()
                }
                updateCollapsed() {
                    super.updateCollapsed(),
                    this.sourceBlock.isCollapsed() && this.setBubbleVisible(!1)
                }
                onLocationChange(Q) {
                    super.onLocationChange(Q);
                    let oe;
                    (oe = this.miniWorkspaceBubble) == null || oe.setAnchorLocation(this.getAnchorLocation())
                }
                onClick() {
                    super.onClick(),
                    this.sourceBlock.isEditable() && this.setBubbleVisible(!this.bubbleIsVisible())
                }
                isClickableInFlyout() {
                    return !1
                }
                bubbleIsVisible() {
                    return !!this.miniWorkspaceBubble
                }
                setBubbleVisible(Q) {
                    if (this.bubbleIsVisible() !== Q) {
                        if (Q) {
                            this.miniWorkspaceBubble = new Zs(this.getMiniWorkspaceConfig(),this.sourceBlock.workspace,this.getAnchorLocation(),this.getBubbleOwnerRect()),
                            this.applyColour(),
                            this.createRootBlock(),
                            this.addSaveConnectionsListener();
                            let oe;
                            (oe = this.miniWorkspaceBubble) == null || oe.addWorkspaceChangeListener(this.createMiniWorkspaceChangeListener())
                        } else {
                            let oe;
                            (oe = this.miniWorkspaceBubble) == null || oe.dispose(),
                            this.miniWorkspaceBubble = null,
                            this.saveConnectionsListener && this.sourceBlock.workspace.removeChangeListener(this.saveConnectionsListener),
                            this.saveConnectionsListener = null
                        }
                        Ye(new (gt(_s))(this.sourceBlock,Q,"mutator"))
                    }
                }
                getMiniWorkspaceConfig() {
                    let Q;
                    const oe = {
                        disable: !1,
                        media: this.sourceBlock.workspace.options.pathToMedia,
                        rtl: this.sourceBlock.RTL,
                        renderer: this.sourceBlock.workspace.options.renderer,
                        rendererOverrides: (Q = this.sourceBlock.workspace.options.rendererOverrides) != null ? Q : void 0
                    };
                    return this.flyoutBlockTypes.length && (oe.toolbox = {
                        kind: "flyoutToolbox",
                        contents: this.flyoutBlockTypes.map(pe => ({
                            kind: "block",
                            type: pe
                        }))
                    }),
                    oe
                }
                getAnchorLocation() {
                    const Q = Cc / 2;
                    return Zt.sum(this.workspaceLocation, new Zt(Q,Q))
                }
                getBubbleOwnerRect() {
                    const Q = this.sourceBlock.getSvgRoot().getBBox();
                    return new Vn(Q.y,Q.y + Q.height,Q.x,Q.x + Q.width)
                }
                createRootBlock() {
                    if (!this.sourceBlock.decompose)
                        throw Error("Blocks with mutator icons must include a decompose method");
                    this.rootBlock = this.sourceBlock.decompose(this.miniWorkspaceBubble.getWorkspace());
                    for (var Q of this.rootBlock.getDescendants(!1))
                        Q.queueRender();
                    this.rootBlock.setMovable(!1),
                    this.rootBlock.setDeletable(!1);
                    let oe, pe, Ae, Re;
                    Q = (Re = (oe = this.miniWorkspaceBubble) == null || (pe = oe.getWorkspace()) == null || (Ae = pe.getFlyout()) == null ? void 0 : Ae.getWidth()) != null ? Re : 0,
                    this.rootBlock.moveBy(this.rootBlock.RTL ? -(Q + vc) : vc, vc)
                }
                addSaveConnectionsListener() {
                    this.sourceBlock.saveConnections && this.rootBlock && (this.saveConnectionsListener = () => {
                        this.sourceBlock.saveConnections && this.rootBlock && this.sourceBlock.saveConnections(this.rootBlock)
                    }
                    ,
                    this.saveConnectionsListener(),
                    this.sourceBlock.workspace.addChangeListener(this.saveConnectionsListener))
                }
                createMiniWorkspaceChangeListener() {
                    return Q => {
                        J.MutatorIcon$$module$build$src$core$icons$mutator_icon.isIgnorableMutatorEvent(Q) || this.updateWorkspacePid || (this.updateWorkspacePid = setTimeout( () => {
                            this.updateWorkspacePid = null,
                            this.recomposeSourceBlock()
                        }
                        , 0))
                    }
                }
                static isIgnorableMutatorEvent(Q) {
                    return Q.isUiEvent || Q.type === J.CREATE$$module$build$src$core$events$utils || Q.type === J.CHANGE$$module$build$src$core$events$utils && Q.element === "disabled"
                }
                recomposeSourceBlock() {
                    if (this.rootBlock) {
                        if (!this.sourceBlock.compose)
                            throw Error("Blocks with mutator icons must include a compose method");
                        var Q = J.getGroup$$module$build$src$core$events$utils();
                        Q || J.setGroup$$module$build$src$core$events$utils(!0);
                        var oe = ai.getExtraBlockState_(this.sourceBlock);
                        this.sourceBlock.compose(this.rootBlock);
                        var pe = ai.getExtraBlockState_(this.sourceBlock);
                        oe !== pe && Ye(new (gt(J.CHANGE$$module$build$src$core$events$utils))(this.sourceBlock,"mutation",null,oe,pe)),
                        J.setGroup$$module$build$src$core$events$utils(Q)
                    }
                }
                getWorkspace() {
                    let Q;
                    return (Q = this.miniWorkspaceBubble) == null ? void 0 : Q.getWorkspace()
                }
                static reconnect(Q, oe, pe) {
                    return zt("MutatorIcon.reconnect", "v10", "v11", "connection.reconnect"),
                    Q ? Q.reconnect(oe, pe) : !1
                }
                static findParentWs(Q) {
                    return zt("MutatorIcon.findParentWs", "v10", "v11", "workspace.getRootWorkspace"),
                    Q.getRootWorkspace()
                }
            }
            ,
            J.MutatorIcon$$module$build$src$core$icons$mutator_icon.TYPE = Lr.MUTATOR,
            J.MutatorIcon$$module$build$src$core$icons$mutator_icon.WEIGHT = 1,
            J.MutatorIcon$$module$build$src$core$icons$mutator_icon;
            var sa = Object.create(null)
              , fT = {
                allExtensions: sa
            };
            J.register$$module$build$src$core$extensions("parent_tooltip_when_inline", sf);
            var as = {
                TEST_ONLY: fT
            };
            as.apply = Yl,
            as.buildTooltipForDropdown = J.buildTooltipForDropdown$$module$build$src$core$extensions,
            as.buildTooltipWithFieldText = J.buildTooltipWithFieldText$$module$build$src$core$extensions,
            as.isRegistered = Wu,
            as.register = J.register$$module$build$src$core$extensions,
            as.registerMixin = J.registerMixin$$module$build$src$core$extensions,
            as.registerMutator = J.registerMutator$$module$build$src$core$extensions,
            as.runAfterPageLoad = nf,
            as.unregister = qm;
            var bn;
            (function(Q) {
                Q[Q.WIN_KEY_FF_LINUX = 0] = "WIN_KEY_FF_LINUX",
                Q[Q.MAC_ENTER = 3] = "MAC_ENTER",
                Q[Q.BACKSPACE = 8] = "BACKSPACE",
                Q[Q.TAB = 9] = "TAB",
                Q[Q.NUM_CENTER = 12] = "NUM_CENTER",
                Q[Q.ENTER = 13] = "ENTER",
                Q[Q.SHIFT = 16] = "SHIFT",
                Q[Q.CTRL = 17] = "CTRL",
                Q[Q.ALT = 18] = "ALT",
                Q[Q.PAUSE = 19] = "PAUSE",
                Q[Q.CAPS_LOCK = 20] = "CAPS_LOCK",
                Q[Q.ESC = 27] = "ESC",
                Q[Q.SPACE = 32] = "SPACE",
                Q[Q.PAGE_UP = 33] = "PAGE_UP",
                Q[Q.PAGE_DOWN = 34] = "PAGE_DOWN",
                Q[Q.END = 35] = "END",
                Q[Q.HOME = 36] = "HOME",
                Q[Q.LEFT = 37] = "LEFT",
                Q[Q.UP = 38] = "UP",
                Q[Q.RIGHT = 39] = "RIGHT",
                Q[Q.DOWN = 40] = "DOWN",
                Q[Q.PLUS_SIGN = 43] = "PLUS_SIGN",
                Q[Q.PRINT_SCREEN = 44] = "PRINT_SCREEN",
                Q[Q.INSERT = 45] = "INSERT",
                Q[Q.DELETE = 46] = "DELETE",
                Q[Q.ZERO = 48] = "ZERO",
                Q[Q.ONE = 49] = "ONE",
                Q[Q.TWO = 50] = "TWO",
                Q[Q.THREE = 51] = "THREE",
                Q[Q.FOUR = 52] = "FOUR",
                Q[Q.FIVE = 53] = "FIVE",
                Q[Q.SIX = 54] = "SIX",
                Q[Q.SEVEN = 55] = "SEVEN",
                Q[Q.EIGHT = 56] = "EIGHT",
                Q[Q.NINE = 57] = "NINE",
                Q[Q.FF_SEMICOLON = 59] = "FF_SEMICOLON",
                Q[Q.FF_EQUALS = 61] = "FF_EQUALS",
                Q[Q.FF_DASH = 173] = "FF_DASH",
                Q[Q.FF_HASH = 163] = "FF_HASH",
                Q[Q.QUESTION_MARK = 63] = "QUESTION_MARK",
                Q[Q.AT_SIGN = 64] = "AT_SIGN",
                Q[Q.A = 65] = "A",
                Q[Q.B = 66] = "B",
                Q[Q.C = 67] = "C",
                Q[Q.D = 68] = "D",
                Q[Q.E = 69] = "E",
                Q[Q.F = 70] = "F",
                Q[Q.G = 71] = "G",
                Q[Q.H = 72] = "H",
                Q[Q.I = 73] = "I",
                Q[Q.J = 74] = "J",
                Q[Q.K = 75] = "K",
                Q[Q.L = 76] = "L",
                Q[Q.M = 77] = "M",
                Q[Q.N = 78] = "N",
                Q[Q.O = 79] = "O",
                Q[Q.P = 80] = "P",
                Q[Q.Q = 81] = "Q",
                Q[Q.R = 82] = "R",
                Q[Q.S = 83] = "S",
                Q[Q.T = 84] = "T",
                Q[Q.U = 85] = "U",
                Q[Q.V = 86] = "V",
                Q[Q.W = 87] = "W",
                Q[Q.X = 88] = "X",
                Q[Q.Y = 89] = "Y",
                Q[Q.Z = 90] = "Z",
                Q[Q.META = 91] = "META",
                Q[Q.WIN_KEY_RIGHT = 92] = "WIN_KEY_RIGHT",
                Q[Q.CONTEXT_MENU = 93] = "CONTEXT_MENU",
                Q[Q.NUM_ZERO = 96] = "NUM_ZERO",
                Q[Q.NUM_ONE = 97] = "NUM_ONE",
                Q[Q.NUM_TWO = 98] = "NUM_TWO",
                Q[Q.NUM_THREE = 99] = "NUM_THREE",
                Q[Q.NUM_FOUR = 100] = "NUM_FOUR",
                Q[Q.NUM_FIVE = 101] = "NUM_FIVE",
                Q[Q.NUM_SIX = 102] = "NUM_SIX",
                Q[Q.NUM_SEVEN = 103] = "NUM_SEVEN",
                Q[Q.NUM_EIGHT = 104] = "NUM_EIGHT",
                Q[Q.NUM_NINE = 105] = "NUM_NINE",
                Q[Q.NUM_MULTIPLY = 106] = "NUM_MULTIPLY",
                Q[Q.NUM_PLUS = 107] = "NUM_PLUS",
                Q[Q.NUM_MINUS = 109] = "NUM_MINUS",
                Q[Q.NUM_PERIOD = 110] = "NUM_PERIOD",
                Q[Q.NUM_DIVISION = 111] = "NUM_DIVISION",
                Q[Q.F1 = 112] = "F1",
                Q[Q.F2 = 113] = "F2",
                Q[Q.F3 = 114] = "F3",
                Q[Q.F4 = 115] = "F4",
                Q[Q.F5 = 116] = "F5",
                Q[Q.F6 = 117] = "F6",
                Q[Q.F7 = 118] = "F7",
                Q[Q.F8 = 119] = "F8",
                Q[Q.F9 = 120] = "F9",
                Q[Q.F10 = 121] = "F10",
                Q[Q.F11 = 122] = "F11",
                Q[Q.F12 = 123] = "F12",
                Q[Q.NUMLOCK = 144] = "NUMLOCK",
                Q[Q.SCROLL_LOCK = 145] = "SCROLL_LOCK",
                Q[Q.FIRST_MEDIA_KEY = 166] = "FIRST_MEDIA_KEY",
                Q[Q.LAST_MEDIA_KEY = 183] = "LAST_MEDIA_KEY",
                Q[Q.SEMICOLON = 186] = "SEMICOLON",
                Q[Q.DASH = 189] = "DASH",
                Q[Q.EQUALS = 187] = "EQUALS",
                Q[Q.COMMA = 188] = "COMMA",
                Q[Q.PERIOD = 190] = "PERIOD",
                Q[Q.SLASH = 191] = "SLASH",
                Q[Q.APOSTROPHE = 192] = "APOSTROPHE",
                Q[Q.TILDE = 192] = "TILDE",
                Q[Q.SINGLE_QUOTE = 222] = "SINGLE_QUOTE",
                Q[Q.OPEN_SQUARE_BRACKET = 219] = "OPEN_SQUARE_BRACKET",
                Q[Q.BACKSLASH = 220] = "BACKSLASH",
                Q[Q.CLOSE_SQUARE_BRACKET = 221] = "CLOSE_SQUARE_BRACKET",
                Q[Q.WIN_KEY = 224] = "WIN_KEY",
                Q[Q.MAC_FF_META = 224] = "MAC_FF_META",
                Q[Q.MAC_WK_CMD_LEFT = 91] = "MAC_WK_CMD_LEFT",
                Q[Q.MAC_WK_CMD_RIGHT = 93] = "MAC_WK_CMD_RIGHT",
                Q[Q.WIN_IME = 229] = "WIN_IME",
                Q[Q.VK_NONAME = 252] = "VK_NONAME",
                Q[Q.PHANTOM = 255] = "PHANTOM"
            }
            )(bn || (bn = {}));
            var eo = {};
            eo.arc = sr,
            eo.curve = xr,
            eo.line = Pi,
            eo.lineOnAxis = ln,
            eo.lineTo = As,
            eo.moveBy = qn,
            eo.moveTo = mr,
            eo.point = gn;
            var Zn = {};
            Zn.Coordinate = Zt,
            Zn.KeyCodes = bn,
            Zn.Rect = Vn,
            Zn.Size = Yn,
            Zn.Svg = bt,
            Zn.aria = qa,
            Zn.array = Xf,
            Zn.browserEvents = zs,
            Zn.colour = Zr,
            Zn.deprecation = zf,
            Zn.dom = hr,
            Zn.extensions = as,
            Zn.idGenerator = Dd,
            Zn.math = _c,
            Zn.object = Cg,
            Zn.parsing = sl,
            Zn.string = si,
            Zn.style = Ao,
            Zn.svgMath = Ko,
            Zn.svgPaths = eo,
            Zn.toolbox = _o,
            Zn.userAgent = tT,
            Zn.xml = Yi;
            var Lh = {};
            Lh.register = zu,
            Lh.unregister = of;
            var Ph = class extends kn {
                constructor(Q, oe, pe, Ae) {
                    super(oe, pe, Ae),
                    this.text = Q,
                    this.workspace = oe,
                    this.anchor = pe,
                    this.ownerRect = Ae,
                    this.paragraph = this.stringToSvg(Q, this.contentContainer),
                    this.updateBubbleSize()
                }
                getText() {
                    return this.text
                }
                setText(Q) {
                    this.text = Q,
                    Bt(this.paragraph),
                    this.paragraph = this.stringToSvg(Q, this.contentContainer),
                    this.updateBubbleSize()
                }
                stringToSvg(Q, oe) {
                    return oe = this.createParagraph(oe),
                    Q = this.createSpans(oe, Q),
                    this.workspace.RTL && this.rightAlignSpans(oe.getBBox().width, Q),
                    oe
                }
                createParagraph(Q) {
                    return $t(bt.TEXT, {
                        class: "blocklyText blocklyBubbleText blocklyNoPointerEvents",
                        y: kn.BORDER_WIDTH
                    }, Q)
                }
                createSpans(Q, oe) {
                    return oe.split(`
`).map(pe => {
                        const Ae = $t(bt.TSPAN, {
                            dy: "1em",
                            x: kn.BORDER_WIDTH
                        }, Q);
                        return pe = document.createTextNode(pe),
                        Ae.appendChild(pe),
                        Ae
                    }
                    )
                }
                rightAlignSpans(Q, oe) {
                    for (const pe of oe)
                        pe.setAttribute("text-anchor", "end"),
                        pe.setAttribute("x", `${Q + kn.BORDER_WIDTH}`)
                }
                updateBubbleSize() {
                    const Q = this.paragraph.getBBox();
                    this.setSize(new Yn(Q.width + 2 * kn.BORDER_WIDTH,Q.height + 2 * kn.BORDER_WIDTH), !0)
                }
            }
              , Lg = class extends kn {
                constructor(Q, oe, pe) {
                    super(Q, oe, pe),
                    this.workspace = Q,
                    this.anchor = oe,
                    this.ownerRect = pe,
                    this.resizePointerMoveListener = this.resizePointerUpListener = null,
                    this.textChangeListeners = [],
                    this.sizeChangeListeners = [],
                    this.text = "",
                    this.DEFAULT_SIZE = new Yn(160 + kn.DOUBLE_BORDER,80 + kn.DOUBLE_BORDER),
                    this.MIN_SIZE = new Yn(45 + kn.DOUBLE_BORDER,20 + kn.DOUBLE_BORDER),
                    {inputRoot: this.inputRoot, textArea: this.textArea} = this.createEditor(this.contentContainer),
                    this.resizeGroup = this.createResizeHandle(this.svgRoot),
                    this.setSize(this.DEFAULT_SIZE, !0)
                }
                getText() {
                    return this.text
                }
                setText(Q) {
                    this.text = Q,
                    this.textArea.value = Q,
                    this.onTextChange()
                }
                addTextChangeListener(Q) {
                    this.textChangeListeners.push(Q)
                }
                addSizeChangeListener(Q) {
                    this.sizeChangeListeners.push(Q)
                }
                createEditor(Q) {
                    Q = $t(bt.FOREIGNOBJECT, {
                        x: kn.BORDER_WIDTH,
                        y: kn.BORDER_WIDTH
                    }, Q);
                    const oe = document.createElementNS(Rs, "body");
                    oe.setAttribute("xmlns", Rs),
                    oe.className = "blocklyMinimalBody";
                    const pe = document.createElementNS(Rs, "textarea");
                    return pe.className = "blocklyCommentTextarea",
                    pe.setAttribute("dir", this.workspace.RTL ? "RTL" : "LTR"),
                    oe.appendChild(pe),
                    Q.appendChild(oe),
                    this.bindTextAreaEvents(pe),
                    setTimeout( () => {
                        pe.focus()
                    }
                    , 0),
                    {
                        inputRoot: Q,
                        textArea: pe
                    }
                }
                bindTextAreaEvents(Q) {
                    vt(Q, "wheel", this, oe => {
                        oe.stopPropagation()
                    }
                    ),
                    vt(Q, "focus", this, this.onStartEdit, !0),
                    vt(Q, "change", this, this.onTextChange)
                }
                createResizeHandle(Q) {
                    Q = $t(bt.G, {
                        class: this.workspace.RTL ? "blocklyResizeSW" : "blocklyResizeSE"
                    }, Q);
                    const oe = 2 * kn.BORDER_WIDTH;
                    return $t(bt.POLYGON, {
                        points: `0,${oe} ${oe},${oe} ${oe},0`
                    }, Q),
                    $t(bt.LINE, {
                        class: "blocklyResizeLine",
                        x1: oe / 3,
                        y1: oe - 1,
                        x2: oe - 1,
                        y2: oe / 3
                    }, Q),
                    $t(bt.LINE, {
                        class: "blocklyResizeLine",
                        x1: 2 * oe / 3,
                        y1: oe - 1,
                        x2: oe - 1,
                        y2: 2 * oe / 3
                    }, Q),
                    vt(Q, "pointerdown", this, this.onResizePointerDown),
                    Q
                }
                setSize(Q, oe=!1) {
                    Q.width = Math.max(Q.width, this.MIN_SIZE.width),
                    Q.height = Math.max(Q.height, this.MIN_SIZE.height);
                    const pe = Q.width - kn.DOUBLE_BORDER
                      , Ae = Q.height - kn.DOUBLE_BORDER;
                    this.inputRoot.setAttribute("width", `${pe}`),
                    this.inputRoot.setAttribute("height", `${Ae}`),
                    this.textArea.style.width = `${pe - 4}px`,
                    this.textArea.style.height = `${Ae - 4}px`,
                    this.workspace.RTL ? this.resizeGroup.setAttribute("transform", `translate(${kn.DOUBLE_BORDER}, ${Ae}) scale(-1 1)`) : this.resizeGroup.setAttribute("transform", `translate(${pe}, ${Ae})`),
                    super.setSize(Q, oe),
                    this.onSizeChange()
                }
                getSize() {
                    return super.getSize()
                }
                onResizePointerDown(Q) {
                    this.bringToFront(),
                    nn(Q) || (this.workspace.startDrag(Q, new Zt(this.workspace.RTL ? -this.getSize().width : this.getSize().width,this.getSize().height)),
                    this.resizePointerUpListener = vt(document, "pointerup", this, this.onResizePointerUp),
                    this.resizePointerMoveListener = vt(document, "pointermove", this, this.onResizePointerMove),
                    this.workspace.hideChaff()),
                    Q.stopPropagation()
                }
                onResizePointerUp(Q) {
                    Kt(),
                    this.resizePointerUpListener && (Ct(this.resizePointerUpListener),
                    this.resizePointerUpListener = null),
                    this.resizePointerMoveListener && (Ct(this.resizePointerMoveListener),
                    this.resizePointerMoveListener = null)
                }
                onResizePointerMove(Q) {
                    Q = this.workspace.moveDrag(Q),
                    this.setSize(new Yn(this.workspace.RTL ? -Q.x : Q.x,Q.y), !1),
                    this.onSizeChange()
                }
                onStartEdit() {
                    this.bringToFront() && this.textArea.focus()
                }
                onTextChange() {
                    this.text = this.textArea.value;
                    for (const Q of this.textChangeListeners)
                        Q()
                }
                onSizeChange() {
                    for (const Q of this.sizeChangeListeners)
                        Q()
                }
            }
            ;
            Qt(`
.blocklyCommentTextarea {
  background-color: #fef49c;
  border: 0;
  display: block;
  margin: 0;
  outline: 0;
  padding: 3px;
  resize: none;
  text-overflow: hidden;
}
`);
            var Mh = 17
              , Pg = 160
              , Mg = 80
              , Rr = class extends $c {
                constructor(Q) {
                    super(Q),
                    this.sourceBlock = Q,
                    this.textBubble = this.textInputBubble = null,
                    this.text = "",
                    this.bubbleSize = new Yn(Pg,Mg),
                    this.bubbleVisiblity = !1
                }
                getType() {
                    return Rr.TYPE
                }
                initView(Q) {
                    this.svgRoot || (super.initView(Q),
                    $t(bt.CIRCLE, {
                        class: "blocklyIconShape",
                        r: "8",
                        cx: "8",
                        cy: "8"
                    }, this.svgRoot),
                    $t(bt.PATH, {
                        class: "blocklyIconSymbol",
                        d: "m6.8,10h2c0.003,-0.617 0.271,-0.962 0.633,-1.266 2.875,-2.4050.607,-5.534 -3.765,-3.874v1.7c3.12,-1.657 3.698,0.118 2.336,1.25-1.201,0.998 -1.201,1.528 -1.204,2.19z"
                    }, this.svgRoot),
                    $t(bt.RECT, {
                        class: "blocklyIconSymbol",
                        x: "6.8",
                        y: "10.78",
                        height: "2",
                        width: "2"
                    }, this.svgRoot),
                    Ut(this.svgRoot, "blockly-icon-comment"))
                }
                dispose() {
                    super.dispose();
                    let Q;
                    (Q = this.textInputBubble) == null || Q.dispose();
                    let oe;
                    (oe = this.textBubble) == null || oe.dispose()
                }
                getWeight() {
                    return Rr.WEIGHT
                }
                getSize() {
                    return new Yn(Mh,Mh)
                }
                applyColour() {
                    super.applyColour();
                    const Q = this.sourceBlock.style.colourPrimary;
                    let oe;
                    (oe = this.textInputBubble) == null || oe.setColour(Q);
                    let pe;
                    (pe = this.textBubble) == null || pe.setColour(Q)
                }
                updateEditable() {
                    super.updateEditable(),
                    this.bubbleIsVisible() && (this.setBubbleVisible(!1),
                    this.setBubbleVisible(!0))
                }
                onLocationChange(Q) {
                    super.onLocationChange(Q),
                    Q = this.getAnchorLocation();
                    let oe;
                    (oe = this.textInputBubble) == null || oe.setAnchorLocation(Q);
                    let pe;
                    (pe = this.textBubble) == null || pe.setAnchorLocation(Q)
                }
                setText(Q) {
                    const oe = this.text;
                    Ye(new (gt(J.CHANGE$$module$build$src$core$events$utils))(this.sourceBlock,"comment",null,oe,Q)),
                    this.text = Q;
                    let pe;
                    (pe = this.textInputBubble) == null || pe.setText(this.text);
                    let Ae;
                    (Ae = this.textBubble) == null || Ae.setText(this.text)
                }
                getText() {
                    return this.text
                }
                setBubbleSize(Q) {
                    this.bubbleSize = Q;
                    let oe;
                    (oe = this.textInputBubble) == null || oe.setSize(this.bubbleSize, !0)
                }
                getBubbleSize() {
                    return this.bubbleSize
                }
                saveState() {
                    return this.text ? {
                        text: this.text,
                        pinned: this.bubbleIsVisible(),
                        height: this.bubbleSize.height,
                        width: this.bubbleSize.width
                    } : null
                }
                loadState(Q) {
                    let oe;
                    this.text = (oe = Q.text) != null ? oe : "";
                    let pe, Ae;
                    this.bubbleSize = new Yn((pe = Q.width) != null ? pe : Pg,(Ae = Q.height) != null ? Ae : Mg);
                    let Re;
                    this.bubbleVisiblity = (Re = Q.pinned) != null ? Re : !1,
                    setTimeout( () => this.setBubbleVisible(this.bubbleVisiblity), 1)
                }
                onClick() {
                    super.onClick(),
                    this.setBubbleVisible(!this.bubbleIsVisible())
                }
                isClickableInFlyout() {
                    return !1
                }
                onTextChange() {
                    if (this.textInputBubble) {
                        var Q = this.textInputBubble.getText();
                        this.text !== Q && (Ye(new (gt(J.CHANGE$$module$build$src$core$events$utils))(this.sourceBlock,"comment",null,this.text,Q)),
                        this.text = Q)
                    }
                }
                onSizeChange() {
                    this.textInputBubble && (this.bubbleSize = this.textInputBubble.getSize())
                }
                bubbleIsVisible() {
                    return this.bubbleVisiblity
                }
                setBubbleVisible(Q) {
                    (!Q || !this.textBubble && !this.textInputBubble) && (Q || this.textBubble || this.textInputBubble) && (this.bubbleVisiblity = Q,
                    this.sourceBlock.rendered && !this.sourceBlock.isInFlyout && (Q ? (this.sourceBlock.isEditable() ? this.showEditableBubble() : this.showNonEditableBubble(),
                    this.applyColour()) : this.hideBubble(),
                    Ye(new (gt(_s))(this.sourceBlock,Q,"comment"))))
                }
                showEditableBubble() {
                    this.textInputBubble = new Lg(this.sourceBlock.workspace,this.getAnchorLocation(),this.getBubbleOwnerRect()),
                    this.textInputBubble.setText(this.getText()),
                    this.textInputBubble.setSize(this.bubbleSize, !0),
                    this.textInputBubble.addTextChangeListener( () => this.onTextChange()),
                    this.textInputBubble.addSizeChangeListener( () => this.onSizeChange())
                }
                showNonEditableBubble() {
                    this.textBubble = new Ph(this.getText(),this.sourceBlock.workspace,this.getAnchorLocation(),this.getBubbleOwnerRect())
                }
                hideBubble() {
                    let Q;
                    (Q = this.textInputBubble) == null || Q.dispose(),
                    this.textInputBubble = null;
                    let oe;
                    (oe = this.textBubble) == null || oe.dispose(),
                    this.textBubble = null
                }
                getAnchorLocation() {
                    const Q = Mh / 2;
                    return Zt.sum(this.workspaceLocation, new Zt(Q,Q))
                }
                getBubbleOwnerRect() {
                    const Q = this.sourceBlock.getSvgRoot().getBBox();
                    return new Vn(Q.y,Q.y + Q.height,Q.x,Q.x + Q.width)
                }
            }
            ;
            Rr.TYPE = Lr.COMMENT,
            Rr.WEIGHT = 3,
            zu(Rr.TYPE, Rr);
            var kh = 17
              , ls = class extends $c {
                constructor(Q) {
                    super(Q),
                    this.sourceBlock = Q,
                    this.textMap = new Map,
                    this.textBubble = null
                }
                getType() {
                    return ls.TYPE
                }
                initView(Q) {
                    this.svgRoot || (super.initView(Q),
                    $t(bt.PATH, {
                        class: "blocklyIconShape",
                        d: "M2,15Q-1,15 0.5,12L6.5,1.7Q8,-1 9.5,1.7L15.5,12Q17,15 14,15z"
                    }, this.svgRoot),
                    $t(bt.PATH, {
                        class: "blocklyIconSymbol",
                        d: "m7,4.8v3.16l0.27,2.27h1.46l0.27,-2.27v-3.16z"
                    }, this.svgRoot),
                    $t(bt.RECT, {
                        class: "blocklyIconSymbol",
                        x: "7",
                        y: "11",
                        height: "2",
                        width: "2"
                    }, this.svgRoot),
                    Ut(this.svgRoot, "blockly-icon-warning"))
                }
                dispose() {
                    super.dispose();
                    let Q;
                    (Q = this.textBubble) == null || Q.dispose()
                }
                getWeight() {
                    return ls.WEIGHT
                }
                getSize() {
                    return new Yn(kh,kh)
                }
                applyColour() {
                    super.applyColour();
                    let Q;
                    (Q = this.textBubble) == null || Q.setColour(this.sourceBlock.style.colourPrimary)
                }
                updateCollapsed() {}
                isShownWhenCollapsed() {
                    return !0
                }
                onLocationChange(Q) {
                    super.onLocationChange(Q);
                    let oe;
                    (oe = this.textBubble) == null || oe.setAnchorLocation(this.getAnchorLocation())
                }
                addMessage(Q, oe) {
                    if (this.textMap.get(oe) === Q)
                        return this;
                    Q ? this.textMap.set(oe, Q) : this.textMap.delete(oe);
                    let pe;
                    return (pe = this.textBubble) == null || pe.setText(this.getText()),
                    this
                }
                getText() {
                    return [...this.textMap.values()].join(`
`)
                }
                onClick() {
                    super.onClick(),
                    this.setBubbleVisible(!this.bubbleIsVisible())
                }
                isClickableInFlyout() {
                    return !1
                }
                bubbleIsVisible() {
                    return !!this.textBubble
                }
                setBubbleVisible(Q) {
                    if (this.bubbleIsVisible() !== Q) {
                        if (Q)
                            this.textBubble = new Ph(this.getText(),this.sourceBlock.workspace,this.getAnchorLocation(),this.getBubbleOwnerRect()),
                            this.applyColour();
                        else {
                            let oe;
                            (oe = this.textBubble) == null || oe.dispose(),
                            this.textBubble = null
                        }
                        Ye(new (gt(_s))(this.sourceBlock,Q,"warning"))
                    }
                }
                getAnchorLocation() {
                    const Q = kh / 2;
                    return Zt.sum(this.workspaceLocation, new Zt(Q,Q))
                }
                getBubbleOwnerRect() {
                    const Q = this.sourceBlock.getSvgRoot().getBBox();
                    return new Vn(Q.y,Q.y + Q.height,Q.x,Q.x + Q.width)
                }
            }
            ;
            ls.TYPE = Lr.WARNING,
            ls.WEIGHT = 2;
            var kg = class extends Error {
                constructor(Q) {
                    super(`Tried to append an icon of type ${Q.getType()} when an icon of that type already exists on the block. Use getIcon to access the existing icon.`),
                    this.icon = Q
                }
            }
              , Dg = {};
            Dg.DuplicateIconType = kg;
            var Ro = {};
            Ro.CommentIcon = Rr,
            Ro.Icon = $c,
            Ro.IconType = Lr,
            Ro.MutatorIcon = J.MutatorIcon$$module$build$src$core$icons$mutator_icon,
            Ro.WarningIcon = ls,
            Ro.exceptions = Dg,
            Ro.registry = Lh;
            var xc, yr;
            xc = "PROCEDURE",
            J.DEFAULT_ARG$$module$build$src$core$procedures = "x",
            yr = {
                CATEGORY_NAME: xc,
                DEFAULT_ARG: J.DEFAULT_ARG$$module$build$src$core$procedures
            },
            yr.ObservableProcedureMap = xg,
            yr.allProcedures = Kl,
            yr.findLegalName = J.findLegalName$$module$build$src$core$procedures,
            yr.flyoutCategory = Jl,
            yr.getCallers = Zu,
            yr.getDefinition = J.getDefinition$$module$build$src$core$procedures,
            yr.isNameUsed = Ju,
            yr.isProcedureBlock = po,
            yr.mutateCallers = J.mutateCallers$$module$build$src$core$procedures,
            yr.mutatorOpenListener = Qu,
            yr.rename = J.rename$$module$build$src$core$procedures;
            var gT = class {
                constructor() {
                    this.NONE = 0,
                    this.FIELD = 1,
                    this.HAT = 2,
                    this.ICON = 4,
                    this.SPACER = 8,
                    this.BETWEEN_ROW_SPACER = 16,
                    this.IN_ROW_SPACER = 32,
                    this.EXTERNAL_VALUE_INPUT = 64,
                    this.INPUT = 128,
                    this.INLINE_INPUT = 256,
                    this.STATEMENT_INPUT = 512,
                    this.CONNECTION = 1024,
                    this.PREVIOUS_CONNECTION = 2048,
                    this.NEXT_CONNECTION = 4096,
                    this.OUTPUT_CONNECTION = 8192,
                    this.CORNER = 16384,
                    this.LEFT_SQUARE_CORNER = 32768,
                    this.LEFT_ROUND_CORNER = 65536,
                    this.RIGHT_SQUARE_CORNER = 131072,
                    this.RIGHT_ROUND_CORNER = 262144,
                    this.JAGGED_EDGE = 524288,
                    this.ROW = 1048576,
                    this.TOP_ROW = 2097152,
                    this.BOTTOM_ROW = 4194304,
                    this.INPUT_ROW = 8388608,
                    this.LEFT_CORNER = this.LEFT_SQUARE_CORNER | this.LEFT_ROUND_CORNER,
                    this.RIGHT_CORNER = this.RIGHT_SQUARE_CORNER | this.RIGHT_ROUND_CORNER,
                    this.nextTypeValue_ = 16777216
                }
                getType(Q) {
                    return Object.prototype.hasOwnProperty.call(this, Q) || (this[Q] = this.nextTypeValue_,
                    this.nextTypeValue_ <<= 1),
                    this[Q]
                }
                isField(Q) {
                    return Q.type & this.FIELD
                }
                isHat(Q) {
                    return Q.type & this.HAT
                }
                isIcon(Q) {
                    return Q.type & this.ICON
                }
                isSpacer(Q) {
                    return Q.type & this.SPACER
                }
                isInRowSpacer(Q) {
                    return Q.type & this.IN_ROW_SPACER
                }
                isInput(Q) {
                    return Q.type & this.INPUT
                }
                isExternalInput(Q) {
                    return Q.type & this.EXTERNAL_VALUE_INPUT
                }
                isInlineInput(Q) {
                    return Q.type & this.INLINE_INPUT
                }
                isStatementInput(Q) {
                    return Q.type & this.STATEMENT_INPUT
                }
                isPreviousConnection(Q) {
                    return Q.type & this.PREVIOUS_CONNECTION
                }
                isNextConnection(Q) {
                    return Q.type & this.NEXT_CONNECTION
                }
                isPreviousOrNextConnection(Q) {
                    return Q.type & (this.PREVIOUS_CONNECTION | this.NEXT_CONNECTION)
                }
                isLeftRoundedCorner(Q) {
                    return Q.type & this.LEFT_ROUND_CORNER
                }
                isRightRoundedCorner(Q) {
                    return Q.type & this.RIGHT_ROUND_CORNER
                }
                isLeftSquareCorner(Q) {
                    return Q.type & this.LEFT_SQUARE_CORNER
                }
                isRightSquareCorner(Q) {
                    return Q.type & this.RIGHT_SQUARE_CORNER
                }
                isCorner(Q) {
                    return Q.type & this.CORNER
                }
                isJaggedEdge(Q) {
                    return Q.type & this.JAGGED_EDGE
                }
                isRow(Q) {
                    return Q.type & this.ROW
                }
                isBetweenRowSpacer(Q) {
                    return Q.type & this.BETWEEN_ROW_SPACER
                }
                isTopRow(Q) {
                    return Q.type & this.TOP_ROW
                }
                isBottomRow(Q) {
                    return Q.type & this.BOTTOM_ROW
                }
                isTopOrBottomRow(Q) {
                    return Q.type & (this.TOP_ROW | this.BOTTOM_ROW)
                }
                isInputRow(Q) {
                    return Q.type & this.INPUT_ROW
                }
            }
              , Rt = new gT
              , vs = class {
                constructor(Q) {
                    this.centerline = this.xPos = this.height = this.width = 0,
                    this.constants_ = Q,
                    this.type = Rt.NONE,
                    this.notchOffset = this.constants_.NOTCH_OFFSET_LEFT
                }
            }
              , ol = class {
                constructor(Q) {
                    this.elements = [],
                    this.xPos = this.yPos = this.widthWithConnectedBlocks = this.minWidth = this.minHeight = this.width = this.height = 0,
                    this.hasStatement = this.hasExternalInput = !1,
                    this.statementEdge = 0,
                    this.hasJaggedEdge = this.hasDummyInput = this.hasInlineInput = !1,
                    this.align = null,
                    this.constants_ = Q,
                    this.type = Rt.ROW,
                    this.notchOffset = this.constants_.NOTCH_OFFSET_LEFT
                }
                getLastInput() {
                    for (let Q = this.elements.length - 1; 0 <= Q; Q--) {
                        const oe = this.elements[Q];
                        if (Rt.isInput(oe))
                            return oe
                    }
                    return null
                }
                measure() {
                    throw Error("Unexpected attempt to measure a base Row.")
                }
                startsWithElemSpacer() {
                    return !0
                }
                endsWithElemSpacer() {
                    return !0
                }
                getFirstSpacer() {
                    for (let Q = 0; Q < this.elements.length; Q++) {
                        const oe = this.elements[Q];
                        if (Rt.isSpacer(oe))
                            return oe
                    }
                    return null
                }
                getLastSpacer() {
                    for (let Q = this.elements.length - 1; 0 <= Q; Q--) {
                        const oe = this.elements[Q];
                        if (Rt.isSpacer(oe))
                            return oe
                    }
                    return null
                }
            }
              , Dh = class extends ol {
                constructor(Q) {
                    super(Q),
                    this.hasNextConnection = !1,
                    this.connection = null,
                    this.baseline = this.descenderHeight = 0,
                    this.type |= Rt.BOTTOM_ROW
                }
                hasLeftSquareCorner(Q) {
                    return !!Q.outputConnection || !!Q.getNextBlock()
                }
                hasRightSquareCorner(Q) {
                    return !0
                }
                measure() {
                    let Q = 0
                      , oe = 0
                      , pe = 0;
                    for (let Ae = 0; Ae < this.elements.length; Ae++) {
                        const Re = this.elements[Ae];
                        oe += Re.width,
                        Rt.isSpacer(Re) || (Rt.isNextConnection(Re) ? pe = Math.max(pe, Re.height) : Q = Math.max(Q, Re.height))
                    }
                    this.width = Math.max(this.minWidth, oe),
                    this.height = Math.max(this.minHeight, Q) + pe,
                    this.descenderHeight = pe,
                    this.widthWithConnectedBlocks = this.width
                }
                startsWithElemSpacer() {
                    return !1
                }
                endsWithElemSpacer() {
                    return !1
                }
            }
              , li = class extends vs {
                constructor(Q, oe) {
                    super(Q),
                    this.connectionModel = oe,
                    this.shape = this.constants_.shapeFor(oe),
                    this.isDynamicShape = "isDynamic"in this.shape && this.shape.isDynamic,
                    this.type |= Rt.CONNECTION
                }
            }
              , yo = class extends li {
                constructor(Q, oe) {
                    super(Q, oe.connection),
                    this.input = oe,
                    this.connectionOffsetY = this.connectionOffsetX = 0,
                    this.type |= Rt.INPUT,
                    this.align = oe.align,
                    (this.connectedBlock = oe.connection && oe.connection.targetBlock() ? oe.connection.targetBlock() : null) ? (Q = this.connectedBlock.getHeightWidth(),
                    this.connectedBlockWidth = Q.width,
                    this.connectedBlockHeight = Q.height) : this.connectedBlockHeight = this.connectedBlockWidth = 0
                }
            }
              , Nc = class extends yo {
                constructor(Q, oe) {
                    super(Q, oe),
                    this.height = 0,
                    this.type |= Rt.EXTERNAL_VALUE_INPUT,
                    this.height = this.connectedBlock ? this.connectedBlockHeight - this.constants_.TAB_OFFSET_FROM_TOP - this.constants_.MEDIUM_PADDING : this.shape.height,
                    this.width = this.shape.width + this.constants_.EXTERNAL_VALUE_INPUT_PADDING,
                    this.connectionOffsetY = this.constants_.TAB_OFFSET_FROM_TOP,
                    this.connectionHeight = this.shape.height,
                    this.connectionWidth = this.shape.width
                }
            }
              , oa = class extends vs {
                constructor(Q, oe, pe) {
                    super(Q),
                    this.field = oe,
                    this.parentInput = pe,
                    this.isEditable = oe.EDITABLE,
                    this.flipRtl = oe.getFlipRtl(),
                    this.type |= Rt.FIELD,
                    Q = this.field.getSize(),
                    this.height = Q.height,
                    this.width = Q.width
                }
            }
              , wh = class extends vs {
                constructor(Q) {
                    super(Q),
                    this.type |= Rt.HAT,
                    this.height = this.constants_.START_HAT.height,
                    this.width = this.constants_.START_HAT.width,
                    this.ascenderHeight = this.height
                }
            }
              , wg = class extends vs {
                constructor(Q, oe) {
                    super(Q),
                    this.icon = oe,
                    this.flipRtl = !1,
                    this.isVisible = uo(oe) && oe.bubbleIsVisible(),
                    this.type |= Rt.ICON,
                    Q = oe.getSize(),
                    this.height = Q.height,
                    this.width = Q.width
                }
            }
              , Gr = class extends vs {
                constructor(Q, oe) {
                    super(Q),
                    this.type = this.type | Rt.SPACER | Rt.IN_ROW_SPACER,
                    this.width = oe,
                    this.height = this.constants_.SPACER_DEFAULT_HEIGHT
                }
            }
              , Bh = class extends yo {
                constructor(Q, oe) {
                    super(Q, oe),
                    this.type |= Rt.INLINE_INPUT,
                    this.connectedBlock ? (this.width = this.connectedBlockWidth,
                    this.height = this.connectedBlockHeight) : (this.height = this.constants_.EMPTY_INLINE_INPUT_HEIGHT,
                    this.width = this.constants_.EMPTY_INLINE_INPUT_PADDING),
                    this.connectionHeight = this.isDynamicShape ? this.shape.height(this.height) : this.shape.height,
                    this.connectionWidth = this.isDynamicShape ? this.shape.width(this.height) : this.shape.width,
                    this.connectedBlock || (this.width += this.connectionWidth * (this.isDynamicShape ? 2 : 1)),
                    this.connectionOffsetY = "connectionOffsetY"in this.shape ? this.shape.connectionOffsetY(this.connectionHeight) : this.constants_.TAB_OFFSET_FROM_TOP,
                    this.connectionOffsetX = "connectionOffsetX"in this.shape ? this.shape.connectionOffsetX(this.connectionWidth) : 0
                }
            }
              , il = class extends yo {
                constructor(Q, oe) {
                    super(Q, oe),
                    this.type |= Rt.STATEMENT_INPUT,
                    this.height = this.connectedBlock ? this.connectedBlockHeight + this.constants_.STATEMENT_BOTTOM_SPACER : this.constants_.EMPTY_STATEMENT_INPUT_HEIGHT,
                    this.width = this.constants_.STATEMENT_INPUT_NOTCH_OFFSET + this.shape.width
                }
            }
              , Uh = class extends ol {
                constructor(Q) {
                    super(Q),
                    this.connectedBlockWidths = 0,
                    this.type |= Rt.INPUT_ROW
                }
                measure() {
                    this.width = this.minWidth,
                    this.height = this.minHeight;
                    let Q = 0;
                    for (let oe = 0; oe < this.elements.length; oe++) {
                        const pe = this.elements[oe];
                        this.width += pe.width,
                        Rt.isInput(pe) && pe instanceof yo && (Rt.isStatementInput(pe) && pe instanceof il ? Q += pe.connectedBlockWidth : Rt.isExternalInput(pe) && pe instanceof Nc && pe.connectedBlockWidth !== 0 && (Q += pe.connectedBlockWidth - pe.connectionWidth)),
                        Rt.isSpacer(pe) || (this.height = Math.max(this.height, pe.height))
                    }
                    this.connectedBlockWidths = Q,
                    this.widthWithConnectedBlocks = this.width + Q
                }
                endsWithElemSpacer() {
                    return !this.hasExternalInput && !this.hasStatement
                }
            }
              , Bg = class extends vs {
                constructor(Q) {
                    super(Q),
                    this.type |= Rt.JAGGED_EDGE,
                    this.height = this.constants_.JAGGED_TEETH.height,
                    this.width = this.constants_.JAGGED_TEETH.width
                }
            }
              , Ug = class extends li {
                constructor(Q, oe) {
                    super(Q, oe),
                    this.type |= Rt.NEXT_CONNECTION,
                    this.height = this.shape.height,
                    this.width = this.shape.width
                }
            }
              , Fg = class extends li {
                constructor(Q, oe) {
                    super(Q, oe),
                    this.connectionOffsetX = 0,
                    this.type |= Rt.OUTPUT_CONNECTION,
                    this.height = this.isDynamicShape ? 0 : this.shape.height,
                    this.startX = this.width = this.isDynamicShape ? 0 : this.shape.width,
                    this.connectionOffsetY = this.constants_.TAB_OFFSET_FROM_TOP
                }
            }
              , Hg = class extends li {
                constructor(Q, oe) {
                    super(Q, oe),
                    this.type |= Rt.PREVIOUS_CONNECTION,
                    this.height = this.shape.height,
                    this.width = this.shape.width
                }
            }
              , al = class extends vs {
                constructor(Q, oe) {
                    super(Q),
                    this.type = (oe && oe !== "left" ? Rt.RIGHT_ROUND_CORNER : Rt.LEFT_ROUND_CORNER) | Rt.CORNER,
                    this.width = this.constants_.CORNER_RADIUS,
                    this.height = this.constants_.CORNER_RADIUS / 2
                }
            }
              , Fh = class extends ol {
                constructor(Q, oe, pe) {
                    super(Q),
                    this.height = oe,
                    this.width = pe,
                    this.precedesStatement = this.followsStatement = !1,
                    this.widthWithConnectedBlocks = 0,
                    this.type = this.type | Rt.SPACER | Rt.BETWEEN_ROW_SPACER,
                    this.elements = [new Gr(this.constants_,pe)]
                }
                measure() {}
            }
              , ll = class extends vs {
                constructor(Q, oe) {
                    super(Q),
                    this.type = (oe && oe !== "left" ? Rt.RIGHT_SQUARE_CORNER : Rt.LEFT_SQUARE_CORNER) | Rt.CORNER,
                    this.width = this.height = this.constants_.NO_PADDING
                }
            }
              , Hh = class extends ol {
                constructor(Q) {
                    super(Q),
                    this.ascenderHeight = this.capline = 0,
                    this.hasPreviousConnection = !1,
                    this.connection = null,
                    this.type |= Rt.TOP_ROW
                }
                hasLeftSquareCorner(Q) {
                    const oe = (Q.hat ? Q.hat === "cap" : this.constants_.ADD_START_HATS) && !Q.outputConnection && !Q.previousConnection
                      , pe = Q.getPreviousBlock();
                    return !!Q.outputConnection || oe || (pe ? pe.getNextBlock() === Q : !1)
                }
                hasRightSquareCorner(Q) {
                    return !0
                }
                measure() {
                    let Q = 0
                      , oe = 0
                      , pe = 0;
                    for (let Ae = 0; Ae < this.elements.length; Ae++) {
                        const Re = this.elements[Ae];
                        oe += Re.width,
                        Rt.isSpacer(Re) || (Rt.isHat(Re) && Re instanceof wh ? pe = Math.max(pe, Re.ascenderHeight) : Q = Math.max(Q, Re.height))
                    }
                    this.width = Math.max(this.minWidth, oe),
                    this.height = Math.max(this.minHeight, Q) + pe,
                    this.capline = this.ascenderHeight = pe,
                    this.widthWithConnectedBlocks = this.width
                }
                startsWithElemSpacer() {
                    return !1
                }
                endsWithElemSpacer() {
                    return !1
                }
            }
              , cl = class {
                constructor() {
                    this.NO_PADDING = 0,
                    this.SMALL_PADDING = 3,
                    this.MEDIUM_PADDING = 5,
                    this.MEDIUM_LARGE_PADDING = 8,
                    this.LARGE_PADDING = 10,
                    this.TAB_HEIGHT = 15,
                    this.TAB_OFFSET_FROM_TOP = 5,
                    this.TAB_VERTICAL_OVERLAP = 2.5,
                    this.TAB_WIDTH = 8,
                    this.NOTCH_WIDTH = 15,
                    this.NOTCH_HEIGHT = 4,
                    this.MIN_BLOCK_WIDTH = 12,
                    this.EMPTY_BLOCK_SPACER_HEIGHT = 16,
                    this.CORNER_RADIUS = 8,
                    this.NOTCH_OFFSET_LEFT = 15,
                    this.STATEMENT_BOTTOM_SPACER = 0,
                    this.STATEMENT_INPUT_PADDING_LEFT = 20,
                    this.BETWEEN_STATEMENT_PADDING_Y = 4,
                    this.ADD_START_HATS = !1,
                    this.START_HAT_HEIGHT = 15,
                    this.START_HAT_WIDTH = 100,
                    this.SPACER_DEFAULT_HEIGHT = 15,
                    this.MIN_BLOCK_HEIGHT = 24,
                    this.EMPTY_INLINE_INPUT_PADDING = 14.5,
                    this.EXTERNAL_VALUE_INPUT_PADDING = 2,
                    this.JAGGED_TEETH_HEIGHT = 12,
                    this.JAGGED_TEETH_WIDTH = 6,
                    this.FIELD_TEXT_FONTSIZE = 11,
                    this.FIELD_TEXT_FONTWEIGHT = "normal",
                    this.FIELD_TEXT_FONTFAMILY = "sans-serif",
                    this.FIELD_TEXT_BASELINE = this.FIELD_TEXT_HEIGHT = -1,
                    this.FIELD_BORDER_RECT_RADIUS = 4,
                    this.FIELD_BORDER_RECT_HEIGHT = 16,
                    this.FIELD_BORDER_RECT_X_PADDING = 5,
                    this.FIELD_BORDER_RECT_Y_PADDING = 3,
                    this.FIELD_BORDER_RECT_COLOUR = "#fff",
                    this.FIELD_DROPDOWN_SVG_ARROW = this.FIELD_DROPDOWN_COLOURED_DIV = this.FIELD_DROPDOWN_NO_BORDER_RECT_SHADOW = !1,
                    this.FIELD_DROPDOWN_SVG_ARROW_SIZE = 12,
                    this.FIELD_COLOUR_FULL_BLOCK = this.FIELD_TEXTINPUT_BOX_SHADOW = !1,
                    this.FIELD_COLOUR_DEFAULT_WIDTH = 26,
                    this.defs = null,
                    this.embossFilterId = "",
                    this.embossFilter = null,
                    this.disabledPatternId = "",
                    this.disabledPattern = null,
                    this.debugFilterId = "",
                    this.cssNode = this.debugFilter = null,
                    this.CURSOR_COLOUR = "#cc0a0a",
                    this.MARKER_COLOUR = "#4286f4",
                    this.CURSOR_WS_WIDTH = 100,
                    this.WS_CURSOR_HEIGHT = 5,
                    this.CURSOR_STACK_PADDING = 10,
                    this.CURSOR_BLOCK_PADDING = 2,
                    this.CURSOR_STROKE_WIDTH = 4,
                    this.FULL_BLOCK_FIELDS = !1,
                    this.INSERTION_MARKER_COLOUR = "#000000",
                    this.INSERTION_MARKER_OPACITY = .2,
                    this.SHAPES = {
                        PUZZLE: 1,
                        NOTCH: 2
                    },
                    this.TALL_INPUT_FIELD_OFFSET_Y = this.MEDIUM_PADDING,
                    this.DUMMY_INPUT_SHADOW_MIN_HEIGHT = this.DUMMY_INPUT_MIN_HEIGHT = this.TAB_HEIGHT,
                    this.STATEMENT_INPUT_NOTCH_OFFSET = this.NOTCH_OFFSET_LEFT,
                    this.TOP_ROW_MIN_HEIGHT = this.MEDIUM_PADDING,
                    this.TOP_ROW_PRECEDES_STATEMENT_MIN_HEIGHT = this.LARGE_PADDING,
                    this.BOTTOM_ROW_MIN_HEIGHT = this.MEDIUM_PADDING,
                    this.BOTTOM_ROW_AFTER_STATEMENT_MIN_HEIGHT = this.LARGE_PADDING,
                    this.EMPTY_INLINE_INPUT_HEIGHT = this.TAB_HEIGHT + 11,
                    this.EMPTY_STATEMENT_INPUT_HEIGHT = this.MIN_BLOCK_HEIGHT,
                    this.START_POINT = qn(0, 0),
                    this.FIELD_TEXT_BASELINE_CENTER = !0,
                    this.FIELD_DROPDOWN_BORDER_RECT_HEIGHT = this.FIELD_BORDER_RECT_HEIGHT,
                    this.FIELD_DROPDOWN_SVG_ARROW_PADDING = this.FIELD_BORDER_RECT_X_PADDING,
                    this.FIELD_DROPDOWN_SVG_ARROW_DATAURI = "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMi43MSIgaGVpZ2h0PSI4Ljc5IiB2aWV3Qm94PSIwIDAgMTIuNzEgOC43OSI+PHRpdGxlPmRyb3Bkb3duLWFycm93PC90aXRsZT48ZyBvcGFjaXR5PSIwLjEiPjxwYXRoIGQ9Ik0xMi43MSwyLjQ0QTIuNDEsMi40MSwwLDAsMSwxMiw0LjE2TDguMDgsOC4wOGEyLjQ1LDIuNDUsMCwwLDEtMy40NSwwTDAuNzIsNC4xNkEyLjQyLDIuNDIsMCwwLDEsMCwyLjQ0LDIuNDgsMi40OCwwLDAsMSwuNzEuNzFDMSwwLjQ3LDEuNDMsMCw2LjM2LDBTMTEuNzUsMC40NiwxMiwuNzFBMi40NCwyLjQ0LDAsMCwxLDEyLjcxLDIuNDRaIiBmaWxsPSIjMjMxZjIwIi8+PC9nPjxwYXRoIGQ9Ik02LjM2LDcuNzlhMS40MywxLjQzLDAsMCwxLTEtLjQyTDEuNDIsMy40NWExLjQ0LDEuNDQsMCwwLDEsMC0yYzAuNTYtLjU2LDkuMzEtMC41Niw5Ljg3LDBhMS40NCwxLjQ0LDAsMCwxLDAsMkw3LjM3LDcuMzdBMS40MywxLjQzLDAsMCwxLDYuMzYsNy43OVoiIGZpbGw9IiNmZmYiLz48L3N2Zz4=",
                    this.FIELD_COLOUR_DEFAULT_HEIGHT = this.FIELD_BORDER_RECT_HEIGHT,
                    this.FIELD_CHECKBOX_X_OFFSET = this.FIELD_BORDER_RECT_X_PADDING - 3,
                    this.randomIdentifier = String(Math.random()).substring(2)
                }
                init() {
                    this.JAGGED_TEETH = this.makeJaggedTeeth(),
                    this.NOTCH = this.makeNotch(),
                    this.START_HAT = this.makeStartHat(),
                    this.PUZZLE_TAB = this.makePuzzleTab(),
                    this.INSIDE_CORNERS = this.makeInsideCorners(),
                    this.OUTSIDE_CORNERS = this.makeOutsideCorners()
                }
                setTheme(Q) {
                    this.blockStyles = Object.create(null);
                    const oe = Q.blockStyles;
                    for (const pe in oe)
                        this.blockStyles[pe] = this.validatedBlockStyle_(oe[pe]);
                    this.setDynamicProperties_(Q)
                }
                setDynamicProperties_(Q) {
                    this.setFontConstants_(Q),
                    this.setComponentConstants_(Q),
                    this.ADD_START_HATS = Q.startHats !== void 0 ? Q.startHats : this.ADD_START_HATS
                }
                setFontConstants_(Q) {
                    Q.fontStyle && Q.fontStyle.family && (this.FIELD_TEXT_FONTFAMILY = Q.fontStyle.family),
                    Q.fontStyle && Q.fontStyle.weight && (this.FIELD_TEXT_FONTWEIGHT = Q.fontStyle.weight),
                    Q.fontStyle && Q.fontStyle.size && (this.FIELD_TEXT_FONTSIZE = Q.fontStyle.size),
                    Q = Sn("Hg", this.FIELD_TEXT_FONTSIZE + "pt", this.FIELD_TEXT_FONTWEIGHT, this.FIELD_TEXT_FONTFAMILY),
                    this.FIELD_TEXT_HEIGHT = Q.height,
                    this.FIELD_TEXT_BASELINE = Q.baseline
                }
                setComponentConstants_(Q) {
                    this.CURSOR_COLOUR = Q.getComponentStyle("cursorColour") || this.CURSOR_COLOUR,
                    this.MARKER_COLOUR = Q.getComponentStyle("markerColour") || this.MARKER_COLOUR,
                    this.INSERTION_MARKER_COLOUR = Q.getComponentStyle("insertionMarkerColour") || this.INSERTION_MARKER_COLOUR,
                    this.INSERTION_MARKER_OPACITY = Number(Q.getComponentStyle("insertionMarkerOpacity")) || this.INSERTION_MARKER_OPACITY
                }
                getBlockStyleForColour(Q) {
                    const oe = "auto_" + Q;
                    return this.blockStyles[oe] || (this.blockStyles[oe] = this.createBlockStyle_(Q)),
                    {
                        style: this.blockStyles[oe],
                        name: oe
                    }
                }
                getBlockStyle(Q) {
                    return this.blockStyles[Q || ""] || (Q && Q.indexOf("auto_") === 0 ? this.getBlockStyleForColour(Q.substring(5)).style : this.createBlockStyle_("#000000"))
                }
                createBlockStyle_(Q) {
                    return this.validatedBlockStyle_({
                        colourPrimary: Q
                    })
                }
                validatedBlockStyle_(Q) {
                    const oe = {};
                    return Q && Object.assign(oe, Q),
                    Q = Li(oe.colourPrimary || "#000"),
                    oe.colourPrimary = Q.hex,
                    oe.colourSecondary = oe.colourSecondary ? Li(oe.colourSecondary).hex : this.generateSecondaryColour_(oe.colourPrimary),
                    oe.colourTertiary = oe.colourTertiary ? Li(oe.colourTertiary).hex : this.generateTertiaryColour_(oe.colourPrimary),
                    oe.hat = oe.hat || "",
                    oe
                }
                generateSecondaryColour_(Q) {
                    return Ho("#fff", Q, .6) || Q
                }
                generateTertiaryColour_(Q) {
                    return Ho("#fff", Q, .3) || Q
                }
                dispose() {
                    this.embossFilter && Bt(this.embossFilter),
                    this.disabledPattern && Bt(this.disabledPattern),
                    this.debugFilter && Bt(this.debugFilter),
                    this.cssNode = null
                }
                makeJaggedTeeth() {
                    const Q = this.JAGGED_TEETH_HEIGHT
                      , oe = this.JAGGED_TEETH_WIDTH
                      , pe = Pi([gn(oe, Q / 4), gn(2 * -oe, Q / 2), gn(oe, Q / 4)]);
                    return {
                        height: Q,
                        width: oe,
                        path: pe
                    }
                }
                makeStartHat() {
                    const Q = this.START_HAT_HEIGHT
                      , oe = this.START_HAT_WIDTH
                      , pe = xr("c", [gn(30, -Q), gn(70, -Q), gn(oe, 0)]);
                    return {
                        height: Q,
                        width: oe,
                        path: pe
                    }
                }
                makePuzzleTab() {
                    function Q(Ue) {
                        Ue = Ue ? -1 : 1;
                        const tt = -Ue;
                        var dt = pe / 2;
                        const wt = dt + 2.5
                          , sn = dt + .5
                          , zn = gn(-oe, Ue * dt);
                        return dt = gn(oe, Ue * dt),
                        xr("c", [gn(0, Ue * wt), gn(-oe, tt * sn), zn]) + xr("s", [gn(oe, 2.5 * tt), dt])
                    }
                    const oe = this.TAB_WIDTH
                      , pe = this.TAB_HEIGHT
                      , Ae = Q(!0)
                      , Re = Q(!1);
                    return {
                        type: this.SHAPES.PUZZLE,
                        width: oe,
                        height: pe,
                        pathDown: Re,
                        pathUp: Ae
                    }
                }
                makeNotch() {
                    function Q(tt) {
                        return Pi([gn(tt * Ae, pe), gn(3 * tt, 0), gn(tt * Ae, -pe)])
                    }
                    const oe = this.NOTCH_WIDTH
                      , pe = this.NOTCH_HEIGHT
                      , Ae = (oe - 3) / 2
                      , Re = Q(1)
                      , Ue = Q(-1);
                    return {
                        type: this.SHAPES.NOTCH,
                        width: oe,
                        height: pe,
                        pathLeft: Re,
                        pathRight: Ue
                    }
                }
                makeInsideCorners() {
                    const Q = this.CORNER_RADIUS
                      , oe = sr("a", "0 0,0", Q, gn(-Q, Q))
                      , pe = sr("a", "0 0,0", Q, gn(Q, Q));
                    return {
                        width: Q,
                        height: Q,
                        pathTop: oe,
                        pathBottom: pe
                    }
                }
                makeOutsideCorners() {
                    const Q = this.CORNER_RADIUS
                      , oe = qn(0, Q) + sr("a", "0 0,1", Q, gn(Q, -Q))
                      , pe = sr("a", "0 0,1", Q, gn(Q, Q))
                      , Ae = sr("a", "0 0,1", Q, gn(-Q, -Q))
                      , Re = sr("a", "0 0,1", Q, gn(-Q, Q));
                    return {
                        topLeft: oe,
                        topRight: pe,
                        bottomRight: Re,
                        bottomLeft: Ae,
                        rightHeight: Q
                    }
                }
                shapeFor(Q) {
                    switch (Q.type) {
                    case pn.INPUT_VALUE:
                    case pn.OUTPUT_VALUE:
                        return this.PUZZLE_TAB;
                    case pn.PREVIOUS_STATEMENT:
                    case pn.NEXT_STATEMENT:
                        return this.NOTCH;
                    default:
                        throw Error("Unknown connection type")
                    }
                }
                createDom(Q, oe, pe) {
                    this.injectCSS_(oe, pe),
                    this.defs = $t(bt.DEFS, {}, Q),
                    Q = $t(bt.FILTER, {
                        id: "blocklyEmbossFilter" + this.randomIdentifier
                    }, this.defs),
                    $t(bt.FEGAUSSIANBLUR, {
                        in: "SourceAlpha",
                        stdDeviation: 1,
                        result: "blur"
                    }, Q),
                    oe = $t(bt.FESPECULARLIGHTING, {
                        in: "blur",
                        surfaceScale: 1,
                        specularConstant: .5,
                        specularExponent: 10,
                        "lighting-color": "white",
                        result: "specOut"
                    }, Q),
                    $t(bt.FEPOINTLIGHT, {
                        x: -5e3,
                        y: -1e4,
                        z: 2e4
                    }, oe),
                    $t(bt.FECOMPOSITE, {
                        in: "specOut",
                        in2: "SourceAlpha",
                        operator: "in",
                        result: "specOut"
                    }, Q),
                    $t(bt.FECOMPOSITE, {
                        in: "SourceGraphic",
                        in2: "specOut",
                        operator: "arithmetic",
                        k1: 0,
                        k2: 1,
                        k3: 1,
                        k4: 0
                    }, Q),
                    this.embossFilterId = Q.id,
                    this.embossFilter = Q,
                    Q = $t(bt.PATTERN, {
                        id: "blocklyDisabledPattern" + this.randomIdentifier,
                        patternUnits: "userSpaceOnUse",
                        width: 10,
                        height: 10
                    }, this.defs),
                    $t(bt.RECT, {
                        width: 10,
                        height: 10,
                        fill: "#aaa"
                    }, Q),
                    $t(bt.PATH, {
                        d: "M 0 0 L 10 10 M 10 0 L 0 10",
                        stroke: "#cc0"
                    }, Q),
                    this.disabledPatternId = Q.id,
                    this.disabledPattern = Q,
                    this.createDebugFilter()
                }
                createDebugFilter() {
                    if (!this.debugFilter) {
                        const Q = $t(bt.FILTER, {
                            id: "blocklyDebugFilter" + this.randomIdentifier,
                            height: "160%",
                            width: "180%",
                            y: "-30%",
                            x: "-40%"
                        }, this.defs)
                          , oe = $t(bt.FECOMPONENTTRANSFER, {
                            result: "outBlur"
                        }, Q);
                        $t(bt.FEFUNCA, {
                            type: "table",
                            tableValues: "0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"
                        }, oe),
                        $t(bt.FEFLOOD, {
                            "flood-color": "#ff0000",
                            "flood-opacity": .5,
                            result: "outColor"
                        }, Q),
                        $t(bt.FECOMPOSITE, {
                            in: "outColor",
                            in2: "outBlur",
                            operator: "in",
                            result: "outGlow"
                        }, Q),
                        this.debugFilterId = Q.id,
                        this.debugFilter = Q
                    }
                }
                injectCSS_(Q, oe) {
                    oe = this.getCSS_(oe),
                    Q = "blockly-renderer-style-" + Q,
                    this.cssNode = document.getElementById(Q);
                    const pe = oe.join(`
`);
                    this.cssNode ? this.cssNode.firstChild.textContent = pe : (oe = document.createElement("style"),
                    oe.id = Q,
                    Q = document.createTextNode(pe),
                    oe.appendChild(Q),
                    document.head.insertBefore(oe, document.head.firstChild),
                    this.cssNode = oe)
                }
                getCSS_(Q) {
                    return [`${Q} .blocklyText, `, `${Q} .blocklyFlyoutLabelText {`, `font: ${this.FIELD_TEXT_FONTWEIGHT} ${this.FIELD_TEXT_FONTSIZE}pt ${this.FIELD_TEXT_FONTFAMILY};`, "}", `${Q} .blocklyText {`, "fill: #fff;", "}", `${Q} .blocklyNonEditableText>rect,`, `${Q} .blocklyEditableText>rect {`, `fill: ${this.FIELD_BORDER_RECT_COLOUR};`, "fill-opacity: .6;", "stroke: none;", "}", `${Q} .blocklyNonEditableText>text,`, `${Q} .blocklyEditableText>text {`, "fill: #000;", "}", `${Q} .blocklyFlyoutLabelText {`, "fill: #000;", "}", `${Q} .blocklyText.blocklyBubbleText {`, "fill: #000;", "}", `${Q} .blocklyEditableText:not(.editing):hover>rect {`, "stroke: #fff;", "stroke-width: 2;", "}", `${Q} .blocklyHtmlInput {`, `font-family: ${this.FIELD_TEXT_FONTFAMILY};`, `font-weight: ${this.FIELD_TEXT_FONTWEIGHT};`, "}", `${Q} .blocklySelected>.blocklyPath {`, "stroke: #fc3;", "stroke-width: 3px;", "}", `${Q} .blocklyHighlightedConnectionPath {`, "stroke: #fc3;", "}", `${Q} .blocklyReplaceable .blocklyPath {`, "fill-opacity: .5;", "}", `${Q} .blocklyReplaceable .blocklyPathLight,`, `${Q} .blocklyReplaceable .blocklyPathDark {`, "display: none;", "}", `${Q} .blocklyInsertionMarker>.blocklyPath {`, `fill-opacity: ${this.INSERTION_MARKER_OPACITY};`, "stroke: none;", "}"]
                }
            }
              , ul = class {
                constructor(Q, oe) {
                    this.inlinePath_ = this.outlinePath_ = "",
                    this.block_ = Q,
                    this.info_ = oe,
                    this.topLeft_ = Q.getRelativeToSurfaceXY(),
                    this.constants_ = oe.getRenderer().getConstants()
                }
                draw() {
                    this.drawOutline_(),
                    this.drawInternals_(),
                    this.block_.pathObject.setPath(this.outlinePath_ + `
` + this.inlinePath_),
                    this.info_.RTL && this.block_.pathObject.flipRTL(),
                    this.recordSizeOnBlock_()
                }
                hideHiddenIcons_() {
                    zt("hideHiddenIcons_", "v10", "v11")
                }
                recordSizeOnBlock_() {
                    this.block_.height = this.info_.height,
                    this.block_.width = this.info_.widthWithChildren
                }
                drawOutline_() {
                    this.drawTop_();
                    for (let Q = 1; Q < this.info_.rows.length - 1; Q++) {
                        const oe = this.info_.rows[Q];
                        oe.hasJaggedEdge ? this.drawJaggedEdge_(oe) : oe.hasStatement ? this.drawStatementInput_(oe) : oe.hasExternalInput ? this.drawValueInput_(oe) : this.drawRightSideRow_(oe)
                    }
                    this.drawBottom_(),
                    this.drawLeft_()
                }
                drawTop_() {
                    const Q = this.info_.topRow
                      , oe = Q.elements;
                    this.positionPreviousConnection_(),
                    this.outlinePath_ += qn(Q.xPos, this.info_.startY);
                    for (let pe = 0, Ae; Ae = oe[pe]; pe++)
                        Rt.isLeftRoundedCorner(Ae) ? this.outlinePath_ += this.constants_.OUTSIDE_CORNERS.topLeft : Rt.isRightRoundedCorner(Ae) ? this.outlinePath_ += this.constants_.OUTSIDE_CORNERS.topRight : Rt.isPreviousConnection(Ae) && Ae instanceof li ? this.outlinePath_ += Ae.shape.pathLeft : Rt.isHat(Ae) ? this.outlinePath_ += this.constants_.START_HAT.path : Rt.isSpacer(Ae) && (this.outlinePath_ += ln("h", Ae.width));
                    this.outlinePath_ += ln("v", Q.height)
                }
                drawJaggedEdge_(Q) {
                    this.outlinePath_ += this.constants_.JAGGED_TEETH.path + ln("v", Q.height - this.constants_.JAGGED_TEETH.height)
                }
                drawValueInput_(Q) {
                    const oe = Q.getLastInput();
                    this.positionExternalValueConnection_(Q);
                    const pe = ed(oe.shape) ? oe.shape.pathDown(oe.height) : oe.shape.pathDown;
                    this.outlinePath_ += ln("H", oe.xPos + oe.width) + pe + ln("v", Q.height - oe.connectionHeight)
                }
                drawStatementInput_(Q) {
                    var oe = Q.getLastInput();
                    if (oe) {
                        var pe = oe.xPos + oe.notchOffset + oe.shape.width;
                        oe = oe.shape.pathRight + ln("h", -(oe.notchOffset - this.constants_.INSIDE_CORNERS.width)) + this.constants_.INSIDE_CORNERS.pathTop;
                        var Ae = Q.height - 2 * this.constants_.INSIDE_CORNERS.height;
                        this.outlinePath_ += ln("H", pe) + oe + ln("v", Ae) + this.constants_.INSIDE_CORNERS.pathBottom + ln("H", Q.xPos + Q.width),
                        this.positionStatementInputConnection_(Q)
                    }
                }
                drawRightSideRow_(Q) {
                    this.outlinePath_ += ln("V", Q.yPos + Q.height)
                }
                drawBottom_() {
                    const Q = this.info_.bottomRow
                      , oe = Q.elements;
                    this.positionNextConnection_();
                    let pe = 0
                      , Ae = "";
                    for (let Re = oe.length - 1, Ue; Ue = oe[Re]; Re--)
                        Rt.isNextConnection(Ue) && Ue instanceof li ? Ae += Ue.shape.pathRight : Rt.isLeftSquareCorner(Ue) ? Ae += ln("H", Q.xPos) : Rt.isLeftRoundedCorner(Ue) ? Ae += this.constants_.OUTSIDE_CORNERS.bottomLeft : Rt.isRightRoundedCorner(Ue) ? (Ae += this.constants_.OUTSIDE_CORNERS.bottomRight,
                        pe = this.constants_.OUTSIDE_CORNERS.rightHeight) : Rt.isSpacer(Ue) && (Ae += ln("h", -1 * Ue.width));
                    this.outlinePath_ += ln("V", Q.baseline - pe),
                    this.outlinePath_ += Ae
                }
                drawLeft_() {
                    var Q = this.info_.outputConnection;
                    if (this.positionOutputConnection_(),
                    Q) {
                        const oe = Q.connectionOffsetY + Q.height;
                        Q = ed(Q.shape) ? Q.shape.pathUp(Q.height) : Q.shape.pathUp,
                        this.outlinePath_ += ln("V", oe) + Q
                    }
                    this.outlinePath_ += "z"
                }
                drawInternals_() {
                    for (let Q = 0, oe; oe = this.info_.rows[Q]; Q++)
                        for (let pe = 0, Ae; Ae = oe.elements[pe]; pe++)
                            Rt.isInlineInput(Ae) ? this.drawInlineInput_(Ae) : (Rt.isIcon(Ae) || Rt.isField(Ae)) && this.layoutField_(Ae)
                }
                layoutField_(Q) {
                    const oe = Q.centerline - Q.height / 2;
                    let pe = Q.xPos;
                    var Ae = "";
                    this.info_.RTL && (pe = -(pe + Q.width),
                    Q.flipRtl && (pe += Q.width,
                    Ae = "scale(-1 1)")),
                    Rt.isIcon(Q) ? (Ae = Q.icon,
                    Ae.setOffsetInBlock(new Zt(pe,oe)),
                    this.info_.isInsertionMarker && Ae.hideForInsertionMarker()) : (Q = Q.field.getSvgRoot(),
                    Q.setAttribute("transform", "translate(" + pe + "," + oe + ")" + Ae),
                    this.info_.isInsertionMarker && Q.setAttribute("display", "none"))
                }
                drawInlineInput_(Q) {
                    const oe = Q.width
                      , pe = Q.height
                      , Ae = Q.connectionOffsetY
                      , Re = Q.connectionHeight + Ae;
                    this.inlinePath_ += mr(Q.xPos + Q.connectionWidth, Q.centerline - pe / 2) + ln("v", Ae) + Q.shape.pathDown + ln("v", pe - Re) + ln("h", oe - Q.connectionWidth) + ln("v", -pe) + "z",
                    this.positionInlineInputConnection_(Q)
                }
                positionInlineInputConnection_(Q) {
                    const oe = Q.centerline - Q.height / 2;
                    if (Q.connectionModel) {
                        let pe = Q.xPos + Q.connectionWidth + Q.connectionOffsetX;
                        this.info_.RTL && (pe *= -1),
                        Q.connectionModel.setOffsetInBlock(pe, oe + Q.connectionOffsetY)
                    }
                }
                positionStatementInputConnection_(Q) {
                    const oe = Q.getLastInput();
                    if (oe != null && oe.connectionModel) {
                        let pe = Q.xPos + Q.statementEdge + oe.notchOffset;
                        this.info_.RTL && (pe *= -1),
                        oe.connectionModel.setOffsetInBlock(pe, Q.yPos)
                    }
                }
                positionExternalValueConnection_(Q) {
                    const oe = Q.getLastInput();
                    if (oe && oe.connectionModel) {
                        let pe = Q.xPos + Q.width;
                        this.info_.RTL && (pe *= -1),
                        oe.connectionModel.setOffsetInBlock(pe, Q.yPos)
                    }
                }
                positionPreviousConnection_() {
                    const Q = this.info_.topRow;
                    if (Q.connection) {
                        const oe = Q.xPos + Q.notchOffset;
                        Q.connection.connectionModel.setOffsetInBlock(this.info_.RTL ? -oe : oe, 0)
                    }
                }
                positionNextConnection_() {
                    const Q = this.info_.bottomRow;
                    if (Q.connection) {
                        const oe = Q.connection
                          , pe = oe.xPos;
                        oe.connectionModel.setOffsetInBlock(this.info_.RTL ? -pe : pe, Q.baseline)
                    }
                }
                positionOutputConnection_() {
                    if (this.info_.outputConnection) {
                        const Q = this.info_.startX + this.info_.outputConnection.connectionOffsetX;
                        this.block_.outputConnection.setOffsetInBlock(this.info_.RTL ? -Q : Q, this.info_.outputConnection.connectionOffsetY)
                    }
                }
            }
            ;
            (function(Q) {
                Q[Q.LEFT = -1] = "LEFT",
                Q[Q.CENTRE = 0] = "CENTRE",
                Q[Q.RIGHT = 1] = "RIGHT"
            }
            )(J.Align$$module$build$src$core$inputs$align || (J.Align$$module$build$src$core$inputs$align = {})),
            J.Align$$module$build$src$core$inputs$align;
            var ci = class extends vn {
                constructor(Q, oe, pe) {
                    super(vn.SKIP_SETUP),
                    this.class = null,
                    this.EDITABLE = !1,
                    this.maxDisplayLength = 1 / 0,
                    Q !== vn.SKIP_SETUP && (pe ? this.configure_(pe) : this.class = oe || null,
                    this.setValue(Q))
                }
                configure_(Q) {
                    super.configure_(Q),
                    Q.class && (this.class = Q.class)
                }
                initView() {
                    this.createTextElement_(),
                    this.class && Ut(this.getTextElement(), this.class)
                }
                doClassValidation_(Q) {
                    return Q == null ? null : `${Q}`
                }
                setClass(Q) {
                    this.textElement_ && (this.class && yt(this.textElement_, this.class),
                    Q && Ut(this.textElement_, Q)),
                    this.class = Q
                }
                static fromJson(Q) {
                    return new this(rr(Q.text),void 0,Q)
                }
            }
            ;
            Ur("field_label", ci),
            ci.prototype.DEFAULT_VALUE = "";
            var xs = class {
                constructor(Q, oe) {
                    this.name = Q,
                    this.sourceBlock = oe,
                    this.fieldRow = [],
                    this.align = J.Align$$module$build$src$core$inputs$input.LEFT,
                    this.visible = !0,
                    this.type = J.inputTypes$$module$build$src$core$inputs$input_types.CUSTOM,
                    this.connection = null
                }
                getSourceBlock() {
                    return this.sourceBlock
                }
                appendField(Q, oe) {
                    return this.insertFieldAt(this.fieldRow.length, Q, oe),
                    this
                }
                insertFieldAt(Q, oe, pe) {
                    if (0 > Q || Q > this.fieldRow.length)
                        throw Error("index " + Q + " out of bounds.");
                    return (oe || oe === "" && pe) && (typeof oe == "string" && (oe = J.fromJson$$module$build$src$core$field_registry({
                        type: "field_label",
                        text: oe
                    })),
                    oe.setSourceBlock(this.sourceBlock),
                    this.sourceBlock.rendered && (oe.init(),
                    oe.applyColour()),
                    oe.name = pe,
                    oe.setVisible(this.isVisible()),
                    oe.prefixField && (Q = this.insertFieldAt(Q, oe.prefixField)),
                    this.fieldRow.splice(Q, 0, oe),
                    Q++,
                    oe.suffixField && (Q = this.insertFieldAt(Q, oe.suffixField)),
                    this.sourceBlock.rendered && (this.sourceBlock.queueRender(),
                    this.sourceBlock.bumpNeighbours())),
                    Q
                }
                removeField(Q, oe) {
                    for (let pe = 0, Ae; Ae = this.fieldRow[pe]; pe++)
                        if (Ae.name === Q)
                            return Ae.dispose(),
                            this.fieldRow.splice(pe, 1),
                            this.sourceBlock.rendered && (this.sourceBlock.queueRender(),
                            this.sourceBlock.bumpNeighbours()),
                            !0;
                    if (oe)
                        return !1;
                    throw Error('Field "' + Q + '" not found.')
                }
                isVisible() {
                    return this.visible
                }
                setVisible(Q) {
                    let oe = [];
                    if (this.visible === Q)
                        return oe;
                    this.visible = Q;
                    for (let Ae = 0, Re; Re = this.fieldRow[Ae]; Ae++)
                        Re.setVisible(Q);
                    if (this.connection) {
                        var pe = this.connection;
                        Q ? oe = pe.startTrackingAll() : pe.stopTrackingAll(),
                        (pe = pe.targetBlock()) && (pe.getSvgRoot().style.display = Q ? "block" : "none")
                    }
                    return oe
                }
                markDirty() {
                    for (let Q = 0, oe; oe = this.fieldRow[Q]; Q++)
                        oe.markDirty()
                }
                setCheck(Q) {
                    if (!this.connection)
                        throw Error("This input does not have a connection.");
                    return this.connection.setCheck(Q),
                    this
                }
                setAlign(Q) {
                    return this.align = Q,
                    this.sourceBlock.rendered && this.sourceBlock.queueRender(),
                    this
                }
                setShadowDom(Q) {
                    if (!this.connection)
                        throw Error("This input does not have a connection.");
                    return this.connection.setShadowDom(Q),
                    this
                }
                getShadowDom() {
                    if (!this.connection)
                        throw Error("This input does not have a connection.");
                    return this.connection.getShadowDom()
                }
                init() {
                    if (this.sourceBlock.workspace.rendered)
                        for (let Q = 0; Q < this.fieldRow.length; Q++)
                            this.fieldRow[Q].init()
                }
                dispose() {
                    for (let Q = 0, oe; oe = this.fieldRow[Q]; Q++)
                        oe.dispose();
                    this.connection && this.connection.dispose()
                }
                makeConnection(Q) {
                    return this.sourceBlock.makeConnection_(Q)
                }
            }
            , Vg;
            (function(Q) {
                Q = Q.Align || (Q.Align = {}),
                Q[Q.LEFT = -1] = "LEFT",
                Q[Q.CENTRE = 0] = "CENTRE",
                Q[Q.RIGHT = 1] = "RIGHT"
            }
            )(xs || (xs = {})),
            J.Align$$module$build$src$core$inputs$input = xs.Align,
            Vg = {
                Align: J.Align$$module$build$src$core$inputs$input
            },
            Vg.Input = xs;
            var Ns = class extends xs {
                constructor(Q, oe) {
                    super(Q, oe),
                    this.name = Q,
                    this.type = J.inputTypes$$module$build$src$core$inputs$input_types.DUMMY
                }
            }
            , to = class extends xs {
                constructor(Q, oe) {
                    super(Q, oe),
                    this.name = Q,
                    this.type = J.inputTypes$$module$build$src$core$inputs$input_types.END_ROW
                }
            }
            , jr = class extends xs {
                constructor(Q, oe) {
                    if (!Q)
                        throw Error("Statement inputs must have a non-empty name");
                    super(Q, oe),
                    this.name = Q,
                    this.type = J.inputTypes$$module$build$src$core$inputs$input_types.STATEMENT,
                    this.connection = this.makeConnection(pn.NEXT_STATEMENT)
                }
            }
            , Gg;
            J.ValueInput$$module$build$src$core$inputs$value_input = class extends xs {
                constructor(Q, oe) {
                    if (!Q)
                        throw Error("Value inputs must have a non-empty name");
                    super(Q, oe),
                    this.name = Q,
                    this.type = J.inputTypes$$module$build$src$core$inputs$input_types.VALUE,
                    this.connection = this.makeConnection(pn.INPUT_VALUE)
                }
            }
            ,
            Gg = {},
            Gg.ValueInput = J.ValueInput$$module$build$src$core$inputs$value_input;
            var ia = class {
                constructor(Q, oe) {
                    this.statementEdge = this.width = this.widthWithChildren = this.height = 0,
                    this.rows = [],
                    this.inputRows = [],
                    this.startY = this.startX = 0,
                    this.renderer_ = Q,
                    this.block_ = oe,
                    this.constants_ = this.renderer_.getConstants(),
                    this.outputConnection = oe.outputConnection ? new Fg(this.constants_,oe.outputConnection) : null,
                    this.isInline = oe.getInputsInline() && !oe.isCollapsed(),
                    this.isCollapsed = oe.isCollapsed(),
                    this.isInsertionMarker = oe.isInsertionMarker(),
                    this.RTL = oe.RTL,
                    this.topRow = new Hh(this.constants_),
                    this.bottomRow = new Dh(this.constants_)
                }
                getRenderer() {
                    return this.renderer_
                }
                measure() {
                    this.createRows_(),
                    this.addElemSpacing_(),
                    this.addRowSpacing_(),
                    this.computeBounds_(),
                    this.alignRowElements_(),
                    this.finalize_()
                }
                createRows_() {
                    this.populateTopRow_(),
                    this.rows.push(this.topRow);
                    let Q = new Uh(this.constants_);
                    this.inputRows.push(Q);
                    var oe = this.block_.getIcons();
                    for (let pe = 0, Ae; Ae = oe[pe]; pe++) {
                        const Re = new wg(this.constants_,Ae);
                        this.isCollapsed && !Ae.isShownWhenCollapsed() || Q.elements.push(Re)
                    }
                    oe = void 0;
                    for (let pe = 0, Ae; Ae = this.block_.inputList[pe]; pe++)
                        if (Ae.isVisible()) {
                            this.shouldStartNewRow_(Ae, oe) && (this.rows.push(Q),
                            Q = new Uh(this.constants_),
                            this.inputRows.push(Q));
                            for (let Re = 0, Ue; Ue = Ae.fieldRow[Re]; Re++)
                                Q.elements.push(new oa(this.constants_,Ue,Ae));
                            this.addInput_(Ae, Q),
                            oe = Ae
                        }
                    this.isCollapsed && (Q.hasJaggedEdge = !0,
                    Q.elements.push(new Bg(this.constants_))),
                    (Q.elements.length || Q.hasDummyInput) && this.rows.push(Q),
                    this.populateBottomRow_(),
                    this.rows.push(this.bottomRow)
                }
                populateTopRow_() {
                    var Q = !!this.block_.previousConnection;
                    const oe = (this.block_.hat ? this.block_.hat === "cap" : this.constants_.ADD_START_HATS) && !this.outputConnection && !Q;
                    let pe = this.topRow.hasLeftSquareCorner(this.block_) ? ll : al;
                    this.topRow.elements.push(new pe(this.constants_)),
                    oe ? (Q = new wh(this.constants_),
                    this.topRow.elements.push(Q),
                    this.topRow.capline = Q.ascenderHeight) : Q && (this.topRow.hasPreviousConnection = !0,
                    this.topRow.connection = new Hg(this.constants_,this.block_.previousConnection),
                    this.topRow.elements.push(this.topRow.connection)),
                    this.block_.inputList.length && this.block_.inputList[0]instanceof jr && !this.block_.isCollapsed() ? this.topRow.minHeight = this.constants_.TOP_ROW_PRECEDES_STATEMENT_MIN_HEIGHT : this.topRow.minHeight = this.constants_.TOP_ROW_MIN_HEIGHT,
                    pe = this.topRow.hasRightSquareCorner(this.block_) ? ll : al,
                    this.topRow.elements.push(new pe(this.constants_,"right"))
                }
                populateBottomRow_() {
                    this.bottomRow.hasNextConnection = !!this.block_.nextConnection,
                    this.bottomRow.minHeight = this.block_.inputList.length && this.block_.inputList[this.block_.inputList.length - 1]instanceof jr ? this.constants_.BOTTOM_ROW_AFTER_STATEMENT_MIN_HEIGHT : this.constants_.BOTTOM_ROW_MIN_HEIGHT,
                    this.bottomRow.hasLeftSquareCorner(this.block_) ? this.bottomRow.elements.push(new ll(this.constants_)) : this.bottomRow.elements.push(new al(this.constants_)),
                    this.bottomRow.hasNextConnection && (this.bottomRow.connection = new Ug(this.constants_,this.block_.nextConnection),
                    this.bottomRow.elements.push(this.bottomRow.connection)),
                    this.bottomRow.hasRightSquareCorner(this.block_) ? this.bottomRow.elements.push(new ll(this.constants_,"right")) : this.bottomRow.elements.push(new al(this.constants_,"right"))
                }
                addInput_(Q, oe) {
                    this.isInline && Q instanceof J.ValueInput$$module$build$src$core$inputs$value_input ? (oe.elements.push(new Bh(this.constants_,Q)),
                    oe.hasInlineInput = !0) : Q instanceof jr ? (oe.elements.push(new il(this.constants_,Q)),
                    oe.hasStatement = !0) : Q instanceof J.ValueInput$$module$build$src$core$inputs$value_input ? (oe.elements.push(new Nc(this.constants_,Q)),
                    oe.hasExternalInput = !0) : (Q instanceof Ns || Q instanceof to) && (oe.minHeight = Math.max(oe.minHeight, Q.getSourceBlock() && Q.getSourceBlock().isShadow() ? this.constants_.DUMMY_INPUT_SHADOW_MIN_HEIGHT : this.constants_.DUMMY_INPUT_MIN_HEIGHT),
                    oe.hasDummyInput = !0),
                    oe.align === null && (oe.align = Q.align)
                }
                shouldStartNewRow_(Q, oe) {
                    return oe ? oe instanceof to || Q instanceof jr || oe instanceof jr ? !0 : Q instanceof J.ValueInput$$module$build$src$core$inputs$value_input || Q instanceof Ns || oe instanceof J.ValueInput$$module$build$src$core$inputs$value_input ? !this.isInline : !1 : !1
                }
                addElemSpacing_() {
                    for (let Q = 0, oe; oe = this.rows[Q]; Q++) {
                        const pe = oe.elements;
                        if (oe.elements = [],
                        oe.startsWithElemSpacer() && oe.elements.push(new Gr(this.constants_,this.getInRowSpacing_(null, pe[0]))),
                        pe.length) {
                            for (let Ae = 0; Ae < pe.length - 1; Ae++) {
                                oe.elements.push(pe[Ae]);
                                const Re = this.getInRowSpacing_(pe[Ae], pe[Ae + 1]);
                                oe.elements.push(new Gr(this.constants_,Re))
                            }
                            oe.elements.push(pe[pe.length - 1]),
                            oe.endsWithElemSpacer() && oe.elements.push(new Gr(this.constants_,this.getInRowSpacing_(pe[pe.length - 1], null)))
                        }
                    }
                }
                getInRowSpacing_(Q, oe) {
                    if (!Q && oe && Rt.isStatementInput(oe))
                        return this.constants_.STATEMENT_INPUT_PADDING_LEFT;
                    if (Q && Rt.isInput(Q) && !oe) {
                        if (Rt.isExternalInput(Q))
                            return this.constants_.NO_PADDING;
                        if (Rt.isInlineInput(Q))
                            return this.constants_.LARGE_PADDING;
                        if (Rt.isStatementInput(Q))
                            return this.constants_.NO_PADDING
                    }
                    return Q && Rt.isLeftSquareCorner(Q) && oe && (Rt.isPreviousConnection(oe) || Rt.isNextConnection(oe)) ? oe.notchOffset : Q && Rt.isLeftRoundedCorner(Q) && oe && (Rt.isPreviousConnection(oe) || Rt.isNextConnection(oe)) ? oe.notchOffset - this.constants_.CORNER_RADIUS : this.constants_.MEDIUM_PADDING
                }
                computeBounds_() {
                    let Q = 0
                      , oe = 0
                      , pe = 0;
                    for (let Re = 0, Ue; Ue = this.rows[Re]; Re++) {
                        if (Ue.measure(),
                        oe = Math.max(oe, Ue.width),
                        Ue.hasStatement) {
                            var Ae = Ue.getLastInput();
                            let tt, dt;
                            Ae = Ue.width - ((dt = (tt = Ae) == null ? void 0 : tt.width) != null ? dt : 0),
                            Q = Math.max(Q, Ae)
                        }
                        pe = Math.max(pe, Ue.widthWithConnectedBlocks)
                    }
                    this.statementEdge = Q,
                    this.width = oe;
                    for (let Re = 0, Ue; Ue = this.rows[Re]; Re++)
                        Ue.hasStatement && (Ue.statementEdge = this.statementEdge);
                    this.widthWithChildren = Math.max(oe, pe),
                    this.outputConnection && (this.startX = this.outputConnection.width,
                    this.width += this.outputConnection.width,
                    this.widthWithChildren += this.outputConnection.width)
                }
                alignRowElements_() {
                    for (let oe = 0, pe; pe = this.rows[oe]; oe++)
                        if (pe.hasStatement)
                            this.alignStatementRow_(pe);
                        else {
                            var Q = pe.width;
                            Q = this.getDesiredRowWidth_(pe) - Q,
                            0 < Q && this.addAlignmentPadding_(pe, Q),
                            Rt.isTopOrBottomRow(pe) && (pe.widthWithConnectedBlocks = pe.width)
                        }
                }
                getDesiredRowWidth_(Q) {
                    return this.width - this.startX
                }
                addAlignmentPadding_(Q, oe) {
                    const pe = Q.getFirstSpacer()
                      , Ae = Q.getLastSpacer();
                    if ((Q.hasExternalInput || Q.hasStatement) && (Q.widthWithConnectedBlocks += oe),
                    Q.align === J.Align$$module$build$src$core$inputs$align.LEFT && Ae)
                        Ae.width += oe;
                    else if (Q.align === J.Align$$module$build$src$core$inputs$align.CENTRE && pe && Ae)
                        pe.width += oe / 2,
                        Ae.width += oe / 2;
                    else if (Q.align === J.Align$$module$build$src$core$inputs$align.RIGHT && pe)
                        pe.width += oe;
                    else if (Ae)
                        Ae.width += oe;
                    else
                        return;
                    Q.width += oe
                }
                alignStatementRow_(Q) {
                    const oe = Q.getLastInput();
                    if (oe) {
                        var pe = Q.width - oe.width
                          , Ae = this.statementEdge;
                        pe = Ae - pe,
                        0 < pe && this.addAlignmentPadding_(Q, pe),
                        pe = Q.width,
                        Ae = this.getDesiredRowWidth_(Q),
                        oe.width += Ae - pe,
                        oe.height = Math.max(oe.height, Q.height),
                        Q.width += Ae - pe,
                        Q.widthWithConnectedBlocks = Math.max(Q.width, this.statementEdge + Q.connectedBlockWidths)
                    }
                }
                addRowSpacing_() {
                    const Q = this.rows;
                    this.rows = [];
                    for (let oe = 0; oe < Q.length; oe++)
                        this.rows.push(Q[oe]),
                        oe !== Q.length - 1 && this.rows.push(this.makeSpacerRow_(Q[oe], Q[oe + 1]))
                }
                makeSpacerRow_(Q, oe) {
                    var pe = this.getSpacerRowHeight_(Q, oe);
                    const Ae = this.getSpacerRowWidth_(Q, oe);
                    return pe = new Fh(this.constants_,pe,Ae),
                    Q.hasStatement && (pe.followsStatement = !0),
                    oe.hasStatement && (pe.precedesStatement = !0),
                    pe
                }
                getSpacerRowWidth_(Q, oe) {
                    return this.width - this.startX
                }
                getSpacerRowHeight_(Q, oe) {
                    return this.constants_.MEDIUM_PADDING
                }
                getElemCenterline_(Q, oe) {
                    return Rt.isSpacer(oe) ? Q.yPos + oe.height / 2 : Rt.isBottomRow(Q) ? (Q = Q.yPos + Q.height - Q.descenderHeight,
                    Rt.isNextConnection(oe) ? Q + oe.height / 2 : Q - oe.height / 2) : Rt.isTopRow(Q) ? Rt.isHat(oe) ? Q.capline - oe.height / 2 : Q.capline + oe.height / 2 : Q.yPos + Q.height / 2
                }
                recordElemPositions_(Q) {
                    let oe = Q.xPos;
                    for (let pe = 0, Ae; Ae = Q.elements[pe]; pe++)
                        Rt.isSpacer(Ae) && (Ae.height = Q.height),
                        Ae.xPos = oe,
                        Ae.centerline = this.getElemCenterline_(Q, Ae),
                        oe += Ae.width
                }
                finalize_() {
                    let Q = 0
                      , oe = 0;
                    for (let pe = 0, Ae; Ae = this.rows[pe]; pe++)
                        Ae.yPos = oe,
                        Ae.xPos = this.startX,
                        oe += Ae.height,
                        Q = Math.max(Q, Ae.widthWithConnectedBlocks),
                        this.recordElemPositions_(Ae);
                    if (this.outputConnection && this.block_.nextConnection) {
                        const pe = this.block_.nextConnection.targetBlock();
                        pe && (Q = Math.max(Q, pe.getHeightWidth().width))
                    }
                    this.widthWithChildren = Q + this.startX,
                    this.height = oe,
                    this.startY = this.topRow.capline,
                    this.bottomRow.baseline = oe - this.bottomRow.descenderHeight
                }
            }
              , jt = class {
                constructor(Q, oe, pe) {
                    if (this.wsCoordinate = null,
                    !oe)
                        throw Error("Cannot create a node without a location.");
                    this.type = Q,
                    this.isConnectionLocation = jt.isConnectionType(Q),
                    this.location = oe,
                    this.processParams(pe || null)
                }
                processParams(Q) {
                    Q && Q.wsCoordinate && (this.wsCoordinate = Q.wsCoordinate)
                }
                getLocation() {
                    return this.location
                }
                getType() {
                    return this.type
                }
                getWsCoordinate() {
                    return this.wsCoordinate
                }
                isConnection() {
                    return this.isConnectionLocation
                }
                findNextForInput() {
                    var Q = this.location.getParentInput();
                    const oe = Q.getSourceBlock();
                    for (Q = oe.inputList.indexOf(Q),
                    Q += 1; Q < oe.inputList.length; Q++) {
                        const pe = oe.inputList[Q]
                          , Ae = pe.fieldRow;
                        for (let Re = 0; Re < Ae.length; Re++) {
                            const Ue = Ae[Re];
                            if (Ue.isClickable() || jt.NAVIGATE_ALL_FIELDS)
                                return jt.createFieldNode(Ue)
                        }
                        if (pe.connection)
                            return jt.createInputNode(pe)
                    }
                    return null
                }
                findNextForField() {
                    var Q = this.location
                      , oe = Q.getParentInput();
                    const pe = Q.getSourceBlock();
                    if (!pe)
                        throw Error("The current AST location is not associated with a block");
                    var Ae = pe.inputList.indexOf(oe);
                    for (Q = oe.fieldRow.indexOf(Q) + 1; Ae < pe.inputList.length; Ae++) {
                        oe = pe.inputList[Ae];
                        const Re = oe.fieldRow;
                        for (; Q < Re.length; ) {
                            if (Re[Q].isClickable() || jt.NAVIGATE_ALL_FIELDS)
                                return jt.createFieldNode(Re[Q]);
                            Q++
                        }
                        if (Q = 0,
                        oe.connection)
                            return jt.createInputNode(oe)
                    }
                    return null
                }
                findPrevForInput() {
                    const Q = this.location.getParentInput()
                      , oe = Q.getSourceBlock();
                    for (var pe = oe.inputList.indexOf(Q); 0 <= pe; pe--) {
                        var Ae = oe.inputList[pe];
                        if (Ae.connection && Ae !== Q)
                            return jt.createInputNode(Ae);
                        Ae = Ae.fieldRow;
                        for (let Re = Ae.length - 1; 0 <= Re; Re--) {
                            const Ue = Ae[Re];
                            if (Ue.isClickable() || jt.NAVIGATE_ALL_FIELDS)
                                return jt.createFieldNode(Ue)
                        }
                    }
                    return null
                }
                findPrevForField() {
                    var Q = this.location;
                    const oe = Q.getParentInput()
                      , pe = Q.getSourceBlock();
                    if (!pe)
                        throw Error("The current AST location is not associated with a block");
                    var Ae = pe.inputList.indexOf(oe);
                    for (Q = oe.fieldRow.indexOf(Q) - 1; 0 <= Ae; Ae--) {
                        var Re = pe.inputList[Ae];
                        if (Re.connection && Re !== oe)
                            return jt.createInputNode(Re);
                        for (Re = Re.fieldRow; -1 < Q; ) {
                            if (Re[Q].isClickable() || jt.NAVIGATE_ALL_FIELDS)
                                return jt.createFieldNode(Re[Q]);
                            Q--
                        }
                        0 <= Ae - 1 && (Q = pe.inputList[Ae - 1].fieldRow.length - 1)
                    }
                    return null
                }
                navigateBetweenStacks(Q) {
                    var oe = this.getLocation();
                    if (oe.getSourceBlock) {
                        var pe = oe.getSourceBlock();
                        pe && (oe = pe)
                    }
                    if (!oe || oe.isDeadOrDying())
                        return null;
                    pe = oe.getRootBlock(),
                    oe = pe.workspace.getTopBlocks(!0);
                    for (let Ae = 0; Ae < oe.length; Ae++)
                        if (pe.id === oe[Ae].id)
                            return Q = Ae + (Q ? 1 : -1),
                            Q === -1 || Q === oe.length ? null : jt.createStackNode(oe[Q]);
                    throw Error("Couldn't find " + (Q ? "next" : "previous") + " stack?!")
                }
                findTopASTNodeForBlock(Q) {
                    const oe = Ua(Q);
                    return oe ? jt.createConnectionNode(oe) : jt.createBlockNode(Q)
                }
                getOutAstNodeForBlock(Q) {
                    if (!Q)
                        return null;
                    Q = Q.getTopStackBlock();
                    const oe = Ua(Q);
                    return oe && oe.targetConnection && oe.targetConnection.getParentInput() ? jt.createInputNode(oe.targetConnection.getParentInput()) : jt.createStackNode(Q)
                }
                findFirstFieldOrInput(Q) {
                    Q = Q.inputList;
                    for (let oe = 0; oe < Q.length; oe++) {
                        const pe = Q[oe]
                          , Ae = pe.fieldRow;
                        for (let Re = 0; Re < Ae.length; Re++) {
                            const Ue = Ae[Re];
                            if (Ue.isClickable() || jt.NAVIGATE_ALL_FIELDS)
                                return jt.createFieldNode(Ue)
                        }
                        if (pe.connection)
                            return jt.createInputNode(pe)
                    }
                    return null
                }
                getSourceBlock() {
                    return this.getType() === jt.types.BLOCK ? this.getLocation() : this.getType() === jt.types.STACK ? this.getLocation() : this.getType() === jt.types.WORKSPACE ? null : this.getLocation().getSourceBlock()
                }
                next() {
                    switch (this.type) {
                    case jt.types.STACK:
                        return this.navigateBetweenStacks(!0);
                    case jt.types.OUTPUT:
                        return jt.createBlockNode(this.location.getSourceBlock());
                    case jt.types.FIELD:
                        return this.findNextForField();
                    case jt.types.INPUT:
                        return this.findNextForInput();
                    case jt.types.BLOCK:
                        const Q = this.location.nextConnection;
                        if (!Q)
                            break;
                        return jt.createConnectionNode(Q);
                    case jt.types.PREVIOUS:
                        return jt.createBlockNode(this.location.getSourceBlock());
                    case jt.types.NEXT:
                        return jt.createConnectionNode(this.location.targetConnection)
                    }
                    return null
                }
                in() {
                    switch (this.type) {
                    case jt.types.WORKSPACE:
                        const Q = this.location.getTopBlocks(!0);
                        if (0 < Q.length)
                            return jt.createStackNode(Q[0]);
                        break;
                    case jt.types.STACK:
                        return this.findTopASTNodeForBlock(this.location);
                    case jt.types.BLOCK:
                        return this.findFirstFieldOrInput(this.location);
                    case jt.types.INPUT:
                        return jt.createConnectionNode(this.location.targetConnection)
                    }
                    return null
                }
                prev() {
                    switch (this.type) {
                    case jt.types.STACK:
                        return this.navigateBetweenStacks(!1);
                    case jt.types.FIELD:
                        return this.findPrevForField();
                    case jt.types.INPUT:
                        return this.findPrevForInput();
                    case jt.types.BLOCK:
                        var Q = Ua(this.location);
                        if (!Q)
                            break;
                        return jt.createConnectionNode(Q);
                    case jt.types.PREVIOUS:
                        if ((Q = this.location.targetConnection) && !Q.getParentInput())
                            return jt.createConnectionNode(Q);
                        break;
                    case jt.types.NEXT:
                        return jt.createBlockNode(this.location.getSourceBlock())
                    }
                    return null
                }
                out() {
                    switch (this.type) {
                    case jt.types.STACK:
                        var Q = this.location
                          , oe = Q.getRelativeToSurfaceXY();
                        return oe = new Zt(oe.x,oe.y + jt.DEFAULT_OFFSET_Y),
                        jt.createWorkspaceNode(Q.workspace, oe);
                    case jt.types.OUTPUT:
                        return Q = this.location,
                        (oe = Q.targetConnection) ? jt.createConnectionNode(oe) : jt.createStackNode(Q.getSourceBlock());
                    case jt.types.FIELD:
                        if (Q = this.location.getSourceBlock(),
                        !Q)
                            throw Error("The current AST location is not associated with a block");
                        return jt.createBlockNode(Q);
                    case jt.types.INPUT:
                        return jt.createBlockNode(this.location.getSourceBlock());
                    case jt.types.BLOCK:
                        return this.getOutAstNodeForBlock(this.location);
                    case jt.types.PREVIOUS:
                        return this.getOutAstNodeForBlock(this.location.getSourceBlock());
                    case jt.types.NEXT:
                        return this.getOutAstNodeForBlock(this.location.getSourceBlock())
                    }
                    return null
                }
                static isConnectionType(Q) {
                    switch (Q) {
                    case jt.types.PREVIOUS:
                    case jt.types.NEXT:
                    case jt.types.INPUT:
                    case jt.types.OUTPUT:
                        return !0
                    }
                    return !1
                }
                static createFieldNode(Q) {
                    return Q ? new jt(jt.types.FIELD,Q) : null
                }
                static createConnectionNode(Q) {
                    if (!Q)
                        return null;
                    const oe = Q.type;
                    return oe === pn.INPUT_VALUE || oe === pn.NEXT_STATEMENT && Q.getParentInput() ? jt.createInputNode(Q.getParentInput()) : oe === pn.NEXT_STATEMENT ? new jt(jt.types.NEXT,Q) : oe === pn.OUTPUT_VALUE ? new jt(jt.types.OUTPUT,Q) : oe === pn.PREVIOUS_STATEMENT ? new jt(jt.types.PREVIOUS,Q) : null
                }
                static createInputNode(Q) {
                    return Q && Q.connection ? new jt(jt.types.INPUT,Q.connection) : null
                }
                static createBlockNode(Q) {
                    return Q ? new jt(jt.types.BLOCK,Q) : null
                }
                static createStackNode(Q) {
                    return Q ? new jt(jt.types.STACK,Q) : null
                }
                static createWorkspaceNode(Q, oe) {
                    return oe && Q ? new jt(jt.types.WORKSPACE,Q,{
                        wsCoordinate: oe
                    }) : null
                }
                static createTopNode(Q) {
                    const oe = Ua(Q);
                    return oe ? jt.createConnectionNode(oe) : jt.createBlockNode(Q)
                }
            }
            ;
            jt.NAVIGATE_ALL_FIELDS = !1,
            jt.DEFAULT_OFFSET_Y = -20,
            function(Q) {
                Q = Q.types || (Q.types = {}),
                Q.FIELD = "field",
                Q.BLOCK = "block",
                Q.INPUT = "input",
                Q.OUTPUT = "output",
                Q.NEXT = "next",
                Q.PREVIOUS = "previous",
                Q.STACK = "stack",
                Q.WORKSPACE = "workspace"
            }(jt || (jt = {}));
            var Vh = class extends Is {
                constructor(Q, oe, pe, Ae) {
                    let Re = Q ? Q.workspace.id : void 0;
                    Ae && Ae.getType() === jt.types.WORKSPACE && (Re = Ae.getLocation().id),
                    super(Re),
                    this.type = Ui,
                    this.blockId = Q == null ? void 0 : Q.id,
                    this.oldNode = pe || void 0,
                    this.newNode = Ae,
                    this.isCursor = oe
                }
                toJson() {
                    const Q = super.toJson();
                    if (this.isCursor === void 0)
                        throw Error("Whether this is a cursor event or not is undefined. Either pass a value to the constructor, or call fromJson");
                    if (!this.newNode)
                        throw Error("The new node is undefined. Either pass a node to the constructor, or call fromJson");
                    return Q.isCursor = this.isCursor,
                    Q.blockId = this.blockId,
                    Q.oldNode = this.oldNode,
                    Q.newNode = this.newNode,
                    Q
                }
                static fromJson(Q, oe, pe) {
                    return oe = super.fromJson(Q, oe, pe ?? new Vh),
                    oe.isCursor = Q.isCursor,
                    oe.blockId = Q.blockId,
                    oe.oldNode = Q.oldNode,
                    oe.newNode = Q.newNode,
                    oe
                }
            }
            ;
            ne(Yt.EVENT, Ui, Vh);
            var ET = "blocklyCursor"
              , TT = "blocklyMarker"
              , AT = .75
              , Gh = class {
                constructor(Q, oe, pe) {
                    this.workspace = Q,
                    this.marker = pe,
                    this.markerSvgRect_ = this.markerSvgLine_ = this.markerInput_ = this.markerBlock_ = this.svgGroup_ = this.markerSvg_ = this.currentMarkerSvg = this.parent = null,
                    this.constants_ = oe,
                    Q = this.isCursor() ? this.constants_.CURSOR_COLOUR : this.constants_.MARKER_COLOUR,
                    this.colour_ = pe.colour || Q
                }
                getSvgRoot() {
                    return this.svgGroup_
                }
                getMarker() {
                    return this.marker
                }
                isCursor() {
                    return this.marker.type === "cursor"
                }
                createDom() {
                    const Q = this.isCursor() ? ET : TT;
                    return this.svgGroup_ = $t(bt.G, {
                        class: Q
                    }),
                    this.createDomInternal_(),
                    this.svgGroup_
                }
                setParent_(Q) {
                    this.isCursor() ? (this.parent && this.parent.setCursorSvg(null),
                    Q.setCursorSvg(this.getSvgRoot())) : (this.parent && this.parent.setMarkerSvg(null),
                    Q.setMarkerSvg(this.getSvgRoot())),
                    this.parent = Q
                }
                draw(Q, oe) {
                    if (oe) {
                        this.constants_ = this.workspace.getRenderer().getConstants();
                        var pe = this.isCursor() ? this.constants_.CURSOR_COLOUR : this.constants_.MARKER_COLOUR;
                        this.colour_ = this.marker.colour || pe,
                        this.applyColour_(oe),
                        this.showAtLocation_(oe),
                        this.fireMarkerEvent(Q, oe),
                        Q = this.currentMarkerSvg.childNodes[0],
                        Q !== void 0 && Q.beginElement && Q.beginElement()
                    } else
                        this.hide()
                }
                showAtLocation_(Q) {
                    const oe = Q.getLocation().type;
                    Q.getType() === jt.types.BLOCK ? this.showWithBlock_(Q) : Q.getType() === jt.types.OUTPUT ? this.showWithOutput_(Q) : oe === pn.INPUT_VALUE ? this.showWithInput_(Q) : oe === pn.NEXT_STATEMENT ? this.showWithNext_(Q) : Q.getType() === jt.types.PREVIOUS ? this.showWithPrevious_(Q) : Q.getType() === jt.types.FIELD ? this.showWithField_(Q) : Q.getType() === jt.types.WORKSPACE ? this.showWithCoordinates_(Q) : Q.getType() === jt.types.STACK && this.showWithStack_(Q)
                }
                showWithBlockPrevOutput(Q) {
                    Q = Q.getSourceBlock();
                    const oe = Q.width;
                    var pe = Q.height
                      , Ae = pe * AT;
                    const Re = this.constants_.CURSOR_BLOCK_PADDING;
                    Q.previousConnection ? (pe = this.constants_.shapeFor(Q.previousConnection),
                    this.positionPrevious_(oe, Re, Ae, pe)) : Q.outputConnection ? (Ae = this.constants_.shapeFor(Q.outputConnection),
                    this.positionOutput_(oe, pe, Ae)) : this.positionBlock_(oe, Re, Ae),
                    this.setParent_(Q),
                    this.showCurrent_()
                }
                showWithBlock_(Q) {
                    this.showWithBlockPrevOutput(Q)
                }
                showWithPrevious_(Q) {
                    this.showWithBlockPrevOutput(Q)
                }
                showWithOutput_(Q) {
                    this.showWithBlockPrevOutput(Q)
                }
                showWithCoordinates_(Q) {
                    var oe = Q.getWsCoordinate();
                    Q = oe.x,
                    oe = oe.y,
                    this.workspace.RTL && (Q -= this.constants_.CURSOR_WS_WIDTH),
                    this.positionLine_(Q, oe, this.constants_.CURSOR_WS_WIDTH),
                    this.setParent_(this.workspace),
                    this.showCurrent_()
                }
                showWithField_(Q) {
                    Q = Q.getLocation();
                    const oe = Q.getSize().width
                      , pe = Q.getSize().height;
                    this.positionRect_(0, 0, oe, pe),
                    this.setParent_(Q),
                    this.showCurrent_()
                }
                showWithInput_(Q) {
                    Q = Q.getLocation();
                    const oe = Q.getSourceBlock();
                    this.positionInput_(Q),
                    this.setParent_(oe),
                    this.showCurrent_()
                }
                showWithNext_(Q) {
                    var oe = Q.getLocation();
                    Q = oe.getSourceBlock();
                    let pe = 0;
                    oe = oe.getOffsetInBlock().y;
                    const Ae = Q.getHeightWidth().width;
                    this.workspace.RTL && (pe = -Ae),
                    this.positionLine_(pe, oe, Ae),
                    this.setParent_(Q),
                    this.showCurrent_()
                }
                showWithStack_(Q) {
                    Q = Q.getLocation();
                    var oe = Q.getHeightWidth();
                    const pe = oe.width + this.constants_.CURSOR_STACK_PADDING;
                    oe = oe.height + this.constants_.CURSOR_STACK_PADDING;
                    const Ae = -this.constants_.CURSOR_STACK_PADDING / 2
                      , Re = -this.constants_.CURSOR_STACK_PADDING / 2;
                    let Ue = Ae;
                    this.workspace.RTL && (Ue = -(pe + Ae)),
                    this.positionRect_(Ue, Re, pe, oe),
                    this.setParent_(Q),
                    this.showCurrent_()
                }
                showCurrent_() {
                    this.hide(),
                    this.currentMarkerSvg && (this.currentMarkerSvg.style.display = "")
                }
                positionBlock_(Q, oe, pe) {
                    if (Q = qn(-oe, pe) + ln("V", -oe) + ln("H", Q + 2 * oe) + ln("V", pe),
                    !this.markerBlock_)
                        throw Error("createDom should be called before positioning the marker");
                    this.markerBlock_.setAttribute("d", Q),
                    this.workspace.RTL && this.flipRtl(this.markerBlock_),
                    this.currentMarkerSvg = this.markerBlock_
                }
                positionInput_(Q) {
                    const oe = Q.getOffsetInBlock().x
                      , pe = Q.getOffsetInBlock().y;
                    Q = mr(0, 0) + this.constants_.shapeFor(Q).pathDown,
                    this.markerInput_.setAttribute("d", Q),
                    this.markerInput_.setAttribute("transform", "translate(" + oe + "," + pe + ")" + (this.workspace.RTL ? " scale(-1 1)" : "")),
                    this.currentMarkerSvg = this.markerInput_
                }
                positionLine_(Q, oe, pe) {
                    if (!this.markerSvgLine_)
                        throw Error("createDom should be called before positioning the line");
                    this.markerSvgLine_.setAttribute("x", `${Q}`),
                    this.markerSvgLine_.setAttribute("y", `${oe}`),
                    this.markerSvgLine_.setAttribute("width", `${pe}`),
                    this.currentMarkerSvg = this.markerSvgLine_
                }
                positionOutput_(Q, oe, pe) {
                    if (!this.markerBlock_)
                        throw Error("createDom should be called before positioning the output");
                    Q = qn(Q, 0) + ln("h", -(Q - pe.width)) + ln("v", this.constants_.TAB_OFFSET_FROM_TOP) + pe.pathDown + ln("V", oe) + ln("H", Q),
                    this.markerBlock_.setAttribute("d", Q),
                    this.workspace.RTL && this.flipRtl(this.markerBlock_),
                    this.currentMarkerSvg = this.markerBlock_
                }
                positionPrevious_(Q, oe, pe, Ae) {
                    if (!this.markerBlock_)
                        throw Error("createDom should be called before positioning the previous connection marker");
                    Q = qn(-oe, pe) + ln("V", -oe) + ln("H", this.constants_.NOTCH_OFFSET_LEFT) + Ae.pathLeft + ln("H", Q + 2 * oe) + ln("V", pe),
                    this.markerBlock_.setAttribute("d", Q),
                    this.workspace.RTL && this.flipRtl(this.markerBlock_),
                    this.currentMarkerSvg = this.markerBlock_
                }
                positionRect_(Q, oe, pe, Ae) {
                    if (!this.markerSvgRect_)
                        throw Error("createDom should be called before positioning the rect");
                    this.markerSvgRect_.setAttribute("x", `${Q}`),
                    this.markerSvgRect_.setAttribute("y", `${oe}`),
                    this.markerSvgRect_.setAttribute("width", `${pe}`),
                    this.markerSvgRect_.setAttribute("height", `${Ae}`),
                    this.currentMarkerSvg = this.markerSvgRect_
                }
                flipRtl(Q) {
                    Q.setAttribute("transform", "scale(-1 1)")
                }
                hide() {
                    if (!(this.markerSvgLine_ && this.markerSvgRect_ && this.markerInput_ && this.markerBlock_))
                        throw Error("createDom should be called before hiding the marker");
                    this.markerSvgLine_.style.display = "none",
                    this.markerSvgRect_.style.display = "none",
                    this.markerInput_.style.display = "none",
                    this.markerBlock_.style.display = "none"
                }
                fireMarkerEvent(Q, oe) {
                    const pe = oe.getSourceBlock();
                    Q = new (gt(Ui))(pe,this.isCursor(),Q,oe),
                    Ye(Q)
                }
                getBlinkProperties_() {
                    return {
                        attributeType: "XML",
                        attributeName: "fill",
                        dur: "1s",
                        values: this.colour_ + ";transparent;transparent;",
                        repeatCount: "indefinite"
                    }
                }
                createDomInternal_() {
                    if (this.markerSvg_ = $t(bt.G, {
                        width: this.constants_.CURSOR_WS_WIDTH,
                        height: this.constants_.WS_CURSOR_HEIGHT
                    }, this.svgGroup_),
                    this.markerSvgLine_ = $t(bt.RECT, {
                        width: this.constants_.CURSOR_WS_WIDTH,
                        height: this.constants_.WS_CURSOR_HEIGHT
                    }, this.markerSvg_),
                    this.markerSvgRect_ = $t(bt.RECT, {
                        class: "blocklyVerticalMarker",
                        rx: 10,
                        ry: 10
                    }, this.markerSvg_),
                    this.markerInput_ = $t(bt.PATH, {
                        transform: ""
                    }, this.markerSvg_),
                    this.markerBlock_ = $t(bt.PATH, {
                        transform: "",
                        fill: "none",
                        "stroke-width": this.constants_.CURSOR_STROKE_WIDTH
                    }, this.markerSvg_),
                    this.hide(),
                    this.isCursor()) {
                        const Q = this.getBlinkProperties_();
                        $t(bt.ANIMATE, Q, this.markerSvgLine_),
                        $t(bt.ANIMATE, Q, this.markerInput_),
                        $t(bt.ANIMATE, Object.assign({}, Q, {
                            attributeName: "stroke"
                        }), this.markerBlock_)
                    }
                    return this.markerSvg_
                }
                applyColour_(Q) {
                    if (!(this.markerSvgLine_ && this.markerSvgRect_ && this.markerInput_ && this.markerBlock_))
                        throw Error("createDom should be called before applying color to the markerj");
                    this.markerSvgLine_.setAttribute("fill", this.colour_),
                    this.markerSvgRect_.setAttribute("stroke", this.colour_),
                    this.markerInput_.setAttribute("fill", this.colour_),
                    this.markerBlock_.setAttribute("stroke", this.colour_),
                    this.isCursor() && (Q = this.colour_ + ";transparent;transparent;",
                    this.markerSvgLine_.firstElementChild.setAttribute("values", Q),
                    this.markerInput_.firstElementChild.setAttribute("values", Q),
                    this.markerBlock_.firstElementChild.setAttribute("values", Q))
                }
                dispose() {
                    this.svgGroup_ && Bt(this.svgGroup_)
                }
            }
              , Lc = class {
                constructor(Q, oe, pe) {
                    this.markerSvg = this.cursorSvg = null,
                    this.constants = pe,
                    this.style = oe,
                    this.svgRoot = Q,
                    this.svgPath = $t(bt.PATH, {
                        class: "blocklyPath"
                    }, this.svgRoot)
                }
                setPath(Q) {
                    this.svgPath.setAttribute("d", Q)
                }
                flipRTL() {
                    this.svgPath.setAttribute("transform", "scale(-1 1)")
                }
                setCursorSvg(Q) {
                    Q ? (this.svgRoot.appendChild(Q),
                    this.cursorSvg = Q) : this.cursorSvg = null
                }
                setMarkerSvg(Q) {
                    Q ? (this.cursorSvg ? this.svgRoot.insertBefore(Q, this.cursorSvg) : this.svgRoot.appendChild(Q),
                    this.markerSvg = Q) : this.markerSvg = null
                }
                applyColour(Q) {
                    this.svgPath.setAttribute("stroke", this.style.colourTertiary),
                    this.svgPath.setAttribute("fill", this.style.colourPrimary),
                    this.updateShadow_(Q.isShadow()),
                    this.updateDisabled_(!Q.isEnabled() || Q.getInheritedDisabled())
                }
                setStyle(Q) {
                    this.style = Q
                }
                setClass_(Q, oe) {
                    Q && (oe ? Ut(this.svgRoot, Q) : yt(this.svgRoot, Q))
                }
                updateHighlighted(Q) {
                    Q ? this.svgPath.setAttribute("filter", "url(#" + this.constants.embossFilterId + ")") : this.svgPath.setAttribute("filter", "none")
                }
                updateShadow_(Q) {
                    Q && (this.svgPath.setAttribute("stroke", "none"),
                    this.svgPath.setAttribute("fill", this.style.colourSecondary))
                }
                updateDisabled_(Q) {
                    this.setClass_("blocklyDisabled", Q),
                    Q && this.svgPath.setAttribute("fill", "url(#" + this.constants.disabledPatternId + ")")
                }
                updateSelected(Q) {
                    this.setClass_("blocklySelected", Q)
                }
                updateDraggingDelete(Q) {
                    this.setClass_("blocklyDraggingDelete", Q)
                }
                updateInsertionMarker(Q) {
                    this.setClass_("blocklyInsertionMarker", Q)
                }
                updateMovable(Q) {
                    this.setClass_("blocklyDraggable", Q)
                }
                updateReplacementFade(Q) {
                    this.setClass_("blocklyReplaceable", Q)
                }
                updateShapeForInputHighlight(Q, oe) {}
            }
              , Pn = class {
                constructor(Q, oe) {
                    this.type = oe,
                    this.targetConnection = null,
                    this.disposed = !1,
                    this.shadowDom = this.check = null,
                    this.y = this.x = 0,
                    this.shadowState = null,
                    this.sourceBlock_ = Q
                }
                connect_(Q) {
                    const oe = pn.INPUT_VALUE
                      , pe = this.getSourceBlock();
                    var Ae = Q.getSourceBlock();
                    Q.isConnected() && Q.disconnectInternal(!1);
                    let Re;
                    if (this.isConnected()) {
                        const tt = this.stashShadowState()
                          , dt = this.targetBlock();
                        dt.isShadow() ? dt.dispose(!1) : (this.disconnectInternal(),
                        Re = dt),
                        this.applyShadowState(tt)
                    }
                    let Ue;
                    Ke() && (Ue = new (gt(J.MOVE$$module$build$src$core$events$utils))(Ae),
                    Ue.setReason(["connect"])),
                    uf(this, Q),
                    Ae.setParent(pe),
                    Ue && (Ue.recordNew(),
                    Ye(Ue)),
                    Re && (Q = this.type === oe ? Re.outputConnection : Re.previousConnection) && ((Ae = Pn.getConnectionForOrphanedConnection(Ae, Q)) ? Q.connect(Ae) : Q.onFailedConnect(this))
                }
                dispose() {
                    if (this.isConnected()) {
                        this.setShadowStateInternal();
                        const Q = this.targetBlock();
                        Q && !Q.isDeadOrDying() && Q.unplug()
                    }
                    this.disposed = !0
                }
                getSourceBlock() {
                    return this.sourceBlock_
                }
                isSuperior() {
                    return this.type === pn.INPUT_VALUE || this.type === pn.NEXT_STATEMENT
                }
                isConnected() {
                    return !!this.targetConnection
                }
                getConnectionChecker() {
                    return this.sourceBlock_.workspace.connectionChecker
                }
                onFailedConnect(Q) {}
                connect(Q) {
                    if (this.targetConnection === Q)
                        return !0;
                    if (this.getConnectionChecker().canConnect(this, Q, !1)) {
                        const oe = J.getGroup$$module$build$src$core$events$utils();
                        oe || J.setGroup$$module$build$src$core$events$utils(!0),
                        this.isSuperior() ? this.connect_(Q) : Q.connect_(this),
                        J.setGroup$$module$build$src$core$events$utils(oe)
                    }
                    return this.isConnected()
                }
                disconnect() {
                    this.disconnectInternal()
                }
                disconnectInternal(Q=!0) {
                    const {parentConnection: oe, childConnection: pe} = this.getParentAndChildConnections();
                    if (!oe || !pe)
                        throw Error("Source connection not connected.");
                    const Ae = J.getGroup$$module$build$src$core$events$utils();
                    Ae || J.setGroup$$module$build$src$core$events$utils(!0);
                    let Re;
                    Ke() && (Re = new (gt(J.MOVE$$module$build$src$core$events$utils))(pe.getSourceBlock()),
                    Re.setReason(["disconnect"]));
                    const Ue = this.targetConnection;
                    Ue && (Ue.targetConnection = null),
                    this.targetConnection = null,
                    Q && pe.getSourceBlock().setParent(null),
                    Re && (Re.recordNew(),
                    Ye(Re)),
                    pe.getSourceBlock().isShadow() || oe.respawnShadow_(),
                    J.setGroup$$module$build$src$core$events$utils(Ae)
                }
                getParentAndChildConnections() {
                    return this.targetConnection ? this.isSuperior() ? {
                        parentConnection: this,
                        childConnection: this.targetConnection
                    } : {
                        parentConnection: this.targetConnection,
                        childConnection: this
                    } : {}
                }
                respawnShadow_() {
                    this.createShadowBlock(!0)
                }
                reconnect(Q, oe) {
                    if (this.getSourceBlock().isDeadOrDying())
                        return !1;
                    var pe;
                    return oe = (pe = Q.getInput(oe)) == null ? void 0 : pe.connection,
                    pe = this.targetBlock(),
                    pe && pe !== Q || !oe || oe.targetConnection === this ? !1 : (oe.isConnected() && oe.disconnect(),
                    oe.connect(this),
                    !0)
                }
                targetBlock() {
                    if (this.isConnected()) {
                        let Q, oe;
                        return (oe = (Q = this.targetConnection) == null ? void 0 : Q.getSourceBlock()) != null ? oe : null
                    }
                    return null
                }
                onCheckChanged_() {
                    !this.isConnected() || this.targetConnection && this.getConnectionChecker().canConnect(this, this.targetConnection, !1) || (this.isSuperior() ? this.targetBlock() : this.sourceBlock_).unplug()
                }
                setCheck(Q) {
                    return Q ? (Array.isArray(Q) || (Q = [Q]),
                    this.check = Q,
                    this.onCheckChanged_()) : this.check = null,
                    this
                }
                getCheck() {
                    return this.check
                }
                setShadowDom(Q) {
                    this.setShadowStateInternal({
                        shadowDom: Q
                    })
                }
                getShadowDom(Q) {
                    return Q && this.targetBlock().isShadow() ? ao(this.targetBlock()) : this.shadowDom
                }
                setShadowState(Q) {
                    this.setShadowStateInternal({
                        shadowState: Q
                    })
                }
                getShadowState(Q) {
                    return Q && this.targetBlock() && this.targetBlock().isShadow() ? Ts(this.targetBlock()) : this.shadowState
                }
                neighbours(Q) {
                    return []
                }
                getParentInput() {
                    let Q = null;
                    const oe = this.sourceBlock_.inputList;
                    for (let pe = 0; pe < oe.length; pe++)
                        if (oe[pe].connection === this) {
                            Q = oe[pe];
                            break
                        }
                    return Q
                }
                toString() {
                    const Q = this.sourceBlock_;
                    if (!Q)
                        return "Orphan Connection";
                    if (Q.outputConnection === this)
                        var oe = "Output Connection of ";
                    else if (Q.previousConnection === this)
                        oe = "Previous Connection of ";
                    else if (Q.nextConnection === this)
                        oe = "Next Connection of ";
                    else {
                        oe = null;
                        for (let pe = 0, Ae; Ae = Q.inputList[pe]; pe++)
                            if (Ae.connection === this) {
                                oe = Ae;
                                break
                            }
                        if (oe)
                            oe = 'Input "' + oe.name + '" connection on ';
                        else
                            return console.warn("Connection not actually connected to sourceBlock_"),
                            "Orphan Connection"
                    }
                    return oe + Q.toDevString()
                }
                stashShadowState() {
                    const Q = this.getShadowDom(!0)
                      , oe = this.getShadowState(!0);
                    return this.shadowState = this.shadowDom = null,
                    {
                        shadowDom: Q,
                        shadowState: oe
                    }
                }
                applyShadowState({shadowDom: Q, shadowState: oe}) {
                    this.shadowDom = Q,
                    this.shadowState = oe
                }
                setShadowStateInternal({shadowDom: Q=null, shadowState: oe=null}={}) {
                    this.shadowDom = Q,
                    this.shadowState = oe,
                    (Q = this.targetBlock()) ? Q.isShadow() ? (Q.dispose(!1),
                    this.getSourceBlock().isDeadOrDying() || (this.respawnShadow_(),
                    this.targetBlock() && this.targetBlock().isShadow() && this.serializeShadow(this.targetBlock()))) : (Q = this.createShadowBlock(!1),
                    this.serializeShadow(Q),
                    Q && Q.dispose(!1)) : (this.respawnShadow_(),
                    this.targetBlock() && this.targetBlock().isShadow() && this.serializeShadow(this.targetBlock()))
                }
                createShadowBlock(Q) {
                    var oe = this.getSourceBlock();
                    const pe = this.getShadowState()
                      , Ae = this.getShadowDom();
                    if (oe.isDeadOrDying() || !pe && !Ae)
                        return null;
                    if (pe)
                        return oe = Ri(pe, oe.workspace, {
                            parentConnection: Q ? this : void 0,
                            isShadow: !0,
                            recordUndo: !1
                        });
                    if (Ae) {
                        if (oe = lo(Ae, oe.workspace),
                        Q)
                            if (this.type === pn.INPUT_VALUE) {
                                if (!oe.outputConnection)
                                    throw Error("Shadow block is missing an output connection");
                                if (!this.connect(oe.outputConnection))
                                    throw Error("Could not connect shadow block to connection")
                            } else if (this.type === pn.NEXT_STATEMENT) {
                                if (!oe.previousConnection)
                                    throw Error("Shadow block is missing previous connection");
                                if (!this.connect(oe.previousConnection))
                                    throw Error("Could not connect shadow block to connection")
                            } else
                                throw Error("Cannot connect a shadow block to a previous/output connection");
                        return oe
                    }
                    return null
                }
                serializeShadow(Q) {
                    Q && (this.shadowDom = ao(Q),
                    this.shadowState = Ts(Q))
                }
                static getConnectionForOrphanedConnection(Q, oe) {
                    if (oe.type === pn.OUTPUT_VALUE)
                        return hf(Q, oe.getSourceBlock());
                    Q = Q.lastConnectionInStack(!0);
                    const pe = oe.getConnectionChecker();
                    return Q && pe.canConnect(oe, Q, !1) ? Q : null
                }
            }
            ;
            Pn.CAN_CONNECT = 0,
            Pn.REASON_SELF_CONNECTION = 1,
            Pn.REASON_WRONG_TYPE = 2,
            Pn.REASON_TARGET_NULL = 3,
            Pn.REASON_CHECKS_FAILED = 4,
            Pn.REASON_DIFFERENT_WORKSPACES = 5,
            Pn.REASON_SHADOW_PARENT = 6,
            Pn.REASON_DRAG_CHECKS_FAILED = 7,
            Pn.REASON_PREVIOUS_AND_OUTPUT = 8;
            var aa = "_TEMP_COLLAPSED_INPUT"
              , Pc = "_TEMP_COLLAPSED_FIELD"
              , _T = {
                COLLAPSED_FIELD_NAME: Pc,
                COLLAPSED_INPUT_NAME: aa
            }
              , jg = "The insertion marker manager tried to create a marker but the result is missing %1. If you are using a mutator, make sure your domToMutation method is properly defined."
              , Wr = class {
                constructor(Q) {
                    this.activeCandidate = this.lastMarker = this.lastOnStack = null,
                    this.wouldDeleteBlock = !1,
                    this.fadedBlock = this.highlightedBlock = this.markerConnection = null,
                    Fe(Q),
                    this.topBlock = Q,
                    this.workspace = Q.workspace,
                    this.firstMarker = this.createMarkerBlock(this.topBlock),
                    this.availableConnections = this.initAvailableConnections(),
                    this.lastOnStack && (this.lastMarker = this.createMarkerBlock(this.lastOnStack.getSourceBlock()))
                }
                dispose() {
                    this.availableConnections.length = 0,
                    this.disposeInsertionMarker(this.firstMarker),
                    this.disposeInsertionMarker(this.lastMarker)
                }
                updateAvailableConnections() {
                    this.availableConnections = this.initAvailableConnections()
                }
                wouldConnectBlock() {
                    return !!this.activeCandidate
                }
                applyConnections() {
                    if (this.activeCandidate) {
                        J.disable$$module$build$src$core$events$utils(),
                        this.hidePreview(),
                        J.enable$$module$build$src$core$events$utils();
                        var {local: Q, closest: oe} = this.activeCandidate;
                        if (Q.connect(oe),
                        this.topBlock.rendered) {
                            const pe = Q.isSuperior() ? oe : Q
                              , Ae = this.topBlock.getRootBlock();
                            Na().then( () => {
                                Cu(pe.getSourceBlock()),
                                setTimeout( () => {
                                    Ae.bringToFront()
                                }
                                , 0)
                            }
                            )
                        }
                    }
                }
                update(Q, oe) {
                    const pe = this.getCandidate(Q);
                    ((this.wouldDeleteBlock = this.shouldDelete(!!pe, oe)) || this.shouldUpdatePreviews(pe, Q)) && (J.disable$$module$build$src$core$events$utils(),
                    this.maybeHidePreview(pe),
                    this.maybeShowPreview(pe),
                    J.enable$$module$build$src$core$events$utils())
                }
                createMarkerBlock(Q) {
                    var oe = Q.type;
                    J.disable$$module$build$src$core$events$utils();
                    let pe;
                    try {
                        if (pe = this.workspace.newBlock(oe),
                        pe.setInsertionMarker(!0),
                        Q.saveExtraState) {
                            var Ae = Q.saveExtraState(!0);
                            Ae && pe.loadExtraState && pe.loadExtraState(Ae)
                        } else if (Q.mutationToDom) {
                            const Re = Q.mutationToDom();
                            Re && pe.domToMutation && pe.domToMutation(Re)
                        }
                        for (oe = 0; oe < Q.inputList.length; oe++) {
                            const Re = Q.inputList[oe];
                            if (Re.name === aa)
                                continue;
                            const Ue = pe.inputList[oe];
                            if (!Ue)
                                throw Error(jg.replace("%1", "an input"));
                            for (Ae = 0; Ae < Re.fieldRow.length; Ae++) {
                                const tt = Re.fieldRow[Ae]
                                  , dt = Ue.fieldRow[Ae];
                                if (!dt)
                                    throw Error(jg.replace("%1", "a field"));
                                dt.setValue(tt.getValue())
                            }
                        }
                        for (const Re of pe.getDescendants(!1))
                            Re.setInsertionMarker(!0);
                        pe.setCollapsed(Q.isCollapsed()),
                        pe.setInputsInline(Q.getInputsInline()),
                        pe.initSvg(),
                        pe.getSvgRoot().setAttribute("visibility", "hidden")
                    } finally {
                        J.enable$$module$build$src$core$events$utils()
                    }
                    return pe
                }
                initAvailableConnections() {
                    const Q = this.topBlock.getConnections_(!1)
                      , oe = this.topBlock.lastConnectionInStack(!0);
                    return oe && oe !== this.topBlock.nextConnection && (Q.push(oe),
                    this.lastOnStack = oe),
                    Q
                }
                shouldUpdatePreviews(Q, oe) {
                    if (!Q)
                        return !!this.activeCandidate;
                    if (!this.activeCandidate)
                        return !0;
                    const {local: pe, closest: Ae} = this.activeCandidate;
                    if (Ae === Q.closest && pe === Q.local)
                        return !1;
                    const Re = pe.x + oe.x - Ae.x;
                    return oe = pe.y + oe.y - Ae.y,
                    Q.radius < Math.sqrt(Re * Re + oe * oe) - J.config$$module$build$src$core$config.currentConnectionPreference
                }
                getCandidate(Q) {
                    this.markerConnection && this.markerConnection.isConnected() || this.updateAvailableConnections();
                    let oe = this.getStartRadius()
                      , pe = null;
                    for (let Ae = 0; Ae < this.availableConnections.length; Ae++) {
                        const Re = this.availableConnections[Ae]
                          , Ue = Re.closest(oe, Q);
                        Ue.connection && (pe = {
                            closest: Ue.connection,
                            local: Re,
                            radius: Ue.radius
                        },
                        oe = Ue.radius)
                    }
                    return pe
                }
                getStartRadius() {
                    return this.activeCandidate ? J.config$$module$build$src$core$config.connectingSnapRadius : J.config$$module$build$src$core$config.snapRadius
                }
                shouldDelete(Q, oe) {
                    return oe && this.workspace.getComponentManager().hasCapability(oe.id, dr.Capability.DELETE_AREA) ? oe.wouldDelete(this.topBlock, Q) : !1
                }
                maybeShowPreview(Q) {
                    if (!this.wouldDeleteBlock && Q) {
                        var oe = Q.closest, pe;
                        oe === ((pe = this.activeCandidate) == null ? void 0 : pe.closest) || oe.getSourceBlock().isInsertionMarker() ? console.log("Trying to connect to an insertion marker") : (this.activeCandidate = Q,
                        this.showPreview(this.activeCandidate))
                    }
                }
                showPreview(Q) {
                    const oe = this.workspace.getRenderer();
                    switch (oe.getConnectionPreviewMethod(Q.closest, Q.local, this.topBlock)) {
                    case Wr.PREVIEW_TYPE.INPUT_OUTLINE:
                        this.showInsertionInputOutline(Q);
                        break;
                    case Wr.PREVIEW_TYPE.INSERTION_MARKER:
                        this.showInsertionMarker(Q);
                        break;
                    case Wr.PREVIEW_TYPE.REPLACEMENT_FADE:
                        this.showReplacementFade(Q)
                    }
                    oe.shouldHighlightConnection(Q.closest) && Q.closest.highlight()
                }
                maybeHidePreview(Q) {
                    if (!Q)
                        this.hidePreview();
                    else if (this.activeCandidate) {
                        const oe = this.activeCandidate.local !== Q.local;
                        (this.activeCandidate.closest !== Q.closest || oe || this.wouldDeleteBlock) && this.hidePreview()
                    }
                    this.activeCandidate = this.markerConnection = null
                }
                hidePreview() {
                    let Q;
                    const oe = (Q = this.activeCandidate) == null ? void 0 : Q.closest;
                    oe && oe.targetBlock() && this.workspace.getRenderer().shouldHighlightConnection(oe) && oe.unhighlight(),
                    this.hideReplacementFade(),
                    this.hideInsertionInputOutline(),
                    this.hideInsertionMarker()
                }
                showInsertionMarker(Q) {
                    const {local: oe, closest: pe} = Q;
                    let Ae = (Q = this.lastOnStack && oe === this.lastOnStack) ? this.lastMarker : this.firstMarker;
                    if (!Ae)
                        throw Error("Cannot show the insertion marker because there is no insertion marker block");
                    let Re;
                    try {
                        Re = Ae.getMatchingConnection(oe.getSourceBlock(), oe)
                    } catch {
                        if (Q && this.lastOnStack ? (this.disposeInsertionMarker(this.lastMarker),
                        Ae = this.lastMarker = this.createMarkerBlock(this.lastOnStack.getSourceBlock())) : (this.disposeInsertionMarker(this.firstMarker),
                        Ae = this.firstMarker = this.createMarkerBlock(this.topBlock)),
                        !Ae)
                            throw Error("Cannot show the insertion marker because there is no insertion marker block");
                        Re = Ae.getMatchingConnection(oe.getSourceBlock(), oe)
                    }
                    if (!Re)
                        throw Error("Cannot show the insertion marker because there is no associated connection");
                    if (Re === this.markerConnection)
                        throw Error("Made it to showInsertionMarker_ even though the marker isn't changing");
                    Ae.queueRender(),
                    gs(),
                    Re.connect(pe);
                    const Ue = {
                        x: pe.x - Re.x,
                        y: pe.y - Re.y
                    }
                      , tt = Re.getOffsetInBlock().clone()
                      , dt = Re;
                    Na().then( () => {
                        let wt;
                        (wt = Ae) == null || wt.positionNearConnection(dt, Ue, tt);
                        let sn;
                        (sn = Ae) == null || sn.getSvgRoot().setAttribute("visibility", "visible")
                    }
                    ),
                    this.markerConnection = Re
                }
                hideInsertionMarker() {
                    if (this.markerConnection) {
                        var Q = this.markerConnection, oe = Q.getSourceBlock(), pe = oe.outputConnection, Ae;
                        if ((Ae = oe.previousConnection) != null && Ae.targetConnection || pe != null && pe.targetConnection)
                            oe.unplug(!0);
                        else {
                            let Re;
                            (Re = Q.targetBlock()) == null || Re.unplug(!1)
                        }
                        if (Q.targetConnection)
                            throw Error("markerConnection still connected at the end of disconnectInsertionMarker");
                        this.markerConnection = null,
                        (Q = oe.getSvgRoot()) && Q.setAttribute("visibility", "hidden")
                    }
                }
                showInsertionInputOutline(Q) {
                    Q = Q.closest,
                    this.highlightedBlock = Q.getSourceBlock(),
                    this.highlightedBlock.highlightShapeForInput(Q, !0)
                }
                hideInsertionInputOutline() {
                    if (this.highlightedBlock) {
                        if (!this.activeCandidate)
                            throw Error("Cannot hide the insertion marker outline because there is no active candidate");
                        this.highlightedBlock.highlightShapeForInput(this.activeCandidate.closest, !1),
                        this.highlightedBlock = null
                    }
                }
                showReplacementFade(Q) {
                    if (this.fadedBlock = Q.closest.targetBlock(),
                    !this.fadedBlock)
                        throw Error("Cannot show the replacement fade because the closest connection does not have a target block");
                    this.fadedBlock.fadeForReplacement(!0)
                }
                hideReplacementFade() {
                    this.fadedBlock && (this.fadedBlock.fadeForReplacement(!1),
                    this.fadedBlock = null)
                }
                getInsertionMarkers() {
                    const Q = [];
                    return this.firstMarker && Q.push(this.firstMarker),
                    this.lastMarker && Q.push(this.lastMarker),
                    Q
                }
                disposeInsertionMarker(Q) {
                    if (Q) {
                        J.disable$$module$build$src$core$events$utils();
                        try {
                            Q.dispose()
                        } finally {
                            J.enable$$module$build$src$core$events$utils()
                        }
                    }
                }
            }
            ;
            (function(Q) {
                Q = Q.PREVIEW_TYPE || (Q.PREVIEW_TYPE = {}),
                Q[Q.INSERTION_MARKER = 0] = "INSERTION_MARKER",
                Q[Q.INPUT_OUTLINE = 1] = "INPUT_OUTLINE",
                Q[Q.REPLACEMENT_FADE = 2] = "REPLACEMENT_FADE"
            }
            )(Wr || (Wr = {})),
            Wr.PREVIEW_TYPE;
            var dl = class {
                constructor(Q) {
                    this.overrides = null,
                    this.name = Q
                }
                getClassName() {
                    return this.name + "-renderer"
                }
                init(Q, oe) {
                    this.constants_ = this.makeConstants_(),
                    oe && (this.overrides = oe,
                    Object.assign(this.constants_, oe)),
                    this.constants_.setTheme(Q),
                    this.constants_.init()
                }
                createDom(Q, oe) {
                    this.constants_.createDom(Q, this.name + "-" + oe.name, "." + this.getClassName() + "." + oe.getClassName())
                }
                refreshDom(Q, oe) {
                    const pe = this.getConstants();
                    pe.dispose(),
                    this.constants_ = this.makeConstants_(),
                    this.overrides && Object.assign(this.constants_, this.overrides),
                    this.constants_.randomIdentifier = pe.randomIdentifier,
                    this.constants_.setTheme(oe),
                    this.constants_.init(),
                    this.createDom(Q, oe)
                }
                dispose() {
                    this.constants_ && this.constants_.dispose()
                }
                makeConstants_() {
                    return new cl
                }
                makeRenderInfo_(Q) {
                    return new ia(this,Q)
                }
                makeDrawer_(Q, oe) {
                    return new ul(Q,oe)
                }
                makeMarkerDrawer(Q, oe) {
                    return new Gh(Q,this.getConstants(),oe)
                }
                makePathObject(Q, oe) {
                    return new Lc(Q,oe,this.constants_)
                }
                getConstants() {
                    return this.constants_
                }
                shouldHighlightConnection(Q) {
                    return !0
                }
                orphanCanConnectAtEnd(Q, oe, pe) {
                    return !!Pn.getConnectionForOrphanedConnection(Q, pe === pn.OUTPUT_VALUE ? oe.outputConnection : oe.previousConnection)
                }
                getConnectionPreviewMethod(Q, oe, pe) {
                    return oe.type === pn.OUTPUT_VALUE || oe.type === pn.PREVIOUS_STATEMENT ? !Q.isConnected() || this.orphanCanConnectAtEnd(pe, Q.targetBlock(), oe.type) ? Wr.PREVIEW_TYPE.INSERTION_MARKER : Wr.PREVIEW_TYPE.REPLACEMENT_FADE : Wr.PREVIEW_TYPE.INSERTION_MARKER
                }
                render(Q) {
                    const oe = this.makeRenderInfo_(Q);
                    oe.measure(),
                    this.makeDrawer_(Q, oe).draw()
                }
            }
              , Bn = {};
            Bn.BottomRow = Dh,
            Bn.Connection = li,
            Bn.ConstantProvider = cl,
            Bn.Drawer = ul,
            Bn.ExternalValueInput = Nc,
            Bn.Field = oa,
            Bn.Hat = wh,
            Bn.Icon = wg,
            Bn.InRowSpacer = Gr,
            Bn.InlineInput = Bh,
            Bn.InputConnection = yo,
            Bn.InputRow = Uh,
            Bn.JaggedEdge = Bg,
            Bn.MarkerSvg = Gh,
            Bn.Measurable = vs,
            Bn.NextConnection = Ug,
            Bn.OutputConnection = Fg,
            Bn.PathObject = Lc,
            Bn.PreviousConnection = Hg,
            Bn.RenderInfo = ia,
            Bn.Renderer = dl,
            Bn.RoundCorner = al,
            Bn.Row = ol,
            Bn.SpacerRow = Fh,
            Bn.SquareCorner = ll,
            Bn.StatementInput = il,
            Bn.TopRow = Hh,
            Bn.Types = Rt,
            Bn.init = td,
            Bn.register = Mi,
            Bn.unregister = pf;
            var Wg = class {
                constructor(Q, oe) {
                    this.workspace = Q,
                    this.theme = oe,
                    this.subscribedWorkspaces_ = [],
                    this.componentDB = new Map
                }
                getTheme() {
                    return this.theme
                }
                setTheme(Q) {
                    var oe = this.theme;
                    this.theme = Q,
                    (Q = this.workspace.getInjectionDiv()) && (oe && (oe = oe.getClassName()) && yt(Q, oe),
                    (oe = this.theme.getClassName()) && Ut(Q, oe));
                    for (let pe = 0, Ae; Ae = this.subscribedWorkspaces_[pe]; pe++)
                        Ae.refreshTheme();
                    for (const [pe,Ae] of this.componentDB)
                        for (const Re of Ae) {
                            Q = Re.element,
                            oe = Re.propertyName;
                            const Ue = this.theme && this.theme.getComponentStyle(pe);
                            Q.style.setProperty(oe, Ue || "")
                        }
                    for (const pe of this.subscribedWorkspaces_)
                        pe.hideChaff()
                }
                subscribeWorkspace(Q) {
                    this.subscribedWorkspaces_.push(Q)
                }
                unsubscribeWorkspace(Q) {
                    if (!dn(this.subscribedWorkspaces_, Q))
                        throw Error("Cannot unsubscribe a workspace that hasn't been subscribed.")
                }
                subscribe(Q, oe, pe) {
                    this.componentDB.has(oe) || this.componentDB.set(oe, []),
                    this.componentDB.get(oe).push({
                        element: Q,
                        propertyName: pe
                    }),
                    oe = this.theme && this.theme.getComponentStyle(oe),
                    Q.style.setProperty(pe, oe || "")
                }
                unsubscribe(Q) {
                    if (Q)
                        for (const [oe,pe] of this.componentDB) {
                            for (let Ae = pe.length - 1; 0 <= Ae; Ae--)
                                pe[Ae].element === Q && pe.splice(Ae, 1);
                            pe.length || this.componentDB.delete(oe)
                        }
                }
                dispose() {
                    this.subscribedWorkspaces_.length = 0,
                    this.componentDB.clear()
                }
            }
              , jh = "VARIABLE_DYNAMIC"
              , ui = {
                CATEGORY_NAME: jh
            };
            ui.flyoutCategory = ql,
            ui.flyoutCategoryBlocks = od,
            ui.onCreateVariableButtonClick_Colour = sd,
            ui.onCreateVariableButtonClick_Number = rd,
            ui.onCreateVariableButtonClick_String = nd;
            var Yg = class {
                canConnect(Q, oe, pe, Ae) {
                    return this.canConnectWithReason(Q, oe, pe, Ae) === Pn.CAN_CONNECT
                }
                canConnectWithReason(Q, oe, pe, Ae) {
                    const Re = this.doSafetyChecks(Q, oe);
                    return Re !== Pn.CAN_CONNECT ? Re : this.doTypeChecks(Q, oe) ? pe && !this.doDragChecks(Q, oe, Ae || 0) ? Pn.REASON_DRAG_CHECKS_FAILED : Pn.CAN_CONNECT : Pn.REASON_CHECKS_FAILED
                }
                getErrorMessage(Q, oe, pe) {
                    switch (Q) {
                    case Pn.REASON_SELF_CONNECTION:
                        return "Attempted to connect a block to itself.";
                    case Pn.REASON_DIFFERENT_WORKSPACES:
                        return "Blocks not on same workspace.";
                    case Pn.REASON_WRONG_TYPE:
                        return "Attempt to connect incompatible types.";
                    case Pn.REASON_TARGET_NULL:
                        return "Target connection is null.";
                    case Pn.REASON_CHECKS_FAILED:
                        return "Connection checks failed. " + (oe + " expected " + oe.getCheck() + ", found " + pe.getCheck());
                    case Pn.REASON_SHADOW_PARENT:
                        return "Connecting non-shadow to shadow block.";
                    case Pn.REASON_DRAG_CHECKS_FAILED:
                        return "Drag checks failed.";
                    case Pn.REASON_PREVIOUS_AND_OUTPUT:
                        return "Block would have an output and a previous connection.";
                    default:
                        return "Unknown connection failure: this should never happen!"
                    }
                }
                doSafetyChecks(Q, oe) {
                    if (!Q || !oe)
                        return Pn.REASON_TARGET_NULL;
                    let pe, Ae, Re;
                    return Q.isSuperior() ? (pe = Q.getSourceBlock(),
                    Ae = oe.getSourceBlock(),
                    Re = oe) : (Ae = Q.getSourceBlock(),
                    pe = oe.getSourceBlock(),
                    Re = Q,
                    Q = oe),
                    pe === Ae ? Pn.REASON_SELF_CONNECTION : Re.type !== ri[Q.type] ? Pn.REASON_WRONG_TYPE : pe.workspace !== Ae.workspace ? Pn.REASON_DIFFERENT_WORKSPACES : pe.isShadow() && !Ae.isShadow() ? Pn.REASON_SHADOW_PARENT : Re.type === pn.OUTPUT_VALUE && Ae.previousConnection && Ae.previousConnection.isConnected() || Re.type === pn.PREVIOUS_STATEMENT && Ae.outputConnection && Ae.outputConnection.isConnected() ? Pn.REASON_PREVIOUS_AND_OUTPUT : Pn.CAN_CONNECT
                }
                doTypeChecks(Q, oe) {
                    if (Q = Q.getCheck(),
                    oe = oe.getCheck(),
                    !Q || !oe)
                        return !0;
                    for (let pe = 0; pe < Q.length; pe++)
                        if (oe.indexOf(Q[pe]) !== -1)
                            return !0;
                    return !1
                }
                doDragChecks(Q, oe, pe) {
                    if (Q.distanceFrom(oe) > pe || oe.getSourceBlock().isInsertionMarker())
                        return !1;
                    switch (oe.type) {
                    case pn.PREVIOUS_STATEMENT:
                        return this.canConnectToPrevious_(Q, oe);
                    case pn.OUTPUT_VALUE:
                        if (oe.isConnected() && !oe.targetBlock().isInsertionMarker() || Q.isConnected())
                            return !1;
                        break;
                    case pn.INPUT_VALUE:
                        if (oe.isConnected() && !oe.targetBlock().isMovable() && !oe.targetBlock().isShadow())
                            return !1;
                        break;
                    case pn.NEXT_STATEMENT:
                        if (oe.isConnected() && !Q.getSourceBlock().nextConnection && !oe.targetBlock().isShadow() && oe.targetBlock().nextConnection || oe.targetBlock() && !oe.targetBlock().isMovable() && !oe.targetBlock().isShadow())
                            return !1;
                        break;
                    default:
                        return !1
                    }
                    return Di.indexOf(oe) === -1
                }
                canConnectToPrevious_(Q, oe) {
                    return Q.targetConnection || Di.indexOf(oe) !== -1 ? !1 : oe.targetConnection ? (Q = oe.targetBlock(),
                    Q.isInsertionMarker() ? !Q.getPreviousBlock() : !1) : !0
                }
            }
            ;
            ne(Yt.CONNECTION_CHECKER, js, Yg);
            var Wh = class extends Ya {
                constructor(Q) {
                    super(Q),
                    this.type = Vo,
                    Q && (this.varType = Q.type,
                    this.varName = Q.name)
                }
                toJson() {
                    const Q = super.toJson();
                    if (this.varType === void 0)
                        throw Error("The var type is undefined. Either pass a variable to the constructor, or call fromJson");
                    if (!this.varName)
                        throw Error("The var name is undefined. Either pass a variable to the constructor, or call fromJson");
                    return Q.varType = this.varType,
                    Q.varName = this.varName,
                    Q
                }
                static fromJson(Q, oe, pe) {
                    return oe = super.fromJson(Q, oe, pe ?? new Wh),
                    oe.varType = Q.varType,
                    oe.varName = Q.varName,
                    oe
                }
                run(Q) {
                    const oe = this.getEventWorkspace_();
                    if (!this.varId)
                        throw Error("The var ID is undefined. Either pass a variable to the constructor, or call fromJson");
                    if (!this.varName)
                        throw Error("The var name is undefined. Either pass a variable to the constructor, or call fromJson");
                    Q ? oe.deleteVariableById(this.varId) : oe.createVariable(this.varName, this.varType, this.varId)
                }
            }
            ;
            ne(Yt.EVENT, Vo, Wh);
            var Yh = class extends Ya {
                constructor(Q, oe) {
                    super(Q),
                    this.type = Bi,
                    Q && (this.oldName = Q.name,
                    this.newName = typeof oe > "u" ? "" : oe)
                }
                toJson() {
                    const Q = super.toJson();
                    if (!this.oldName)
                        throw Error("The old var name is undefined. Either pass a variable to the constructor, or call fromJson");
                    if (!this.newName)
                        throw Error("The new var name is undefined. Either pass a value to the constructor, or call fromJson");
                    return Q.oldName = this.oldName,
                    Q.newName = this.newName,
                    Q
                }
                static fromJson(Q, oe, pe) {
                    return oe = super.fromJson(Q, oe, pe ?? new Yh),
                    oe.oldName = Q.oldName,
                    oe.newName = Q.newName,
                    oe
                }
                run(Q) {
                    const oe = this.getEventWorkspace_();
                    if (!this.varId)
                        throw Error("The var ID is undefined. Either pass a variable to the constructor, or call fromJson");
                    if (!this.oldName)
                        throw Error("The old var name is undefined. Either pass a variable to the constructor, or call fromJson");
                    if (!this.newName)
                        throw Error("The new var name is undefined. Either pass a value to the constructor, or call fromJson");
                    Q ? oe.renameVariableById(this.varId, this.newName) : oe.renameVariableById(this.varId, this.oldName)
                }
            }
            ;
            ne(Yt.EVENT, Bi, Yh);
            var Xh = class {
                constructor(Q) {
                    this.workspace = Q,
                    this.variableMap = new Map
                }
                clear() {
                    for (const Q of this.variableMap.values())
                        for (; 0 < Q.length; )
                            this.deleteVariable(Q[0]);
                    if (this.variableMap.size !== 0)
                        throw Error("Non-empty variable map")
                }
                renameVariable(Q, oe) {
                    if (Q.name !== oe) {
                        var pe = this.getVariable(oe, Q.type)
                          , Ae = this.workspace.getAllBlocks(!1)
                          , Re = J.getGroup$$module$build$src$core$events$utils();
                        Re || J.setGroup$$module$build$src$core$events$utils(!0);
                        try {
                            pe && pe.getId() !== Q.getId() ? this.renameVariableWithConflict_(Q, oe, pe, Ae) : this.renameVariableAndUses_(Q, oe, Ae)
                        } finally {
                            J.setGroup$$module$build$src$core$events$utils(Re)
                        }
                    }
                }
                renameVariableById(Q, oe) {
                    const pe = this.getVariableById(Q);
                    if (!pe)
                        throw Error("Tried to rename a variable that didn't exist. ID: " + Q);
                    this.renameVariable(pe, oe)
                }
                renameVariableAndUses_(Q, oe, pe) {
                    for (Ye(new (gt(Bi))(Q,oe)),
                    Q.name = oe,
                    oe = 0; oe < pe.length; oe++)
                        pe[oe].updateVarName(Q)
                }
                renameVariableWithConflict_(Q, oe, pe, Ae) {
                    const Re = Q.type;
                    for (oe !== pe.name && this.renameVariableAndUses_(pe, oe, Ae),
                    oe = 0; oe < Ae.length; oe++)
                        Ae[oe].renameVarById(Q.getId(), pe.getId());
                    Ye(new (gt(Vo))(Q)),
                    dn(this.variableMap.get(Re), Q)
                }
                createVariable(Q, oe, pe) {
                    var Ae = this.getVariable(Q, oe);
                    if (Ae) {
                        if (pe && Ae.getId() !== pe)
                            throw Error('Variable "' + Q + '" is already in use and its id is "' + Ae.getId() + '" which conflicts with the passed in id, "' + pe + '".');
                        return Ae
                    }
                    if (pe && this.getVariableById(pe))
                        throw Error('Variable id, "' + pe + '", is already in use.');
                    return Ae = pe || rt(),
                    oe = oe || "",
                    Ae = new Xa(this.workspace,Q,oe,Ae),
                    Q = this.variableMap.get(oe) || [],
                    Q.push(Ae),
                    this.variableMap.delete(oe),
                    this.variableMap.set(oe, Q),
                    Ye(new (gt(go))(Ae)),
                    Ae
                }
                deleteVariable(Q) {
                    const oe = Q.getId()
                      , pe = this.variableMap.get(Q.type);
                    if (pe) {
                        for (let Ae = 0; Ae < pe.length; Ae++)
                            if (pe[Ae].getId() === oe) {
                                pe.splice(Ae, 1),
                                Ye(new (gt(Vo))(Q)),
                                pe.length === 0 && this.variableMap.delete(Q.type);
                                break
                            }
                    }
                }
                deleteVariableById(Q) {
                    const oe = this.getVariableById(Q);
                    if (oe) {
                        var pe = oe.name;
                        const Ae = this.getVariableUsesById(Q);
                        for (let Re = 0, Ue; Ue = Ae[Re]; Re++)
                            if (Ue.type === "procedures_defnoreturn" || Ue.type === "procedures_defreturn") {
                                Q = String(Ue.getFieldValue("NAME")),
                                pe = J.Msg$$module$build$src$core$msg.CANNOT_DELETE_VARIABLE_PROCEDURE.replace("%1", pe).replace("%2", Q),
                                Hs(pe);
                                return
                            }
                        1 < Ae.length ? (pe = J.Msg$$module$build$src$core$msg.DELETE_VARIABLE_CONFIRMATION.replace("%1", String(Ae.length)).replace("%2", pe),
                        zr(pe, Re => {
                            Re && oe && this.deleteVariableInternal(oe, Ae)
                        }
                        )) : this.deleteVariableInternal(oe, Ae)
                    } else
                        console.warn("Can't delete non-existent variable: " + Q)
                }
                deleteVariableInternal(Q, oe) {
                    const pe = J.getGroup$$module$build$src$core$events$utils();
                    pe || J.setGroup$$module$build$src$core$events$utils(!0);
                    try {
                        for (let Ae = 0; Ae < oe.length; Ae++)
                            oe[Ae].dispose(!0);
                        this.deleteVariable(Q)
                    } finally {
                        J.setGroup$$module$build$src$core$events$utils(pe)
                    }
                }
                getVariable(Q, oe) {
                    if (oe = this.variableMap.get(oe || "")) {
                        for (let pe = 0, Ae; Ae = oe[pe]; pe++)
                            if (J.Names$$module$build$src$core$names.equals(Ae.name, Q))
                                return Ae
                    }
                    return null
                }
                getVariableById(Q) {
                    for (const oe of this.variableMap.values())
                        for (const pe of oe)
                            if (pe.getId() === Q)
                                return pe;
                    return null
                }
                getVariablesOfType(Q) {
                    return (Q = this.variableMap.get(Q || "")) ? Q.slice() : []
                }
                getVariableTypes(Q) {
                    const oe = new Set(this.variableMap.keys());
                    if (Q && Q.getPotentialVariableMap())
                        for (const pe of Q.getPotentialVariableMap().variableMap.keys())
                            oe.add(pe);
                    return oe.has("") || oe.add(""),
                    Array.from(oe.values())
                }
                getAllVariables() {
                    let Q = [];
                    for (const oe of this.variableMap.values())
                        Q = Q.concat(oe);
                    return Q
                }
                getAllVariableNames() {
                    return Array.from(this.variableMap.values()).flat().map(Q => Q.name)
                }
                getVariableUsesById(Q) {
                    const oe = []
                      , pe = this.workspace.getAllBlocks(!1);
                    for (let Ae = 0; Ae < pe.length; Ae++) {
                        const Re = pe[Ae].getVarModels();
                        if (Re)
                            for (let Ue = 0; Ue < Re.length; Ue++)
                                Re[Ue].getId() === Q && oe.push(pe[Ae])
                    }
                    return oe
                }
            }
              , hl = class {
                get isFlyout() {
                    return this.internalIsFlyout
                }
                get isMutator() {
                    return this.internalIsMutator
                }
                constructor(Q) {
                    this.isClearing = this.internalIsMutator = this.internalIsFlyout = this.rendered = !1,
                    this.MAX_UNDO = 1024,
                    this.connectionDBList = [],
                    this.topBlocks = [],
                    this.topComments = [],
                    this.commentDB = new Map,
                    this.listeners = [],
                    this.undoStack_ = [],
                    this.redoStack_ = [],
                    this.blockDB = new Map,
                    this.typedBlocksDB = new Map,
                    this.procedureMap = new xg,
                    this.potentialVariableMap = null,
                    this.id = rt(),
                    Ne(this),
                    this.options = Q || new Qr({}),
                    this.RTL = !!this.options.RTL,
                    this.horizontalLayout = !!this.options.horizontalLayout,
                    this.toolboxPosition = this.options.toolboxPosition,
                    this.connectionChecker = new (Ie(Yt.CONNECTION_CHECKER, this.options, !0))(this),
                    this.variableMap = new Xh(this)
                }
                dispose() {
                    this.listeners.length = 0,
                    this.clear(),
                    ve(this)
                }
                sortObjects_(Q, oe) {
                    const pe = Math.sin(bi(hl.SCAN_ANGLE)) * (this.RTL ? -1 : 1);
                    return Q = Q.getRelativeToSurfaceXY(),
                    oe = oe.getRelativeToSurfaceXY(),
                    Q.y + pe * Q.x - (oe.y + pe * oe.x)
                }
                addTopBlock(Q) {
                    this.topBlocks.push(Q)
                }
                removeTopBlock(Q) {
                    if (!dn(this.topBlocks, Q))
                        throw Error("Block not present in workspace's list of top-most blocks.")
                }
                getTopBlocks(Q=!1) {
                    const oe = [].concat(this.topBlocks);
                    return Q && 1 < oe.length && oe.sort(this.sortObjects_.bind(this)),
                    oe
                }
                addTypedBlock(Q) {
                    this.typedBlocksDB.has(Q.type) || this.typedBlocksDB.set(Q.type, []),
                    this.typedBlocksDB.get(Q.type).push(Q)
                }
                removeTypedBlock(Q) {
                    dn(this.typedBlocksDB.get(Q.type), Q),
                    this.typedBlocksDB.get(Q.type).length || this.typedBlocksDB.delete(Q.type)
                }
                getBlocksByType(Q, oe=!1) {
                    return this.typedBlocksDB.has(Q) ? (Q = this.typedBlocksDB.get(Q).slice(0),
                    oe && Q && 1 < Q.length && Q.sort(this.sortObjects_.bind(this)),
                    Q.filter(function(pe) {
                        return !pe.isInsertionMarker()
                    })) : []
                }
                addTopComment(Q) {
                    this.topComments.push(Q),
                    this.commentDB.has(Q.id) && console.warn('Overriding an existing comment on this workspace, with id "' + Q.id + '"'),
                    this.commentDB.set(Q.id, Q)
                }
                removeTopComment(Q) {
                    if (!dn(this.topComments, Q))
                        throw Error("Comment not present in workspace's list of top-most comments.");
                    this.commentDB.delete(Q.id)
                }
                getTopComments(Q=!1) {
                    const oe = [].concat(this.topComments);
                    return Q && 1 < oe.length && oe.sort(this.sortObjects_.bind(this)),
                    oe
                }
                getAllBlocks(Q=!1) {
                    if (Q) {
                        var oe = this.getTopBlocks(!0);
                        Q = [];
                        for (let pe = 0; pe < oe.length; pe++)
                            Q.push(...oe[pe].getDescendants(!0))
                    } else
                        for (Q = this.getTopBlocks(!1),
                        oe = 0; oe < Q.length; oe++)
                            Q.push(...Q[oe].getChildren(!1));
                    return Q.filter(function(pe) {
                        return !pe.isInsertionMarker()
                    })
                }
                clear() {
                    this.isClearing = !0;
                    try {
                        const Q = J.getGroup$$module$build$src$core$events$utils();
                        for (Q || J.setGroup$$module$build$src$core$events$utils(!0); this.topBlocks.length; )
                            this.topBlocks[0].dispose(!1);
                        for (; this.topComments.length; )
                            this.topComments[this.topComments.length - 1].dispose();
                        J.setGroup$$module$build$src$core$events$utils(Q),
                        this.variableMap.clear(),
                        this.potentialVariableMap && this.potentialVariableMap.clear()
                    } finally {
                        this.isClearing = !1
                    }
                }
                renameVariableById(Q, oe) {
                    this.variableMap.renameVariableById(Q, oe)
                }
                createVariable(Q, oe, pe) {
                    return this.variableMap.createVariable(Q, oe, pe)
                }
                getVariableUsesById(Q) {
                    return this.variableMap.getVariableUsesById(Q)
                }
                deleteVariableById(Q) {
                    this.variableMap.deleteVariableById(Q)
                }
                getVariable(Q, oe) {
                    return this.variableMap.getVariable(Q, oe)
                }
                getVariableById(Q) {
                    return this.variableMap.getVariableById(Q)
                }
                getVariablesOfType(Q) {
                    return this.variableMap.getVariablesOfType(Q)
                }
                getVariableTypes() {
                    return this.variableMap.getVariableTypes(this)
                }
                getAllVariables() {
                    return this.variableMap.getAllVariables()
                }
                getAllVariableNames() {
                    return this.variableMap.getAllVariableNames()
                }
                getWidth() {
                    return 0
                }
                newBlock(Q, oe) {
                    throw Error("The implementation of newBlock should be monkey-patched in by blockly.ts")
                }
                remainingCapacity() {
                    return isNaN(this.options.maxBlocks) ? 1 / 0 : this.options.maxBlocks - this.getAllBlocks(!1).length
                }
                remainingCapacityOfType(Q) {
                    return this.options.maxInstances ? (this.options.maxInstances[Q] !== void 0 ? this.options.maxInstances[Q] : 1 / 0) - this.getBlocksByType(Q, !1).length : 1 / 0
                }
                isCapacityAvailable(Q) {
                    if (!this.hasBlockLimits())
                        return !0;
                    let oe = 0;
                    for (const pe in Q) {
                        if (Q[pe] > this.remainingCapacityOfType(pe))
                            return !1;
                        oe += Q[pe]
                    }
                    return !(oe > this.remainingCapacity())
                }
                hasBlockLimits() {
                    return this.options.maxBlocks !== 1 / 0 || !!this.options.maxInstances
                }
                getUndoStack() {
                    return this.undoStack_
                }
                getRedoStack() {
                    return this.redoStack_
                }
                undo(Q) {
                    var oe = Q ? this.redoStack_ : this.undoStack_
                      , pe = Q ? this.undoStack_ : this.redoStack_;
                    const Ae = oe.pop();
                    if (Ae) {
                        for (var Re = [Ae]; oe.length && Ae.group && Ae.group === oe[oe.length - 1].group; ) {
                            const Ue = oe.pop();
                            Ue && Re.push(Ue)
                        }
                        for (oe = 0; oe < Re.length; oe++)
                            pe.push(Re[oe]);
                        Re = ct(Re, Q),
                        ft(!1);
                        try {
                            for (pe = 0; pe < Re.length; pe++)
                                Re[pe].run(Q)
                        } finally {
                            ft(!0)
                        }
                    }
                }
                clearUndo() {
                    this.undoStack_.length = 0,
                    this.redoStack_.length = 0,
                    Et()
                }
                addChangeListener(Q) {
                    return this.listeners.push(Q),
                    Q
                }
                removeChangeListener(Q) {
                    dn(this.listeners, Q)
                }
                fireChangeListener(Q) {
                    if (Q.recordUndo)
                        for (this.undoStack_.push(Q),
                        this.redoStack_.length = 0; this.undoStack_.length > this.MAX_UNDO && 0 <= this.MAX_UNDO; )
                            this.undoStack_.shift();
                    for (let oe = 0; oe < this.listeners.length; oe++)
                        (0,
                        this.listeners[oe])(Q)
                }
                getBlockById(Q) {
                    return this.blockDB.get(Q) || null
                }
                setBlockById(Q, oe) {
                    this.blockDB.set(Q, oe)
                }
                removeBlockById(Q) {
                    this.blockDB.delete(Q)
                }
                getCommentById(Q) {
                    let oe;
                    return (oe = this.commentDB.get(Q)) != null ? oe : null
                }
                allInputsFilled(Q) {
                    const oe = this.getTopBlocks(!1);
                    for (let pe = 0; pe < oe.length; pe++)
                        if (!oe[pe].allInputsFilled(Q))
                            return !1;
                    return !0
                }
                getPotentialVariableMap() {
                    return this.potentialVariableMap
                }
                createPotentialVariableMap() {
                    this.potentialVariableMap = new Xh(this)
                }
                getVariableMap() {
                    return this.variableMap
                }
                setVariableMap(Q) {
                    this.variableMap = Q
                }
                getProcedureMap() {
                    return this.procedureMap
                }
                getRootWorkspace() {
                    let Q = null;
                    const oe = this.options.parentWorkspace;
                    return this.isFlyout ? oe && oe.options && (Q = oe.options.parentWorkspace) : oe && (Q = oe),
                    Q
                }
                static getById(Q) {
                    return ye(Q)
                }
                static getAll() {
                    return $e()
                }
            }
            ;
            hl.SCAN_ANGLE = 3;
            var ST = 100
              , Xg = class {
                constructor(Q) {
                    this.parentWorkspace = Q,
                    this.sounds = new Map,
                    this.lastSound_ = null
                }
                dispose() {
                    this.sounds.clear()
                }
                load(Q, oe) {
                    if (Q.length) {
                        try {
                            var pe = new globalThis.Audio
                        } catch {
                            return
                        }
                        for (let Re = 0; Re < Q.length; Re++) {
                            const Ue = Q[Re]
                              , tt = Ue.match(/\.(\w+)$/);
                            if (tt && pe.canPlayType("audio/" + tt[1])) {
                                var Ae = new globalThis.Audio(Ue);
                                break
                            }
                        }
                        Ae && this.sounds.set(oe, Ae)
                    }
                }
                preload() {
                    for (const Q of this.sounds.values()) {
                        Q.volume = .01;
                        const oe = Q.play();
                        if (oe !== void 0 ? oe.then(Q.pause).catch(function() {}) : Q.pause(),
                        Wi || jf)
                            break
                    }
                }
                play(Q, oe) {
                    var pe = this.sounds.get(Q);
                    pe ? (Q = new Date,
                    this.lastSound_ !== null && Q.getTime() - this.lastSound_.getTime() < ST || (this.lastSound_ = Q,
                    pe = Wi || cc ? pe : pe.cloneNode(),
                    pe.volume = oe === void 0 ? 1 : oe,
                    pe.play())) : this.parentWorkspace && this.parentWorkspace.getAudioManager().play(Q, oe)
                }
            }
              , IT = class {
                constructor(Q) {
                    this.workspace = Q,
                    this.layers = new Map,
                    (Q = Q.getInjectionDiv()) && (this.dragLayer = this.createDragLayer(Q)),
                    Q = this.createLayer(Sh),
                    Ut(Q, "blocklyBlockCanvas"),
                    Q = this.createLayer(Ih),
                    Ut(Q, "blocklyBubbleCanvas")
                }
                createDragLayer(Q) {
                    const oe = $t(bt.SVG, {
                        class: "blocklyBlockDragSurface",
                        xmlns: Ga,
                        "xmlns:html": Rs,
                        "xmlns:xlink": Fr,
                        version: "1.1"
                    });
                    return Q.append(oe),
                    $t(bt.G, {}, oe)
                }
                translateLayers(Q, oe) {
                    Q = `translate(${Q.x}, ${Q.y}) scale(${oe})`;
                    let pe;
                    (pe = this.dragLayer) == null || pe.setAttribute("transform", Q);
                    for (const [,Ae] of this.layers)
                        Ae.setAttribute("transform", Q)
                }
                moveToDragLayer(Q) {
                    let oe;
                    (oe = this.dragLayer) == null || oe.appendChild(Q.getSvgRoot())
                }
                moveOffDragLayer(Q, oe) {
                    this.append(Q, oe)
                }
                append(Q, oe) {
                    this.layers.has(oe) || this.createLayer(oe);
                    let pe;
                    (pe = this.layers.get(oe)) == null || pe.appendChild(Q.getSvgRoot())
                }
                createLayer(Q) {
                    const oe = this.workspace.getSvgGroup()
                      , pe = $t(bt.G, {});
                    let Ae = !1;
                    const Re = [...this.layers].sort( (Ue, tt) => Ue[0] - tt[0]);
                    for (const [Ue,tt] of Re)
                        if (Q < Ue) {
                            oe.insertBefore(pe, tt),
                            Ae = !0;
                            break
                        }
                    return Ae || oe.appendChild(pe),
                    this.layers.set(Q, pe),
                    pe
                }
                hasLayer(Q) {
                    return Q === this.dragLayer || new Set(this.layers.values()).has(Q)
                }
                getBlockLayer() {
                    return this.layers.get(Sh)
                }
                getBubbleLayer() {
                    return this.layers.get(Ih)
                }
            }
              , RT = 20
              , cs = class extends hl {
                constructor(Q) {
                    super(Q),
                    this.resizeHandlerWrapper = null,
                    this.resizesEnabled = this.isVisible_ = this.rendered = !0,
                    this.startScrollY = this.startScrollX = this.scrollY = this.scrollX = 0,
                    this.dragDeltaXY = null,
                    this.oldScale = this.scale = 1,
                    this.oldLeft = this.oldTop = 0,
                    this.inverseScreenCTM = this.targetWorkspace = this.dummyWheelListener = this.configureContextMenu = this.lastRecordedPageScroll = this.injectionDiv = this.currentGesture_ = this.toolbox_ = this.flyout = this.scrollbar = this.trashcan = null,
                    this.inverseScreenCTMDirty = !0,
                    this.highlightedBlocks = [],
                    this.toolboxCategoryCallbacks = new Map,
                    this.flyoutButtonCallbacks = new Map,
                    this.cachedParentSvg = null,
                    this.keyboardAccessibilityMode = !1,
                    this.topBoundedElements = [],
                    this.dragTargetAreas = [],
                    this.zoomControls_ = this.layerManager = null,
                    this.metricsManager = new (Ie(Yt.METRICS_MANAGER, Q, !0))(this),
                    this.getMetrics = Q.getMetrics || this.metricsManager.getMetrics.bind(this.metricsManager),
                    this.setMetrics = Q.setMetrics || cs.setTopLevelWorkspaceMetrics_,
                    this.componentManager = new dr,
                    this.connectionDBList = Ji.init(this.connectionChecker),
                    this.audioManager = new Xg(Q.parentWorkspace),
                    this.grid = this.options.gridPattern ? new vh(this.options.gridPattern,Q.gridOptions) : null,
                    this.markerManager = new rl(this),
                    gr && ns && this.registerToolboxCategoryCallback(Zd, ns),
                    ui && ql && this.registerToolboxCategoryCallback(jh, ql),
                    yr && Jl && (this.registerToolboxCategoryCallback(xc, Jl),
                    this.addChangeListener(Qu)),
                    this.themeManager_ = this.options.parentWorkspace ? this.options.parentWorkspace.getThemeManager() : new Wg(this,this.options.theme || bc),
                    this.themeManager_.subscribeWorkspace(this);
                    let oe;
                    this.renderer = td(this.options.renderer || "geras", this.getTheme(), (oe = this.options.rendererOverrides) != null ? oe : void 0),
                    this.cachedParentSvgSize = new Yn(0,0)
                }
                getMarkerManager() {
                    return this.markerManager
                }
                getMetricsManager() {
                    return this.metricsManager
                }
                setMetricsManager(Q) {
                    this.metricsManager = Q,
                    this.getMetrics = this.metricsManager.getMetrics.bind(this.metricsManager)
                }
                getComponentManager() {
                    return this.componentManager
                }
                setCursorSvg(Q) {
                    this.markerManager.setCursorSvg(Q)
                }
                setMarkerSvg(Q) {
                    this.markerManager.setMarkerSvg(Q)
                }
                getMarker(Q) {
                    return this.markerManager ? this.markerManager.getMarker(Q) : null
                }
                getCursor() {
                    return this.markerManager ? this.markerManager.getCursor() : null
                }
                getRenderer() {
                    return this.renderer
                }
                getThemeManager() {
                    return this.themeManager_
                }
                getTheme() {
                    return this.themeManager_.getTheme()
                }
                setTheme(Q) {
                    Q || (Q = bc),
                    this.themeManager_.setTheme(Q)
                }
                refreshTheme() {
                    this.svgGroup_ && this.renderer.refreshDom(this.svgGroup_, this.getTheme()),
                    this.updateBlockStyles_(this.getAllBlocks(!1).filter(function(oe) {
                        return !!oe.getStyleName()
                    })),
                    this.refreshToolboxSelection(),
                    this.toolbox_ && this.toolbox_.refreshTheme(),
                    this.isVisible() && this.setVisible(!0);
                    const Q = new (gt(Vi))(this.getTheme().name,this.id);
                    Ye(Q)
                }
                updateBlockStyles_(Q) {
                    for (let oe = 0, pe; pe = Q[oe]; oe++) {
                        const Ae = pe.getStyleName();
                        Ae && pe.setStyle(Ae)
                    }
                }
                getInverseScreenCTM() {
                    if (this.inverseScreenCTMDirty) {
                        const Q = this.getParentSvg().getScreenCTM();
                        Q && (this.inverseScreenCTM = Q.inverse(),
                        this.inverseScreenCTMDirty = !1)
                    }
                    return this.inverseScreenCTM
                }
                updateInverseScreenCTM() {
                    this.inverseScreenCTMDirty = !0
                }
                isVisible() {
                    return this.isVisible_
                }
                getSvgXY(Q) {
                    let oe = 0
                      , pe = 0
                      , Ae = 1;
                    (this.getCanvas().contains(Q) || this.getBubbleCanvas().contains(Q)) && (Ae = this.scale);
                    do {
                        const Re = _t(Q);
                        (Q === this.getCanvas() || Q === this.getBubbleCanvas()) && (Ae = 1),
                        oe += Re.x * Ae,
                        pe += Re.y * Ae,
                        Q = Q.parentNode
                    } while (Q && Q !== this.getParentSvg() && Q !== this.getInjectionDiv());
                    return new Zt(oe,pe)
                }
                getCachedParentSvgSize() {
                    const Q = this.cachedParentSvgSize;
                    return new Yn(Q.width,Q.height)
                }
                getOriginOffsetInPixels() {
                    return Be(this.getCanvas())
                }
                getInjectionDiv() {
                    if (!this.injectionDiv) {
                        let Q = this.svgGroup_;
                        for (; Q; ) {
                            if ((" " + (Q.getAttribute("class") || "") + " ").indexOf(" injectionDiv ") !== -1) {
                                this.injectionDiv = Q;
                                break
                            }
                            Q = Q.parentNode
                        }
                    }
                    return this.injectionDiv
                }
                getSvgGroup() {
                    return this.svgGroup_
                }
                getBlockCanvas() {
                    return this.getCanvas()
                }
                setResizeHandlerWrapper(Q) {
                    this.resizeHandlerWrapper = Q
                }
                createDom(Q, oe) {
                    return this.injectionDiv || (this.injectionDiv = oe ?? null),
                    this.svgGroup_ = $t(bt.G, {
                        class: "blocklyWorkspace"
                    }),
                    Q && (this.svgBackground_ = $t(bt.RECT, {
                        height: "100%",
                        width: "100%",
                        class: Q
                    }, this.svgGroup_),
                    Q === "blocklyMainBackground" && this.grid ? this.svgBackground_.style.fill = "url(#" + this.grid.getPatternId() + ")" : this.themeManager_.subscribe(this.svgBackground_, "workspaceBackgroundColour", "fill")),
                    this.layerManager = new IT(this),
                    this.svgBlockCanvas_ = this.layerManager.getBlockLayer(),
                    this.svgBubbleCanvas_ = this.layerManager.getBubbleLayer(),
                    this.isFlyout || (vt(this.svgGroup_, "pointerdown", this, this.onMouseDown_, !1),
                    this.dummyWheelListener = () => {}
                    ,
                    document.body.addEventListener("wheel", this.dummyWheelListener),
                    vt(this.svgGroup_, "wheel", this, this.onMouseWheel_)),
                    this.options.hasCategories && (this.toolbox_ = new (Ie(Yt.TOOLBOX, this.options, !0))(this)),
                    this.grid && this.grid.update(this.scale),
                    this.recordDragTargets(),
                    (Q = Ie(Yt.CURSOR, this.options)) && this.markerManager.setCursor(new Q),
                    this.renderer.createDom(this.svgGroup_, this.getTheme()),
                    this.svgGroup_
                }
                dispose() {
                    if (this.rendered = !1,
                    this.currentGesture_ && this.currentGesture_.cancel(),
                    this.svgGroup_ && Bt(this.svgGroup_),
                    this.toolbox_ && (this.toolbox_.dispose(),
                    this.toolbox_ = null),
                    this.flyout && (this.flyout.dispose(),
                    this.flyout = null),
                    this.trashcan && (this.trashcan.dispose(),
                    this.trashcan = null),
                    this.scrollbar && (this.scrollbar.dispose(),
                    this.scrollbar = null),
                    this.zoomControls_ && this.zoomControls_.dispose(),
                    this.audioManager && this.audioManager.dispose(),
                    this.grid && (this.grid = null),
                    this.renderer.dispose(),
                    this.markerManager && this.markerManager.dispose(),
                    super.dispose(),
                    this.themeManager_ && (this.themeManager_.unsubscribeWorkspace(this),
                    this.themeManager_.unsubscribe(this.svgBackground_),
                    this.options.parentWorkspace || this.themeManager_.dispose()),
                    this.connectionDBList.length = 0,
                    this.toolboxCategoryCallbacks.clear(),
                    this.flyoutButtonCallbacks.clear(),
                    !this.options.parentWorkspace) {
                        const Q = this.getParentSvg();
                        Q && Q.parentNode && Bt(Q.parentNode)
                    }
                    this.resizeHandlerWrapper && (Ct(this.resizeHandlerWrapper),
                    this.resizeHandlerWrapper = null),
                    this.dummyWheelListener && (document.body.removeEventListener("wheel", this.dummyWheelListener),
                    this.dummyWheelListener = null)
                }
                addTrashcan() {
                    this.trashcan = cs.newTrashcan(this);
                    const Q = this.trashcan.createDom();
                    this.svgGroup_.insertBefore(Q, this.getCanvas())
                }
                static newTrashcan(Q) {
                    throw Error("The implementation of newTrashcan should be monkey-patched in by blockly.ts")
                }
                addZoomControls() {
                    this.zoomControls_ = new tg(this);
                    const Q = this.zoomControls_.createDom();
                    this.svgGroup_.appendChild(Q)
                }
                addFlyout(Q) {
                    const oe = new Qr({
                        parentWorkspace: this,
                        rtl: this.RTL,
                        oneBasedIndex: this.options.oneBasedIndex,
                        horizontalLayout: this.horizontalLayout,
                        renderer: this.options.renderer,
                        rendererOverrides: this.options.rendererOverrides,
                        move: {
                            scrollbars: !0
                        }
                    });
                    return oe.toolboxPosition = this.options.toolboxPosition,
                    this.flyout = this.horizontalLayout ? new (Ie(Yt.FLYOUTS_HORIZONTAL_TOOLBOX, this.options, !0))(oe) : new (Ie(Yt.FLYOUTS_VERTICAL_TOOLBOX, this.options, !0))(oe),
                    this.flyout.autoClose = !1,
                    this.flyout.getWorkspace().setVisible(!0),
                    this.flyout.createDom(Q)
                }
                getFlyout(Q) {
                    return this.flyout || Q ? this.flyout : this.toolbox_ ? this.toolbox_.getFlyout() : null
                }
                getToolbox() {
                    return this.toolbox_
                }
                updateScreenCalculations_() {
                    this.updateInverseScreenCTM(),
                    this.recordDragTargets()
                }
                resizeContents() {
                    this.resizesEnabled && this.rendered && (this.scrollbar && this.scrollbar.resize(),
                    this.updateInverseScreenCTM())
                }
                resize() {
                    this.toolbox_ && this.toolbox_.position(),
                    this.flyout && this.flyout.position();
                    const Q = this.componentManager.getComponents(dr.Capability.POSITIONABLE, !0)
                      , oe = this.getMetricsManager().getUiMetrics()
                      , pe = [];
                    for (let Ae = 0, Re; Re = Q[Ae]; Ae++) {
                        Re.position(oe, pe);
                        const Ue = Re.getBoundingRectangle();
                        Ue && pe.push(Ue)
                    }
                    this.scrollbar && this.scrollbar.resize(),
                    this.updateScreenCalculations_()
                }
                updateScreenCalculationsIfScrolled() {
                    const Q = ot();
                    Zt.equals(this.lastRecordedPageScroll, Q) || (this.lastRecordedPageScroll = Q,
                    this.updateScreenCalculations_())
                }
                getLayerManager() {
                    return this.layerManager
                }
                getCanvas() {
                    return this.layerManager.getBlockLayer()
                }
                setCachedParentSvgSize(Q, oe) {
                    const pe = this.getParentSvg();
                    Q != null && (this.cachedParentSvgSize.width = Q,
                    pe.setAttribute("data-cached-width", `${Q}`)),
                    oe != null && (this.cachedParentSvgSize.height = oe,
                    pe.setAttribute("data-cached-height", `${oe}`))
                }
                getBubbleCanvas() {
                    return this.layerManager.getBubbleLayer()
                }
                getParentSvg() {
                    if (!this.cachedParentSvg) {
                        let Q = this.svgGroup_;
                        for (; Q; ) {
                            if (Q.tagName === "svg") {
                                this.cachedParentSvg = Q;
                                break
                            }
                            Q = Q.parentNode
                        }
                    }
                    return this.cachedParentSvg
                }
                maybeFireViewportChangeEvent() {
                    if (Ke()) {
                        var Q = this.scale
                          , oe = -this.scrollY
                          , pe = -this.scrollX;
                        if (!(Q === this.oldScale && 1 > Math.abs(oe - this.oldTop) && 1 > Math.abs(pe - this.oldLeft))) {
                            var Ae = new (gt(Eo))(oe,pe,Q,this.id,this.oldScale);
                            this.oldScale = Q,
                            this.oldTop = oe,
                            this.oldLeft = pe,
                            Ye(Ae)
                        }
                    }
                }
                translate(Q, oe) {
                    let pe;
                    (pe = this.layerManager) == null || pe.translateLayers(new Zt(Q,oe), this.scale);
                    let Ae;
                    (Ae = this.grid) == null || Ae.moveTo(Q, oe),
                    this.maybeFireViewportChangeEvent()
                }
                getWidth() {
                    const Q = this.getMetrics();
                    return Q ? Q.viewWidth / this.scale : 0
                }
                setVisible(Q) {
                    this.isVisible_ = Q,
                    this.svgGroup_ && (this.scrollbar && this.scrollbar.setContainerVisible(Q),
                    this.getFlyout() && this.getFlyout().setContainerVisible(Q),
                    this.getParentSvg().style.display = Q ? "block" : "none",
                    this.toolbox_ && this.toolbox_.setVisible(Q),
                    Q || this.hideChaff(!0))
                }
                render() {
                    for (var Q = this.getAllBlocks(!1), oe = Q.length - 1; 0 <= oe; oe--)
                        Q[oe].queueRender();
                    if (this.currentGesture_)
                        for (Q = this.currentGesture_.getInsertionMarkers(),
                        oe = 0; oe < Q.length; oe++)
                            Q[oe].queueRender();
                    Na().then( () => void this.markerManager.updateMarkers())
                }
                highlightBlock(Q, oe) {
                    if (oe === void 0) {
                        for (let pe = 0, Ae; Ae = this.highlightedBlocks[pe]; pe++)
                            Ae.setHighlighted(!1);
                        this.highlightedBlocks.length = 0
                    }
                    (Q = Q ? this.getBlockById(Q) : null) && ((oe = oe === void 0 || oe) ? this.highlightedBlocks.indexOf(Q) === -1 && this.highlightedBlocks.push(Q) : dn(this.highlightedBlocks, Q),
                    Q.setHighlighted(oe))
                }
                paste(Q) {
                    if (zt("Blockly.WorkspaceSvg.prototype.paste", "v10", "v11", "Blockly.clipboard.paste"),
                    !this.rendered || !Q.type && !Q.tagName)
                        return null;
                    this.currentGesture_ && this.currentGesture_.cancel();
                    const oe = J.getGroup$$module$build$src$core$events$utils();
                    oe || J.setGroup$$module$build$src$core$events$utils(!0);
                    let pe;
                    try {
                        pe = Q.type ? this.pasteBlock_(null, Q) : Q.tagName.toLowerCase() === "comment" ? this.pasteWorkspaceComment_(Q) : this.pasteBlock_(Q, null)
                    } finally {
                        J.setGroup$$module$build$src$core$events$utils(oe)
                    }
                    return pe
                }
                pasteBlock_(Q, oe) {
                    J.disable$$module$build$src$core$events$utils();
                    let pe;
                    try {
                        let Ae = 0
                          , Re = 0;
                        if (Q) {
                            pe = lo(Q, this);
                            let Ue;
                            Ae = parseInt((Ue = Q.getAttribute("x")) != null ? Ue : "0"),
                            this.RTL && (Ae = -Ae);
                            let tt;
                            Re = parseInt((tt = Q.getAttribute("y")) != null ? tt : "0")
                        } else
                            oe && (pe = co(oe, this),
                            Ae = oe.x || 10,
                            this.RTL && (Ae = this.getWidth() - Ae),
                            Re = oe.y || 10);
                        if (!isNaN(Ae) && !isNaN(Re)) {
                            let Ue;
                            do {
                                Ue = !1;
                                const tt = this.getAllBlocks(!1);
                                for (let dt = 0, wt; wt = tt[dt]; dt++) {
                                    const sn = wt.getRelativeToSurfaceXY();
                                    if (1 >= Math.abs(Ae - sn.x) && 1 >= Math.abs(Re - sn.y)) {
                                        Ue = !0;
                                        break
                                    }
                                }
                                if (!Ue) {
                                    const dt = pe.getConnections_(!1);
                                    for (let wt = 0, sn; sn = dt[wt]; wt++)
                                        if (sn.closest(J.config$$module$build$src$core$config.snapRadius, new Zt(Ae,Re)).connection) {
                                            Ue = !0;
                                            break
                                        }
                                }
                                Ue && (Ae = this.RTL ? Ae - J.config$$module$build$src$core$config.snapRadius : Ae + J.config$$module$build$src$core$config.snapRadius,
                                Re += 2 * J.config$$module$build$src$core$config.snapRadius)
                            } while (Ue);
                            pe.moveTo(new Zt(Ae,Re))
                        }
                    } finally {
                        J.enable$$module$build$src$core$events$utils()
                    }
                    return Ke() && !pe.isShadow() && Ye(new (gt(J.CREATE$$module$build$src$core$events$utils))(pe)),
                    pe.select(),
                    pe
                }
                pasteWorkspaceComment_(Q) {
                    J.disable$$module$build$src$core$events$utils();
                    let oe;
                    try {
                        oe = Er.fromXmlRendered(Q, this);
                        let pe, Ae = parseInt((pe = Q.getAttribute("x")) != null ? pe : "0"), Re, Ue = parseInt((Re = Q.getAttribute("y")) != null ? Re : "0");
                        isNaN(Ae) || isNaN(Ue) || (this.RTL && (Ae = -Ae),
                        oe.moveBy(Ae + 50, Ue + 50))
                    } finally {
                        J.enable$$module$build$src$core$events$utils()
                    }
                    return Ke() && ys.fireCreateEvent(oe),
                    oe.select(),
                    oe
                }
                refreshToolboxSelection() {
                    const Q = this.isFlyout ? this.targetWorkspace : this;
                    Q && !Q.currentGesture_ && Q.toolbox_ && Q.toolbox_.getFlyout() && Q.toolbox_.refreshSelection()
                }
                renameVariableById(Q, oe) {
                    super.renameVariableById(Q, oe),
                    this.refreshToolboxSelection()
                }
                deleteVariableById(Q) {
                    super.deleteVariableById(Q),
                    this.refreshToolboxSelection()
                }
                createVariable(Q, oe, pe) {
                    return Q = super.createVariable(Q, oe, pe),
                    this.refreshToolboxSelection(),
                    Q
                }
                recordDragTargets() {
                    const Q = this.componentManager.getComponents(dr.Capability.DRAG_TARGET, !0);
                    this.dragTargetAreas = [];
                    for (let oe = 0, pe; pe = Q[oe]; oe++) {
                        const Ae = pe.getClientRect();
                        Ae && this.dragTargetAreas.push({
                            component: pe,
                            clientRect: Ae
                        })
                    }
                }
                newBlock(Q, oe) {
                    throw Error("The implementation of newBlock should be monkey-patched in by blockly.ts")
                }
                getDragTarget(Q) {
                    for (let oe = 0, pe; pe = this.dragTargetAreas[oe]; oe++)
                        if (pe.clientRect.contains(Q.clientX, Q.clientY))
                            return pe.component;
                    return null
                }
                onMouseDown_(Q) {
                    const oe = this.getGesture(Q);
                    oe && oe.handleWsStart(Q, this)
                }
                startDrag(Q, oe) {
                    Q = tn(Q, this.getParentSvg(), this.getInverseScreenCTM()),
                    Q.x /= this.scale,
                    Q.y /= this.scale,
                    this.dragDeltaXY = Zt.difference(oe, Q)
                }
                moveDrag(Q) {
                    return Q = tn(Q, this.getParentSvg(), this.getInverseScreenCTM()),
                    Q.x /= this.scale,
                    Q.y /= this.scale,
                    Zt.sum(this.dragDeltaXY, Q)
                }
                isDragging() {
                    return this.currentGesture_ !== null && this.currentGesture_.isDragging()
                }
                isDraggable() {
                    return this.options.moveOptions && this.options.moveOptions.drag
                }
                isMovable() {
                    return this.options.moveOptions && !!this.options.moveOptions.scrollbars || this.options.moveOptions && this.options.moveOptions.wheel || this.options.moveOptions && this.options.moveOptions.drag || this.options.zoomOptions && this.options.zoomOptions.wheel || this.options.zoomOptions && this.options.zoomOptions.pinch
                }
                isMovableHorizontally() {
                    const Q = !!this.scrollbar;
                    return this.isMovable() && (!Q || Q && this.scrollbar.canScrollHorizontally())
                }
                isMovableVertically() {
                    const Q = !!this.scrollbar;
                    return this.isMovable() && (!Q || Q && this.scrollbar.canScrollVertically())
                }
                onMouseWheel_(Q) {
                    if (Qs.inProgress())
                        Q.preventDefault(),
                        Q.stopPropagation();
                    else {
                        var oe = this.options.zoomOptions && this.options.zoomOptions.wheel
                          , pe = this.options.moveOptions && this.options.moveOptions.wheel;
                        if (oe || pe) {
                            var Ae = mn(Q);
                            if (Gd)
                                var Re = Q.metaKey;
                            oe && (Q.ctrlKey || Re || !pe) ? (Ae = -Ae.y / 50,
                            oe = tn(Q, this.getParentSvg(), this.getInverseScreenCTM()),
                            this.zoom(oe.x, oe.y, Ae)) : (oe = this.scrollX - Ae.x,
                            pe = this.scrollY - Ae.y,
                            Q.shiftKey && !Ae.x && (oe = this.scrollX - Ae.y,
                            pe = this.scrollY),
                            this.scroll(oe, pe)),
                            Q.preventDefault()
                        }
                    }
                }
                getBlocksBoundingBox() {
                    const Q = this.getTopBoundedElements();
                    if (!Q.length)
                        return new Vn(0,0,0,0);
                    const oe = Q[0].getBoundingRectangle();
                    for (let Ae = 1; Ae < Q.length; Ae++) {
                        var pe = Q[Ae];
                        pe.isInsertionMarker && pe.isInsertionMarker() || (pe = pe.getBoundingRectangle(),
                        pe.top < oe.top && (oe.top = pe.top),
                        pe.bottom > oe.bottom && (oe.bottom = pe.bottom),
                        pe.left < oe.left && (oe.left = pe.left),
                        pe.right > oe.right && (oe.right = pe.right))
                    }
                    return oe
                }
                cleanUp() {
                    this.setResizesEnabled(!1),
                    J.setGroup$$module$build$src$core$events$utils(!0);
                    const Q = this.getTopBlocks(!0);
                    let oe = 0;
                    for (let pe = 0, Ae; Ae = Q[pe]; pe++) {
                        if (!Ae.isMovable())
                            continue;
                        const Re = Ae.getRelativeToSurfaceXY();
                        Ae.moveBy(-Re.x, oe - Re.y, ["cleanup"]),
                        Ae.snapToGrid(),
                        oe = Ae.getRelativeToSurfaceXY().y + Ae.getHeightWidth().height + this.renderer.getConstants().MIN_BLOCK_HEIGHT
                    }
                    J.setGroup$$module$build$src$core$events$utils(!1),
                    this.setResizesEnabled(!0)
                }
                showContextMenu(Q) {
                    if (!this.options.readOnly && !this.isFlyout) {
                        var oe = Ln.registry.getContextMenuOptions(Ln.ScopeType.WORKSPACE, {
                            workspace: this
                        });
                        this.configureContextMenu && this.configureContextMenu(oe, Q),
                        Pa(Q, oe, this.RTL)
                    }
                }
                updateToolbox(Q) {
                    if (Q = rn(Q)) {
                        if (!this.options.languageTree)
                            throw Error("Existing toolbox is null.  Can't create new toolbox.");
                        if (On(Q)) {
                            if (!this.toolbox_)
                                throw Error("Existing toolbox has no categories.  Can't change mode.");
                            this.options.languageTree = Q,
                            this.toolbox_.render(Q)
                        } else {
                            if (!this.flyout)
                                throw Error("Existing toolbox has categories.  Can't change mode.");
                            this.options.languageTree = Q,
                            this.flyout.show(Q)
                        }
                    } else if (this.options.languageTree)
                        throw Error("Can't nullify an existing toolbox.")
                }
                markFocused() {
                    this.options.parentWorkspace ? this.options.parentWorkspace.markFocused() : (xe(this),
                    this.getParentSvg().focus({
                        preventScroll: !0
                    }))
                }
                zoom(Q, oe, pe) {
                    pe = Math.pow(this.options.zoomOptions.scaleSpeed, pe);
                    const Ae = this.scale * pe;
                    if (this.scale !== Ae) {
                        Ae > this.options.zoomOptions.maxScale ? pe = this.options.zoomOptions.maxScale / this.scale : Ae < this.options.zoomOptions.minScale && (pe = this.options.zoomOptions.minScale / this.scale);
                        var Re = this.getCanvas().getCTM()
                          , Ue = this.getParentSvg().createSVGPoint();
                        Ue.x = Q,
                        Ue.y = oe,
                        Ue = Ue.matrixTransform(Re.inverse()),
                        Q = Ue.x,
                        oe = Ue.y,
                        Re = Re.translate(Q * (1 - pe), oe * (1 - pe)).scale(pe),
                        this.scrollX = Re.e,
                        this.scrollY = Re.f,
                        this.setScale(Ae)
                    }
                }
                zoomCenter(Q) {
                    var oe = this.getMetrics();
                    let pe;
                    this.flyout ? (pe = oe.svgWidth ? oe.svgWidth / 2 : 0,
                    oe = oe.svgHeight ? oe.svgHeight / 2 : 0) : (pe = oe.viewWidth / 2 + oe.absoluteLeft,
                    oe = oe.viewHeight / 2 + oe.absoluteTop),
                    this.zoom(pe, oe, Q)
                }
                zoomToFit() {
                    if (this.isMovable()) {
                        var Q = this.getMetrics()
                          , oe = Q.viewWidth;
                        Q = Q.viewHeight;
                        var pe = this.getBlocksBoundingBox()
                          , Ae = 2 * RT
                          , Re = pe.right - pe.left + Ae;
                        if (pe = pe.bottom - pe.top + Ae,
                        Re) {
                            this.flyout && (this.horizontalLayout ? (Q += this.flyout.getHeight(),
                            pe += this.flyout.getHeight() / this.scale) : (oe += this.flyout.getWidth(),
                            Re += this.flyout.getWidth() / this.scale)),
                            oe /= Re,
                            Q /= pe,
                            J.disable$$module$build$src$core$events$utils();
                            try {
                                this.setScale(Math.min(oe, Q)),
                                this.scrollCenter()
                            } finally {
                                J.enable$$module$build$src$core$events$utils()
                            }
                            this.maybeFireViewportChangeEvent()
                        }
                    } else
                        console.warn("Tried to move a non-movable workspace. This could result in blocks becoming inaccessible.")
                }
                beginCanvasTransition() {
                    Ut(this.getCanvas(), "blocklyCanvasTransitioning"),
                    Ut(this.getBubbleCanvas(), "blocklyCanvasTransitioning")
                }
                endCanvasTransition() {
                    yt(this.getCanvas(), "blocklyCanvasTransitioning"),
                    yt(this.getBubbleCanvas(), "blocklyCanvasTransitioning")
                }
                scrollCenter() {
                    if (this.isMovable()) {
                        var Q = this.getMetrics()
                          , oe = (Q.scrollWidth - Q.viewWidth) / 2
                          , pe = (Q.scrollHeight - Q.viewHeight) / 2;
                        oe = -oe - Q.scrollLeft,
                        pe = -pe - Q.scrollTop,
                        this.scroll(oe, pe)
                    } else
                        console.warn("Tried to move a non-movable workspace. This could result in blocks becoming inaccessible.")
                }
                centerOnBlock(Q, oe) {
                    if (this.isMovable()) {
                        var pe = Q ? this.getBlockById(Q) : null;
                        if (pe) {
                            Q = pe.getRelativeToSurfaceXY(),
                            pe = oe ? {
                                height: pe.height,
                                width: pe.width
                            } : pe.getHeightWidth();
                            var Ae = this.scale;
                            oe = (Q.x + (this.RTL ? -1 : 1) * pe.width / 2) * Ae,
                            Q = (Q.y + pe.height / 2) * Ae,
                            pe = this.getMetrics(),
                            this.scroll(-(oe - pe.viewWidth / 2), -(Q - pe.viewHeight / 2))
                        }
                    } else
                        console.warn("Tried to move a non-movable workspace. This could result in blocks becoming inaccessible.")
                }
                setScale(Q) {
                    this.options.zoomOptions.maxScale && Q > this.options.zoomOptions.maxScale ? Q = this.options.zoomOptions.maxScale : this.options.zoomOptions.minScale && Q < this.options.zoomOptions.minScale && (Q = this.options.zoomOptions.minScale),
                    this.scale = Q,
                    this.hideChaff(!1),
                    (Q = this.getFlyout(!1)) && Q.isVisible() && (Q.reflow(),
                    this.recordDragTargets()),
                    this.grid && this.grid.update(this.scale),
                    Q = this.getMetrics(),
                    this.scrollX -= Q.absoluteLeft,
                    this.scrollY -= Q.absoluteTop,
                    Q.viewLeft += Q.absoluteLeft,
                    Q.viewTop += Q.absoluteTop,
                    this.scroll(this.scrollX, this.scrollY),
                    this.scrollbar && (this.flyout ? this.scrollbar.resizeView(Q) : this.scrollbar.resizeContent(Q))
                }
                getScale() {
                    return this.options.parentWorkspace ? this.options.parentWorkspace.getScale() : this.scale
                }
                scroll(Q, oe) {
                    this.hideChaff(!0);
                    const pe = this.getMetrics();
                    Q = Math.min(Q, -pe.scrollLeft),
                    oe = Math.min(oe, -pe.scrollTop);
                    const Ae = pe.scrollTop + Math.max(0, pe.scrollHeight - pe.viewHeight);
                    Q = Math.max(Q, -(pe.scrollLeft + Math.max(0, pe.scrollWidth - pe.viewWidth))),
                    oe = Math.max(oe, -Ae),
                    this.scrollX = Q,
                    this.scrollY = oe,
                    this.scrollbar && this.scrollbar.set(-(Q + pe.scrollLeft), -(oe + pe.scrollTop), !1),
                    Q += pe.absoluteLeft,
                    oe += pe.absoluteTop,
                    this.translate(Q, oe)
                }
                getBlockById(Q) {
                    return super.getBlockById(Q)
                }
                getAllBlocks(Q=!1) {
                    return super.getAllBlocks(Q)
                }
                getTopBlocks(Q=!1) {
                    return super.getTopBlocks(Q)
                }
                addTopBlock(Q) {
                    this.addTopBoundedElement(Q),
                    super.addTopBlock(Q)
                }
                removeTopBlock(Q) {
                    this.removeTopBoundedElement(Q),
                    super.removeTopBlock(Q)
                }
                addTopComment(Q) {
                    this.addTopBoundedElement(Q),
                    super.addTopComment(Q)
                }
                removeTopComment(Q) {
                    this.removeTopBoundedElement(Q),
                    super.removeTopComment(Q)
                }
                getRootWorkspace() {
                    return super.getRootWorkspace()
                }
                addTopBoundedElement(Q) {
                    this.topBoundedElements.push(Q)
                }
                removeTopBoundedElement(Q) {
                    dn(this.topBoundedElements, Q)
                }
                getTopBoundedElements() {
                    return [].concat(this.topBoundedElements)
                }
                setResizesEnabled(Q) {
                    const oe = !this.resizesEnabled && Q;
                    this.resizesEnabled = Q,
                    oe && this.resizeContents()
                }
                clear() {
                    this.setResizesEnabled(!1),
                    super.clear(),
                    this.topBoundedElements = [],
                    this.setResizesEnabled(!0)
                }
                registerButtonCallback(Q, oe) {
                    if (typeof oe != "function")
                        throw TypeError("Button callbacks must be functions.");
                    this.flyoutButtonCallbacks.set(Q, oe)
                }
                getButtonCallback(Q) {
                    let oe;
                    return (oe = this.flyoutButtonCallbacks.get(Q)) != null ? oe : null
                }
                removeButtonCallback(Q) {
                    this.flyoutButtonCallbacks.delete(Q)
                }
                registerToolboxCategoryCallback(Q, oe) {
                    if (typeof oe != "function")
                        throw TypeError("Toolbox category callbacks must be functions.");
                    this.toolboxCategoryCallbacks.set(Q, oe)
                }
                getToolboxCategoryCallback(Q) {
                    return this.toolboxCategoryCallbacks.get(Q) || null
                }
                removeToolboxCategoryCallback(Q) {
                    this.toolboxCategoryCallbacks.delete(Q)
                }
                getGesture(Q) {
                    const oe = Q.type === "pointerdown"
                      , pe = this.currentGesture_;
                    return pe ? oe && pe.hasStarted() ? (console.warn("Tried to start the same gesture twice."),
                    pe.cancel(),
                    null) : pe : oe ? this.currentGesture_ = new Qs(Q,this) : null
                }
                clearGesture() {
                    this.currentGesture_ = null
                }
                cancelCurrentGesture() {
                    this.currentGesture_ && this.currentGesture_.cancel()
                }
                getAudioManager() {
                    return this.audioManager
                }
                getGrid() {
                    return this.grid
                }
                hideChaff(Q=!1) {
                    Vs(),
                    Jr(),
                    ss(),
                    this.hideComponents(Q)
                }
                hideComponents(Q=!1) {
                    this.getComponentManager().getComponents(dr.Capability.AUTOHIDEABLE, !0).forEach(oe => oe.autoHide(Q))
                }
                static setTopLevelWorkspaceMetrics_(Q) {
                    const oe = this.getMetrics();
                    typeof Q.x == "number" && (this.scrollX = -(oe.scrollLeft + (oe.scrollWidth - oe.viewWidth) * Q.x)),
                    typeof Q.y == "number" && (this.scrollY = -(oe.scrollTop + (oe.scrollHeight - oe.viewHeight) * Q.y)),
                    this.translate(this.scrollX + oe.absoluteLeft, this.scrollY + oe.absoluteTop)
                }
            }
              , zh = class extends Is {
                constructor(Q, oe) {
                    super(oe),
                    this.type = Fi,
                    this.isOpen = Q
                }
                toJson() {
                    const Q = super.toJson();
                    if (this.isOpen === void 0)
                        throw Error("Whether this is already open or not is undefined. Either pass a value to the constructor, or call fromJson");
                    return Q.isOpen = this.isOpen,
                    Q
                }
                static fromJson(Q, oe, pe) {
                    return oe = super.fromJson(Q, oe, pe ?? new zh),
                    oe.isOpen = Q.isOpen,
                    oe
                }
            }
            ;
            ne(Yt.EVENT, Fi, zh);
            var Kh = class extends Zo {
                constructor(Q) {
                    if (super(Q),
                    this.type = J.DELETE$$module$build$src$core$events$utils,
                    Q) {
                        if (Q.getParent())
                            throw Error("Connected blocks cannot be deleted.");
                        Q.isShadow() && (this.recordUndo = !1),
                        this.oldXml = La(Q),
                        this.ids = lt(Q),
                        this.wasShadow = Q.isShadow(),
                        this.oldJson = Ts(Q, {
                            addCoordinates: !0
                        })
                    }
                }
                toJson() {
                    const Q = super.toJson();
                    if (!this.oldXml)
                        throw Error("The old block XML is undefined. Either pass a block to the constructor, or call fromJson");
                    if (!this.ids)
                        throw Error("The block IDs are undefined. Either pass a block to the constructor, or call fromJson");
                    if (this.wasShadow === void 0)
                        throw Error("Whether the block was a shadow is undefined. Either pass a block to the constructor, or call fromJson");
                    if (!this.oldJson)
                        throw Error("The old block JSON is undefined. Either pass a block to the constructor, or call fromJson");
                    return Q.oldXml = Es(this.oldXml),
                    Q.ids = this.ids,
                    Q.wasShadow = this.wasShadow,
                    Q.oldJson = this.oldJson,
                    this.recordUndo || (Q.recordUndo = this.recordUndo),
                    Q
                }
                static fromJson(Q, oe, pe) {
                    return oe = super.fromJson(Q, oe, pe ?? new Kh),
                    oe.oldXml = J.textToDom$$module$build$src$core$utils$xml(Q.oldXml),
                    oe.ids = Q.ids,
                    oe.wasShadow = Q.wasShadow || oe.oldXml.tagName.toLowerCase() === "shadow",
                    oe.oldJson = Q.oldJson,
                    Q.recordUndo !== void 0 && (oe.recordUndo = Q.recordUndo),
                    oe
                }
                run(Q) {
                    const oe = this.getEventWorkspace_();
                    if (!this.ids)
                        throw Error("The block IDs are undefined. Either pass a block to the constructor, or call fromJson");
                    if (!this.oldJson)
                        throw Error("The old block JSON is undefined. Either pass a block to the constructor, or call fromJson");
                    if (Q)
                        for (Q = 0; Q < this.ids.length; Q++) {
                            const pe = this.ids[Q]
                              , Ae = oe.getBlockById(pe);
                            Ae ? Ae.dispose(!1) : pe === this.blockId && console.warn("Can't delete non-existent block: " + pe)
                        }
                    else
                        co(this.oldJson, oe)
                }
            }
            ;
            ne(Yt.EVENT, J.DELETE$$module$build$src$core$events$utils, Kh);
            var la = class {
                constructor(Q, oe, pe) {
                    if (this.data = null,
                    this.disposed = !1,
                    this.hue_ = null,
                    this.colour_ = "#000000",
                    this.styleName_ = "",
                    this.suppressPrefixSuffix = !1,
                    this.previousConnection = this.nextConnection = this.outputConnection = null,
                    this.inputList = [],
                    this.icons = [],
                    this.disabled = !1,
                    this.tooltip = "",
                    this.contextMenu = !0,
                    this.parentBlock_ = null,
                    this.childBlocks_ = [],
                    this.editable_ = this.movable_ = this.deletable_ = !0,
                    this.collapsed_ = this.isShadow_ = !1,
                    this.outputShape_ = null,
                    this.isInsertionMarker_ = this.disposing = !1,
                    this.onchangeWrapper_ = this.helpUrl = this.rendered = null,
                    this.statementInputCount = 0,
                    this.workspace = Q,
                    this.id = pe && !Q.getBlockById(pe) ? pe : rt(),
                    Q.setBlockById(this.id, this),
                    this.xy_ = new Zt(0,0),
                    this.isInFlyout = Q.isFlyout,
                    this.isInMutator = Q.isMutator,
                    this.RTL = Q.RTL,
                    oe) {
                        if (this.type = oe,
                        pe = Nr[oe],
                        !pe || typeof pe != "object")
                            throw TypeError("Invalid block definition for type: " + oe);
                        Object.assign(this, pe)
                    }
                    Q.addTopBlock(this),
                    Q.addTypedBlock(this),
                    new.target === la && this.doInit_()
                }
                doInit_() {
                    const Q = J.getGroup$$module$build$src$core$events$utils();
                    Q || J.setGroup$$module$build$src$core$events$utils(!0);
                    const oe = St();
                    try {
                        typeof this.init == "function" && (ft(!1),
                        this.init(),
                        ft(oe)),
                        Ke() && Ye(new (gt(J.CREATE$$module$build$src$core$events$utils))(this))
                    } finally {
                        J.setGroup$$module$build$src$core$events$utils(Q),
                        ft(oe)
                    }
                    this.inputsInlineDefault = this.inputsInline,
                    typeof this.onchange == "function" && this.setOnChange(this.onchange)
                }
                dispose(Q) {
                    this.isDeadOrDying() || (this.onchangeWrapper_ && this.workspace.removeChangeListener(this.onchangeWrapper_),
                    this.unplug(Q),
                    Ke() && Ye(new (gt(J.DELETE$$module$build$src$core$events$utils))(this)),
                    this.workspace.removeTopBlock(this),
                    this.disposeInternal())
                }
                disposeInternal() {
                    this.isDeadOrDying() || (this.onchangeWrapper_ && this.workspace.removeChangeListener(this.onchangeWrapper_),
                    this.workspace.removeTypedBlock(this),
                    this.workspace.removeBlockById(this.id),
                    this.disposing = !0,
                    typeof this.destroy == "function" && this.destroy(),
                    this.childBlocks_.forEach(Q => Q.disposeInternal()),
                    this.inputList.forEach(Q => Q.dispose()),
                    this.inputList.length = 0,
                    this.getConnections_(!0).forEach(Q => Q.dispose()),
                    this.disposed = !0)
                }
                isDeadOrDying() {
                    return this.disposing || this.disposed
                }
                initModel() {
                    for (const Q of this.inputList)
                        for (const oe of Q.fieldRow)
                            oe.initModel && oe.initModel()
                }
                unplug(Q) {
                    this.outputConnection && this.unplugFromRow_(Q),
                    this.previousConnection && this.unplugFromStack_(Q)
                }
                unplugFromRow_(Q) {
                    let oe = null, pe;
                    (pe = this.outputConnection) != null && pe.isConnected() && (oe = this.outputConnection.targetConnection,
                    this.outputConnection.disconnect()),
                    oe && Q && (Q = this.getOnlyValueConnection_()) && Q.isConnected() && !Q.targetBlock().isShadow() && (Q = Q.targetConnection,
                    Q == null || Q.disconnect(),
                    this.workspace.connectionChecker.canConnect(Q, oe, !1) ? oe.connect(Q) : Q == null || Q.onFailedConnect(oe))
                }
                getOnlyValueConnection_() {
                    let Q = null;
                    for (let oe = 0; oe < this.inputList.length; oe++) {
                        const pe = this.inputList[oe].connection;
                        if (pe && pe.type === pn.INPUT_VALUE && pe.targetConnection) {
                            if (Q)
                                return null;
                            Q = pe
                        }
                    }
                    return Q
                }
                unplugFromStack_(Q) {
                    let oe = null;
                    var pe;
                    if ((pe = this.previousConnection) != null && pe.isConnected() && (oe = this.previousConnection.targetConnection,
                    this.previousConnection.disconnect()),
                    pe = this.getNextBlock(),
                    Q && pe && !pe.isShadow()) {
                        let Ae, Re;
                        Q = (Re = (Ae = this.nextConnection) == null ? void 0 : Ae.targetConnection) != null ? Re : null,
                        Q == null || Q.disconnect(),
                        oe && this.workspace.connectionChecker.canConnect(oe, Q, !1) && oe.connect(Q)
                    }
                }
                getConnections_(Q) {
                    Q = [],
                    this.outputConnection && Q.push(this.outputConnection),
                    this.previousConnection && Q.push(this.previousConnection),
                    this.nextConnection && Q.push(this.nextConnection);
                    for (let oe = 0, pe; pe = this.inputList[oe]; oe++)
                        pe.connection && Q.push(pe.connection);
                    return Q
                }
                lastConnectionInStack(Q) {
                    let oe = this.nextConnection;
                    for (; oe; ) {
                        const pe = oe.targetBlock();
                        if (!pe || Q && pe.isShadow())
                            return oe;
                        oe = pe.nextConnection
                    }
                    return null
                }
                bumpNeighbours() {}
                getParent() {
                    return this.parentBlock_
                }
                getInputWithBlock(Q) {
                    for (let oe = 0, pe; pe = this.inputList[oe]; oe++)
                        if (pe.connection && pe.connection.targetBlock() === Q)
                            return pe;
                    return null
                }
                getSurroundParent() {
                    let Q = this, oe;
                    do
                        if (oe = Q,
                        Q = Q.getParent(),
                        !Q)
                            return null;
                    while (Q.getNextBlock() === oe);
                    return Q
                }
                getNextBlock() {
                    return this.nextConnection && this.nextConnection.targetBlock()
                }
                getPreviousBlock() {
                    return this.previousConnection && this.previousConnection.targetBlock()
                }
                getRootBlock() {
                    let Q, oe = this;
                    do
                        Q = oe,
                        oe = Q.parentBlock_;
                    while (oe);
                    return Q
                }
                getTopStackBlock() {
                    let Q = this, oe;
                    do
                        oe = Q.getPreviousBlock();
                    while (oe && oe.getNextBlock() === Q && (Q = oe));
                    return Q
                }
                getChildren(Q) {
                    if (!Q)
                        return this.childBlocks_;
                    Q = [];
                    for (let pe = 0, Ae; Ae = this.inputList[pe]; pe++)
                        if (Ae.connection) {
                            var oe = Ae.connection.targetBlock();
                            oe && Q.push(oe)
                        }
                    return (oe = this.getNextBlock()) && Q.push(oe),
                    Q
                }
                setParent(Q) {
                    if (Q !== this.parentBlock_) {
                        var oe = this.previousConnection && this.previousConnection.targetBlock() || this.outputConnection && this.outputConnection.targetBlock()
                          , pe = !!oe;
                        if (pe && Q && oe !== Q)
                            throw Error("Block connected to superior one that is not new parent.");
                        if (!pe && Q)
                            throw Error("Block not connected to new parent.");
                        if (pe && !Q)
                            throw Error("Cannot set parent to null while block is still connected to superior block.");
                        this.parentBlock_ ? dn(this.parentBlock_.childBlocks_, this) : this.workspace.removeTopBlock(this),
                        (this.parentBlock_ = Q) ? Q.childBlocks_.push(this) : this.workspace.addTopBlock(this)
                    }
                }
                getDescendants(Q) {
                    const oe = [this]
                      , pe = this.getChildren(Q);
                    for (let Ae, Re = 0; Ae = pe[Re]; Re++)
                        oe.push(...Ae.getDescendants(Q));
                    return oe
                }
                isDeletable() {
                    return this.deletable_ && !this.isShadow_ && !this.isDeadOrDying() && !this.workspace.options.readOnly
                }
                isOwnDeletable() {
                    return this.deletable_
                }
                setDeletable(Q) {
                    this.deletable_ = Q
                }
                isMovable() {
                    return this.movable_ && !this.isShadow_ && !this.isDeadOrDying() && !this.workspace.options.readOnly
                }
                isOwnMovable() {
                    return this.movable_
                }
                setMovable(Q) {
                    this.movable_ = Q
                }
                isDuplicatable() {
                    return this.workspace.hasBlockLimits() ? this.workspace.isCapacityAvailable(qe(this, !0)) : !0
                }
                isShadow() {
                    return this.isShadow_
                }
                setShadow(Q) {
                    this.isShadow_ = Q
                }
                isInsertionMarker() {
                    return this.isInsertionMarker_
                }
                setInsertionMarker(Q) {
                    this.isInsertionMarker_ = Q
                }
                isEditable() {
                    return this.editable_ && !this.isDeadOrDying() && !this.workspace.options.readOnly
                }
                isOwnEditable() {
                    return this.editable_
                }
                setEditable(Q) {
                    this.editable_ = Q;
                    for (let oe = 0, pe; pe = this.inputList[oe]; oe++)
                        for (let Ae = 0, Re; Re = pe.fieldRow[Ae]; Ae++)
                            Re.updateEditable()
                }
                isDisposed() {
                    return this.disposed
                }
                isSimpleReporter() {
                    if (!this.outputConnection)
                        return !1;
                    for (const Q of this.inputList)
                        if (Q.connection || 1 < Q.fieldRow.length)
                            return !1;
                    return !0
                }
                getMatchingConnection(Q, oe) {
                    const pe = this.getConnections_(!0);
                    if (Q = Q.getConnections_(!0),
                    pe.length !== Q.length)
                        throw Error("Connection lists did not match in length.");
                    for (let Ae = 0; Ae < Q.length; Ae++)
                        if (Q[Ae] === oe)
                            return pe[Ae];
                    return null
                }
                setHelpUrl(Q) {
                    this.helpUrl = Q
                }
                setTooltip(Q) {
                    this.tooltip = Q
                }
                getTooltip() {
                    return xi(this)
                }
                getColour() {
                    return this.colour_
                }
                getStyleName() {
                    return this.styleName_
                }
                getHue() {
                    return this.hue_
                }
                setColour(Q) {
                    Q = Li(Q),
                    this.hue_ = Q.hue,
                    this.colour_ = Q.hex
                }
                setStyle(Q) {
                    this.styleName_ = Q
                }
                setOnChange(Q) {
                    if (Q && typeof Q != "function")
                        throw Error("onchange must be a function.");
                    this.onchangeWrapper_ && this.workspace.removeChangeListener(this.onchangeWrapper_),
                    this.onchange = Q,
                    this.onchangeWrapper_ = Q.bind(this),
                    this.workspace.addChangeListener(this.onchangeWrapper_)
                }
                getField(Q) {
                    if (typeof Q != "string")
                        throw TypeError("Block.prototype.getField expects a string with the field name but received " + (Q === void 0 ? "nothing" : Q + " of type " + typeof Q) + " instead");
                    for (let oe = 0, pe; pe = this.inputList[oe]; oe++)
                        for (let Ae = 0, Re; Re = pe.fieldRow[Ae]; Ae++)
                            if (Re.name === Q)
                                return Re;
                    return null
                }
                getVars() {
                    const Q = [];
                    for (let oe = 0, pe; pe = this.inputList[oe]; oe++)
                        for (let Ae = 0, Re; Re = pe.fieldRow[Ae]; Ae++)
                            Re.referencesVariables() && Q.push(Re.getValue());
                    return Q
                }
                getVarModels() {
                    const Q = [];
                    for (let oe = 0, pe; pe = this.inputList[oe]; oe++)
                        for (let Ae = 0, Re; Re = pe.fieldRow[Ae]; Ae++)
                            if (Re.referencesVariables()) {
                                const Ue = this.workspace.getVariableById(Re.getValue());
                                Ue && Q.push(Ue)
                            }
                    return Q
                }
                updateVarName(Q) {
                    for (let oe = 0, pe; pe = this.inputList[oe]; oe++)
                        for (let Ae = 0, Re; Re = pe.fieldRow[Ae]; Ae++)
                            Re.referencesVariables() && Q.getId() === Re.getValue() && Re.refreshVariableName()
                }
                renameVarById(Q, oe) {
                    for (let pe = 0, Ae; Ae = this.inputList[pe]; pe++)
                        for (let Re = 0, Ue; Ue = Ae.fieldRow[Re]; Re++)
                            Ue.referencesVariables() && Q === Ue.getValue() && Ue.setValue(oe)
                }
                getFieldValue(Q) {
                    return (Q = this.getField(Q)) ? Q.getValue() : null
                }
                setFieldValue(Q, oe) {
                    const pe = this.getField(oe);
                    if (!pe)
                        throw Error('Field "' + oe + '" not found.');
                    pe.setValue(Q)
                }
                setPreviousStatement(Q, oe) {
                    if (Q)
                        oe === void 0 && (oe = null),
                        this.previousConnection || (this.previousConnection = this.makeConnection_(pn.PREVIOUS_STATEMENT)),
                        this.previousConnection.setCheck(oe);
                    else if (this.previousConnection) {
                        if (this.previousConnection.isConnected())
                            throw Error("Must disconnect previous statement before removing connection.");
                        this.previousConnection.dispose(),
                        this.previousConnection = null
                    }
                }
                setNextStatement(Q, oe) {
                    if (Q)
                        oe === void 0 && (oe = null),
                        this.nextConnection || (this.nextConnection = this.makeConnection_(pn.NEXT_STATEMENT)),
                        this.nextConnection.setCheck(oe);
                    else if (this.nextConnection) {
                        if (this.nextConnection.isConnected())
                            throw Error("Must disconnect next statement before removing connection.");
                        this.nextConnection.dispose(),
                        this.nextConnection = null
                    }
                }
                setOutput(Q, oe) {
                    if (Q)
                        oe === void 0 && (oe = null),
                        this.outputConnection || (this.outputConnection = this.makeConnection_(pn.OUTPUT_VALUE)),
                        this.outputConnection.setCheck(oe);
                    else if (this.outputConnection) {
                        if (this.outputConnection.isConnected())
                            throw Error("Must disconnect output value before removing connection.");
                        this.outputConnection.dispose(),
                        this.outputConnection = null
                    }
                }
                setInputsInline(Q) {
                    this.inputsInline !== Q && (Ye(new (gt(J.CHANGE$$module$build$src$core$events$utils))(this,"inline",null,this.inputsInline,Q)),
                    this.inputsInline = Q)
                }
                getInputsInline() {
                    if (this.inputsInline !== void 0)
                        return this.inputsInline;
                    for (var Q = 1; Q < this.inputList.length; Q++)
                        if (this.inputList[Q - 1]instanceof Ns && this.inputList[Q]instanceof Ns)
                            return !1;
                    for (Q = 1; Q < this.inputList.length; Q++)
                        if (this.inputList[Q - 1]instanceof J.ValueInput$$module$build$src$core$inputs$value_input && this.inputList[Q]instanceof Ns)
                            return !0;
                    for (Q = 0; Q < this.inputList.length; Q++)
                        if (this.inputList[Q]instanceof to)
                            return !0;
                    return !1
                }
                setOutputShape(Q) {
                    this.outputShape_ = Q
                }
                getOutputShape() {
                    return this.outputShape_
                }
                isEnabled() {
                    return !this.disabled
                }
                setEnabled(Q) {
                    if (this.isEnabled() !== Q) {
                        const oe = this.disabled;
                        this.disabled = !Q,
                        Ye(new (gt(J.CHANGE$$module$build$src$core$events$utils))(this,"disabled",null,oe,!Q))
                    }
                }
                getInheritedDisabled() {
                    let Q = this.getSurroundParent();
                    for (; Q; ) {
                        if (Q.disabled)
                            return !0;
                        Q = Q.getSurroundParent()
                    }
                    return !1
                }
                isCollapsed() {
                    return this.collapsed_
                }
                setCollapsed(Q) {
                    this.collapsed_ !== Q && (Ye(new (gt(J.CHANGE$$module$build$src$core$events$utils))(this,"collapsed",null,this.collapsed_,Q)),
                    this.collapsed_ = Q)
                }
                toString(Q, oe) {
                    oe = this.toTokens(oe);
                    for (let Ae = 2; Ae < oe.length; Ae++)
                        oe[Ae - 2] === "(" && oe[Ae] === ")" && (oe[Ae - 2] = oe[Ae - 1],
                        oe.splice(Ae - 1, 2));
                    let pe = "";
                    return oe = oe.reduce( (Ae, Re) => (Ae = Ae + (pe === "(" || Re === ")" ? "" : " ") + Re,
                    pe = Re[Re.length - 1],
                    Ae), ""),
                    oe = oe.trim() || "???",
                    Q && oe.length > Q && (oe = oe.substring(0, Q - 3) + "..."),
                    oe
                }
                toTokens(Q="?") {
                    const oe = [];
                    for (const Ae of this.inputList)
                        if (Ae.name != aa) {
                            for (const Re of Ae.fieldRow)
                                oe.push(Re.getText());
                            if (Ae.connection) {
                                const Re = Ae.connection.targetBlock();
                                if (Re) {
                                    var pe = Ae.connection;
                                    let Ue = pe.getCheck();
                                    !Ue && pe.targetConnection && (Ue = pe.targetConnection.getCheck()),
                                    (pe = !!Ue && (Ue.indexOf("Boolean") !== -1 || Ue.indexOf("Number") !== -1)) && oe.push("("),
                                    oe.push(...Re.toTokens(Q)),
                                    pe && oe.push(")")
                                } else
                                    oe.push(Q)
                            }
                        }
                    return oe
                }
                appendValueInput(Q) {
                    return this.appendInput(new J.ValueInput$$module$build$src$core$inputs$value_input(Q,this))
                }
                appendStatementInput(Q) {
                    return this.statementInputCount++,
                    this.appendInput(new jr(Q,this))
                }
                appendDummyInput(Q="") {
                    return this.appendInput(new Ns(Q,this))
                }
                appendEndRowInput(Q="") {
                    return this.appendInput(new to(Q,this))
                }
                appendInput(Q) {
                    return this.inputList.push(Q),
                    Q
                }
                appendInputFromRegistry(Q, oe) {
                    return (Q = Te(Yt.INPUT, Q, !1)) ? this.appendInput(new Q(oe,this)) : null
                }
                jsonInit(Q) {
                    var oe = Q.type ? 'Block "' + Q.type + '": ' : "";
                    if (Q.output && Q.previousStatement)
                        throw Error(oe + "Must not have both an output and a previousStatement.");
                    for (var pe = 0; Q["args" + pe]; ) {
                        if (Q["message" + pe] === void 0)
                            throw Error(oe + `args${pe} must have a corresponding message (message${pe}).`);
                        pe++
                    }
                    if (Q.style && Q.style.hat && (this.hat = Q.style.hat,
                    Q.style = null),
                    Q.style && Q.colour)
                        throw Error(oe + "Must not have both a colour and a style.");
                    for (Q.style ? this.jsonInitStyle_(Q, oe) : this.jsonInitColour_(Q, oe),
                    pe = 0; Q["message" + pe] !== void 0; )
                        this.interpolate_(Q["message" + pe], Q["args" + pe] || [], Q["implicitAlign" + pe] || Q["lastDummyAlign" + pe], oe),
                        pe++;
                    if (Q.inputsInline !== void 0 && (J.disable$$module$build$src$core$events$utils(),
                    this.setInputsInline(Q.inputsInline),
                    J.enable$$module$build$src$core$events$utils()),
                    Q.output !== void 0 && this.setOutput(!0, Q.output),
                    Q.outputShape !== void 0 && this.setOutputShape(Q.outputShape),
                    Q.previousStatement !== void 0 && this.setPreviousStatement(!0, Q.previousStatement),
                    Q.nextStatement !== void 0 && this.setNextStatement(!0, Q.nextStatement),
                    Q.tooltip !== void 0 && (pe = rr(Q.tooltip),
                    this.setTooltip(pe)),
                    Q.enableContextMenu !== void 0 && (this.contextMenu = !!Q.enableContextMenu),
                    Q.suppressPrefixSuffix !== void 0 && (this.suppressPrefixSuffix = !!Q.suppressPrefixSuffix),
                    Q.helpUrl !== void 0 && (pe = rr(Q.helpUrl),
                    this.setHelpUrl(pe)),
                    typeof Q.extensions == "string" && (console.warn(oe + "JSON attribute 'extensions' should be an array of strings. Found raw string in JSON for '" + Q.type + "' block."),
                    Q.extensions = [Q.extensions]),
                    Q.mutator !== void 0 && Yl(Q.mutator, this, !0),
                    Q = Q.extensions,
                    Array.isArray(Q))
                        for (oe = 0; oe < Q.length; oe++)
                            Yl(Q[oe], this, !1)
                }
                jsonInitColour_(Q, oe) {
                    if ("colour"in Q)
                        if (Q.colour === void 0)
                            console.warn(oe + "Undefined colour value.");
                        else {
                            Q = Q.colour;
                            try {
                                this.setColour(Q)
                            } catch {
                                console.warn(oe + "Illegal colour value: ", Q)
                            }
                        }
                }
                jsonInitStyle_(Q, oe) {
                    Q = Q.style;
                    try {
                        this.setStyle(Q)
                    } catch {
                        console.warn(oe + "Style does not exist: ", Q)
                    }
                }
                mixin(Q, oe) {
                    if (oe !== void 0 && typeof oe != "boolean")
                        throw Error("opt_disableCheck must be a boolean if provided");
                    if (!oe) {
                        oe = [];
                        for (const pe in Q)
                            this[pe] !== void 0 && oe.push(pe);
                        if (oe.length)
                            throw Error("Mixin will overwrite block members: " + JSON.stringify(oe))
                    }
                    Object.assign(this, Q)
                }
                interpolate_(Q, oe, pe, Ae) {
                    Q = Gu(Q),
                    this.validateTokens_(Q, oe.length),
                    oe = this.interpolateArguments_(Q, oe, pe),
                    pe = [];
                    for (let Re = 0, Ue; Ue = oe[Re]; Re++)
                        if (this.isInputKeyword_(Ue.type)) {
                            if (Q = this.inputFromJson_(Ue, Ae)) {
                                for (let tt = 0, dt; dt = pe[tt]; tt++)
                                    Q.appendField(dt[0], dt[1]);
                                pe.length = 0
                            }
                        } else
                            (Q = this.fieldFromJson_(Ue)) && pe.push([Q, Ue.name])
                }
                validateTokens_(Q, oe) {
                    const pe = [];
                    let Ae = 0;
                    for (let Re = 0; Re < Q.length; Re++) {
                        const Ue = Q[Re];
                        if (typeof Ue == "number") {
                            if (1 > Ue || Ue > oe)
                                throw Error('Block "' + this.type + '": Message index %' + Ue + " out of range.");
                            if (pe[Ue])
                                throw Error('Block "' + this.type + '": Message index %' + Ue + " duplicated.");
                            pe[Ue] = !0,
                            Ae++
                        }
                    }
                    if (Ae !== oe)
                        throw Error('Block "' + this.type + '": Message does not reference all ' + oe + " arg(s).")
                }
                interpolateArguments_(Q, oe, pe) {
                    const Ae = [];
                    for (let Ue = 0; Ue < Q.length; Ue++) {
                        var Re = Q[Ue];
                        if (typeof Re == "number" && (Re = oe[Re - 1]),
                        typeof Re == "string") {
                            if (Re === `
`)
                                Re = {
                                    type: "input_end_row"
                                },
                                pe && (Re.align = pe);
                            else if (Re = this.stringToFieldJson_(Re),
                            !Re)
                                continue
                        }
                        Ae.push(Re)
                    }
                    return (Q = Ae.length) && !this.isInputKeyword_(Ae[Q - 1].type) && (Q = {
                        type: "input_dummy"
                    },
                    pe && (Q.align = pe),
                    Ae.push(Q)),
                    Ae
                }
                fieldFromJson_(Q) {
                    const oe = J.fromJson$$module$build$src$core$field_registry(Q);
                    return !oe && Q.alt ? typeof Q.alt == "string" ? (Q = this.stringToFieldJson_(Q.alt)) ? this.fieldFromJson_(Q) : null : this.fieldFromJson_(Q.alt) : oe
                }
                inputFromJson_(Q, oe) {
                    var pe = {
                        LEFT: J.Align$$module$build$src$core$inputs$align.LEFT,
                        RIGHT: J.Align$$module$build$src$core$inputs$align.RIGHT,
                        CENTRE: J.Align$$module$build$src$core$inputs$align.CENTRE,
                        CENTER: J.Align$$module$build$src$core$inputs$align.CENTRE
                    };
                    let Ae;
                    switch (Q.type) {
                    case "input_value":
                        Ae = this.appendValueInput(Q.name);
                        break;
                    case "input_statement":
                        Ae = this.appendStatementInput(Q.name);
                        break;
                    case "input_dummy":
                        Ae = this.appendDummyInput(Q.name);
                        break;
                    case "input_end_row":
                        Ae = this.appendEndRowInput(Q.name);
                        break;
                    default:
                        Ae = this.appendInputFromRegistry(Q.type, Q.name)
                    }
                    return Ae ? (Q.check && Ae.setCheck(Q.check),
                    Q.align && (pe = pe[Q.align.toUpperCase()],
                    pe === void 0 ? console.warn(oe + "Illegal align value: ", Q.align) : Ae.setAlign(pe)),
                    Ae) : null
                }
                isInputKeyword_(Q) {
                    return Q === "input_value" || Q === "input_statement" || Q === "input_dummy" || Q === "input_end_row" || ge(Yt.INPUT, Q)
                }
                stringToFieldJson_(Q) {
                    return (Q = Q.trim()) ? {
                        type: "field_label",
                        text: Q
                    } : null
                }
                moveInputBefore(Q, oe) {
                    if (Q !== oe) {
                        var pe = -1
                          , Ae = oe ? -1 : this.inputList.length;
                        for (let Re = 0, Ue; Ue = this.inputList[Re]; Re++)
                            if (Ue.name === Q) {
                                if (pe = Re,
                                Ae !== -1)
                                    break
                            } else if (oe && Ue.name === oe && (Ae = Re,
                            pe !== -1))
                                break;
                        if (pe === -1)
                            throw Error('Named input "' + Q + '" not found.');
                        if (Ae === -1)
                            throw Error('Reference input "' + oe + '" not found.');
                        this.moveNumberedInputBefore(pe, Ae)
                    }
                }
                moveNumberedInputBefore(Q, oe) {
                    if (Q === oe)
                        throw Error("Can't move input to itself.");
                    if (Q >= this.inputList.length)
                        throw RangeError("Input index " + Q + " out of bounds.");
                    if (oe > this.inputList.length)
                        throw RangeError("Reference input " + oe + " out of bounds.");
                    const pe = this.inputList[Q];
                    this.inputList.splice(Q, 1),
                    Q < oe && oe--,
                    this.inputList.splice(oe, 0, pe)
                }
                removeInput(Q, oe) {
                    for (let pe = 0, Ae; Ae = this.inputList[pe]; pe++)
                        if (Ae.name === Q)
                            return Ae instanceof jr && this.statementInputCount--,
                            Ae.dispose(),
                            this.inputList.splice(pe, 1),
                            !0;
                    if (oe)
                        return !1;
                    throw Error("Input not found: " + Q)
                }
                getInput(Q) {
                    for (let oe = 0, pe; pe = this.inputList[oe]; oe++)
                        if (pe.name === Q)
                            return pe;
                    return null
                }
                getInputTargetBlock(Q) {
                    return (Q = this.getInput(Q)) && Q.connection && Q.connection.targetBlock()
                }
                getCommentText() {
                    let Q, oe;
                    return (oe = (Q = this.getIcon(Rr.TYPE)) == null ? void 0 : Q.getText()) != null ? oe : null
                }
                setCommentText(Q) {
                    var oe;
                    let pe;
                    const Ae = (pe = (oe = this.getIcon(Rr.TYPE)) == null ? void 0 : oe.getText()) != null ? pe : null;
                    Ae !== Q && (Q !== null ? ((oe = this.getIcon(Rr.TYPE)) || (oe = this.addIcon(new Rr(this))),
                    J.disable$$module$build$src$core$events$utils(),
                    oe.setText(Q),
                    J.enable$$module$build$src$core$events$utils()) : this.removeIcon(Rr.TYPE),
                    Ye(new (gt(J.CHANGE$$module$build$src$core$events$utils))(this,"comment",null,Ae,Q)))
                }
                setWarningText(Q, oe) {}
                setMutator(Q) {}
                addIcon(Q) {
                    if (this.hasIcon(Q.getType()))
                        throw new kg(Q);
                    return this.icons.push(Q),
                    this.icons.sort( (oe, pe) => oe.getWeight() - pe.getWeight()),
                    Q
                }
                removeIcon(Q) {
                    if (!this.hasIcon(Q))
                        return !1;
                    let oe;
                    return (oe = this.getIcon(Q)) == null || oe.dispose(),
                    this.icons = this.icons.filter(pe => !pe.getType().equals(Q)),
                    !0
                }
                hasIcon(Q) {
                    return this.icons.some(oe => oe.getType().equals(Q))
                }
                getIcon(Q) {
                    return Q instanceof Lr ? this.icons.find(oe => oe.getType().equals(Q)) : this.icons.find(oe => oe.getType().toString() === Q)
                }
                getIcons() {
                    return [...this.icons]
                }
                getRelativeToSurfaceXY() {
                    return this.xy_
                }
                moveBy(Q, oe, pe) {
                    if (this.parentBlock_)
                        throw Error("Block has parent");
                    const Ae = new (gt(J.MOVE$$module$build$src$core$events$utils))(this);
                    pe && Ae.setReason(pe),
                    this.xy_.translate(Q, oe),
                    Ae.recordNew(),
                    Ye(Ae)
                }
                makeConnection_(Q) {
                    return new Pn(this,Q)
                }
                allInputsFilled(Q) {
                    if (Q === void 0 && (Q = !0),
                    !Q && this.isShadow())
                        return !1;
                    for (let pe = 0, Ae; Ae = this.inputList[pe]; pe++)
                        if (Ae.connection) {
                            var oe = Ae.connection.targetBlock();
                            if (!oe || !oe.allInputsFilled(Q))
                                return !1
                        }
                    return (oe = this.getNextBlock()) ? oe.allInputsFilled(Q) : !0
                }
                toDevString() {
                    let Q = this.type ? '"' + this.type + '" block' : "Block";
                    return this.id && (Q += ' (id="' + this.id + '")'),
                    Q
                }
            }
            ;
            la.COLLAPSED_INPUT_NAME = aa,
            la.COLLAPSED_FIELD_NAME = Pc;
            var zg = class {
                constructor() {
                    this.drawer = this.curNode = this.colour = null,
                    this.type = "marker"
                }
                setDrawer(Q) {
                    this.drawer = Q
                }
                getDrawer() {
                    return this.drawer
                }
                getCurNode() {
                    return this.curNode
                }
                setCurNode(Q) {
                    const oe = this.curNode;
                    this.curNode = Q,
                    this.drawer && this.drawer.draw(oe, this.curNode)
                }
                draw() {
                    this.drawer && this.drawer.draw(this.curNode, this.curNode)
                }
                hide() {
                    this.drawer && this.drawer.hide()
                }
                dispose() {
                    this.getDrawer() && this.getDrawer().dispose()
                }
            }
              , Jh = class extends zg {
                constructor() {
                    super(),
                    this.type = "cursor"
                }
                next() {
                    var Q = this.getCurNode();
                    if (!Q)
                        return null;
                    for (Q = Q.next(); Q && Q.next() && (Q.getType() === jt.types.NEXT || Q.getType() === jt.types.BLOCK); )
                        Q = Q.next();
                    return Q && this.setCurNode(Q),
                    Q
                }
                in() {
                    var Q = this.getCurNode();
                    if (!Q)
                        return null;
                    (Q.getType() === jt.types.PREVIOUS || Q.getType() === jt.types.OUTPUT) && (Q = Q.next());
                    let oe, pe;
                    return (Q = (pe = (oe = Q) == null ? void 0 : oe.in()) != null ? pe : null) && this.setCurNode(Q),
                    Q
                }
                prev() {
                    var Q = this.getCurNode();
                    if (!Q)
                        return null;
                    for (Q = Q.prev(); Q && Q.prev() && (Q.getType() === jt.types.NEXT || Q.getType() === jt.types.BLOCK); )
                        Q = Q.prev();
                    return Q && this.setCurNode(Q),
                    Q
                }
                out() {
                    var Q = this.getCurNode();
                    return Q ? ((Q = Q.out()) && Q.getType() === jt.types.BLOCK && (Q = Q.prev() || Q),
                    Q && this.setCurNode(Q),
                    Q) : null
                }
            }
            ;
            ne(Yt.CURSOR, js, Jh);
            var pl = class extends Jh {
                constructor() {
                    super()
                }
                next() {
                    var Q = this.getCurNode();
                    return Q ? ((Q = this.getNextNode_(Q, this.validNode_)) && this.setCurNode(Q),
                    Q) : null
                }
                in() {
                    return this.next()
                }
                prev() {
                    var Q = this.getCurNode();
                    return Q ? ((Q = this.getPreviousNode_(Q, this.validNode_)) && this.setCurNode(Q),
                    Q) : null
                }
                out() {
                    return this.prev()
                }
                getNextNode_(Q, oe) {
                    if (!Q)
                        return null;
                    const pe = Q.in() || Q.next();
                    return oe(pe) ? pe : pe ? this.getNextNode_(pe, oe) : (Q = this.findSiblingOrParent(Q.out()),
                    oe(Q) ? Q : Q ? this.getNextNode_(Q, oe) : null)
                }
                getPreviousNode_(Q, oe) {
                    if (!Q)
                        return null;
                    let pe = Q.prev();
                    return pe = pe ? this.getRightMostChild(pe) : Q.out(),
                    oe(pe) ? pe : pe ? this.getPreviousNode_(pe, oe) : null
                }
                validNode_(Q) {
                    let oe = !1;
                    return Q = Q && Q.getType(),
                    (Q === jt.types.OUTPUT || Q === jt.types.INPUT || Q === jt.types.FIELD || Q === jt.types.NEXT || Q === jt.types.PREVIOUS || Q === jt.types.WORKSPACE) && (oe = !0),
                    oe
                }
                findSiblingOrParent(Q) {
                    if (!Q)
                        return null;
                    const oe = Q.next();
                    return oe || this.findSiblingOrParent(Q.out())
                }
                getRightMostChild(Q) {
                    if (!Q.in())
                        return Q;
                    for (Q = Q.in(); Q && Q.next(); )
                        Q = Q.next();
                    return this.getRightMostChild(Q)
                }
            }
            ;
            pl.registrationName = "basicCursor",
            ne(Yt.CURSOR, pl.registrationName, pl);
            var Kg = class extends pl {
                validNode_(Q) {
                    let oe = !1;
                    const pe = Q && Q.getType();
                    return Q && (Q = Q.getLocation(),
                    pe === jt.types.FIELD && Q && Q.isTabNavigable() && Q.isClickable() && (oe = !0)),
                    oe
                }
            }
              , qh = 10
              , br = class extends Pn {
                constructor(Q, oe) {
                    super(Q, oe),
                    this.targetConnection = this.highlightPath = null,
                    this.db = Q.workspace.connectionDBList[oe],
                    this.dbOpposite = Q.workspace.connectionDBList[ri[oe]],
                    this.offsetInBlock = new Zt(0,0),
                    this.trackedState = br.TrackedState.WILL_TRACK
                }
                dispose() {
                    super.dispose(),
                    this.trackedState === br.TrackedState.TRACKED && this.db.removeConnection(this, this.y),
                    this.highlightPath && (Bt(this.highlightPath),
                    this.highlightPath = null)
                }
                getSourceBlock() {
                    return super.getSourceBlock()
                }
                targetBlock() {
                    return super.targetBlock()
                }
                distanceFrom(Q) {
                    const oe = this.x - Q.x;
                    return Q = this.y - Q.y,
                    Math.sqrt(oe * oe + Q * Q)
                }
                bumpAwayFrom(Q) {
                    if (!this.sourceBlock_.workspace.isDragging()) {
                        var oe = this.sourceBlock_.getRootBlock();
                        if (!oe.isInFlyout) {
                            var pe = !1;
                            if (!oe.isMovable()) {
                                if (oe = Q.getSourceBlock().getRootBlock(),
                                !oe.isMovable())
                                    return;
                                Q = this,
                                pe = !0
                            }
                            var Ae = we() == oe;
                            Ae || oe.addSelect();
                            var Re = Q.x + J.config$$module$build$src$core$config.snapRadius + Math.floor(Math.random() * qh) - this.x
                              , Ue = Q.y + J.config$$module$build$src$core$config.snapRadius + Math.floor(Math.random() * qh) - this.y;
                            pe && (Ue = -Ue),
                            oe.RTL && (Re = Q.x - J.config$$module$build$src$core$config.snapRadius - Math.floor(Math.random() * qh) - this.x),
                            oe.moveBy(Re, Ue, ["bump"]),
                            Ae || oe.removeSelect()
                        }
                    }
                }
                moveTo(Q, oe) {
                    let pe = !1;
                    return this.trackedState === br.TrackedState.WILL_TRACK ? (this.db.addConnection(this, oe),
                    this.trackedState = br.TrackedState.TRACKED,
                    pe = !0) : this.trackedState === br.TrackedState.TRACKED && (this.db.removeConnection(this, this.y),
                    this.db.addConnection(this, oe),
                    pe = !0),
                    this.x = Q,
                    this.y = oe,
                    pe
                }
                moveBy(Q, oe) {
                    return this.moveTo(this.x + Q, this.y + oe)
                }
                moveToOffset(Q) {
                    return this.moveTo(Q.x + this.offsetInBlock.x, Q.y + this.offsetInBlock.y)
                }
                setOffsetInBlock(Q, oe) {
                    this.offsetInBlock.x = Q,
                    this.offsetInBlock.y = oe
                }
                getOffsetInBlock() {
                    return this.offsetInBlock
                }
                tightenEfficiently() {
                    var Q = this.targetConnection;
                    const oe = this.targetBlock();
                    Q && oe && (Q = Zt.difference(this.offsetInBlock, Q.offsetInBlock),
                    oe.translate(Q.x, Q.y))
                }
                closest(Q, oe) {
                    return this.dbOpposite.searchForClosest(this, Q, oe)
                }
                highlight() {
                    if (!this.highlightPath) {
                        var Q = this.sourceBlock_.workspace.getRenderer().getConstants()
                          , oe = Q.shapeFor(this);
                        this.type === pn.INPUT_VALUE || this.type === pn.OUTPUT_VALUE ? (Q = Q.TAB_OFFSET_FROM_TOP,
                        oe = qn(0, -Q) + ln("v", Q) + oe.pathDown + ln("v", Q)) : (Q = Q.NOTCH_OFFSET_LEFT - Q.CORNER_RADIUS,
                        oe = qn(-Q, 0) + ln("h", Q) + oe.pathLeft + ln("h", Q)),
                        Q = this.offsetInBlock,
                        this.highlightPath = $t(bt.PATH, {
                            class: "blocklyHighlightedConnectionPath",
                            d: oe,
                            transform: `translate(${Q.x}, ${Q.y})` + (this.sourceBlock_.RTL ? " scale(-1 1)" : "")
                        }, this.sourceBlock_.getSvgRoot())
                    }
                }
                unhighlight() {
                    this.highlightPath && (Bt(this.highlightPath),
                    this.highlightPath = null)
                }
                setTracking(Q) {
                    Q && this.trackedState === br.TrackedState.TRACKED || !Q && this.trackedState === br.TrackedState.UNTRACKED || this.sourceBlock_.isInFlyout || (Q ? (this.db.addConnection(this, this.y),
                    this.trackedState = br.TrackedState.TRACKED) : (this.trackedState === br.TrackedState.TRACKED && this.db.removeConnection(this, this.y),
                    this.trackedState = br.TrackedState.UNTRACKED))
                }
                stopTrackingAll() {
                    if (this.setTracking(!1),
                    this.targetConnection) {
                        const Q = this.targetBlock().getDescendants(!1);
                        for (let oe = 0; oe < Q.length; oe++) {
                            const pe = Q[oe]
                              , Ae = pe.getConnections_(!0);
                            for (let Re = 0; Re < Ae.length; Re++)
                                Ae[Re].setTracking(!1);
                            for (const Re of pe.getIcons())
                                uo(Re) && Re.setBubbleVisible(!1)
                        }
                    }
                }
                startTrackingAll() {
                    this.setTracking(!0);
                    let Q = [];
                    if (this.type !== pn.INPUT_VALUE && this.type !== pn.NEXT_STATEMENT)
                        return Q;
                    const oe = this.targetBlock();
                    if (oe) {
                        let pe;
                        oe.isCollapsed() ? (pe = [],
                        oe.outputConnection && pe.push(oe.outputConnection),
                        oe.nextConnection && pe.push(oe.nextConnection),
                        oe.previousConnection && pe.push(oe.previousConnection)) : pe = oe.getConnections_(!0);
                        for (let Ae = 0; Ae < pe.length; Ae++)
                            Q.push(...pe[Ae].startTrackingAll());
                        Q.length || (Q = [oe])
                    }
                    return Q
                }
                onFailedConnect(Q) {
                    const oe = this.getSourceBlock();
                    if (St()) {
                        const pe = J.getGroup$$module$build$src$core$events$utils();
                        setTimeout((function() {
                            oe.isDisposed() || oe.getParent() || (J.setGroup$$module$build$src$core$events$utils(pe),
                            this.bumpAwayFrom(Q),
                            J.setGroup$$module$build$src$core$events$utils(!1))
                        }
                        ).bind(this), J.config$$module$build$src$core$config.bumpDelay)
                    }
                }
                disconnectInternal(Q=!0) {
                    const {parentConnection: oe, childConnection: pe} = this.getParentAndChildConnections();
                    if (oe && pe) {
                        var Ae = oe.getSourceBlock()
                          , Re = pe.getSourceBlock();
                        super.disconnectInternal(Q),
                        Ae.rendered && Ae.queueRender(),
                        Re.rendered && (Re.updateDisabled(),
                        Re.queueRender(),
                        Re.getSvgRoot().style.display = "block")
                    }
                }
                respawnShadow_() {
                    super.respawnShadow_();
                    const Q = this.targetBlock();
                    Q && (Q.initSvg(),
                    Q.queueRender())
                }
                neighbours(Q) {
                    return this.dbOpposite.getNeighbours(this, Q)
                }
                connect_(Q) {
                    super.connect_(Q);
                    var oe = this.getSourceBlock();
                    Q = Q.getSourceBlock();
                    const pe = oe.rendered
                      , Ae = Q.rendered;
                    pe && oe.updateDisabled(),
                    Ae && Q.updateDisabled(),
                    pe && Ae && (this.type === pn.NEXT_STATEMENT || this.type === pn.PREVIOUS_STATEMENT ? Q.queueRender() : oe.queueRender()),
                    (oe = oe.getInputWithBlock(Q)) && (oe = oe.isVisible(),
                    Q.getSvgRoot().style.display = oe ? "block" : "none")
                }
                onCheckChanged_() {
                    !this.isConnected() || this.targetConnection && this.getConnectionChecker().canConnect(this, this.targetConnection, !1) || ((this.isSuperior() ? this.targetBlock() : this.sourceBlock_).unplug(),
                    this.sourceBlock_.bumpNeighbours())
                }
                setCheck(Q) {
                    return super.setCheck(Q),
                    this.sourceBlock_.rendered && this.sourceBlock_.queueRender(),
                    this
                }
            }
            ;
            (function(Q) {
                Q = Q.TrackedState || (Q.TrackedState = {}),
                Q[Q.WILL_TRACK = -1] = "WILL_TRACK",
                Q[Q.UNTRACKED = 0] = "UNTRACKED",
                Q[Q.TRACKED = 1] = "TRACKED"
            }
            )(br || (br = {})),
            br.TrackedState;
            var Ls = class extends la {
                constructor(Q, oe, pe) {
                    super(Q, oe, pe),
                    this.width = this.height = 0,
                    this.warningTextDb = new Map,
                    this.warning = this.mutator = null,
                    this.eventsInit_ = this.renderIsInProgress_ = this.visuallyDisabled = this.rendered = !1,
                    this.translation = "",
                    this.bumpNeighboursPid = 0,
                    this.dragging = !1,
                    this.relativeCoords = new Zt(0,0),
                    this.workspace = Q,
                    this.svgGroup_ = $t(bt.G, {}),
                    this.style = Q.getRenderer().getConstants().getBlockStyle(null),
                    this.pathObject = Q.getRenderer().makePathObject(this.svgGroup_, this.style),
                    Q = this.pathObject.svgPath,
                    Q.tooltip = this,
                    Ni(Q),
                    this.svgGroup_.setAttribute("data-id", this.id),
                    this.doInit_()
                }
                initSvg() {
                    if (!this.workspace.rendered)
                        throw TypeError("Workspace is headless.");
                    for (let oe = 0, pe; pe = this.inputList[oe]; oe++)
                        pe.init();
                    for (var Q of this.getIcons())
                        Q.initView(this.createIconPointerDownListener(Q)),
                        Q.updateEditable();
                    this.applyColour(),
                    this.pathObject.updateMovable(this.isMovable()),
                    Q = this.getSvgRoot(),
                    this.workspace.options.readOnly || this.eventsInit_ || !Q || vt(Q, "pointerdown", this, this.onMouseDown_),
                    this.eventsInit_ = !0,
                    Q.parentNode || this.workspace.getCanvas().appendChild(Q)
                }
                getColourSecondary() {
                    return this.style.colourSecondary
                }
                getColourTertiary() {
                    return this.style.colourTertiary
                }
                select() {
                    if (this.isShadow() && this.getParent())
                        this.getParent().select();
                    else if (we() !== this) {
                        var Q = null;
                        if (we()) {
                            Q = we().id,
                            J.disable$$module$build$src$core$events$utils();
                            try {
                                we().unselect()
                            } finally {
                                J.enable$$module$build$src$core$events$utils()
                            }
                        }
                        Q = new (gt(Ys))(Q,this.id,this.workspace.id),
                        Ye(Q),
                        Fe(this),
                        this.addSelect()
                    }
                }
                unselect() {
                    if (we() === this) {
                        var Q = new (gt(Ys))(this.id,null,this.workspace.id);
                        Q.workspaceId = this.workspace.id,
                        Ye(Q),
                        Fe(null),
                        this.removeSelect()
                    }
                }
                setParent(Q) {
                    const oe = this.parentBlock_;
                    if (Q !== oe) {
                        st(),
                        super.setParent(Q),
                        ht();
                        var pe = this.getSvgRoot();
                        if (!this.workspace.isClearing && pe) {
                            var Ae = this.getRelativeToSurfaceXY();
                            Q ? Q.getSvgRoot().appendChild(pe) : oe && ((Q = this.workspace.getCanvas().querySelector(".blocklyDragging")) ? this.workspace.getCanvas().insertBefore(pe, Q) : this.workspace.getCanvas().appendChild(pe),
                            this.translate(Ae.x, Ae.y)),
                            this.applyColour()
                        }
                    }
                }
                getRelativeToSurfaceXY() {
                    const Q = this.workspace.getLayerManager();
                    if (!Q)
                        throw Error("Cannot calculate position because the workspace has not been appended");
                    let oe = 0
                      , pe = 0
                      , Ae = this.getSvgRoot();
                    if (Ae)
                        do {
                            const Re = _t(Ae);
                            oe += Re.x,
                            pe += Re.y,
                            Ae = Ae.parentNode
                        } while (Ae && !Q.hasLayer(Ae));
                    return new Zt(oe,pe)
                }
                moveBy(Q, oe, pe) {
                    if (this.parentBlock_)
                        throw Error("Block has parent");
                    const Ae = Ke();
                    let Re = null;
                    Ae && (Re = new (gt(J.MOVE$$module$build$src$core$events$utils))(this),
                    pe && Re.setReason(pe)),
                    Q = new Zt(Q,oe),
                    oe = this.getRelativeToSurfaceXY(),
                    Q = Zt.sum(oe, Q),
                    this.translate(Q.x, Q.y),
                    this.updateComponentLocations(Q),
                    Ae && Re && (Re.recordNew(),
                    Ye(Re)),
                    this.workspace.resizeContents()
                }
                translate(Q, oe) {
                    this.translation = `translate(${Q}, ${oe})`,
                    this.relativeCoords = new Zt(Q,oe),
                    this.getSvgRoot().setAttribute("transform", this.getTranslation())
                }
                getTranslation() {
                    return this.translation
                }
                moveTo(Q, oe) {
                    const pe = this.getRelativeToSurfaceXY();
                    this.moveBy(Q.x - pe.x, Q.y - pe.y, oe)
                }
                moveDuringDrag(Q) {
                    this.translate(Q.x, Q.y),
                    this.getSvgRoot().setAttribute("transform", this.getTranslation()),
                    this.updateComponentLocations(Q)
                }
                snapToGrid() {
                    if (!(this.isDeadOrDying() || this.workspace.isDragging() || this.getParent() || this.isInFlyout)) {
                        var Q = this.workspace.getGrid();
                        if (Q && Q.shouldSnap()) {
                            var oe = Q.getSpacing()
                              , pe = oe / 2
                              , Ae = this.getRelativeToSurfaceXY();
                            Q = Math.round(Math.round((Ae.x - pe) / oe) * oe + pe - Ae.x),
                            oe = Math.round(Math.round((Ae.y - pe) / oe) * oe + pe - Ae.y),
                            (Q || oe) && this.moveBy(Q, oe, ["snap"])
                        }
                    }
                }
                getBoundingRectangle() {
                    const Q = this.getRelativeToSurfaceXY()
                      , oe = this.getHeightWidth();
                    let pe, Ae;
                    return this.RTL ? (pe = Q.x - oe.width,
                    Ae = Q.x) : (pe = Q.x,
                    Ae = Q.x + oe.width),
                    new Vn(Q.y,Q.y + oe.height,pe,Ae)
                }
                markDirty() {
                    this.pathObject.constants = this.workspace.getRenderer().getConstants();
                    for (let Q = 0, oe; oe = this.inputList[Q]; Q++)
                        oe.markDirty()
                }
                setCollapsed(Q) {
                    this.collapsed_ !== Q && (super.setCollapsed(Q),
                    this.updateCollapsed_())
                }
                updateCollapsed_() {
                    var Q = this.isCollapsed();
                    const oe = aa
                      , pe = Pc;
                    for (let Re = 0, Ue; Ue = this.inputList[Re]; Re++)
                        Ue.name !== oe && Ue.setVisible(!Q);
                    for (var Ae of this.getIcons())
                        Ae.updateCollapsed();
                    Q ? (Q = this.toString(Sg),
                    (Ae = this.getField(pe)) ? Ae.setValue(Q) : (this.getInput(oe) || this.appendDummyInput(oe)).appendField(new ci(Q), pe)) : (this.updateDisabled(),
                    this.removeInput(oe))
                }
                tab(Q, oe) {
                    const pe = new Kg;
                    pe.setCurNode(jt.createFieldNode(Q)),
                    Q = pe.getCurNode(),
                    oe ? pe.next() : pe.prev(),
                    (oe = pe.getCurNode()) && oe !== Q && (oe.getLocation().showEditor(),
                    this.workspace.keyboardAccessibilityMode && this.workspace.getCursor().setCurNode(oe))
                }
                onMouseDown_(Q) {
                    const oe = this.workspace.getGesture(Q);
                    oe && oe.handleBlockStart(Q, this)
                }
                showHelp() {
                    const Q = typeof this.helpUrl == "function" ? this.helpUrl() : this.helpUrl;
                    Q && window.open(Q)
                }
                generateContextMenu() {
                    if (this.workspace.options.readOnly || !this.contextMenu)
                        return null;
                    const Q = Ln.registry.getContextMenuOptions(Ln.ScopeType.BLOCK, {
                        block: this
                    });
                    return this.customContextMenu && this.customContextMenu(Q),
                    Q
                }
                showContextMenu(Q) {
                    const oe = this.generateContextMenu();
                    oe && oe.length && (Pa(Q, oe, this.RTL),
                    cu(this))
                }
                updateComponentLocations(Q) {
                    if (this.rendered) {
                        this.dragging || this.updateConnectionLocations(Q),
                        this.updateIconLocations(Q),
                        this.updateFieldLocations(Q);
                        for (const oe of this.getChildren(!1))
                            oe.updateComponentLocations(Zt.sum(Q, oe.relativeCoords))
                    }
                }
                updateConnectionLocations(Q) {
                    for (const oe of this.getConnections_(!1))
                        oe.moveToOffset(Q)
                }
                updateIconLocations(Q) {
                    for (const oe of this.getIcons())
                        oe.onLocationChange(Q)
                }
                updateFieldLocations(Q) {
                    for (const oe of this.inputList)
                        for (const pe of oe.fieldRow)
                            pe.onLocationChange(Q)
                }
                setDragging(Q) {
                    (this.dragging = Q) ? (this.translation = "",
                    Di.push(...this.getConnections_(!0)),
                    Ut(this.svgGroup_, "blocklyDragging")) : (Di.length = 0,
                    yt(this.svgGroup_, "blocklyDragging"));
                    for (let oe = 0; oe < this.childBlocks_.length; oe++)
                        this.childBlocks_[oe].setDragging(Q)
                }
                setMovable(Q) {
                    super.setMovable(Q),
                    this.pathObject.updateMovable(Q)
                }
                setEditable(Q) {
                    super.setEditable(Q),
                    Q = this.getIcons();
                    for (let oe = 0; oe < Q.length; oe++)
                        Q[oe].updateEditable()
                }
                setShadow(Q) {
                    super.setShadow(Q),
                    this.applyColour()
                }
                setInsertionMarker(Q) {
                    this.isInsertionMarker_ !== Q && (this.isInsertionMarker_ = Q) && (this.setColour(this.workspace.getRenderer().getConstants().INSERTION_MARKER_COLOUR),
                    this.pathObject.updateInsertionMarker(!0))
                }
                getSvgRoot() {
                    return this.svgGroup_
                }
                dispose(Q, oe) {
                    this.isDeadOrDying() || (wu(),
                    Ma(),
                    oe && this.rendered && (this.unplug(Q),
                    $u(this)),
                    super.dispose(!!Q),
                    Bt(this.svgGroup_))
                }
                disposeInternal() {
                    this.isDeadOrDying() || (super.disposeInternal(),
                    this.rendered = !1,
                    we() === this && (this.unselect(),
                    this.workspace.cancelCurrentGesture()),
                    [...this.warningTextDb.values()].forEach(Q => clearTimeout(Q)),
                    this.warningTextDb.clear(),
                    this.getIcons().forEach(Q => Q.dispose()))
                }
                checkAndDelete() {
                    this.workspace.isFlyout || (J.setGroup$$module$build$src$core$events$utils(!0),
                    this.workspace.hideChaff(),
                    this.outputConnection ? this.dispose(!1, !0) : this.dispose(!0, !0),
                    J.setGroup$$module$build$src$core$events$utils(!1))
                }
                toCopyData() {
                    return this.isInsertionMarker_ ? null : {
                        paster: Ja.TYPE,
                        blockState: Ts(this, {
                            addCoordinates: !0,
                            addNextBlocks: !1
                        }),
                        typeCounts: qe(this, !0)
                    }
                }
                applyColour() {
                    this.pathObject.applyColour(this);
                    const Q = this.getIcons();
                    for (let oe = 0; oe < Q.length; oe++)
                        Q[oe].applyColour();
                    for (let oe = 0, pe; pe = this.inputList[oe]; oe++)
                        for (let Ae = 0, Re; Re = pe.fieldRow[Ae]; Ae++)
                            Re.applyColour()
                }
                updateDisabled() {
                    const Q = !this.isEnabled() || this.getInheritedDisabled();
                    if (this.visuallyDisabled === Q) {
                        let oe;
                        (oe = this.getNextBlock()) == null || oe.updateDisabled()
                    } else {
                        this.applyColour(),
                        this.visuallyDisabled = Q;
                        for (const oe of this.getChildren(!1))
                            oe.updateDisabled()
                    }
                }
                getCommentIcon() {
                    zt("getCommentIcon", "v10", "v11", "getIcon");
                    let Q;
                    return (Q = this.getIcon(Rr.TYPE)) != null ? Q : null
                }
                setWarningText(Q, oe="") {
                    if (oe)
                        this.warningTextDb.has(oe) && (clearTimeout(this.warningTextDb.get(oe)),
                        this.warningTextDb.delete(oe));
                    else {
                        for (var pe of this.warningTextDb.values())
                            clearTimeout(pe);
                        this.warningTextDb.clear()
                    }
                    if (this.workspace.isDragging())
                        this.warningTextDb.set(oe, setTimeout( () => {
                            this.isDeadOrDying() || (this.warningTextDb.delete(oe),
                            this.setWarningText(Q, oe))
                        }
                        , 100));
                    else if (this.isInFlyout && (Q = null),
                    pe = this.getIcon(ls.TYPE),
                    Q) {
                        let Ae = this.getSurroundParent()
                          , Re = null;
                        for (; Ae; )
                            Ae.isCollapsed() && (Re = Ae),
                            Ae = Ae.getSurroundParent();
                        Re && Re.setWarningText(J.Msg$$module$build$src$core$msg.COLLAPSED_WARNINGS_WARNING, Ls.COLLAPSED_WARNING_ID),
                        pe ? pe.addMessage(Q, oe) : this.addIcon(new ls(this).addMessage(Q, oe))
                    } else
                        pe && (oe ? (pe.addMessage("", oe),
                        pe.getText() || this.removeIcon(ls.TYPE)) : this.removeIcon(ls.TYPE))
                }
                setMutator(Q) {
                    this.removeIcon(J.MutatorIcon$$module$build$src$core$icons$mutator_icon.TYPE),
                    Q && this.addIcon(Q)
                }
                addIcon(Q) {
                    return super.addIcon(Q),
                    Q instanceof ls && (this.warning = Q),
                    Q instanceof J.MutatorIcon$$module$build$src$core$icons$mutator_icon && (this.mutator = Q),
                    this.rendered && (Q.initView(this.createIconPointerDownListener(Q)),
                    Q.applyColour(),
                    Q.updateEditable(),
                    this.queueRender(),
                    gs(),
                    this.bumpNeighbours()),
                    Q
                }
                createIconPointerDownListener(Q) {
                    return oe => {
                        this.isDeadOrDying() || (oe = this.workspace.getGesture(oe)) && oe.setStartIcon(Q)
                    }
                }
                removeIcon(Q) {
                    const oe = super.removeIcon(Q);
                    return Q.equals(ls.TYPE) && (this.warning = null),
                    Q.equals(J.MutatorIcon$$module$build$src$core$icons$mutator_icon.TYPE) && (this.mutator = null),
                    this.rendered && (this.queueRender(),
                    gs(),
                    this.bumpNeighbours()),
                    oe
                }
                setEnabled(Q) {
                    this.isEnabled() !== Q && (super.setEnabled(Q),
                    this.rendered && !this.getInheritedDisabled() && this.updateDisabled())
                }
                setHighlighted(Q) {
                    this.rendered && this.pathObject.updateHighlighted(Q)
                }
                addSelect() {
                    this.pathObject.updateSelected(!0)
                }
                removeSelect() {
                    this.pathObject.updateSelected(!1)
                }
                setDeleteStyle(Q) {
                    this.pathObject.updateDraggingDelete(Q)
                }
                getColour() {
                    return this.style.colourPrimary
                }
                setColour(Q) {
                    super.setColour(Q),
                    Q = this.workspace.getRenderer().getConstants().getBlockStyleForColour(this.colour_),
                    this.pathObject.setStyle(Q.style),
                    this.style = Q.style,
                    this.styleName_ = Q.name,
                    this.applyColour()
                }
                setStyle(Q) {
                    const oe = this.workspace.getRenderer().getConstants().getBlockStyle(Q);
                    if (this.styleName_ = Q,
                    oe)
                        this.hat = oe.hat,
                        this.pathObject.setStyle(oe),
                        this.colour_ = oe.colourPrimary,
                        this.style = oe,
                        this.applyColour();
                    else
                        throw Error("Invalid style name: " + Q)
                }
                bringToFront(Q=!1) {
                    let oe = this;
                    if (!oe.isDeadOrDying())
                        do {
                            const pe = oe.getSvgRoot()
                              , Ae = pe.parentNode
                              , Re = Ae.childNodes;
                            if (Re[Re.length - 1] !== pe && Ae.appendChild(pe),
                            Q)
                                break;
                            oe = oe.getParent()
                        } while (oe)
                }
                setPreviousStatement(Q, oe) {
                    super.setPreviousStatement(Q, oe),
                    this.rendered && (this.queueRender(),
                    this.bumpNeighbours())
                }
                setNextStatement(Q, oe) {
                    super.setNextStatement(Q, oe),
                    this.rendered && (this.queueRender(),
                    this.bumpNeighbours())
                }
                setOutput(Q, oe) {
                    super.setOutput(Q, oe),
                    this.rendered && (this.queueRender(),
                    this.bumpNeighbours())
                }
                setInputsInline(Q) {
                    super.setInputsInline(Q),
                    this.rendered && (this.queueRender(),
                    this.bumpNeighbours())
                }
                removeInput(Q, oe) {
                    return Q = super.removeInput(Q, oe),
                    this.rendered && (this.queueRender(),
                    this.bumpNeighbours()),
                    Q
                }
                moveNumberedInputBefore(Q, oe) {
                    super.moveNumberedInputBefore(Q, oe),
                    this.rendered && (this.queueRender(),
                    this.bumpNeighbours())
                }
                appendInput(Q) {
                    return super.appendInput(Q),
                    this.rendered && (this.queueRender(),
                    this.bumpNeighbours()),
                    Q
                }
                setConnectionTracking(Q) {
                    if (this.previousConnection && this.previousConnection.setTracking(Q),
                    this.outputConnection && this.outputConnection.setTracking(Q),
                    this.nextConnection) {
                        this.nextConnection.setTracking(Q);
                        var oe = this.nextConnection.targetBlock();
                        oe && oe.setConnectionTracking(Q)
                    }
                    if (!this.collapsed_)
                        for (oe = 0; oe < this.inputList.length; oe++) {
                            var pe = this.inputList[oe].connection;
                            pe && (pe.setTracking(Q),
                            (pe = pe.targetBlock()) && pe.setConnectionTracking(Q))
                        }
                }
                getConnections_(Q) {
                    const oe = [];
                    if ((Q || this.rendered) && (this.outputConnection && oe.push(this.outputConnection),
                    this.previousConnection && oe.push(this.previousConnection),
                    this.nextConnection && oe.push(this.nextConnection),
                    Q || !this.collapsed_))
                        for (let pe = 0, Ae; Ae = this.inputList[pe]; pe++)
                            Ae.connection && oe.push(Ae.connection);
                    return oe
                }
                lastConnectionInStack(Q) {
                    return super.lastConnectionInStack(Q)
                }
                getMatchingConnection(Q, oe) {
                    return super.getMatchingConnection(Q, oe)
                }
                makeConnection_(Q) {
                    return new br(this,Q)
                }
                getNextBlock() {
                    return super.getNextBlock()
                }
                getPreviousBlock() {
                    return super.getPreviousBlock()
                }
                bumpNeighbours() {
                    if (!this.bumpNeighboursPid) {
                        var Q = J.getGroup$$module$build$src$core$events$utils();
                        this.bumpNeighboursPid = setTimeout( () => {
                            const oe = J.getGroup$$module$build$src$core$events$utils();
                            J.setGroup$$module$build$src$core$events$utils(Q),
                            this.getRootBlock().bumpNeighboursInternal(),
                            J.setGroup$$module$build$src$core$events$utils(oe),
                            this.bumpNeighboursPid = 0
                        }
                        , J.config$$module$build$src$core$config.bumpDelay)
                    }
                }
                bumpNeighboursInternal() {
                    const Q = this.getRootBlock();
                    if (!(this.isDeadOrDying() || this.workspace.isDragging() || Q.isInFlyout))
                        for (const oe of this.getConnections_(!1)) {
                            if (oe.isSuperior()) {
                                let pe;
                                (pe = oe.targetBlock()) == null || pe.bumpNeighboursInternal()
                            }
                            for (const pe of oe.neighbours(J.config$$module$build$src$core$config.snapRadius))
                                pe.getSourceBlock().getRootBlock() !== Q && (oe.isConnected() && pe.isConnected() || (oe.isSuperior() ? pe.bumpAwayFrom(oe) : oe.bumpAwayFrom(pe)))
                        }
                }
                scheduleSnapAndBump() {
                    const Q = J.getGroup$$module$build$src$core$events$utils();
                    setTimeout( () => {
                        J.setGroup$$module$build$src$core$events$utils(Q),
                        this.snapToGrid(),
                        J.setGroup$$module$build$src$core$events$utils(!1)
                    }
                    , J.config$$module$build$src$core$config.bumpDelay / 2),
                    this.bumpNeighbours()
                }
                positionNearConnection(Q, oe, pe) {
                    if (Q.type === pn.NEXT_STATEMENT || Q.type === pn.INPUT_VALUE) {
                        let Ae = oe.x;
                        oe = oe.y,
                        Ae += pe.x - Q.getOffsetInBlock().x,
                        oe += pe.y - Q.getOffsetInBlock().y,
                        this.moveBy(Ae, oe)
                    }
                }
                getChildren(Q) {
                    return super.getChildren(Q)
                }
                queueRender() {
                    return Yc(this)
                }
                render() {
                    this.queueRender(),
                    gs()
                }
                renderEfficiently() {
                    this.rendered = !0,
                    st(),
                    this.isCollapsed() && this.updateCollapsed_(),
                    this.isEnabled() || this.updateDisabled(),
                    this.workspace.getRenderer().render(this),
                    this.tightenChildrenEfficiently(),
                    ht(),
                    this.updateMarkers_()
                }
                tightenChildrenEfficiently() {
                    for (const Q of this.inputList) {
                        const oe = Q.connection;
                        oe && oe.tightenEfficiently()
                    }
                    this.nextConnection && this.nextConnection.tightenEfficiently()
                }
                updateMarkers_() {
                    this.workspace.keyboardAccessibilityMode && this.pathObject.cursorSvg && this.workspace.getCursor().draw(),
                    this.workspace.keyboardAccessibilityMode && this.pathObject.markerSvg && this.workspace.getMarker(rl.LOCAL_MARKER).draw();
                    for (const Q of this.inputList)
                        for (const oe of Q.fieldRow)
                            oe.updateMarkers_()
                }
                setCursorSvg(Q) {
                    this.pathObject.setCursorSvg(Q)
                }
                setMarkerSvg(Q) {
                    this.pathObject.setMarkerSvg(Q)
                }
                getHeightWidth() {
                    let Q = this.height
                      , oe = this.width;
                    var pe = this.getNextBlock();
                    if (pe) {
                        pe = pe.getHeightWidth();
                        const Ae = this.workspace.getRenderer().getConstants().NOTCH_HEIGHT;
                        Q += pe.height - Ae,
                        oe = Math.max(oe, pe.width)
                    }
                    return {
                        height: Q,
                        width: oe
                    }
                }
                fadeForReplacement(Q) {
                    this.pathObject.updateReplacementFade(Q)
                }
                highlightShapeForInput(Q, oe) {
                    this.pathObject.updateShapeForInputHighlight(Q, oe)
                }
            }
            ;
            Ls.INLINE = -1,
            Ls.COLLAPSED_WARNING_ID = "TEMP_COLLAPSED_WARNING_";
            var Jg = class {
                constructor() {}
                onDragEnter(Q) {}
                onDragOver(Q) {}
                onDragExit(Q) {}
                onDrop(Q) {}
                getClientRect() {
                    return null
                }
                shouldPreventMove(Q) {
                    return !1
                }
            }
              , Mc = class extends Jg {
                constructor() {
                    super(),
                    this.wouldDelete_ = !1
                }
                wouldDelete(Q, oe) {
                    return Q instanceof Ls ? (Q = !Q.getParent() && Q.isDeletable(),
                    this.updateWouldDelete_(Q && !oe)) : this.updateWouldDelete_(Q.isDeletable()),
                    this.wouldDelete_
                }
                updateWouldDelete_(Q) {
                    this.wouldDelete_ = Q
                }
            }
              , qg = class extends Mc {
                constructor(Q) {
                    super(),
                    this.workspace = Q,
                    this.id = "trashcan",
                    this.contents = [],
                    this.flyout = null,
                    this.isLidOpen = !1,
                    this.minOpenness = 0,
                    this.lidTask = this.svgLid = this.svgGroup = null,
                    this.top = this.left = this.lidOpen = 0,
                    this.initialized = !1,
                    0 >= this.workspace.options.maxTrashcanContents || (Q = new Qr({
                        scrollbars: !0,
                        parentWorkspace: this.workspace,
                        rtl: this.workspace.RTL,
                        oneBasedIndex: this.workspace.options.oneBasedIndex,
                        renderer: this.workspace.options.renderer,
                        rendererOverrides: this.workspace.options.rendererOverrides,
                        move: {
                            scrollbars: !0
                        }
                    }),
                    this.workspace.horizontalLayout ? (Q.toolboxPosition = this.workspace.toolboxPosition === In.TOP ? In.BOTTOM : In.TOP,
                    this.flyout = new (Ie(Yt.FLYOUTS_HORIZONTAL_TOOLBOX, this.workspace.options, !0))(Q)) : (Q.toolboxPosition = this.workspace.toolboxPosition === In.RIGHT ? In.LEFT : In.RIGHT,
                    this.flyout = new (Ie(Yt.FLYOUTS_VERTICAL_TOOLBOX, this.workspace.options, !0))(Q)),
                    this.workspace.addChangeListener(this.onDelete.bind(this)))
                }
                createDom() {
                    this.svgGroup = $t(bt.G, {
                        class: "blocklyTrash"
                    });
                    let Q;
                    const oe = String(Math.random()).substring(2);
                    Q = $t(bt.CLIPPATH, {
                        id: "blocklyTrashBodyClipPath" + oe
                    }, this.svgGroup),
                    $t(bt.RECT, {
                        width: ca,
                        height: kc,
                        y: ua
                    }, Q);
                    const pe = $t(bt.IMAGE, {
                        width: Ir.width,
                        x: -Qh,
                        height: Ir.height,
                        y: -Zh,
                        "clip-path": "url(#blocklyTrashBodyClipPath" + oe + ")"
                    }, this.svgGroup);
                    return pe.setAttributeNS(Fr, "xlink:href", this.workspace.options.pathToMedia + Ir.url),
                    Q = $t(bt.CLIPPATH, {
                        id: "blocklyTrashLidClipPath" + oe
                    }, this.svgGroup),
                    $t(bt.RECT, {
                        width: ca,
                        height: ua
                    }, Q),
                    this.svgLid = $t(bt.IMAGE, {
                        width: Ir.width,
                        x: -Qh,
                        height: Ir.height,
                        y: -Zh,
                        "clip-path": "url(#blocklyTrashLidClipPath" + oe + ")"
                    }, this.svgGroup),
                    this.svgLid.setAttributeNS(Fr, "xlink:href", this.workspace.options.pathToMedia + Ir.url),
                    Jt(this.svgGroup, "pointerdown", this, this.blockMouseDownWhenOpenable),
                    Jt(this.svgGroup, "pointerup", this, this.click),
                    Jt(pe, "pointerover", this, this.mouseOver),
                    Jt(pe, "pointerout", this, this.mouseOut),
                    this.animateLid(),
                    this.svgGroup
                }
                init() {
                    0 < this.workspace.options.maxTrashcanContents && (Wt(this.flyout.createDom(bt.SVG), this.workspace.getParentSvg()),
                    this.flyout.init(this.workspace)),
                    this.workspace.getComponentManager().addComponent({
                        component: this,
                        weight: 1,
                        capabilities: [dr.Capability.AUTOHIDEABLE, dr.Capability.DELETE_AREA, dr.Capability.DRAG_TARGET, dr.Capability.POSITIONABLE]
                    }),
                    this.initialized = !0,
                    this.setLidOpen(!1)
                }
                dispose() {
                    this.workspace.getComponentManager().removeComponent("trashcan"),
                    this.svgGroup && Bt(this.svgGroup),
                    this.lidTask && clearTimeout(this.lidTask)
                }
                hasContents() {
                    return !!this.contents.length
                }
                contentsIsOpen() {
                    return !!this.flyout && this.flyout.isVisible()
                }
                openFlyout() {
                    if (!this.contentsIsOpen()) {
                        var Q = this.contents.map(function(pe) {
                            return JSON.parse(pe)
                        })
                          , oe = this.workspace.getParentSvg().style;
                        oe.cursor = "wait",
                        setTimeout( () => {
                            let pe;
                            (pe = this.flyout) == null || pe.show(Q),
                            oe.cursor = "";
                            let Ae;
                            (Ae = this.workspace.scrollbar) == null || Ae.setVisible(!1)
                        }
                        , 10),
                        this.fireUiEvent(!0)
                    }
                }
                closeFlyout() {
                    if (this.contentsIsOpen()) {
                        var Q;
                        (Q = this.flyout) == null || Q.hide();
                        var oe;
                        (oe = this.workspace.scrollbar) == null || oe.setVisible(!0),
                        this.fireUiEvent(!1),
                        this.workspace.recordDragTargets()
                    }
                }
                autoHide(Q) {
                    !Q && this.flyout && this.closeFlyout()
                }
                emptyContents() {
                    this.hasContents() && (this.contents.length = 0,
                    this.setMinOpenness(0),
                    this.closeFlyout())
                }
                position(Q, oe) {
                    if (this.initialized) {
                        var pe = vr(this.workspace, Q);
                        Q = fs(pe, new Yn(ca,kc + ua), yT, Qg, Q, this.workspace),
                        oe = _r(Q, Qg, pe.vertical === qs.TOP ? So.DOWN : So.UP, oe),
                        this.top = oe.top,
                        this.left = oe.left;
                        var Ae;
                        (Ae = this.svgGroup) == null || Ae.setAttribute("transform", "translate(" + this.left + "," + this.top + ")")
                    }
                }
                getBoundingRectangle() {
                    return new Vn(this.top,this.top + kc + ua,this.left,this.left + ca)
                }
                getClientRect() {
                    if (!this.svgGroup)
                        return null;
                    var Q = this.svgGroup.getBoundingClientRect();
                    const oe = Q.top + Zh - Dc;
                    return Q = Q.left + Qh - Dc,
                    new Vn(oe,oe + ua + kc + 2 * Dc,Q,Q + ca + 2 * Dc)
                }
                onDragOver(Q) {
                    this.setLidOpen(this.wouldDelete_)
                }
                onDragExit(Q) {
                    this.setLidOpen(!1)
                }
                onDrop(Q) {
                    setTimeout(this.setLidOpen.bind(this, !1), 100)
                }
                setLidOpen(Q) {
                    this.isLidOpen !== Q && (this.lidTask && clearTimeout(this.lidTask),
                    this.isLidOpen = Q,
                    this.animateLid())
                }
                animateLid() {
                    const Q = OT;
                    var oe = 1 / (Q + 1);
                    this.lidOpen += this.isLidOpen ? oe : -oe,
                    this.lidOpen = Math.min(Math.max(this.lidOpen, this.minOpenness), 1),
                    this.setLidAngle(this.lidOpen * eE),
                    oe = Zg + this.lidOpen * (CT - Zg),
                    this.svgGroup && (this.svgGroup.style.opacity = `${oe}`),
                    this.lidOpen > this.minOpenness && 1 > this.lidOpen && (this.lidTask = setTimeout(this.animateLid.bind(this), $T / Q))
                }
                setLidAngle(Q) {
                    const oe = this.workspace.toolboxPosition === In.RIGHT || this.workspace.horizontalLayout && this.workspace.RTL;
                    let pe;
                    (pe = this.svgLid) == null || pe.setAttribute("transform", "rotate(" + (oe ? -Q : Q) + "," + (oe ? 4 : ca - 4) + "," + (ua - 2) + ")")
                }
                setMinOpenness(Q) {
                    this.minOpenness = Q,
                    this.isLidOpen || this.setLidAngle(Q * eE)
                }
                closeLid() {
                    this.setLidOpen(!1)
                }
                click() {
                    this.hasContents() && !this.workspace.isDragging() && this.openFlyout()
                }
                fireUiEvent(Q) {
                    Q = new (gt(Fi))(Q,this.workspace.id),
                    Ye(Q)
                }
                blockMouseDownWhenOpenable(Q) {
                    !this.contentsIsOpen() && this.hasContents() && Q.stopPropagation()
                }
                mouseOver() {
                    this.hasContents() && this.setLidOpen(!0)
                }
                mouseOut() {
                    this.setLidOpen(!1)
                }
                onDelete(Q) {
                    if (!(0 >= this.workspace.options.maxTrashcanContents || Q.type !== J.DELETE$$module$build$src$core$events$utils || Q.type !== J.DELETE$$module$build$src$core$events$utils || Q.wasShadow)) {
                        if (!Q.oldJson)
                            throw Error("Encountered a delete event without proper oldJson");
                        if (Q = JSON.stringify(this.cleanBlockJson(Q.oldJson)),
                        this.contents.indexOf(Q) === -1) {
                            for (this.contents.unshift(Q); this.contents.length > this.workspace.options.maxTrashcanContents; )
                                this.contents.pop();
                            this.setMinOpenness(bT)
                        }
                    }
                }
                cleanBlockJson(Q) {
                    function oe(pe) {
                        if (pe) {
                            if (delete pe.id,
                            delete pe.x,
                            delete pe.y,
                            delete pe.enabled,
                            pe.icons && pe.icons.comment) {
                                var Ae = pe.icons.comment;
                                delete Ae.height,
                                delete Ae.width,
                                delete Ae.pinned
                            }
                            Ae = pe.inputs;
                            for (var Re in Ae) {
                                var Ue = Ae[Re];
                                const tt = Ue.block;
                                Ue = Ue.shadow,
                                tt && oe(tt),
                                Ue && oe(Ue)
                            }
                            pe.next && (Re = pe.next,
                            pe = Re.block,
                            Re = Re.shadow,
                            pe && oe(pe),
                            Re && oe(Re))
                        }
                    }
                    return Q = JSON.parse(JSON.stringify(Q)),
                    oe(Q),
                    Object.assign({}, {
                        kind: "BLOCK"
                    }, Q)
                }
            }
              , ca = 47
              , kc = 44
              , ua = 16
              , Qg = 20
              , yT = 20
              , Dc = 10
              , Qh = 0
              , Zh = 32
              , bT = .1
              , $T = 80
              , OT = 4
              , Zg = .4
              , CT = .8
              , eE = 45
              , Dn = class {
                constructor() {
                    this.shortcuts = new Map,
                    this.keyMap = new Map,
                    this.reset()
                }
                reset() {
                    this.shortcuts.clear(),
                    this.keyMap.clear()
                }
                register(Q, oe) {
                    if (this.shortcuts.get(Q.name) && !oe)
                        throw Error(`Shortcut named "${Q.name}" already exists.`);
                    if (this.shortcuts.set(Q.name, Q),
                    (oe = Q.keyCodes) && 0 < oe.length)
                        for (let pe = 0; pe < oe.length; pe++)
                            this.addKeyMapping(oe[pe], Q.name, !!Q.allowCollision)
                }
                unregister(Q) {
                    return this.shortcuts.get(Q) ? (this.removeAllKeyMappings(Q),
                    this.shortcuts.delete(Q),
                    !0) : (console.warn(`Keyboard shortcut named "${Q}" not found.`),
                    !1)
                }
                addKeyMapping(Q, oe, pe) {
                    Q = `${Q}`;
                    const Ae = this.keyMap.get(Q);
                    if (Ae && !pe)
                        throw Error(`Shortcut named "${oe}" collides with shortcuts "${Ae}"`);
                    Ae && pe ? Ae.unshift(oe) : this.keyMap.set(Q, [oe])
                }
                removeKeyMapping(Q, oe, pe) {
                    const Ae = this.keyMap.get(Q);
                    if (!Ae)
                        return pe || console.warn(`No keyboard shortcut named "${oe}" registered with key code "${Q}"`),
                        !1;
                    const Re = Ae.indexOf(oe);
                    return -1 < Re ? (Ae.splice(Re, 1),
                    Ae.length === 0 && this.keyMap.delete(Q),
                    !0) : (pe || console.warn(`No keyboard shortcut named "${oe}" registered with key code "${Q}"`),
                    !1)
                }
                removeAllKeyMappings(Q) {
                    for (const oe of this.keyMap.keys())
                        this.removeKeyMapping(oe, Q, !0)
                }
                setKeyMap(Q) {
                    this.keyMap.clear();
                    for (const oe in Q)
                        this.keyMap.set(oe, Q[oe])
                }
                getKeyMap() {
                    const Q = Object.create(null);
                    for (const [oe,pe] of this.keyMap)
                        Q[oe] = pe;
                    return Q
                }
                getRegistry() {
                    const Q = Object.create(null);
                    for (const [oe,pe] of this.shortcuts)
                        Q[oe] = pe;
                    return Gs(Object.create(null), Q)
                }
                onKeyDown(Q, oe) {
                    var pe = this.serializeKeyEvent_(oe);
                    if (pe = this.getShortcutNamesByKeyCode(pe),
                    !pe)
                        return !1;
                    for (let Ae = 0, Re; Re = pe[Ae]; Ae++) {
                        const Ue = this.shortcuts.get(Re);
                        let tt, dt;
                        if ((tt = Ue) == null || !tt.preconditionFn || (dt = Ue) != null && dt.preconditionFn(Q)) {
                            let wt, sn;
                            if ((wt = Ue) != null && wt.callback && ((sn = Ue) != null && sn.callback(Q, oe, Ue)))
                                return !0
                        }
                    }
                    return !1
                }
                getShortcutNamesByKeyCode(Q) {
                    return this.keyMap.get(Q) || []
                }
                getKeyCodesByShortcutName(Q) {
                    const oe = [];
                    for (const [pe,Ae] of this.keyMap)
                        -1 < Ae.indexOf(Q) && oe.push(pe);
                    return oe
                }
                serializeKeyEvent_(Q) {
                    let oe = "";
                    for (const pe in Dn.modifierKeys)
                        Q.getModifierState(pe) && (oe !== "" && (oe += "+"),
                        oe += pe);
                    return oe !== "" && Q.keyCode ? oe = oe + "+" + Q.keyCode : Q.keyCode && (oe = String(Q.keyCode)),
                    oe
                }
                checkModifiers_(Q) {
                    for (let oe = 0, pe; pe = Q[oe]; oe++)
                        if (!(pe in Dn.modifierKeys))
                            throw Error(pe + " is not a valid modifier key.")
                }
                createSerializedKey(Q, oe) {
                    let pe = "";
                    if (oe) {
                        this.checkModifiers_(oe);
                        for (const Ae in Dn.modifierKeys)
                            -1 < oe.indexOf(Dn.modifierKeys[Ae]) && (pe !== "" && (pe += "+"),
                            pe += Ae)
                    }
                    return pe !== "" && Q ? pe = pe + "+" + Q : Q && (pe = `${Q}`),
                    pe
                }
            }
            ;
            Dn.registry = new Dn,
            function(Q) {
                Q = Q.modifierKeys || (Q.modifierKeys = {}),
                Q[Q.Shift = 16] = "Shift",
                Q[Q.Control = 17] = "Control",
                Q[Q.Alt = 18] = "Alt",
                Q[Q.Meta = 91] = "Meta"
            }(Dn || (Dn = {}));
            var Ps;
            (function(Q) {
                Q.ESCAPE = "escape",
                Q.DELETE = "delete",
                Q.COPY = "copy",
                Q.CUT = "cut",
                Q.PASTE = "paste",
                Q.UNDO = "undo",
                Q.REDO = "redo"
            }
            )(Ps || (Ps = {}));
            var ml = null
              , wc = null;
            pd();
            var Ms = {};
            Ms.names = Ps,
            Ms.registerCopy = ld,
            Ms.registerCut = cd,
            Ms.registerDefaultShortcuts = pd,
            Ms.registerDelete = ad,
            Ms.registerEscape = id,
            Ms.registerPaste = ud,
            Ms.registerRedo = hd,
            Ms.registerUndo = dd;
            var vT = class {
                constructor(Q, oe) {
                    this.procedureModelClass = Q,
                    this.parameterModelClass = oe,
                    this.priority = mg
                }
                save(Q) {
                    return Q = Q.getProcedureMap().getProcedures().map(oe => md(oe)),
                    Q.length ? Q : null
                }
                load(Q, oe) {
                    const pe = oe.getProcedureMap();
                    for (const Ae of Q)
                        pe.add(gd(this.procedureModelClass, this.parameterModelClass, Ae, oe))
                }
                clear(Q) {
                    Q.getProcedureMap().clear()
                }
            }
              , da = {};
            da.ProcedureSerializer = vT,
            da.loadParameter = Ed,
            da.loadProcedure = gd,
            da.saveParameter = fd,
            da.saveProcedure = md;
            var tE = class {
                constructor() {
                    this.priority = pg
                }
                save(Q) {
                    const oe = [];
                    for (const pe of Q.getAllVariables())
                        Q = {
                            name: pe.name,
                            id: pe.getId()
                        },
                        pe.type && (Q.type = pe.type),
                        oe.push(Q);
                    return oe.length ? oe : null
                }
                load(Q, oe) {
                    for (const pe of Q)
                        oe.createVariable(pe.name, pe.type, pe.id)
                }
                clear(Q) {
                    Q.getVariableMap().clear()
                }
            }
            ;
            Ll("variables", new tE);
            var nE = {};
            nE.VariableSerializer = tE;
            var ep = {};
            ep.load = ff,
            ep.save = mf;
            var xT = {
                blocks: Ka,
                exceptions: Qo,
                priorities: oT,
                procedures: da,
                registry: oh,
                variables: nE,
                workspaces: ep
            }
              , tp = class {
                constructor(Q, oe, pe, Ae, Re) {
                    this.workspace = Q,
                    this.oldHostMetrics_ = this.corner_ = this.vScroll = this.hScroll = null,
                    oe = oe === void 0 ? !0 : oe,
                    pe = pe === void 0 ? !0 : pe;
                    const Ue = oe && pe;
                    oe && (this.hScroll = new or(Q,!0,Ue,Ae,Re)),
                    pe && (this.vScroll = new or(Q,!1,Ue,Ae,Re)),
                    Ue && (this.corner_ = $t(bt.RECT, {
                        height: or.scrollbarThickness,
                        width: or.scrollbarThickness,
                        class: "blocklyScrollbarBackground"
                    }),
                    Wt(this.corner_, Q.getBubbleCanvas()))
                }
                dispose() {
                    Bt(this.corner_),
                    this.oldHostMetrics_ = this.corner_ = null,
                    this.hScroll && (this.hScroll.dispose(),
                    this.hScroll = null),
                    this.vScroll && (this.vScroll.dispose(),
                    this.vScroll = null)
                }
                resize() {
                    const Q = this.workspace.getMetrics();
                    if (Q) {
                        var oe = !1
                          , pe = !1;
                        if (this.oldHostMetrics_ && this.oldHostMetrics_.viewWidth === Q.viewWidth && this.oldHostMetrics_.viewHeight === Q.viewHeight && this.oldHostMetrics_.absoluteTop === Q.absoluteTop && this.oldHostMetrics_.absoluteLeft === Q.absoluteLeft ? (this.oldHostMetrics_ && this.oldHostMetrics_.scrollWidth === Q.scrollWidth && this.oldHostMetrics_.viewLeft === Q.viewLeft && this.oldHostMetrics_.scrollLeft === Q.scrollLeft || (oe = !0),
                        this.oldHostMetrics_ && this.oldHostMetrics_.scrollHeight === Q.scrollHeight && this.oldHostMetrics_.viewTop === Q.viewTop && this.oldHostMetrics_.scrollTop === Q.scrollTop || (pe = !0)) : pe = oe = !0,
                        oe || pe) {
                            try {
                                J.disable$$module$build$src$core$events$utils(),
                                this.hScroll && oe && this.hScroll.resize(Q),
                                this.vScroll && pe && this.vScroll.resize(Q)
                            } finally {
                                J.enable$$module$build$src$core$events$utils()
                            }
                            this.workspace.maybeFireViewportChangeEvent()
                        }
                        if (this.hScroll && this.vScroll) {
                            if (!this.oldHostMetrics_ || this.oldHostMetrics_.viewWidth !== Q.viewWidth || this.oldHostMetrics_.absoluteLeft !== Q.absoluteLeft) {
                                let Ae;
                                (Ae = this.corner_) == null || Ae.setAttribute("x", String(this.vScroll.position.x))
                            }
                            if (!this.oldHostMetrics_ || this.oldHostMetrics_.viewHeight !== Q.viewHeight || this.oldHostMetrics_.absoluteTop !== Q.absoluteTop) {
                                let Ae;
                                (Ae = this.corner_) == null || Ae.setAttribute("y", String(this.hScroll.position.y))
                            }
                        }
                        this.oldHostMetrics_ = Q
                    }
                }
                canScrollHorizontally() {
                    return !!this.hScroll
                }
                canScrollVertically() {
                    return !!this.vScroll
                }
                setOrigin(Q, oe) {
                    this.hScroll && this.hScroll.setOrigin(Q, oe),
                    this.vScroll && this.vScroll.setOrigin(Q, oe)
                }
                set(Q, oe, pe) {
                    this.hScroll && this.hScroll.set(Q, !1),
                    this.vScroll && this.vScroll.set(oe, !1),
                    (pe || pe === void 0) && (Q = {},
                    this.hScroll && (Q.x = this.hScroll.getRatio_()),
                    this.vScroll && (Q.y = this.vScroll.getRatio_()),
                    this.workspace.setMetrics(Q))
                }
                setX(Q) {
                    this.hScroll && this.hScroll.set(Q, !0)
                }
                setY(Q) {
                    this.vScroll && this.vScroll.set(Q, !0)
                }
                setContainerVisible(Q) {
                    this.hScroll && this.hScroll.setContainerVisible(Q),
                    this.vScroll && this.vScroll.setContainerVisible(Q)
                }
                isVisible() {
                    let Q = !1;
                    return this.hScroll && (Q = this.hScroll.isVisible()),
                    this.vScroll && (Q = Q || this.vScroll.isVisible()),
                    Q
                }
                setVisible(Q) {
                    this.hScroll && this.hScroll.setVisibleInternal(Q),
                    this.vScroll && this.vScroll.setVisibleInternal(Q)
                }
                resizeContent(Q) {
                    this.hScroll && this.hScroll.resizeContentHorizontal(Q),
                    this.vScroll && this.vScroll.resizeContentVertical(Q)
                }
                resizeView(Q) {
                    this.hScroll && this.hScroll.resizeViewHorizontal(Q),
                    this.vScroll && this.vScroll.resizeViewVertical(Q)
                }
            }
              , np = class {
                constructor(Q) {
                    this.workspace_ = Q
                }
                getDimensionsPx_(Q) {
                    let oe = 0
                      , pe = 0;
                    return Q && (oe = Q.getWidth(),
                    pe = Q.getHeight()),
                    new Yn(oe,pe)
                }
                getFlyoutMetrics(Q) {
                    return Q = this.getDimensionsPx_(this.workspace_.getFlyout(Q)),
                    {
                        width: Q.width,
                        height: Q.height,
                        position: this.workspace_.toolboxPosition
                    }
                }
                getToolboxMetrics() {
                    const Q = this.getDimensionsPx_(this.workspace_.getToolbox());
                    return {
                        width: Q.width,
                        height: Q.height,
                        position: this.workspace_.toolboxPosition
                    }
                }
                getSvgMetrics() {
                    return this.workspace_.getCachedParentSvgSize()
                }
                getAbsoluteMetrics() {
                    let Q = 0
                      , oe = 0;
                    const pe = this.getToolboxMetrics()
                      , Ae = this.getFlyoutMetrics()
                      , Re = !!this.workspace_.getToolbox();
                    var Ue;
                    const tt = !((Ue = this.workspace_.getFlyout()) != null && Ue.autoClose);
                    Ue = Re ? pe.position : Ae.position;
                    const dt = Ue === In.TOP;
                    return Ue === In.LEFT && (Re && (Q += pe.width),
                    tt && (Q += Ae.width)),
                    dt && (Re && (oe += pe.height),
                    tt && (oe += Ae.height)),
                    {
                        top: oe,
                        left: Q
                    }
                }
                getViewMetrics(Q) {
                    Q = Q ? this.workspace_.scale : 1;
                    const oe = this.getSvgMetrics()
                      , pe = this.getToolboxMetrics()
                      , Ae = this.getFlyoutMetrics()
                      , Re = !!this.workspace_.getToolbox();
                    var Ue;
                    const tt = !((Ue = this.workspace_.getFlyout()) != null && Ue.autoClose);
                    Ue = Re ? pe.position : Ae.position;
                    const dt = Ue === In.LEFT || Ue === In.RIGHT;
                    return (Ue === In.TOP || Ue === In.BOTTOM) && (Re && (oe.height -= pe.height),
                    tt && (oe.height -= Ae.height)),
                    dt && (Re && (oe.width -= pe.width),
                    tt && (oe.width -= Ae.width)),
                    {
                        height: oe.height / Q,
                        width: oe.width / Q,
                        top: -this.workspace_.scrollY / Q,
                        left: -this.workspace_.scrollX / Q
                    }
                }
                getContentMetrics(Q) {
                    Q = Q ? 1 : this.workspace_.scale;
                    const oe = this.workspace_.getBlocksBoundingBox();
                    return {
                        height: (oe.bottom - oe.top) * Q,
                        width: (oe.right - oe.left) * Q,
                        top: oe.top * Q,
                        left: oe.left * Q
                    }
                }
                hasFixedEdges() {
                    return !this.workspace_.isMovableHorizontally() || !this.workspace_.isMovableVertically()
                }
                getComputedFixedEdges_(Q) {
                    if (!this.hasFixedEdges())
                        return {};
                    const oe = this.workspace_.isMovableHorizontally()
                      , pe = this.workspace_.isMovableVertically();
                    Q = Q || this.getViewMetrics(!1);
                    const Ae = {};
                    return pe || (Ae.top = Q.top,
                    Ae.bottom = Q.top + Q.height),
                    oe || (Ae.left = Q.left,
                    Ae.right = Q.left + Q.width),
                    Ae
                }
                getPaddedContent_(Q, oe) {
                    const pe = oe.top + oe.height
                      , Ae = oe.left + oe.width
                      , Re = Q.width;
                    Q = Q.height;
                    const Ue = Re / 2
                      , tt = Q / 2;
                    return {
                        top: Math.min(oe.top - tt, pe - Q),
                        bottom: Math.max(pe + tt, oe.top + Q),
                        left: Math.min(oe.left - Ue, Ae - Re),
                        right: Math.max(Ae + Ue, oe.left + Re)
                    }
                }
                getScrollMetrics(Q, oe, pe) {
                    Q = Q ? this.workspace_.scale : 1,
                    oe = oe || this.getViewMetrics(!1);
                    var Ae = pe || this.getContentMetrics();
                    pe = this.getComputedFixedEdges_(oe),
                    oe = this.getPaddedContent_(oe, Ae),
                    Ae = pe.top !== void 0 ? pe.top : oe.top;
                    const Re = pe.left !== void 0 ? pe.left : oe.left;
                    return {
                        top: Ae / Q,
                        left: Re / Q,
                        width: ((pe.right !== void 0 ? pe.right : oe.right) - Re) / Q,
                        height: ((pe.bottom !== void 0 ? pe.bottom : oe.bottom) - Ae) / Q
                    }
                }
                getUiMetrics() {
                    return {
                        viewMetrics: this.getViewMetrics(),
                        absoluteMetrics: this.getAbsoluteMetrics(),
                        toolboxMetrics: this.getToolboxMetrics()
                    }
                }
                getMetrics() {
                    const Q = this.getToolboxMetrics()
                      , oe = this.getFlyoutMetrics(!0)
                      , pe = this.getSvgMetrics()
                      , Ae = this.getAbsoluteMetrics()
                      , Re = this.getViewMetrics()
                      , Ue = this.getContentMetrics()
                      , tt = this.getScrollMetrics(!1, Re, Ue);
                    return {
                        contentHeight: Ue.height,
                        contentWidth: Ue.width,
                        contentTop: Ue.top,
                        contentLeft: Ue.left,
                        scrollHeight: tt.height,
                        scrollWidth: tt.width,
                        scrollTop: tt.top,
                        scrollLeft: tt.left,
                        viewHeight: Re.height,
                        viewWidth: Re.width,
                        viewTop: Re.top,
                        viewLeft: Re.left,
                        absoluteTop: Ae.top,
                        absoluteLeft: Ae.left,
                        svgHeight: pe.height,
                        svgWidth: pe.width,
                        toolboxWidth: Q.width,
                        toolboxHeight: Q.height,
                        toolboxPosition: Q.position,
                        flyoutWidth: oe.width,
                        flyoutHeight: oe.height
                    }
                }
            }
            ;
            ne(Yt.METRICS_MANAGER, js, np);
            var rE = class extends ji {
                constructor(Q) {
                    super(),
                    this.isBlank = !0,
                    this.recordUndo = !1,
                    this.type = Wo,
                    this.isBlank = !!Q,
                    Q && (this.workspaceId = Q.id)
                }
            }
            ;
            ne(Yt.EVENT, Wo, rE);
            var rp = class extends Is {
                constructor(Q, oe, pe) {
                    super(Q ? Q.workspace.id : void 0),
                    this.type = Go,
                    Q && (this.blockId = Q.id,
                    this.isStart = oe,
                    this.blocks = pe)
                }
                toJson() {
                    const Q = super.toJson();
                    if (this.isStart === void 0)
                        throw Error("Whether this event is the start of a drag is undefined. Either pass the value to the constructor, or call fromJson");
                    if (this.blockId === void 0)
                        throw Error("The block ID is undefined. Either pass a block to the constructor, or call fromJson");
                    return Q.isStart = this.isStart,
                    Q.blockId = this.blockId,
                    Q.blocks = this.blocks,
                    Q
                }
                static fromJson(Q, oe, pe) {
                    return oe = super.fromJson(Q, oe, pe ?? new rp),
                    oe.isStart = Q.isStart,
                    oe.blockId = Q.blockId,
                    oe.blocks = Q.blocks,
                    oe
                }
            }
            ;
            ne(Yt.EVENT, Go, rp);
            var Bc = {};
            Bc.bumpIntoBounds = ki,
            Bc.bumpIntoBoundsHandler = Td,
            Bc.bumpTopObjectsIntoBounds = Ql;
            var sE = class {
                constructor(Q, oe) {
                    this.dragTarget_ = null,
                    this.wouldDeleteBlock_ = !1,
                    this.dragIconData_ = [],
                    this.draggingBlock_ = Q,
                    this.draggedConnectionManager_ = new Wr(this.draggingBlock_),
                    this.workspace_ = oe,
                    this.startXY_ = this.draggingBlock_.getRelativeToSurfaceXY(),
                    this.dragIconData_ = Ad(Q, this.startXY_)
                }
                dispose() {
                    this.dragIconData_.length = 0,
                    this.draggedConnectionManager_ && this.draggedConnectionManager_.dispose()
                }
                startDrag(Q, oe) {
                    J.getGroup$$module$build$src$core$events$utils() || J.setGroup$$module$build$src$core$events$utils(!0),
                    this.fireDragStartEvent_(),
                    this.draggingBlock_.bringToFront(!0),
                    st(),
                    this.workspace_.setResizesEnabled(!1),
                    vi(),
                    this.shouldDisconnect_(oe) && this.disconnectBlock_(oe, Q),
                    this.draggingBlock_.setDragging(!0);
                    let pe;
                    (pe = this.workspace_.getLayerManager()) == null || pe.moveToDragLayer(this.draggingBlock_)
                }
                shouldDisconnect_(Q) {
                    return !!(this.draggingBlock_.getParent() || Q && this.draggingBlock_.nextConnection && this.draggingBlock_.nextConnection.targetBlock())
                }
                disconnectBlock_(Q, oe) {
                    this.draggingBlock_.unplug(Q),
                    Q = this.pixelsToWorkspaceUnits_(oe),
                    Q = Zt.sum(this.startXY_, Q),
                    this.draggingBlock_.translate(Q.x, Q.y),
                    vu(this.draggingBlock_),
                    this.draggedConnectionManager_.updateAvailableConnections()
                }
                fireDragStartEvent_() {
                    const Q = new (gt(Go))(this.draggingBlock_,!0,this.draggingBlock_.getDescendants(!1));
                    Ye(Q)
                }
                drag(Q, oe) {
                    oe = this.pixelsToWorkspaceUnits_(oe);
                    var pe = Zt.sum(this.startXY_, oe);
                    this.draggingBlock_.moveDuringDrag(pe),
                    pe = this.dragTarget_,
                    this.dragTarget_ = this.workspace_.getDragTarget(Q),
                    this.draggedConnectionManager_.update(oe, this.dragTarget_),
                    Q = this.wouldDeleteBlock_,
                    this.wouldDeleteBlock_ = this.draggedConnectionManager_.wouldDeleteBlock,
                    Q !== this.wouldDeleteBlock_ && this.updateCursorDuringBlockDrag_(),
                    this.dragTarget_ !== pe && (pe && pe.onDragExit(this.draggingBlock_),
                    this.dragTarget_ && this.dragTarget_.onDragEnter(this.draggingBlock_)),
                    this.dragTarget_ && this.dragTarget_.onDragOver(this.draggingBlock_)
                }
                endDrag(Q, oe) {
                    if (this.drag(Q, oe),
                    this.fireDragEndEvent_(),
                    ht(),
                    vi(),
                    Q = null,
                    this.dragTarget_ && this.dragTarget_.shouldPreventMove(this.draggingBlock_) || (Q = this.getNewLocationAfterDrag_(oe).delta),
                    this.dragTarget_ && this.dragTarget_.onDrop(this.draggingBlock_),
                    !this.maybeDeleteBlock_()) {
                        let pe;
                        (pe = this.workspace_.getLayerManager()) == null || pe.moveOffDragLayer(this.draggingBlock_, Sh),
                        this.draggingBlock_.setDragging(!1),
                        Q ? this.updateBlockAfterMove_() : ki(this.draggingBlock_.workspace, this.workspace_.getMetricsManager().getScrollMetrics(!0), this.draggingBlock_)
                    }
                    this.workspace_.setResizesEnabled(!0),
                    J.setGroup$$module$build$src$core$events$utils(!1)
                }
                getNewLocationAfterDrag_(Q) {
                    Q = this.pixelsToWorkspaceUnits_(Q);
                    const oe = Zt.sum(this.startXY_, Q);
                    return {
                        delta: Q,
                        newLocation: oe
                    }
                }
                maybeDeleteBlock_() {
                    return this.wouldDeleteBlock_ ? (this.fireMoveEvent_(),
                    this.draggingBlock_.dispose(!1, !0),
                    Di.length = 0,
                    !0) : !1
                }
                updateBlockAfterMove_() {
                    this.fireMoveEvent_(),
                    this.draggedConnectionManager_.wouldConnectBlock() ? this.draggedConnectionManager_.applyConnections() : this.draggingBlock_.queueRender(),
                    this.draggingBlock_.scheduleSnapAndBump()
                }
                fireDragEndEvent_() {
                    const Q = new (gt(Go))(this.draggingBlock_,!1,this.draggingBlock_.getDescendants(!1));
                    Ye(Q)
                }
                updateToolboxStyle_(Q) {
                    const oe = this.workspace_.getToolbox();
                    if (oe) {
                        const pe = this.draggingBlock_.isDeletable() ? "blocklyToolboxDelete" : "blocklyToolboxGrab";
                        Q && typeof oe.removeStyle == "function" ? oe.removeStyle(pe) : Q || typeof oe.addStyle != "function" || oe.addStyle(pe)
                    }
                }
                fireMoveEvent_() {
                    if (!this.draggingBlock_.isDeadOrDying()) {
                        var Q = new (gt(J.MOVE$$module$build$src$core$events$utils))(this.draggingBlock_);
                        Q.setReason(["drag"]),
                        Q.oldCoordinate = this.startXY_,
                        Q.recordNew(),
                        Ye(Q)
                    }
                }
                updateCursorDuringBlockDrag_() {
                    this.draggingBlock_.setDeleteStyle(this.wouldDeleteBlock_)
                }
                pixelsToWorkspaceUnits_(Q) {
                    return Q = new Zt(Q.x / this.workspace_.scale,Q.y / this.workspace_.scale),
                    this.workspace_.isMutator && Q.scale(1 / this.workspace_.options.parentWorkspace.scale),
                    Q
                }
                dragIcons_() {
                    zt("Blockly.BlockDragger.prototype.dragIcons_", "v10", "v11")
                }
                getInsertionMarkers() {
                    return this.draggedConnectionManager_ && this.draggedConnectionManager_.getInsertionMarkers ? this.draggedConnectionManager_.getInsertionMarkers() : []
                }
            }
            ;
            ne(Yt.BLOCK_DRAGGER, js, sE);
            var fl = {};
            fl.Bubble = kn,
            fl.MiniWorkspaceBubble = Zs,
            fl.TextBubble = Ph,
            fl.TextInputBubble = Lg;
            var sp = class extends Zo {
                constructor(Q, oe, pe, Ae) {
                    super(Q),
                    this.type = fo,
                    this.recordUndo = !1,
                    Q && (this.name = oe,
                    this.oldValue = pe,
                    this.newValue = Ae)
                }
                toJson() {
                    const Q = super.toJson();
                    if (!this.name)
                        throw Error("The changed field name is undefined. Either pass a name to the constructor, or call fromJson.");
                    return Q.name = this.name,
                    Q.oldValue = this.oldValue,
                    Q.newValue = this.newValue,
                    Q
                }
                static fromJson(Q, oe, pe) {
                    return oe = super.fromJson(Q, oe, pe ?? new sp),
                    oe.name = Q.name,
                    oe.oldValue = Q.oldValue,
                    oe.newValue = Q.newValue,
                    oe
                }
                isNull() {
                    return this.oldValue === this.newValue
                }
                run(Q) {
                    var oe = this.getEventWorkspace_();
                    if (!this.blockId)
                        throw Error("The block ID is undefined. Either pass a block to the constructor, or call fromJson");
                    if (oe = oe.getBlockById(this.blockId),
                    !oe)
                        throw Error("The associated block is undefined. Either pass a block to the constructor, or call fromJson");
                    Q = Q ? this.newValue : this.oldValue,
                    (oe = oe.getField(this.name)) ? oe.setValue(Q) : console.warn("Can't set non-existent field: " + this.name)
                }
            }
            ;
            ne(Yt.EVENT, fo, sp);
            var op = class extends Zo {
                constructor(Q) {
                    super(Q),
                    this.type = J.MOVE$$module$build$src$core$events$utils,
                    Q && (Q.isShadow() && (this.recordUndo = !1),
                    Q = this.currentLocation_(),
                    this.oldParentId = Q.parentId,
                    this.oldInputName = Q.inputName,
                    this.oldCoordinate = Q.coordinate)
                }
                toJson() {
                    const Q = super.toJson();
                    return Q.oldParentId = this.oldParentId,
                    Q.oldInputName = this.oldInputName,
                    this.oldCoordinate && (Q.oldCoordinate = `${Math.round(this.oldCoordinate.x)}, ${Math.round(this.oldCoordinate.y)}`),
                    Q.newParentId = this.newParentId,
                    Q.newInputName = this.newInputName,
                    this.newCoordinate && (Q.newCoordinate = `${Math.round(this.newCoordinate.x)}, ${Math.round(this.newCoordinate.y)}`),
                    this.reason && (Q.reason = this.reason),
                    this.recordUndo || (Q.recordUndo = this.recordUndo),
                    Q
                }
                static fromJson(Q, oe, pe) {
                    return oe = super.fromJson(Q, oe, pe ?? new op),
                    oe.oldParentId = Q.oldParentId,
                    oe.oldInputName = Q.oldInputName,
                    Q.oldCoordinate && (pe = Q.oldCoordinate.split(","),
                    oe.oldCoordinate = new Zt(Number(pe[0]),Number(pe[1]))),
                    oe.newParentId = Q.newParentId,
                    oe.newInputName = Q.newInputName,
                    Q.newCoordinate && (pe = Q.newCoordinate.split(","),
                    oe.newCoordinate = new Zt(Number(pe[0]),Number(pe[1]))),
                    Q.reason !== void 0 && (oe.reason = Q.reason),
                    Q.recordUndo !== void 0 && (oe.recordUndo = Q.recordUndo),
                    oe
                }
                recordNew() {
                    const Q = this.currentLocation_();
                    this.newParentId = Q.parentId,
                    this.newInputName = Q.inputName,
                    this.newCoordinate = Q.coordinate
                }
                setReason(Q) {
                    this.reason = Q
                }
                currentLocation_() {
                    var Q = this.getEventWorkspace_();
                    if (!this.blockId)
                        throw Error("The block ID is undefined. Either pass a block to the constructor, or call fromJson");
                    var oe = Q.getBlockById(this.blockId);
                    if (!oe)
                        throw Error("The block associated with the block move event could not be found");
                    Q = {};
                    const pe = oe.getParent();
                    return pe ? (Q.parentId = pe.id,
                    (oe = pe.getInputWithBlock(oe)) && (Q.inputName = oe.name)) : Q.coordinate = oe.getRelativeToSurfaceXY(),
                    Q
                }
                isNull() {
                    return this.oldParentId === this.newParentId && this.oldInputName === this.newInputName && Zt.equals(this.oldCoordinate, this.newCoordinate)
                }
                run(Q) {
                    var oe = this.getEventWorkspace_();
                    if (!this.blockId)
                        throw Error("The block ID is undefined. Either pass a block to the constructor, or call fromJson");
                    var pe = oe.getBlockById(this.blockId);
                    if (pe) {
                        var Ae = Q ? this.newParentId : this.oldParentId
                          , Re = Q ? this.newInputName : this.oldInputName;
                        if (Q = Q ? this.newCoordinate : this.oldCoordinate,
                        Ae) {
                            var Ue = oe.getBlockById(Ae);
                            if (!Ue) {
                                console.warn("Can't connect to non-existent block: " + Ae);
                                return
                            }
                        }
                        if (pe.getParent() && pe.unplug(),
                        Q)
                            Re = pe.getRelativeToSurfaceXY(),
                            pe.moveBy(Q.x - Re.x, Q.y - Re.y, this.reason);
                        else {
                            oe = pe.outputConnection,
                            (!oe || pe.previousConnection && pe.previousConnection.isConnected()) && (oe = pe.previousConnection);
                            let tt, dt;
                            pe = (dt = oe) == null ? void 0 : dt.type,
                            Re ? (pe = Ue.getInput(Re)) && (tt = pe.connection) : pe === pn.PREVIOUS_STATEMENT && (tt = Ue.nextConnection),
                            tt && oe ? oe.connect(tt) : console.warn("Can't connect to non-existent input: " + Re)
                        }
                    } else
                        console.warn("Can't move non-existent block: " + this.blockId)
                }
            }
            ;
            ne(Yt.EVENT, J.MOVE$$module$build$src$core$events$utils, op);
            var ip = class extends Is {
                constructor(Q, oe, pe) {
                    super(Q ? Q.workspace.id : void 0),
                    this.type = _s,
                    Q && (this.blockId = Q.id,
                    this.isOpen = oe,
                    this.bubbleType = pe)
                }
                toJson() {
                    const Q = super.toJson();
                    if (this.isOpen === void 0)
                        throw Error("Whether this event is for opening the bubble is undefined. Either pass the value to the constructor, or call fromJson");
                    if (!this.bubbleType)
                        throw Error("The type of bubble is undefined. Either pass the value to the constructor, or call fromJson");
                    return Q.isOpen = this.isOpen,
                    Q.bubbleType = this.bubbleType,
                    Q.blockId = this.blockId || "",
                    Q
                }
                static fromJson(Q, oe, pe) {
                    return oe = super.fromJson(Q, oe, pe ?? new ip),
                    oe.isOpen = Q.isOpen,
                    oe.bubbleType = Q.bubbleType,
                    oe.blockId = Q.blockId,
                    oe
                }
            }
            , ap;
            (function(Q) {
                Q.MUTATOR = "mutator",
                Q.COMMENT = "comment",
                Q.WARNING = "warning"
            }
            )(ap || (ap = {})),
            ne(Yt.EVENT, _s, ip);
            var bo = class extends ji {
                constructor(Q) {
                    super(),
                    this.isBlank = !Q,
                    Q && (this.commentId = Q.id,
                    this.workspaceId = Q.workspace.id,
                    this.group = J.getGroup$$module$build$src$core$events$utils(),
                    this.recordUndo = St())
                }
                toJson() {
                    const Q = super.toJson();
                    if (!this.commentId)
                        throw Error("The comment ID is undefined. Either pass a comment to the constructor, or call fromJson");
                    return Q.commentId = this.commentId,
                    Q
                }
                static fromJson(Q, oe, pe) {
                    return oe = super.fromJson(Q, oe, pe ?? new bo),
                    oe.commentId = Q.commentId,
                    oe
                }
                static CommentCreateDeleteHelper(Q, oe) {
                    var pe = Q.getEventWorkspace_();
                    if (oe) {
                        if (oe = J.createElement$$module$build$src$core$utils$xml("xml"),
                        !Q.xml)
                            throw Error("Ecountered a comment event without proper xml");
                        oe.appendChild(Q.xml),
                        J.domToWorkspace$$module$build$src$core$xml(oe, pe)
                    } else {
                        if (!Q.commentId)
                            throw Error("The comment ID is undefined. Either pass a comment to the constructor, or call fromJson");
                        (pe = pe.getCommentById(Q.commentId)) ? pe.dispose() : console.warn("Can't uncreate non-existent comment: " + Q.commentId)
                    }
                }
            }
              , lp = class extends bo {
                constructor(Q, oe, pe) {
                    super(Q),
                    this.type = Gi,
                    Q && (this.oldContents_ = typeof oe > "u" ? "" : oe,
                    this.newContents_ = typeof pe > "u" ? "" : pe)
                }
                toJson() {
                    const Q = super.toJson();
                    if (!this.oldContents_)
                        throw Error("The old contents is undefined. Either pass a value to the constructor, or call fromJson");
                    if (!this.newContents_)
                        throw Error("The new contents is undefined. Either pass a value to the constructor, or call fromJson");
                    return Q.oldContents = this.oldContents_,
                    Q.newContents = this.newContents_,
                    Q
                }
                static fromJson(Q, oe, pe) {
                    return oe = super.fromJson(Q, oe, pe ?? new lp),
                    oe.oldContents_ = Q.oldContents,
                    oe.newContents_ = Q.newContents,
                    oe
                }
                isNull() {
                    return this.oldContents_ === this.newContents_
                }
                run(Q) {
                    var oe = this.getEventWorkspace_();
                    if (!this.commentId)
                        throw Error("The comment ID is undefined. Either pass a comment to the constructor, or call fromJson");
                    if (oe = oe.getCommentById(this.commentId)) {
                        var pe = Q ? this.newContents_ : this.oldContents_;
                        if (!pe)
                            throw Error(Q ? "The new contents is undefined. Either pass a value to the constructor, or call fromJson" : "The old contents is undefined. Either pass a value to the constructor, or call fromJson");
                        oe.setContent(pe)
                    } else
                        console.warn("Can't change non-existent comment: " + this.commentId)
                }
            }
            ;
            ne(Yt.EVENT, Gi, lp);
            var cp = class extends bo {
                constructor(Q) {
                    super(Q),
                    this.type = To,
                    Q && (this.xml = Q.toXmlWithXY())
                }
                toJson() {
                    const Q = super.toJson();
                    if (!this.xml)
                        throw Error("The comment XML is undefined. Either pass a comment to the constructor, or call fromJson");
                    return Q.xml = Es(this.xml),
                    Q
                }
                static fromJson(Q, oe, pe) {
                    return oe = super.fromJson(Q, oe, pe ?? new cp),
                    oe.xml = J.textToDom$$module$build$src$core$utils$xml(Q.xml),
                    oe
                }
                run(Q) {
                    bo.CommentCreateDeleteHelper(this, Q)
                }
            }
            ;
            ne(Yt.EVENT, To, cp);
            var up = class extends bo {
                constructor(Q) {
                    super(Q),
                    this.type = jo,
                    Q && (this.xml = Q.toXmlWithXY())
                }
                run(Q) {
                    bo.CommentCreateDeleteHelper(this, !Q)
                }
                toJson() {
                    const Q = super.toJson();
                    if (!this.xml)
                        throw Error("The comment XML is undefined. Either pass a comment to the constructor, or call fromJson");
                    return Q.xml = Es(this.xml),
                    Q
                }
                static fromJson(Q, oe, pe) {
                    return oe = super.fromJson(Q, oe, pe ?? new up),
                    oe.xml = J.textToDom$$module$build$src$core$utils$xml(Q.xml),
                    oe
                }
            }
            ;
            ne(Yt.EVENT, jo, up);
            var dp = class extends bo {
                constructor(Q) {
                    super(Q),
                    this.type = Ss,
                    Q && (this.comment_ = Q,
                    this.oldCoordinate_ = Q.getRelativeToSurfaceXY())
                }
                recordNew() {
                    if (this.newCoordinate_)
                        throw Error("Tried to record the new position of a comment on the same event twice.");
                    if (!this.comment_)
                        throw Error("The comment is undefined. Pass a comment to the constructor if you want to use the record functionality");
                    this.newCoordinate_ = this.comment_.getRelativeToSurfaceXY()
                }
                setOldCoordinate(Q) {
                    this.oldCoordinate_ = Q
                }
                toJson() {
                    const Q = super.toJson();
                    if (!this.oldCoordinate_)
                        throw Error("The old comment position is undefined. Either pass a comment to the constructor, or call fromJson");
                    if (!this.newCoordinate_)
                        throw Error("The new comment position is undefined. Either call recordNew, or call fromJson");
                    return Q.oldCoordinate = `${Math.round(this.oldCoordinate_.x)}, ${Math.round(this.oldCoordinate_.y)}`,
                    Q.newCoordinate = Math.round(this.newCoordinate_.x) + "," + Math.round(this.newCoordinate_.y),
                    Q
                }
                static fromJson(Q, oe, pe) {
                    return oe = super.fromJson(Q, oe, pe ?? new dp),
                    pe = Q.oldCoordinate.split(","),
                    oe.oldCoordinate_ = new Zt(Number(pe[0]),Number(pe[1])),
                    pe = Q.newCoordinate.split(","),
                    oe.newCoordinate_ = new Zt(Number(pe[0]),Number(pe[1])),
                    oe
                }
                isNull() {
                    return Zt.equals(this.oldCoordinate_, this.newCoordinate_)
                }
                run(Q) {
                    var oe = this.getEventWorkspace_();
                    if (!this.commentId)
                        throw Error("The comment ID is undefined. Either pass a comment to the constructor, or call fromJson");
                    if (oe = oe.getCommentById(this.commentId)) {
                        if (Q = Q ? this.newCoordinate_ : this.oldCoordinate_,
                        !Q)
                            throw Error("Either oldCoordinate_ or newCoordinate_ is undefined. Either pass a comment to the constructor and call recordNew, or call fromJson");
                        var pe = oe.getRelativeToSurfaceXY();
                        oe.moveBy(Q.x - pe.x, Q.y - pe.y)
                    } else
                        console.warn("Can't move non-existent comment: " + this.commentId)
                }
            }
            ;
            ne(Yt.EVENT, Ss, dp);
            var hp = class extends Is {
                constructor(Q, oe, pe) {
                    super(pe),
                    this.type = Hi,
                    this.oldItem = Q ?? void 0,
                    this.newItem = oe ?? void 0
                }
                toJson() {
                    const Q = super.toJson();
                    return Q.oldItem = this.oldItem,
                    Q.newItem = this.newItem,
                    Q
                }
                static fromJson(Q, oe, pe) {
                    return oe = super.fromJson(Q, oe, pe ?? new hp),
                    oe.oldItem = Q.oldItem,
                    oe.newItem = Q.newItem,
                    oe
                }
            }
            ;
            ne(Yt.EVENT, Hi, hp),
            J.CHANGE$$module$build$src$core$events$utils,
            J.CREATE$$module$build$src$core$events$utils,
            J.DELETE$$module$build$src$core$events$utils,
            J.MOVE$$module$build$src$core$events$utils,
            J.CHANGE$$module$build$src$core$events$utils,
            J.CREATE$$module$build$src$core$events$utils,
            J.DELETE$$module$build$src$core$events$utils,
            J.MOVE$$module$build$src$core$events$utils,
            J.disable$$module$build$src$core$events$utils,
            J.enable$$module$build$src$core$events$utils,
            J.getGroup$$module$build$src$core$events$utils,
            J.setGroup$$module$build$src$core$events$utils;
            var cn = {};
            cn.Abstract = ji,
            cn.BLOCK_CHANGE = J.CHANGE$$module$build$src$core$events$utils,
            cn.BLOCK_CREATE = J.CREATE$$module$build$src$core$events$utils,
            cn.BLOCK_DELETE = J.DELETE$$module$build$src$core$events$utils,
            cn.BLOCK_DRAG = Go,
            cn.BLOCK_FIELD_INTERMEDIATE_CHANGE = fo,
            cn.BLOCK_MOVE = J.MOVE$$module$build$src$core$events$utils,
            cn.BUBBLE_OPEN = _s,
            cn.BUMP_EVENTS = rc,
            cn.BlockBase = Zo,
            cn.BlockChange = ai,
            cn.BlockCreate = ih,
            cn.BlockDelete = Kh,
            cn.BlockDrag = rp,
            cn.BlockFieldIntermediateChange = sp,
            cn.BlockMove = op,
            cn.BubbleOpen = ip,
            cn.BubbleType = ap,
            cn.CHANGE = J.CHANGE$$module$build$src$core$events$utils,
            cn.CLICK = Xs,
            cn.COMMENT_CHANGE = Gi,
            cn.COMMENT_CREATE = To,
            cn.COMMENT_DELETE = jo,
            cn.COMMENT_MOVE = Ss,
            cn.CREATE = J.CREATE$$module$build$src$core$events$utils,
            cn.Click = Bd,
            cn.ClickTarget = Ud,
            cn.CommentBase = bo,
            cn.CommentChange = lp,
            cn.CommentCreate = cp,
            cn.CommentDelete = up,
            cn.CommentMove = dp,
            cn.DELETE = J.DELETE$$module$build$src$core$events$utils,
            cn.FINISHED_LOADING = Wo,
            cn.FinishedLoading = rE,
            cn.MARKER_MOVE = Ui,
            cn.MOVE = J.MOVE$$module$build$src$core$events$utils,
            cn.MarkerMove = Vh,
            cn.SELECTED = Ys,
            cn.Selected = th,
            cn.THEME_CHANGE = Vi,
            cn.TOOLBOX_ITEM_SELECT = Hi,
            cn.TRASHCAN_OPEN = Fi,
            cn.ThemeChange = ah,
            cn.ToolboxItemSelect = hp,
            cn.TrashcanOpen = zh,
            cn.UI = nc,
            cn.UiBase = Is,
            cn.VAR_CREATE = go,
            cn.VAR_DELETE = Vo,
            cn.VAR_RENAME = Bi,
            cn.VIEWPORT_CHANGE = Eo,
            cn.VarBase = Ya,
            cn.VarCreate = Qd,
            cn.VarDelete = Wh,
            cn.VarRename = Yh,
            cn.ViewportChange = lh,
            cn.clearPendingUndo = Et,
            cn.disable = J.disable$$module$build$src$core$events$utils,
            cn.disableOrphans = Nt,
            cn.enable = J.enable$$module$build$src$core$events$utils,
            cn.filter = ct,
            cn.fire = Ye,
            cn.fromJson = Qe,
            cn.get = gt,
            cn.getDescendantIds = lt,
            cn.getGroup = J.getGroup$$module$build$src$core$events$utils,
            cn.getRecordUndo = St,
            cn.isEnabled = Ke,
            cn.setGroup = J.setGroup$$module$build$src$core$events$utils,
            cn.setRecordUndo = ft;
            var oE = class extends cl {
                constructor() {
                    super(),
                    this.GRID_UNIT = 4,
                    this.CURSOR_COLOUR = "#ffa200",
                    this.CURSOR_RADIUS = 5,
                    this.JAGGED_TEETH_WIDTH = this.JAGGED_TEETH_HEIGHT = 0,
                    this.START_HAT_HEIGHT = 22,
                    this.START_HAT_WIDTH = 96,
                    this.SHAPES = {
                        HEXAGONAL: 1,
                        ROUND: 2,
                        SQUARE: 3,
                        PUZZLE: 4,
                        NOTCH: 5
                    },
                    this.SHAPE_IN_SHAPE_PADDING = {
                        1: {
                            0: 5 * this.GRID_UNIT,
                            1: 2 * this.GRID_UNIT,
                            2: 5 * this.GRID_UNIT,
                            3: 5 * this.GRID_UNIT
                        },
                        2: {
                            0: 3 * this.GRID_UNIT,
                            1: 3 * this.GRID_UNIT,
                            2: 1 * this.GRID_UNIT,
                            3: 2 * this.GRID_UNIT
                        },
                        3: {
                            0: 2 * this.GRID_UNIT,
                            1: 2 * this.GRID_UNIT,
                            2: 2 * this.GRID_UNIT,
                            3: 2 * this.GRID_UNIT
                        }
                    },
                    this.FULL_BLOCK_FIELDS = !0,
                    this.FIELD_TEXT_FONTWEIGHT = "bold",
                    this.FIELD_TEXT_FONTFAMILY = '"Helvetica Neue", "Segoe UI", Helvetica, sans-serif',
                    this.FIELD_COLOUR_FULL_BLOCK = this.FIELD_TEXTINPUT_BOX_SHADOW = this.FIELD_DROPDOWN_SVG_ARROW = this.FIELD_DROPDOWN_COLOURED_DIV = this.FIELD_DROPDOWN_NO_BORDER_RECT_SHADOW = !0,
                    this.SELECTED_GLOW_COLOUR = "#fff200",
                    this.SELECTED_GLOW_SIZE = .5,
                    this.REPLACEMENT_GLOW_COLOUR = "#fff200",
                    this.REPLACEMENT_GLOW_SIZE = 2,
                    this.selectedGlowFilterId = "",
                    this.selectedGlowFilter = null,
                    this.replacementGlowFilterId = "",
                    this.SQUARED = this.ROUNDED = this.HEXAGONAL = this.replacementGlowFilter = null,
                    this.SMALL_PADDING = this.GRID_UNIT,
                    this.MEDIUM_PADDING = 2 * this.GRID_UNIT,
                    this.MEDIUM_LARGE_PADDING = 3 * this.GRID_UNIT,
                    this.LARGE_PADDING = 4 * this.GRID_UNIT,
                    this.CORNER_RADIUS = 1 * this.GRID_UNIT,
                    this.NOTCH_WIDTH = 9 * this.GRID_UNIT,
                    this.NOTCH_HEIGHT = 2 * this.GRID_UNIT,
                    this.STATEMENT_INPUT_NOTCH_OFFSET = this.NOTCH_OFFSET_LEFT = 3 * this.GRID_UNIT,
                    this.MIN_BLOCK_WIDTH = 2 * this.GRID_UNIT,
                    this.MIN_BLOCK_HEIGHT = 12 * this.GRID_UNIT,
                    this.EMPTY_STATEMENT_INPUT_HEIGHT = 6 * this.GRID_UNIT,
                    this.TOP_ROW_MIN_HEIGHT = this.CORNER_RADIUS,
                    this.TOP_ROW_PRECEDES_STATEMENT_MIN_HEIGHT = this.LARGE_PADDING,
                    this.BOTTOM_ROW_MIN_HEIGHT = this.CORNER_RADIUS,
                    this.BOTTOM_ROW_AFTER_STATEMENT_MIN_HEIGHT = 6 * this.GRID_UNIT,
                    this.STATEMENT_BOTTOM_SPACER = -this.NOTCH_HEIGHT,
                    this.STATEMENT_INPUT_SPACER_MIN_WIDTH = 40 * this.GRID_UNIT,
                    this.STATEMENT_INPUT_PADDING_LEFT = 4 * this.GRID_UNIT,
                    this.EMPTY_INLINE_INPUT_PADDING = 4 * this.GRID_UNIT,
                    this.EMPTY_INLINE_INPUT_HEIGHT = 8 * this.GRID_UNIT,
                    this.DUMMY_INPUT_MIN_HEIGHT = 8 * this.GRID_UNIT,
                    this.DUMMY_INPUT_SHADOW_MIN_HEIGHT = 6 * this.GRID_UNIT,
                    this.CURSOR_WS_WIDTH = 20 * this.GRID_UNIT,
                    this.FIELD_TEXT_FONTSIZE = 3 * this.GRID_UNIT,
                    this.FIELD_BORDER_RECT_RADIUS = this.CORNER_RADIUS,
                    this.FIELD_BORDER_RECT_X_PADDING = 2 * this.GRID_UNIT,
                    this.FIELD_BORDER_RECT_Y_PADDING = 1.625 * this.GRID_UNIT,
                    this.FIELD_BORDER_RECT_HEIGHT = 8 * this.GRID_UNIT,
                    this.FIELD_DROPDOWN_BORDER_RECT_HEIGHT = 8 * this.GRID_UNIT,
                    this.FIELD_DROPDOWN_SVG_ARROW_PADDING = this.FIELD_BORDER_RECT_X_PADDING,
                    this.FIELD_COLOUR_DEFAULT_WIDTH = 6 * this.GRID_UNIT,
                    this.FIELD_COLOUR_DEFAULT_HEIGHT = 8 * this.GRID_UNIT,
                    this.FIELD_CHECKBOX_X_OFFSET = 1 * this.GRID_UNIT,
                    this.MAX_DYNAMIC_CONNECTION_SHAPE_WIDTH = 12 * this.GRID_UNIT
                }
                setFontConstants_(Q) {
                    super.setFontConstants_(Q),
                    this.FIELD_DROPDOWN_BORDER_RECT_HEIGHT = this.FIELD_BORDER_RECT_HEIGHT = this.FIELD_TEXT_HEIGHT + 2 * this.FIELD_BORDER_RECT_Y_PADDING
                }
                init() {
                    super.init(),
                    this.HEXAGONAL = this.makeHexagonal(),
                    this.ROUNDED = this.makeRounded(),
                    this.SQUARED = this.makeSquared(),
                    this.STATEMENT_INPUT_NOTCH_OFFSET = this.NOTCH_OFFSET_LEFT + this.INSIDE_CORNERS.rightWidth
                }
                setDynamicProperties_(Q) {
                    super.setDynamicProperties_(Q),
                    this.SELECTED_GLOW_COLOUR = Q.getComponentStyle("selectedGlowColour") || this.SELECTED_GLOW_COLOUR;
                    const oe = Number(Q.getComponentStyle("selectedGlowSize"));
                    this.SELECTED_GLOW_SIZE = oe && !isNaN(oe) ? oe : this.SELECTED_GLOW_SIZE,
                    this.REPLACEMENT_GLOW_COLOUR = Q.getComponentStyle("replacementGlowColour") || this.REPLACEMENT_GLOW_COLOUR,
                    this.REPLACEMENT_GLOW_SIZE = (Q = Number(Q.getComponentStyle("replacementGlowSize"))) && !isNaN(Q) ? Q : this.REPLACEMENT_GLOW_SIZE
                }
                dispose() {
                    super.dispose(),
                    this.selectedGlowFilter && Bt(this.selectedGlowFilter),
                    this.replacementGlowFilter && Bt(this.replacementGlowFilter)
                }
                makeStartHat() {
                    const Q = this.START_HAT_HEIGHT
                      , oe = this.START_HAT_WIDTH
                      , pe = xr("c", [gn(25, -Q), gn(71, -Q), gn(oe, 0)]);
                    return {
                        height: Q,
                        width: oe,
                        path: pe
                    }
                }
                makeHexagonal() {
                    function Q(pe, Ae, Re) {
                        var Ue = pe / 2;
                        return Ue = Ue > oe ? oe : Ue,
                        Re = Re ? -1 : 1,
                        pe = (Ae ? -1 : 1) * pe / 2,
                        As(-Re * Ue, pe) + As(Re * Ue, pe)
                    }
                    const oe = this.MAX_DYNAMIC_CONNECTION_SHAPE_WIDTH;
                    return {
                        type: this.SHAPES.HEXAGONAL,
                        isDynamic: !0,
                        width(pe) {
                            return pe /= 2,
                            pe > oe ? oe : pe
                        },
                        height(pe) {
                            return pe
                        },
                        connectionOffsetY(pe) {
                            return pe / 2
                        },
                        connectionOffsetX(pe) {
                            return -pe
                        },
                        pathDown(pe) {
                            return Q(pe, !1, !1)
                        },
                        pathUp(pe) {
                            return Q(pe, !0, !1)
                        },
                        pathRightDown(pe) {
                            return Q(pe, !1, !0)
                        },
                        pathRightUp(pe) {
                            return Q(pe, !1, !0)
                        }
                    }
                }
                makeRounded() {
                    function Q(Ae, Re, Ue) {
                        const tt = Ae > pe ? Ae - pe : 0;
                        return Ae = (Ae > pe ? pe : Ae) / 2,
                        sr("a", "0 0,1", Ae, gn((Re ? -1 : 1) * Ae, (Re ? -1 : 1) * Ae)) + ln("v", (Ue ? 1 : -1) * tt) + sr("a", "0 0,1", Ae, gn((Re ? 1 : -1) * Ae, (Re ? -1 : 1) * Ae))
                    }
                    const oe = this.MAX_DYNAMIC_CONNECTION_SHAPE_WIDTH
                      , pe = 2 * oe;
                    return {
                        type: this.SHAPES.ROUND,
                        isDynamic: !0,
                        width(Ae) {
                            return Ae /= 2,
                            Ae > oe ? oe : Ae
                        },
                        height(Ae) {
                            return Ae
                        },
                        connectionOffsetY(Ae) {
                            return Ae / 2
                        },
                        connectionOffsetX(Ae) {
                            return -Ae
                        },
                        pathDown(Ae) {
                            return Q(Ae, !1, !1)
                        },
                        pathUp(Ae) {
                            return Q(Ae, !0, !1)
                        },
                        pathRightDown(Ae) {
                            return Q(Ae, !1, !0)
                        },
                        pathRightUp(Ae) {
                            return Q(Ae, !1, !0)
                        }
                    }
                }
                makeSquared() {
                    function Q(pe, Ae, Re) {
                        return pe -= 2 * oe,
                        sr("a", "0 0,1", oe, gn((Ae ? -1 : 1) * oe, (Ae ? -1 : 1) * oe)) + ln("v", (Re ? 1 : -1) * pe) + sr("a", "0 0,1", oe, gn((Ae ? 1 : -1) * oe, (Ae ? -1 : 1) * oe))
                    }
                    const oe = this.CORNER_RADIUS;
                    return {
                        type: this.SHAPES.SQUARE,
                        isDynamic: !0,
                        width(pe) {
                            return oe
                        },
                        height(pe) {
                            return pe
                        },
                        connectionOffsetY(pe) {
                            return pe / 2
                        },
                        connectionOffsetX(pe) {
                            return -pe
                        },
                        pathDown(pe) {
                            return Q(pe, !1, !1)
                        },
                        pathUp(pe) {
                            return Q(pe, !0, !1)
                        },
                        pathRightDown(pe) {
                            return Q(pe, !1, !0)
                        },
                        pathRightUp(pe) {
                            return Q(pe, !1, !0)
                        }
                    }
                }
                shapeFor(Q) {
                    let oe = Q.getCheck();
                    switch (!oe && Q.targetConnection && (oe = Q.targetConnection.getCheck()),
                    Q.type) {
                    case pn.INPUT_VALUE:
                    case pn.OUTPUT_VALUE:
                        if (Q = Q.getSourceBlock().getOutputShape(),
                        Q !== null)
                            switch (Q) {
                            case this.SHAPES.HEXAGONAL:
                                return this.HEXAGONAL;
                            case this.SHAPES.ROUND:
                                return this.ROUNDED;
                            case this.SHAPES.SQUARE:
                                return this.SQUARED
                            }
                        return oe && oe.indexOf("Boolean") !== -1 ? this.HEXAGONAL : oe && oe.indexOf("Number") !== -1 ? this.ROUNDED : (oe && oe.indexOf("String"),
                        this.ROUNDED);
                    case pn.PREVIOUS_STATEMENT:
                    case pn.NEXT_STATEMENT:
                        return this.NOTCH;
                    default:
                        throw Error("Unknown type")
                    }
                }
                makeNotch() {
                    function Q(sn) {
                        return xr("c", [gn(sn * Re / 2, 0), gn(sn * Re * 3 / 4, tt / 2), gn(sn * Re, tt)]) + Pi([gn(sn * Re, Ue)]) + xr("c", [gn(sn * Re / 4, tt / 2), gn(sn * Re / 2, tt), gn(sn * Re, tt)]) + ln("h", sn * Ae) + xr("c", [gn(sn * Re / 2, 0), gn(sn * Re * 3 / 4, -(tt / 2)), gn(sn * Re, -tt)]) + Pi([gn(sn * Re, -Ue)]) + xr("c", [gn(sn * Re / 4, -(tt / 2)), gn(sn * Re / 2, -tt), gn(sn * Re, -tt)])
                    }
                    const oe = this.NOTCH_WIDTH
                      , pe = this.NOTCH_HEIGHT
                      , Ae = oe / 3
                      , Re = Ae / 3
                      , Ue = pe / 2
                      , tt = Ue / 2
                      , dt = Q(1)
                      , wt = Q(-1);
                    return {
                        type: this.SHAPES.NOTCH,
                        width: oe,
                        height: pe,
                        pathLeft: dt,
                        pathRight: wt
                    }
                }
                makeInsideCorners() {
                    const Q = this.CORNER_RADIUS
                      , oe = sr("a", "0 0,0", Q, gn(-Q, Q))
                      , pe = sr("a", "0 0,1", Q, gn(-Q, Q))
                      , Ae = sr("a", "0 0,0", Q, gn(Q, Q))
                      , Re = sr("a", "0 0,1", Q, gn(Q, Q));
                    return {
                        width: Q,
                        height: Q,
                        pathTop: oe,
                        pathBottom: Ae,
                        rightWidth: Q,
                        rightHeight: Q,
                        pathTopRight: pe,
                        pathBottomRight: Re
                    }
                }
                generateSecondaryColour_(Q) {
                    return Ho("#000", Q, .15) || Q
                }
                generateTertiaryColour_(Q) {
                    return Ho("#000", Q, .25) || Q
                }
                createDom(Q, oe, pe) {
                    super.createDom(Q, oe, pe),
                    Q = $t(bt.DEFS, {}, Q),
                    oe = $t(bt.FILTER, {
                        id: "blocklySelectedGlowFilter" + this.randomIdentifier,
                        height: "160%",
                        width: "180%",
                        y: "-30%",
                        x: "-40%"
                    }, Q),
                    $t(bt.FEGAUSSIANBLUR, {
                        in: "SourceGraphic",
                        stdDeviation: this.SELECTED_GLOW_SIZE
                    }, oe),
                    pe = $t(bt.FECOMPONENTTRANSFER, {
                        result: "outBlur"
                    }, oe),
                    $t(bt.FEFUNCA, {
                        type: "table",
                        tableValues: "0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"
                    }, pe),
                    $t(bt.FEFLOOD, {
                        "flood-color": this.SELECTED_GLOW_COLOUR,
                        "flood-opacity": 1,
                        result: "outColor"
                    }, oe),
                    $t(bt.FECOMPOSITE, {
                        in: "outColor",
                        in2: "outBlur",
                        operator: "in",
                        result: "outGlow"
                    }, oe),
                    this.selectedGlowFilterId = oe.id,
                    this.selectedGlowFilter = oe,
                    Q = $t(bt.FILTER, {
                        id: "blocklyReplacementGlowFilter" + this.randomIdentifier,
                        height: "160%",
                        width: "180%",
                        y: "-30%",
                        x: "-40%"
                    }, Q),
                    $t(bt.FEGAUSSIANBLUR, {
                        in: "SourceGraphic",
                        stdDeviation: this.REPLACEMENT_GLOW_SIZE
                    }, Q),
                    oe = $t(bt.FECOMPONENTTRANSFER, {
                        result: "outBlur"
                    }, Q),
                    $t(bt.FEFUNCA, {
                        type: "table",
                        tableValues: "0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"
                    }, oe),
                    $t(bt.FEFLOOD, {
                        "flood-color": this.REPLACEMENT_GLOW_COLOUR,
                        "flood-opacity": 1,
                        result: "outColor"
                    }, Q),
                    $t(bt.FECOMPOSITE, {
                        in: "outColor",
                        in2: "outBlur",
                        operator: "in",
                        result: "outGlow"
                    }, Q),
                    $t(bt.FECOMPOSITE, {
                        in: "SourceGraphic",
                        in2: "outGlow",
                        operator: "over"
                    }, Q),
                    this.replacementGlowFilterId = Q.id,
                    this.replacementGlowFilter = Q
                }
                getCSS_(Q) {
                    return [`${Q} .blocklyText,`, `${Q} .blocklyFlyoutLabelText {`, `font: ${this.FIELD_TEXT_FONTWEIGHT} ${this.FIELD_TEXT_FONTSIZE}pt ${this.FIELD_TEXT_FONTFAMILY};`, "}", `${Q} .blocklyText {`, "fill: #fff;", "}", `${Q} .blocklyNonEditableText>rect:not(.blocklyDropdownRect),`, `${Q} .blocklyEditableText>rect:not(.blocklyDropdownRect) {`, `fill: ${this.FIELD_BORDER_RECT_COLOUR};`, "}", `${Q} .blocklyNonEditableText>text,`, `${Q} .blocklyEditableText>text,`, `${Q} .blocklyNonEditableText>g>text,`, `${Q} .blocklyEditableText>g>text {`, "fill: #575E75;", "}", `${Q} .blocklyFlyoutLabelText {`, "fill: #575E75;", "}", `${Q} .blocklyText.blocklyBubbleText {`, "fill: #575E75;", "}", `${Q} .blocklyDraggable:not(.blocklyDisabled)`, " .blocklyEditableText:not(.editing):hover>rect,", `${Q} .blocklyDraggable:not(.blocklyDisabled)`, " .blocklyEditableText:not(.editing):hover>.blocklyPath {", "stroke: #fff;", "stroke-width: 2;", "}", `${Q} .blocklyHtmlInput {`, `font-family: ${this.FIELD_TEXT_FONTFAMILY};`, `font-weight: ${this.FIELD_TEXT_FONTWEIGHT};`, "color: #575E75;", "}", `${Q} .blocklyDropdownText {`, "fill: #fff !important;", "}", `${Q}.blocklyWidgetDiv .goog-menuitem,`, `${Q}.blocklyDropDownDiv .goog-menuitem {`, `font-family: ${this.FIELD_TEXT_FONTFAMILY};`, "}", `${Q}.blocklyDropDownDiv .goog-menuitem-content {`, "color: #fff;", "}", `${Q} .blocklyHighlightedConnectionPath {`, `stroke: ${this.SELECTED_GLOW_COLOUR};`, "}", `${Q} .blocklyDisabled > .blocklyOutlinePath {`, `fill: url(#blocklyDisabledPattern${this.randomIdentifier})`, "}", `${Q} .blocklyInsertionMarker>.blocklyPath {`, `fill-opacity: ${this.INSERTION_MARKER_OPACITY};`, "stroke: none;", "}"]
                }
            }
              , iE = class extends ul {
                constructor(Q, oe) {
                    super(Q, oe)
                }
                draw() {
                    const Q = this.block_.pathObject;
                    Q.beginDrawing(),
                    this.drawOutline_(),
                    this.drawInternals_(),
                    Q.setPath(this.outlinePath_ + `
` + this.inlinePath_),
                    this.info_.RTL && Q.flipRTL(),
                    this.recordSizeOnBlock_(),
                    this.info_.outputConnection && (Q.outputShapeType = this.info_.outputConnection.shape.type),
                    Q.endDrawing()
                }
                drawOutline_() {
                    this.info_.outputConnection && this.info_.outputConnection.isDynamicShape && !this.info_.hasStatementInput && !this.info_.bottomRow.hasNextConnection ? (this.drawFlatTop_(),
                    this.drawRightDynamicConnection_(),
                    this.drawFlatBottom_(),
                    this.drawLeftDynamicConnection_()) : super.drawOutline_()
                }
                drawLeft_() {
                    this.info_.outputConnection && this.info_.outputConnection.isDynamicShape ? this.drawLeftDynamicConnection_() : super.drawLeft_()
                }
                drawRightSideRow_(Q) {
                    if (!(0 >= Q.height)) {
                        if (Rt.isSpacer(Q)) {
                            const Ae = Q.precedesStatement;
                            var oe = Q.followsStatement;
                            if (Ae || oe) {
                                const Re = this.constants_.INSIDE_CORNERS;
                                var pe = Re.rightHeight;
                                pe = Q.height - (Ae ? pe : 0),
                                oe = oe ? Re.pathBottomRight : "",
                                Q = 0 < pe ? ln("V", Q.yPos + pe) : "",
                                this.outlinePath_ += oe + Q + (Ae ? Re.pathTopRight : "");
                                return
                            }
                        }
                        this.outlinePath_ += ln("V", Q.yPos + Q.height)
                    }
                }
                drawRightDynamicConnection_() {
                    if (!this.info_.outputConnection)
                        throw Error("Cannot draw the output connection of a block that doesn't have one");
                    this.outlinePath_ += this.info_.outputConnection.shape.pathRightDown(this.info_.outputConnection.height)
                }
                drawLeftDynamicConnection_() {
                    if (!this.info_.outputConnection)
                        throw Error("Cannot draw the output connection of a block that doesn't have one");
                    this.positionOutputConnection_(),
                    this.outlinePath_ += this.info_.outputConnection.shape.pathUp(this.info_.outputConnection.height),
                    this.outlinePath_ += "z"
                }
                drawFlatTop_() {
                    const Q = this.info_.topRow;
                    this.positionPreviousConnection_(),
                    this.outlinePath_ += qn(Q.xPos, this.info_.startY),
                    this.outlinePath_ += ln("h", Q.width)
                }
                drawFlatBottom_() {
                    const Q = this.info_.bottomRow;
                    this.positionNextConnection_(),
                    this.outlinePath_ += ln("V", Q.baseline),
                    this.outlinePath_ += ln("h", -Q.width)
                }
                drawInlineInput_(Q) {
                    this.positionInlineInputConnection_(Q);
                    const oe = Q.input.name;
                    if (!Q.connectedBlock && !this.info_.isInsertionMarker) {
                        var pe = Q.width - 2 * Q.connectionWidth;
                        Q = mr(Q.xPos + Q.connectionWidth, Q.centerline - Q.height / 2) + ln("h", pe) + Q.shape.pathRightDown(Q.height) + ln("h", -pe) + Q.shape.pathUp(Q.height) + "z",
                        this.block_.pathObject.setOutlinePath(oe, Q)
                    }
                }
                drawStatementInput_(Q) {
                    var oe = Q.getLastInput();
                    const pe = oe.xPos + oe.notchOffset + oe.shape.width
                      , Ae = this.constants_.INSIDE_CORNERS
                      , Re = oe.shape.pathRight + ln("h", -(oe.notchOffset - Ae.width)) + Ae.pathTop
                      , Ue = Q.height - 2 * Ae.height;
                    oe = Ae.pathBottom + ln("h", oe.notchOffset - Ae.width) + (oe.connectedBottomNextConnection ? "" : oe.shape.pathLeft),
                    this.outlinePath_ += ln("H", pe) + Re + ln("v", Ue) + oe + ln("H", Q.xPos + Q.width),
                    this.positionStatementInputConnection_(Q)
                }
            }
              , di = class extends vn {
                constructor(Q, oe, pe, Ae, Re, Ue, tt) {
                    if (super(vn.SKIP_SETUP),
                    this.imageElement = this.clickHandler = null,
                    this.flipRtl = this.isDirty_ = this.EDITABLE = !1,
                    this.altText = "",
                    pe = Number(rr(pe)),
                    oe = Number(rr(oe)),
                    isNaN(pe) || isNaN(oe))
                        throw Error("Height and width values of an image field must cast to numbers.");
                    if (0 >= pe || 0 >= oe)
                        throw Error("Height and width values of an image field must be greater than 0.");
                    this.size_ = new Yn(oe,pe + di.Y_PADDING),
                    this.imageHeight = pe,
                    typeof Re == "function" && (this.clickHandler = Re),
                    Q !== vn.SKIP_SETUP && (tt ? this.configure_(tt) : (this.flipRtl = !!Ue,
                    this.altText = rr(Ae) || ""),
                    this.setValue(rr(Q)))
                }
                configure_(Q) {
                    super.configure_(Q),
                    Q.flipRtl && (this.flipRtl = Q.flipRtl),
                    Q.alt && (this.altText = rr(Q.alt))
                }
                initView() {
                    this.imageElement = $t(bt.IMAGE, {
                        height: this.imageHeight + "px",
                        width: this.size_.width + "px",
                        alt: this.altText
                    }, this.fieldGroup_),
                    this.imageElement.setAttributeNS(Fr, "xlink:href", this.value_),
                    this.clickHandler && (this.imageElement.style.cursor = "pointer")
                }
                updateSize_() {}
                doClassValidation_(Q) {
                    return typeof Q != "string" ? null : Q
                }
                doValueUpdate_(Q) {
                    this.value_ = Q,
                    this.imageElement && this.imageElement.setAttributeNS(Fr, "xlink:href", this.value_)
                }
                getFlipRtl() {
                    return this.flipRtl
                }
                setAlt(Q) {
                    Q !== this.altText && (this.altText = Q || "",
                    this.imageElement && this.imageElement.setAttribute("alt", this.altText))
                }
                showEditor_() {
                    this.clickHandler && this.clickHandler(this)
                }
                setOnClickHandler(Q) {
                    this.clickHandler = Q
                }
                getText_() {
                    return this.altText
                }
                static fromJson(Q) {
                    if (!Q.src || !Q.width || !Q.height)
                        throw Error("src, width, and height values for an image field arerequired. The width and height must be non-zero.");
                    return new this(Q.src,Q.width,Q.height,void 0,void 0,void 0,Q)
                }
            }
            ;
            di.Y_PADDING = 1,
            Ur("field_image", di),
            di.prototype.DEFAULT_VALUE = "";
            var gl = class extends vn {
                constructor(Q, oe, pe) {
                    super(vn.SKIP_SETUP),
                    this.spellcheck_ = !0,
                    this.htmlInput_ = null,
                    this.isTextValid_ = this.isBeingEdited_ = !1,
                    this.onKeyInputWrapper_ = this.onKeyDownWrapper_ = this.valueWhenEditorWasOpened_ = null,
                    this.fullBlockClickTarget_ = !1,
                    this.workspace_ = null,
                    this.SERIALIZABLE = !0,
                    this.CURSOR = "text",
                    Q !== vn.SKIP_SETUP && (pe && this.configure_(pe),
                    this.setValue(Q),
                    oe && this.setValidator(oe))
                }
                configure_(Q) {
                    super.configure_(Q),
                    Q.spellcheck !== void 0 && (this.spellcheck_ = Q.spellcheck)
                }
                initView() {
                    if (!this.getSourceBlock())
                        throw new Gn;
                    super.initView(),
                    this.isFullBlockField() && (this.clickTarget_ = this.sourceBlock_.getSvgRoot())
                }
                isFullBlockField() {
                    const Q = this.getSourceBlock();
                    if (!Q)
                        throw new Gn;
                    let oe;
                    return this.fullBlockClickTarget_ = !((oe = this.getConstants()) == null || !oe.FULL_BLOCK_FIELDS) && Q.isSimpleReporter()
                }
                doValueInvalid_(Q) {
                    this.isBeingEdited_ && (this.isDirty_ = !0,
                    this.isTextValid_ = !1,
                    Q = this.value_,
                    this.value_ = this.htmlInput_.getAttribute("data-untyped-default-value"),
                    this.sourceBlock_ && Ke() && Ye(new (gt(J.CHANGE$$module$build$src$core$events$utils))(this.sourceBlock_,"field",this.name || null,Q,this.value_)))
                }
                doValueUpdate_(Q) {
                    this.isTextValid_ = this.isDirty_ = !0,
                    this.value_ = Q
                }
                applyColour() {
                    const Q = this.getSourceBlock();
                    if (!Q)
                        throw new Gn;
                    this.getConstants().FULL_BLOCK_FIELDS && this.fieldGroup_ && (!this.isFullBlockField() && this.borderRect_ ? (this.borderRect_.style.display = "block",
                    this.borderRect_.setAttribute("stroke", Q.style.colourTertiary)) : (this.borderRect_.style.display = "none",
                    Q.pathObject.svgPath.setAttribute("fill", this.getConstants().FIELD_BORDER_RECT_COLOUR)))
                }
                getSize() {
                    let Q;
                    return (Q = this.getConstants()) != null && Q.FULL_BLOCK_FIELDS && (this.render_(),
                    this.isDirty_ = !1),
                    super.getSize()
                }
                onLocationChange() {
                    this.isBeingEdited_ && this.resizeEditor_()
                }
                render_() {
                    if (super.render_(),
                    this.isBeingEdited_) {
                        var Q = this.htmlInput_;
                        this.isTextValid_ ? (yt(Q, "blocklyInvalidInput"),
                        Jn(Q, Xn.INVALID, !1)) : (Ut(Q, "blocklyInvalidInput"),
                        Jn(Q, Xn.INVALID, !0))
                    }
                    if (Q = this.getSourceBlock(),
                    !Q)
                        throw new Gn;
                    this.getConstants().FULL_BLOCK_FIELDS && Q.applyColour()
                }
                setSpellcheck(Q) {
                    Q !== this.spellcheck_ && (this.spellcheck_ = Q,
                    this.htmlInput_ && this.htmlInput_.setAttribute("spellcheck", this.spellcheck_))
                }
                showEditor_(Q, oe=!1) {
                    this.workspace_ = this.sourceBlock_.workspace,
                    !oe && this.workspace_.options.modalInputs && (jd || cc || Wi) ? this.showPromptEditor_() : this.showInlineEditor_(oe)
                }
                showPromptEditor_() {
                    Un(J.Msg$$module$build$src$core$msg.CHANGE_VALUE_TITLE, this.getText(), Q => {
                        Q !== null && this.setValue(this.getValueFromEditorText_(Q)),
                        this.onFinishEditing_(this.value_)
                    }
                    )
                }
                showInlineEditor_(Q) {
                    const oe = this.getSourceBlock();
                    if (!oe)
                        throw new Gn;
                    Pl(this, oe.RTL, this.widgetDispose_.bind(this)),
                    this.htmlInput_ = this.widgetCreate_(),
                    this.isBeingEdited_ = !0,
                    this.valueWhenEditorWasOpened_ = this.value_,
                    Q || (this.htmlInput_.focus({
                        preventScroll: !0
                    }),
                    this.htmlInput_.select())
                }
                widgetCreate_() {
                    var Q = this.getSourceBlock();
                    if (!Q)
                        throw new Gn;
                    J.setGroup$$module$build$src$core$events$utils(!0);
                    const oe = Fo();
                    var pe = this.getClickTarget_();
                    if (!pe)
                        throw Error("A click target has not been set.");
                    Ut(pe, "editing"),
                    pe = document.createElement("input"),
                    pe.className = "blocklyHtmlInput",
                    pe.setAttribute("spellcheck", this.spellcheck_);
                    const Ae = this.workspace_.getScale();
                    var Re = this.getConstants().FIELD_TEXT_FONTSIZE * Ae + "pt";
                    return oe.style.fontSize = Re,
                    pe.style.fontSize = Re,
                    Re = gl.BORDERRADIUS * Ae + "px",
                    this.isFullBlockField() && (Re = this.getScaledBBox(),
                    Re = (Re.bottom - Re.top) / 2 + "px",
                    Q = Q.getParent() ? Q.getParent().style.colourTertiary : this.sourceBlock_.style.colourTertiary,
                    pe.style.border = 1 * Ae + "px solid " + Q,
                    oe.style.borderRadius = Re,
                    oe.style.transition = "box-shadow 0.25s ease 0s",
                    this.getConstants().FIELD_TEXTINPUT_BOX_SHADOW && (oe.style.boxShadow = "rgba(255, 255, 255, 0.3) 0 0 0 " + 4 * Ae + "px")),
                    pe.style.borderRadius = Re,
                    oe.appendChild(pe),
                    pe.value = pe.defaultValue = this.getEditorText_(this.value_),
                    pe.setAttribute("data-untyped-default-value", String(this.value_)),
                    this.resizeEditor_(),
                    this.bindInputEvents_(pe),
                    pe
                }
                widgetDispose_() {
                    this.isBeingEdited_ = !1,
                    this.isTextValid_ = !0,
                    this.forceRerender(),
                    this.onFinishEditing_(this.value_),
                    this.sourceBlock_ && Ke() && this.valueWhenEditorWasOpened_ !== null && this.valueWhenEditorWasOpened_ !== this.value_ && (Ye(new (gt(J.CHANGE$$module$build$src$core$events$utils))(this.sourceBlock_,"field",this.name || null,this.valueWhenEditorWasOpened_,this.value_)),
                    this.valueWhenEditorWasOpened_ = null),
                    J.setGroup$$module$build$src$core$events$utils(!1),
                    this.unbindInputEvents_();
                    var Q = Fo().style;
                    if (Q.width = "auto",
                    Q.height = "auto",
                    Q.fontSize = "",
                    Q.transition = "",
                    Q.boxShadow = "",
                    this.htmlInput_ = null,
                    Q = this.getClickTarget_(),
                    !Q)
                        throw Error("A click target has not been set.");
                    yt(Q, "editing")
                }
                onFinishEditing_(Q) {}
                bindInputEvents_(Q) {
                    this.onKeyDownWrapper_ = vt(Q, "keydown", this, this.onHtmlInputKeyDown_),
                    this.onKeyInputWrapper_ = vt(Q, "input", this, this.onHtmlInputChange_)
                }
                unbindInputEvents_() {
                    this.onKeyDownWrapper_ && (Ct(this.onKeyDownWrapper_),
                    this.onKeyDownWrapper_ = null),
                    this.onKeyInputWrapper_ && (Ct(this.onKeyInputWrapper_),
                    this.onKeyInputWrapper_ = null)
                }
                onHtmlInputKeyDown_(Q) {
                    Q.key === "Enter" ? (Jr(),
                    ss()) : Q.key === "Escape" ? (this.setValue(this.htmlInput_.getAttribute("data-untyped-default-value")),
                    Jr(),
                    ss()) : Q.key === "Tab" && (Jr(),
                    ss(),
                    this.sourceBlock_.tab(this, !Q.shiftKey),
                    Q.preventDefault())
                }
                onHtmlInputChange_(Q) {
                    Q = this.value_,
                    this.setValue(this.getValueFromEditorText_(this.htmlInput_.value), !1),
                    this.sourceBlock_ && Ke() && this.value_ !== Q && Ye(new (gt(fo))(this.sourceBlock_,this.name || null,Q,this.value_))
                }
                setEditorValue_(Q, oe=!0) {
                    this.isDirty_ = !0,
                    this.isBeingEdited_ && (this.htmlInput_.value = this.getEditorText_(Q)),
                    this.setValue(Q, oe)
                }
                resizeEditor_() {
                    var Q = this.getSourceBlock();
                    if (!Q)
                        throw new Gn;
                    const oe = Fo()
                      , pe = this.getScaledBBox();
                    oe.style.width = pe.right - pe.left + "px",
                    oe.style.height = pe.bottom - pe.top + "px",
                    Q = new Zt(Q.RTL ? pe.right - oe.offsetWidth : pe.left,pe.top),
                    oe.style.left = Q.x + "px",
                    oe.style.top = Q.y + "px"
                }
                repositionForWindowResize() {
                    const Q = this.getSourceBlock();
                    return Q instanceof Ls ? (ki(this.workspace_, this.workspace_.getMetricsManager().getViewMetrics(!0), Q) || this.resizeEditor_(),
                    !0) : !1
                }
                isTabNavigable() {
                    return !0
                }
                getText_() {
                    return this.isBeingEdited_ && this.htmlInput_ ? this.htmlInput_.value : null
                }
                getEditorText_(Q) {
                    return `${Q}`
                }
                getValueFromEditorText_(Q) {
                    return Q
                }
            }
            ;
            gl.BORDERRADIUS = 4;
            var ha = class extends gl {
                constructor(Q, oe, pe) {
                    super(Q, oe, pe)
                }
                doClassValidation_(Q) {
                    return Q === void 0 ? null : `${Q}`
                }
                static fromJson(Q) {
                    return new this(rr(Q.text),void 0,Q)
                }
            }
            ;
            Ur("field_input", ha),
            ha.prototype.DEFAULT_VALUE = "";
            var aE = class extends Dh {
                constructor(Q) {
                    super(Q)
                }
                endsWithElemSpacer() {
                    return !1
                }
                hasLeftSquareCorner(Q) {
                    return !!Q.outputConnection
                }
                hasRightSquareCorner(Q) {
                    return !!Q.outputConnection && !Q.statementInputCount && !Q.nextConnection
                }
            }
              , Uc = class extends il {
                constructor(Q, oe) {
                    if (super(Q, oe),
                    this.connectedBottomNextConnection = !1,
                    this.connectedBlock) {
                        for (Q = this.connectedBlock; oe = Q.getNextBlock(); )
                            Q = oe;
                        Q.nextConnection || (this.height = this.connectedBlockHeight,
                        this.connectedBottomNextConnection = !0)
                    }
                }
            }
              , lE = class extends vs {
                constructor(Q) {
                    super(Q),
                    this.width = this.height = 0,
                    this.type |= Rt.getType("RIGHT_CONNECTION")
                }
            }
              , cE = class extends Hh {
                constructor(Q) {
                    super(Q)
                }
                endsWithElemSpacer() {
                    return !1
                }
                hasLeftSquareCorner(Q) {
                    const oe = (Q.hat ? Q.hat === "cap" : this.constants_.ADD_START_HATS) && !Q.outputConnection && !Q.previousConnection;
                    return !!Q.outputConnection || oe
                }
                hasRightSquareCorner(Q) {
                    return !!Q.outputConnection && !Q.statementInputCount && !Q.nextConnection
                }
            }
              , uE = class extends ia {
                constructor(Q, oe) {
                    super(Q, oe),
                    this.isInline = !0,
                    this.renderer_ = Q,
                    this.constants_ = this.renderer_.getConstants(),
                    this.topRow = new cE(this.constants_),
                    this.bottomRow = new aE(this.constants_),
                    this.isMultiRow = !oe.getInputsInline() || oe.isCollapsed(),
                    this.hasStatementInput = 0 < oe.statementInputCount,
                    this.rightSide = this.outputConnection ? new lE(this.constants_) : null,
                    this.rightAlignedDummyInputs = new WeakMap
                }
                getRenderer() {
                    return this.renderer_
                }
                measure() {
                    this.createRows_(),
                    this.addElemSpacing_(),
                    this.addRowSpacing_(),
                    this.adjustXPosition_(),
                    this.computeBounds_(),
                    this.alignRowElements_(),
                    this.finalize_()
                }
                shouldStartNewRow_(Q, oe) {
                    return oe ? oe instanceof to || Q instanceof jr || oe instanceof jr ? !0 : Q instanceof J.ValueInput$$module$build$src$core$inputs$value_input || Q instanceof Ns || Q instanceof to ? !this.isInline || this.isMultiRow : !1 : !1
                }
                getDesiredRowWidth_(Q) {
                    return Q.hasStatement ? this.width - this.startX - (this.constants_.INSIDE_CORNERS.rightWidth || 0) : super.getDesiredRowWidth_(Q)
                }
                getInRowSpacing_(Q, oe) {
                    return Q && oe || !this.outputConnection || !this.outputConnection.isDynamicShape || this.hasStatementInput || this.bottomRow.hasNextConnection ? !Q && oe && Rt.isStatementInput(oe) ? this.constants_.STATEMENT_INPUT_PADDING_LEFT : Q && Rt.isLeftRoundedCorner(Q) && oe && (Rt.isPreviousConnection(oe) || Rt.isNextConnection(oe)) ? oe.notchOffset - this.constants_.CORNER_RADIUS : Q && Rt.isLeftSquareCorner(Q) && oe && Rt.isHat(oe) ? this.constants_.NO_PADDING : this.constants_.MEDIUM_PADDING : this.constants_.NO_PADDING
                }
                getSpacerRowHeight_(Q, oe) {
                    if (Rt.isTopRow(Q) && Rt.isBottomRow(oe))
                        return this.constants_.EMPTY_BLOCK_SPACER_HEIGHT;
                    const pe = Rt.isInputRow(Q) && Q.hasStatement
                      , Ae = Rt.isInputRow(oe) && oe.hasStatement;
                    return Ae || pe ? (Q = Math.max(this.constants_.NOTCH_HEIGHT, this.constants_.INSIDE_CORNERS.rightHeight || 0),
                    Ae && pe ? Math.max(Q, this.constants_.DUMMY_INPUT_MIN_HEIGHT) : Q) : Rt.isTopRow(Q) ? Q.hasPreviousConnection || this.outputConnection && !this.hasStatementInput ? this.constants_.NO_PADDING : Math.abs(this.constants_.NOTCH_HEIGHT - this.constants_.CORNER_RADIUS) : Rt.isBottomRow(oe) ? this.outputConnection ? !oe.hasNextConnection && this.hasStatementInput ? Math.abs(this.constants_.NOTCH_HEIGHT - this.constants_.CORNER_RADIUS) : this.constants_.NO_PADDING : Math.max(this.topRow.minHeight, Math.max(this.constants_.NOTCH_HEIGHT, this.constants_.CORNER_RADIUS)) - this.constants_.CORNER_RADIUS : this.constants_.MEDIUM_PADDING
                }
                getSpacerRowWidth_(Q, oe) {
                    const pe = this.width - this.startX;
                    return Rt.isInputRow(Q) && Q.hasStatement || Rt.isInputRow(oe) && oe.hasStatement ? Math.max(pe, this.constants_.STATEMENT_INPUT_SPACER_MIN_WIDTH) : pe
                }
                getElemCenterline_(Q, oe) {
                    if (Q.hasStatement && !Rt.isSpacer(oe) && !Rt.isStatementInput(oe))
                        return Q.yPos + this.constants_.EMPTY_STATEMENT_INPUT_HEIGHT / 2;
                    if (Rt.isInlineInput(oe) && oe instanceof yo) {
                        const pe = oe.connectedBlock;
                        if (pe && pe.outputConnection && pe.nextConnection)
                            return Q.yPos + pe.height / 2
                    }
                    return super.getElemCenterline_(Q, oe)
                }
                addInput_(Q, oe) {
                    if ((Q instanceof Ns || Q instanceof to) && oe.hasDummyInput && oe.align === J.Align$$module$build$src$core$inputs$align.LEFT && Q.align === J.Align$$module$build$src$core$inputs$align.RIGHT)
                        this.rightAlignedDummyInputs.set(oe, Q);
                    else if (Q instanceof jr) {
                        oe.elements.push(new Uc(this.constants_,Q)),
                        oe.hasStatement = !0,
                        oe.align === null && (oe.align = Q.align);
                        return
                    }
                    super.addInput_(Q, oe)
                }
                addAlignmentPadding_(Q, oe) {
                    if (this.rightAlignedDummyInputs.get(Q)) {
                        let pe;
                        for (let Ae = 0; Ae < Q.elements.length; Ae++) {
                            const Re = Q.elements[Ae];
                            if (Rt.isSpacer(Re) && (pe = Re),
                            Rt.isField(Re) && Re instanceof oa && Re.parentInput === this.rightAlignedDummyInputs.get(Q))
                                break
                        }
                        if (pe) {
                            pe.width += oe,
                            Q.width += oe;
                            return
                        }
                    }
                    super.addAlignmentPadding_(Q, oe)
                }
                adjustXPosition_() {
                    const Q = this.constants_.NOTCH_OFFSET_LEFT + this.constants_.NOTCH_WIDTH;
                    let oe = Q;
                    for (let Re = 2; Re < this.rows.length - 1; Re += 2) {
                        var pe = this.rows[Re - 1];
                        const Ue = this.rows[Re];
                        var Ae = this.rows[Re + 1];
                        if (pe = Re === 2 ? !!this.topRow.hasPreviousConnection : !!pe.followsStatement,
                        Ae = Re + 2 >= this.rows.length - 1 ? !!this.bottomRow.hasNextConnection : !!Ae.precedesStatement,
                        Rt.isInputRow(Ue) && Ue.hasStatement) {
                            Ue.measure();
                            let tt, dt;
                            oe = Ue.width - ((dt = (tt = Ue.getLastInput()) == null ? void 0 : tt.width) != null ? dt : 0) + Q
                        } else if (pe && (Re === 2 || Ae) && Rt.isInputRow(Ue) && !Ue.hasStatement) {
                            Ae = Ue.xPos,
                            pe = null;
                            for (let tt = 0; tt < Ue.elements.length; tt++) {
                                const dt = Ue.elements[tt];
                                Rt.isSpacer(dt) && (pe = dt),
                                pe && (Rt.isField(dt) || Rt.isInput(dt)) && Ae < oe && !(Rt.isField(dt) && dt instanceof oa && (dt.field instanceof ci || dt.field instanceof di)) && (pe.width += oe - Ae),
                                Ae += dt.width
                            }
                        }
                    }
                }
                finalizeOutputConnection_() {
                    if (this.outputConnection && this.outputConnection.isDynamicShape) {
                        var Q = this.outputConnection.shape;
                        if ("isDynamic"in Q && Q.isDynamic) {
                            for (var oe = 0, pe = 0; pe < this.rows.length; pe++) {
                                const Ae = this.rows[pe];
                                Ae.yPos = oe,
                                oe += Ae.height
                            }
                            this.height = oe,
                            pe = this.bottomRow.hasNextConnection ? this.height - this.bottomRow.descenderHeight : this.height,
                            oe = Q.height(pe),
                            pe = Q.width(pe),
                            this.outputConnection.height = oe,
                            this.outputConnection.width = pe,
                            this.outputConnection.startX = pe,
                            this.outputConnection.connectionOffsetY = Q.connectionOffsetY(oe),
                            this.outputConnection.connectionOffsetX = Q.connectionOffsetX(pe),
                            Q = 0,
                            this.hasStatementInput || this.bottomRow.hasNextConnection || (Q = pe,
                            this.rightSide.height = oe,
                            this.rightSide.width = Q,
                            this.rightSide.centerline = oe / 2,
                            this.rightSide.xPos = this.width + Q),
                            this.startX = pe,
                            this.width += pe + Q,
                            this.widthWithChildren += pe + Q
                        }
                    }
                }
                finalizeHorizontalAlignment_() {
                    if (this.outputConnection && !this.hasStatementInput && !this.bottomRow.hasNextConnection) {
                        for (var Q = 0, oe = 0; oe < this.rows.length; oe++) {
                            var pe = this.rows[oe];
                            if (!Rt.isInputRow(pe))
                                continue;
                            Q = pe.elements[pe.elements.length - 2];
                            let Ae = this.getNegativeSpacing_(pe.elements[1])
                              , Re = this.getNegativeSpacing_(Q);
                            Q = Ae + Re;
                            const Ue = this.constants_.MIN_BLOCK_WIDTH + 2 * this.outputConnection.width;
                            this.width - Q < Ue && (Q = this.width - Ue,
                            Ae = Q / 2,
                            Re = Q / 2),
                            pe.elements.unshift(new Gr(this.constants_,-Ae)),
                            pe.elements.push(new Gr(this.constants_,-Re))
                        }
                        if (Q)
                            for (this.width -= Q,
                            this.widthWithChildren -= Q,
                            this.rightSide.xPos -= Q,
                            oe = 0; oe < this.rows.length; oe++)
                                pe = this.rows[oe],
                                Rt.isTopOrBottomRow(pe) && (pe.elements[1].width -= Q),
                                pe.width -= Q,
                                pe.widthWithConnectedBlocks -= Q
                    }
                }
                getNegativeSpacing_(Q) {
                    if (!Q || !this.outputConnection)
                        return 0;
                    const oe = this.outputConnection.width;
                    var pe = this.outputConnection.shape.type;
                    const Ae = this.constants_;
                    if (1 < this.inputRows.length)
                        switch (pe) {
                        case Ae.SHAPES.ROUND:
                            return pe = this.constants_.MAX_DYNAMIC_CONNECTION_SHAPE_WIDTH,
                            pe = this.height / 2 > pe ? pe : this.height / 2,
                            oe - pe * (1 - Math.sin(Math.acos((pe - this.constants_.SMALL_PADDING) / pe)));
                        default:
                            return 0
                        }
                    if (Rt.isInlineInput(Q) && Q instanceof yo) {
                        const Re = Q.connectedBlock;
                        return Q = Re ? Re.pathObject.outputShapeType : Q.shape.type,
                        Q == null || Re && Re.outputConnection && (Re.statementInputCount || Re.nextConnection) || pe === Ae.SHAPES.HEXAGONAL && pe !== Q ? 0 : oe - this.constants_.SHAPE_IN_SHAPE_PADDING[pe][Q]
                    }
                    return Rt.isField(Q) && Q instanceof oa ? pe === Ae.SHAPES.ROUND && Q.field instanceof ha ? oe - 2.75 * Ae.GRID_UNIT : oe - this.constants_.SHAPE_IN_SHAPE_PADDING[pe][0] : Rt.isIcon(Q) ? this.constants_.SMALL_PADDING : 0
                }
                finalizeVerticalAlignment_() {
                    if (!this.outputConnection)
                        for (let Ae = 2; Ae < this.rows.length - 1; Ae += 2) {
                            const Re = this.rows[Ae - 1]
                              , Ue = this.rows[Ae]
                              , tt = this.rows[Ae + 1];
                            var Q = Ae === 2
                              , oe = Ae + 2 >= this.rows.length - 1 ? !!this.bottomRow.hasNextConnection : !!tt.precedesStatement;
                            if (Q ? this.topRow.hasPreviousConnection : Re.followsStatement) {
                                var pe = Ue.elements[1];
                                if (pe = Ue.elements.length === 3 && pe instanceof oa && (pe.field instanceof ci || pe.field instanceof di),
                                !Q && pe)
                                    Re.height -= this.constants_.SMALL_PADDING,
                                    tt.height -= this.constants_.SMALL_PADDING,
                                    Ue.height -= this.constants_.MEDIUM_PADDING;
                                else if (!Q && !oe)
                                    Re.height += this.constants_.SMALL_PADDING;
                                else if (oe) {
                                    for (Q = !1,
                                    oe = 0; oe < Ue.elements.length; oe++)
                                        if (pe = Ue.elements[oe],
                                        pe instanceof yo && Rt.isInlineInput(pe) && pe.connectedBlock && !pe.connectedBlock.isShadow() && 40 <= pe.connectedBlock.getHeightWidth().height) {
                                            Q = !0;
                                            break
                                        }
                                    Q && (Re.height -= this.constants_.SMALL_PADDING,
                                    tt.height -= this.constants_.SMALL_PADDING)
                                }
                            }
                        }
                }
                finalize_() {
                    this.finalizeOutputConnection_(),
                    this.finalizeHorizontalAlignment_(),
                    this.finalizeVerticalAlignment_(),
                    super.finalize_(),
                    this.rightSide && (this.widthWithChildren += this.rightSide.width)
                }
            }
              , dE = class extends Gh {
                constructor(Q, oe, pe) {
                    super(Q, oe, pe),
                    this.markerCircle = null
                }
                showWithInputOutput(Q) {
                    const oe = Q.getSourceBlock();
                    Q = Q.getLocation().getOffsetInBlock(),
                    this.positionCircle(Q.x, Q.y),
                    this.setParent_(oe),
                    this.showCurrent_()
                }
                showWithOutput_(Q) {
                    this.showWithInputOutput(Q)
                }
                showWithInput_(Q) {
                    this.showWithInputOutput(Q)
                }
                showWithBlock_(Q) {
                    Q = Q.getLocation();
                    const oe = Q.getHeightWidth();
                    this.positionRect_(0, 0, oe.width, oe.height),
                    this.setParent_(Q),
                    this.showCurrent_()
                }
                positionCircle(Q, oe) {
                    let pe;
                    (pe = this.markerCircle) == null || pe.setAttribute("cx", `${Q}`);
                    let Ae;
                    (Ae = this.markerCircle) == null || Ae.setAttribute("cy", `${oe}`),
                    this.currentMarkerSvg = this.markerCircle
                }
                hide() {
                    super.hide(),
                    this.markerCircle && (this.markerCircle.style.display = "none")
                }
                createDomInternal_() {
                    if (super.createDomInternal_(),
                    this.markerCircle = $t(bt.CIRCLE, {
                        r: this.constants_.CURSOR_RADIUS,
                        "stroke-width": this.constants_.CURSOR_STROKE_WIDTH
                    }, this.markerSvg_),
                    this.hide(),
                    this.isCursor()) {
                        const Q = this.getBlinkProperties_();
                        $t(bt.ANIMATE, Q, this.markerCircle)
                    }
                    return this.markerSvg_
                }
                applyColour_(Q) {
                    super.applyColour_(Q);
                    let oe;
                    (oe = this.markerCircle) == null || oe.setAttribute("fill", this.colour_);
                    let pe;
                    if ((pe = this.markerCircle) == null || pe.setAttribute("stroke", this.colour_),
                    this.isCursor()) {
                        Q = this.colour_ + ";transparent;transparent;";
                        let Ae;
                        (Ae = this.markerCircle) == null || Ae.firstElementChild.setAttribute("values", Q)
                    }
                }
            }
              , hE = class extends Lc {
                constructor(Q, oe, pe) {
                    super(Q, oe, pe),
                    this.svgPathSelected = null,
                    this.outlines = new Map,
                    this.remainingOutlines = new Set,
                    this.outputShapeType = null,
                    this.constants = pe
                }
                setPath(Q) {
                    super.setPath(Q),
                    this.svgPathSelected && this.svgPathSelected.setAttribute("d", Q)
                }
                applyColour(Q) {
                    super.applyColour(Q);
                    const oe = Q.getParent();
                    Q.isShadow() && oe && this.svgPath.setAttribute("stroke", oe.style.colourTertiary);
                    for (const pe of this.outlines.values())
                        pe.setAttribute("fill", this.style.colourTertiary)
                }
                flipRTL() {
                    super.flipRTL();
                    for (const Q of this.outlines.values())
                        Q.setAttribute("transform", "scale(-1 1)")
                }
                updateSelected(Q) {
                    this.setClass_("blocklySelected", Q),
                    Q ? this.svgPathSelected || (this.svgPathSelected = this.svgPath.cloneNode(!0),
                    this.svgPathSelected.setAttribute("fill", "none"),
                    this.svgPathSelected.setAttribute("filter", "url(#" + this.constants.selectedGlowFilterId + ")"),
                    this.svgRoot.appendChild(this.svgPathSelected)) : this.svgPathSelected && (this.svgRoot.removeChild(this.svgPathSelected),
                    this.svgPathSelected = null)
                }
                updateReplacementFade(Q) {
                    this.setClass_("blocklyReplaceable", Q),
                    Q ? this.svgPath.setAttribute("filter", "url(#" + this.constants.replacementGlowFilterId + ")") : this.svgPath.removeAttribute("filter")
                }
                updateShapeForInputHighlight(Q, oe) {
                    Q = Q.getParentInput().name,
                    (Q = this.getOutlinePath(Q)) && (oe ? Q.setAttribute("filter", "url(#" + this.constants.replacementGlowFilterId + ")") : Q.removeAttribute("filter"))
                }
                beginDrawing() {
                    this.remainingOutlines.clear();
                    for (const Q of this.outlines.keys())
                        this.remainingOutlines.add(Q)
                }
                endDrawing() {
                    if (this.remainingOutlines.size)
                        for (const Q of this.remainingOutlines)
                            this.removeOutlinePath(Q);
                    this.remainingOutlines.clear()
                }
                setOutlinePath(Q, oe) {
                    Q = this.getOutlinePath(Q),
                    Q.setAttribute("d", oe),
                    Q.setAttribute("fill", this.style.colourTertiary)
                }
                getOutlinePath(Q) {
                    return this.outlines.has(Q) || this.outlines.set(Q, $t(bt.PATH, {
                        class: "blocklyOutlinePath",
                        d: ""
                    }, this.svgRoot)),
                    this.remainingOutlines.delete(Q),
                    this.outlines.get(Q)
                }
                removeOutlinePath(Q) {
                    let oe, pe;
                    (oe = this.outlines.get(Q)) == null || (pe = oe.parentNode) == null || pe.removeChild(this.outlines.get(Q)),
                    this.outlines.delete(Q)
                }
            }
              , pE = class extends dl {
                constructor(Q) {
                    super(Q)
                }
                makeConstants_() {
                    return new oE
                }
                makeRenderInfo_(Q) {
                    return new uE(this,Q)
                }
                makeDrawer_(Q, oe) {
                    return new iE(Q,oe)
                }
                makeMarkerDrawer(Q, oe) {
                    return new dE(Q,this.getConstants(),oe)
                }
                makePathObject(Q, oe) {
                    return new hE(Q,oe,this.getConstants())
                }
                getConstants() {
                    return this.constants_
                }
                shouldHighlightConnection(Q) {
                    return Q.type !== pn.INPUT_VALUE && Q.type !== pn.OUTPUT_VALUE
                }
                getConnectionPreviewMethod(Q, oe, pe) {
                    return oe.type === pn.OUTPUT_VALUE ? Q.isConnected() ? Wr.PREVIEW_TYPE.REPLACEMENT_FADE : Wr.PREVIEW_TYPE.INPUT_OUTLINE : super.getConnectionPreviewMethod(Q, oe, pe)
                }
            }
            ;
            Mi("zelos", pE);
            var us = {};
            us.BottomRow = aE,
            us.ConstantProvider = oE,
            us.Drawer = iE,
            us.MarkerSvg = dE,
            us.PathObject = hE,
            us.RenderInfo = uE,
            us.Renderer = pE,
            us.RightConnectionShape = lE,
            us.StatementInput = Uc,
            us.TopRow = cE,
            kd();
            var $r = {};
            $r.registerCleanup = Id,
            $r.registerCollapse = yd,
            $r.registerCollapseExpandBlock = Nd,
            $r.registerComment = vd,
            $r.registerDefaultOptions = kd,
            $r.registerDelete = Pd,
            $r.registerDeleteAll = Od,
            $r.registerDisable = Ld,
            $r.registerDuplicate = Cd,
            $r.registerExpand = bd,
            $r.registerHelp = Md,
            $r.registerInline = xd,
            $r.registerRedo = Sd,
            $r.registerUndo = _d;
            var $n = class extends gl {
                constructor(Q, oe, pe) {
                    super(vn.SKIP_SETUP),
                    this.clockwise = $n.CLOCKWISE,
                    this.offset = $n.OFFSET,
                    this.wrap = $n.WRAP,
                    this.round = $n.ROUND,
                    this.boundEvents = [],
                    this.symbol_ = this.gauge = this.line = null,
                    Q !== vn.SKIP_SETUP && (pe && this.configure_(pe),
                    this.setValue(Q),
                    oe && this.setValidator(oe))
                }
                configure_(Q) {
                    switch (super.configure_(Q),
                    Q.mode) {
                    case Fc.COMPASS:
                        this.clockwise = !0,
                        this.offset = 90;
                        break;
                    case Fc.PROTRACTOR:
                        this.clockwise = !1,
                        this.offset = 0
                    }
                    Q.clockwise && (this.clockwise = Q.clockwise),
                    Q.offset && (this.offset = Q.offset),
                    Q.wrap && (this.wrap = Q.wrap),
                    Q.round && (this.round = Q.round)
                }
                initView() {
                    super.initView(),
                    this.symbol_ = $t(bt.TSPAN, {}),
                    this.symbol_.appendChild(document.createTextNode("°")),
                    this.getTextElement().appendChild(this.symbol_)
                }
                render_() {
                    super.render_(),
                    this.updateGraph()
                }
                showEditor_(Q) {
                    super.showEditor_(Q, jd || cc || Wi),
                    Q = this.dropdownCreate(),
                    Oi().appendChild(Q),
                    this.sourceBlock_ instanceof Ls && Dl(this.sourceBlock_.style.colourPrimary, this.sourceBlock_.style.colourTertiary),
                    ka(this, this.dropdownDispose.bind(this)),
                    this.updateGraph()
                }
                dropdownCreate() {
                    const Q = $t(bt.SVG, {
                        xmlns: Ga,
                        "xmlns:html": Rs,
                        "xmlns:xlink": Fr,
                        version: "1.1",
                        height: 2 * $n.HALF + "px",
                        width: 2 * $n.HALF + "px"
                    });
                    Q.style.touchAction = "none";
                    const oe = $t(bt.CIRCLE, {
                        cx: $n.HALF,
                        cy: $n.HALF,
                        r: $n.RADIUS,
                        class: "blocklyAngleCircle"
                    }, Q);
                    this.gauge = $t(bt.PATH, {
                        class: "blocklyAngleGauge"
                    }, Q),
                    this.line = $t(bt.LINE, {
                        x1: $n.HALF,
                        y1: $n.HALF,
                        class: "blocklyAngleLine"
                    }, Q);
                    for (let pe = 0; 360 > pe; pe += 15)
                        $t(bt.LINE, {
                            x1: $n.HALF + $n.RADIUS,
                            y1: $n.HALF,
                            x2: $n.HALF + $n.RADIUS - (pe % 45 === 0 ? 10 : 5),
                            y2: $n.HALF,
                            class: "blocklyAngleMarks",
                            transform: "rotate(" + pe + "," + $n.HALF + "," + $n.HALF + ")"
                        }, Q);
                    return this.boundEvents.push(vt(Q, "click", this, this.hide)),
                    this.boundEvents.push(vt(oe, "pointerdown", this, this.onMouseMove_, !0)),
                    this.boundEvents.push(vt(oe, "pointermove", this, this.onMouseMove_, !0)),
                    Q
                }
                dropdownDispose() {
                    for (const Q of this.boundEvents)
                        Ct(Q);
                    this.boundEvents.length = 0,
                    this.line = this.gauge = null
                }
                hide() {
                    Ci(this),
                    Jr()
                }
                onMouseMove_(Q) {
                    var oe = this.gauge.ownerSVGElement.getBoundingClientRect();
                    const pe = Q.clientX - oe.left - $n.HALF;
                    Q = Q.clientY - oe.top - $n.HALF,
                    oe = Math.atan(-Q / pe),
                    isNaN(oe) || (oe = pu(oe),
                    0 > pe ? oe += 180 : 0 < Q && (oe += 360),
                    oe = this.clockwise ? this.offset + 360 - oe : 360 - (this.offset - oe),
                    this.displayMouseOrKeyboardValue(oe))
                }
                displayMouseOrKeyboardValue(Q) {
                    if (this.round && (Q = Math.round(Q / this.round) * this.round),
                    Q = this.wrapValue(Q),
                    Q !== this.value_) {
                        const oe = this.value_;
                        this.setEditorValue_(Q, !1),
                        this.sourceBlock_ && Ke() && this.value_ !== oe && Ye(new (gt(fo))(this.sourceBlock_,this.name || null,oe,this.value_))
                    }
                }
                updateGraph() {
                    if (this.gauge && this.line) {
                        var Q = Number(this.getText()) + this.offset
                          , oe = bi(Q % 360);
                        Q = ["M ", $n.HALF, ",", $n.HALF];
                        var pe = $n.HALF
                          , Ae = $n.HALF;
                        if (!isNaN(oe)) {
                            const Re = Number(this.clockwise)
                              , Ue = bi(this.offset)
                              , tt = Math.cos(Ue) * $n.RADIUS
                              , dt = Math.sin(Ue) * -$n.RADIUS;
                            Re && (oe = 2 * Ue - oe),
                            pe += Math.cos(oe) * $n.RADIUS,
                            Ae -= Math.sin(oe) * $n.RADIUS,
                            oe = Math.abs(Math.floor((oe - Ue) / Math.PI) % 2),
                            Re && (oe = 1 - oe),
                            Q.push(" l ", tt, ",", dt, " A ", $n.RADIUS, ",", $n.RADIUS, " 0 ", oe, " ", Re, " ", pe, ",", Ae, " z")
                        }
                        this.gauge.setAttribute("d", Q.join("")),
                        this.line.setAttribute("x2", `${pe}`),
                        this.line.setAttribute("y2", `${Ae}`)
                    }
                }
                onHtmlInputKeyDown_(Q) {
                    super.onHtmlInputKeyDown_(Q);
                    var oe = this.getSourceBlock();
                    if (!oe)
                        throw new Gn;
                    let pe = 0;
                    switch (Q.key) {
                    case "ArrowLeft":
                        pe = oe.RTL ? 1 : -1;
                        break;
                    case "ArrowRight":
                        pe = oe.RTL ? -1 : 1;
                        break;
                    case "ArrowDown":
                        pe = -1;
                        break;
                    case "ArrowUp":
                        pe = 1
                    }
                    pe && (oe = this.getValue(),
                    this.displayMouseOrKeyboardValue(oe + pe * this.round),
                    Q.preventDefault(),
                    Q.stopPropagation())
                }
                doClassValidation_(Q) {
                    return Q = Number(Q),
                    isNaN(Q) || !isFinite(Q) ? null : this.wrapValue(Q)
                }
                wrapValue(Q) {
                    return Q %= 360,
                    0 > Q && (Q += 360),
                    Q > this.wrap && (Q -= 360),
                    Q
                }
                static fromJson(Q) {
                    return new this(Q.angle,void 0,Q)
                }
            }
            ;
            $n.HALF = 50,
            $n.RADIUS = $n.HALF - 1,
            $n.CLOCKWISE = !1,
            $n.OFFSET = 0,
            $n.WRAP = 360,
            $n.ROUND = 15,
            Ur("field_angle", $n),
            $n.prototype.DEFAULT_VALUE = 0,
            Qt(`
.blocklyAngleCircle {
  stroke: #444;
  stroke-width: 1;
  fill: #ddd;
  fill-opacity: 0.8;
}

.blocklyAngleMarks {
  stroke: #444;
  stroke-width: 1;
}

.blocklyAngleGauge {
  fill: #f88;
  fill-opacity: 0.8;
  pointer-events: none;
}

.blocklyAngleLine {
  stroke: #f00;
  stroke-width: 2;
  stroke-linecap: round;
  pointer-events: none;
}
`);
            var Fc;
            (function(Q) {
                Q.COMPASS = "compass",
                Q.PROTRACTOR = "protractor"
            }
            )(Fc || (Fc = {}));
            var hi = class extends vn {
                constructor(Q, oe, pe) {
                    super(vn.SKIP_SETUP),
                    this.SERIALIZABLE = !0,
                    this.CURSOR = "default",
                    this.value_ = this.value_,
                    this.checkChar = hi.CHECK_CHAR,
                    Q !== vn.SKIP_SETUP && (pe && this.configure_(pe),
                    this.setValue(Q),
                    oe && this.setValidator(oe))
                }
                configure_(Q) {
                    super.configure_(Q),
                    Q.checkCharacter && (this.checkChar = Q.checkCharacter)
                }
                saveState() {
                    const Q = this.saveLegacyState(hi);
                    return Q !== null ? Q : this.getValueBoolean()
                }
                initView() {
                    super.initView();
                    const Q = this.getTextElement();
                    Ut(Q, "blocklyCheckbox"),
                    Q.style.display = this.value_ ? "block" : "none"
                }
                render_() {
                    this.textContent_ && (this.textContent_.nodeValue = this.getDisplayText_()),
                    this.updateSize_(this.getConstants().FIELD_CHECKBOX_X_OFFSET)
                }
                getDisplayText_() {
                    return this.checkChar
                }
                setCheckCharacter(Q) {
                    this.checkChar = Q || hi.CHECK_CHAR,
                    this.forceRerender()
                }
                showEditor_() {
                    this.setValue(!this.value_)
                }
                doClassValidation_(Q) {
                    return Q === !0 || Q === "TRUE" ? "TRUE" : Q === !1 || Q === "FALSE" ? "FALSE" : null
                }
                doValueUpdate_(Q) {
                    this.value_ = this.convertValueToBool_(Q),
                    this.textElement_ && (this.textElement_.style.display = this.value_ ? "block" : "none")
                }
                getValue() {
                    return this.value_ ? "TRUE" : "FALSE"
                }
                getValueBoolean() {
                    return this.value_
                }
                getText() {
                    return String(this.convertValueToBool_(this.value_))
                }
                convertValueToBool_(Q) {
                    return typeof Q == "string" ? Q === "TRUE" : !!Q
                }
                static fromJson(Q) {
                    return new this(Q.checked,void 0,Q)
                }
            }
            ;
            hi.CHECK_CHAR = "✓",
            Ur("field_checkbox", hi),
            hi.prototype.DEFAULT_VALUE = !1;
            var Yr = class extends vn {
                constructor(Q, oe, pe) {
                    super(vn.SKIP_SETUP),
                    this.highlightedIndex = this.picker = null,
                    this.boundEvents = [],
                    this.SERIALIZABLE = !0,
                    this.CURSOR = "default",
                    this.isDirty_ = !1,
                    this.titles = this.colours = null,
                    this.columns = 0,
                    Q !== vn.SKIP_SETUP && (pe && this.configure_(pe),
                    this.setValue(Q),
                    oe && this.setValidator(oe))
                }
                configure_(Q) {
                    super.configure_(Q),
                    Q.colourOptions && (this.colours = Q.colourOptions),
                    Q.colourTitles && (this.titles = Q.colourTitles),
                    Q.columns && (this.columns = Q.columns)
                }
                initView() {
                    this.size_ = new Yn(this.getConstants().FIELD_COLOUR_DEFAULT_WIDTH,this.getConstants().FIELD_COLOUR_DEFAULT_HEIGHT),
                    this.createBorderRect_(),
                    this.getBorderRect().style.fillOpacity = "1",
                    this.getBorderRect().setAttribute("stroke", "#fff"),
                    this.isFullBlockField() && (this.clickTarget_ = this.sourceBlock_.getSvgRoot())
                }
                isFullBlockField() {
                    const Q = this.getSourceBlock();
                    if (!Q)
                        throw new Gn;
                    const oe = this.getConstants();
                    return Q.isSimpleReporter() && !(oe == null || !oe.FIELD_COLOUR_FULL_BLOCK)
                }
                applyColour() {
                    const Q = this.getSourceBlock();
                    if (!Q)
                        throw new Gn;
                    if (this.fieldGroup_) {
                        var oe = this.borderRect_;
                        if (!oe)
                            throw Error("The border rect has not been initialized");
                        this.isFullBlockField() ? (oe.style.display = "none",
                        Q.pathObject.svgPath.setAttribute("fill", this.getValue()),
                        Q.pathObject.svgPath.setAttribute("stroke", "#fff")) : (oe.style.display = "block",
                        oe.style.fill = this.getValue())
                    }
                }
                getSize() {
                    let Q;
                    return (Q = this.getConstants()) != null && Q.FIELD_COLOUR_FULL_BLOCK && (this.render_(),
                    this.isDirty_ = !1),
                    super.getSize()
                }
                render_() {
                    super.render_();
                    const Q = this.getSourceBlock();
                    if (!Q)
                        throw new Gn;
                    Q.applyColour()
                }
                updateSize_(Q) {
                    var oe = this.getConstants();
                    this.isFullBlockField() ? (Q = 2 * (Q ?? 0),
                    oe = oe.FIELD_TEXT_HEIGHT) : (Q = oe.FIELD_COLOUR_DEFAULT_WIDTH,
                    oe = oe.FIELD_COLOUR_DEFAULT_HEIGHT),
                    this.size_.height = oe,
                    this.size_.width = Q,
                    this.positionBorderRect_()
                }
                doClassValidation_(Q) {
                    return typeof Q != "string" ? null : ho(Q)
                }
                getText() {
                    let Q = this.value_;
                    return /^#(.)\1(.)\2(.)\3$/.test(Q) && (Q = "#" + Q[1] + Q[3] + Q[5]),
                    Q
                }
                setColours(Q, oe) {
                    return this.colours = Q,
                    oe && (this.titles = oe),
                    this
                }
                setColumns(Q) {
                    return this.columns = Q,
                    this
                }
                showEditor_() {
                    this.dropdownCreate(),
                    Oi().appendChild(this.picker),
                    ka(this, this.dropdownDispose.bind(this)),
                    this.picker.focus({
                        preventScroll: !0
                    })
                }
                onClick(Q) {
                    Q = (Q = Q.target) && Q.getAttribute("data-colour"),
                    Q !== null && (this.setValue(Q),
                    Ci(this))
                }
                onKeyDown(Q) {
                    let oe = !0;
                    var pe;
                    switch (Q.key) {
                    case "ArrowUp":
                        this.moveHighlightBy(0, -1);
                        break;
                    case "ArrowDown":
                        this.moveHighlightBy(0, 1);
                        break;
                    case "ArrowLeft":
                        this.moveHighlightBy(-1, 0);
                        break;
                    case "ArrowRight":
                        this.moveHighlightBy(1, 0);
                        break;
                    case "Enter":
                        (pe = this.getHighlighted()) && (pe = pe.getAttribute("data-colour"),
                        pe !== null && this.setValue(pe)),
                        ss();
                        break;
                    default:
                        oe = !1
                    }
                    oe && Q.stopPropagation()
                }
                moveHighlightBy(Q, oe) {
                    if (this.highlightedIndex) {
                        var pe = this.colours || Yr.COLOURS
                          , Ae = this.columns || Yr.COLUMNS
                          , Re = this.highlightedIndex % Ae
                          , Ue = Math.floor(this.highlightedIndex / Ae);
                        Re += Q,
                        Ue += oe,
                        0 > Q ? 0 > Re && 0 < Ue ? (Re = Ae - 1,
                        Ue--) : 0 > Re && (Re = 0) : 0 < Q ? Re > Ae - 1 && Ue < Math.floor(pe.length / Ae) - 1 ? (Re = 0,
                        Ue++) : Re > Ae - 1 && Re-- : 0 > oe ? 0 > Ue && (Ue = 0) : 0 < oe && Ue > Math.floor(pe.length / Ae) - 1 && (Ue = Math.floor(pe.length / Ae) - 1),
                        this.setHighlightedCell(this.picker.childNodes[Ue].childNodes[Re], Ue * Ae + Re)
                    }
                }
                onMouseMove(Q) {
                    const oe = (Q = Q.target) && Number(Q.getAttribute("data-index"));
                    oe !== null && oe !== this.highlightedIndex && this.setHighlightedCell(Q, oe)
                }
                onMouseEnter() {
                    let Q;
                    (Q = this.picker) == null || Q.focus({
                        preventScroll: !0
                    })
                }
                onMouseLeave() {
                    var Q;
                    (Q = this.picker) == null || Q.blur(),
                    (Q = this.getHighlighted()) && yt(Q, "blocklyColourHighlighted")
                }
                getHighlighted() {
                    if (!this.highlightedIndex)
                        return null;
                    const Q = this.columns || Yr.COLUMNS
                      , oe = this.picker.childNodes[Math.floor(this.highlightedIndex / Q)];
                    return oe ? oe.childNodes[this.highlightedIndex % Q] : null
                }
                setHighlightedCell(Q, oe) {
                    const pe = this.getHighlighted();
                    pe && yt(pe, "blocklyColourHighlighted"),
                    Ut(Q, "blocklyColourHighlighted"),
                    this.highlightedIndex = oe,
                    (Q = Q.getAttribute("id")) && this.picker && Jn(this.picker, Xn.ACTIVEDESCENDANT, Q)
                }
                dropdownCreate() {
                    const Q = this.columns || Yr.COLUMNS
                      , oe = this.colours || Yr.COLOURS
                      , pe = this.titles || Yr.TITLES
                      , Ae = this.getValue()
                      , Re = document.createElement("table");
                    Re.className = "blocklyColourTable",
                    Re.tabIndex = 0,
                    Re.dir = "ltr",
                    rs(Re, Mr.GRID),
                    Jn(Re, Xn.EXPANDED, !0),
                    Jn(Re, Xn.ROWCOUNT, Math.floor(oe.length / Q)),
                    Jn(Re, Xn.COLCOUNT, Q);
                    let Ue;
                    for (let tt = 0; tt < oe.length; tt++) {
                        tt % Q === 0 && (Ue = document.createElement("tr"),
                        rs(Ue, Mr.ROW),
                        Re.appendChild(Ue));
                        const dt = document.createElement("td");
                        Ue.appendChild(dt),
                        dt.setAttribute("data-colour", oe[tt]),
                        dt.title = pe[tt] || oe[tt],
                        dt.id = at(),
                        dt.setAttribute("data-index", `${tt}`),
                        rs(dt, Mr.GRIDCELL),
                        Jn(dt, Xn.LABEL, oe[tt]),
                        Jn(dt, Xn.SELECTED, oe[tt] === Ae),
                        dt.style.backgroundColor = oe[tt],
                        oe[tt] === Ae && (dt.className = "blocklyColourSelected",
                        this.highlightedIndex = tt)
                    }
                    this.boundEvents.push(vt(Re, "pointerdown", this, this.onClick, !0)),
                    this.boundEvents.push(vt(Re, "pointermove", this, this.onMouseMove, !0)),
                    this.boundEvents.push(vt(Re, "pointerenter", this, this.onMouseEnter, !0)),
                    this.boundEvents.push(vt(Re, "pointerleave", this, this.onMouseLeave, !0)),
                    this.boundEvents.push(vt(Re, "keydown", this, this.onKeyDown, !1)),
                    this.picker = Re
                }
                dropdownDispose() {
                    for (const Q of this.boundEvents)
                        Ct(Q);
                    this.boundEvents.length = 0,
                    this.highlightedIndex = this.picker = null
                }
                static fromJson(Q) {
                    return new this(Q.colour,void 0,Q)
                }
            }
            ;
            Yr.COLOURS = "#ffffff #cccccc #c0c0c0 #999999 #666666 #333333 #000000 #ffcccc #ff6666 #ff0000 #cc0000 #990000 #660000 #330000 #ffcc99 #ff9966 #ff9900 #ff6600 #cc6600 #993300 #663300 #ffff99 #ffff66 #ffcc66 #ffcc33 #cc9933 #996633 #663333 #ffffcc #ffff33 #ffff00 #ffcc00 #999900 #666600 #333300 #99ff99 #66ff99 #33ff33 #33cc00 #009900 #006600 #003300 #99ffff #33ffff #66cccc #00cccc #339999 #336666 #003333 #ccffff #66ffff #33ccff #3366ff #3333ff #000099 #000066 #ccccff #9999ff #6666cc #6633ff #6600cc #333399 #330099 #ffccff #ff99ff #cc66cc #cc33cc #993399 #663366 #330033".split(" "),
            Yr.TITLES = [],
            Yr.COLUMNS = 7,
            Yr.prototype.DEFAULT_VALUE = Yr.COLOURS[0],
            Ur("field_colour", Yr),
            Qt(`
.blocklyColourTable {
  border-collapse: collapse;
  display: block;
  outline: none;
  padding: 1px;
}

.blocklyColourTable>tr>td {
  border: 0.5px solid #888;
  box-sizing: border-box;
  cursor: pointer;
  display: inline-block;
  height: 20px;
  padding: 0;
  width: 20px;
}

.blocklyColourTable>tr>td.blocklyColourHighlighted {
  border-color: #eee;
  box-shadow: 2px 2px 7px 2px rgba(0, 0, 0, 0.3);
  position: relative;
}

.blocklyColourSelected, .blocklyColourSelected:hover {
  border-color: #eee !important;
  outline: 1px solid #333;
  position: relative;
}
`);
            var mE = class extends ci {
                constructor(Q, oe, pe) {
                    super(String(Q ?? ""), oe, pe),
                    this.EDITABLE = !1,
                    this.SERIALIZABLE = !0
                }
                static fromJson(Q) {
                    return new this(rr(Q.text),void 0,Q)
                }
            }
            ;
            Ur("field_label_serializable", mE);
            var pp = class extends ha {
                constructor(Q, oe, pe) {
                    super(vn.SKIP_SETUP),
                    this.textGroup = null,
                    this.maxLines_ = 1 / 0,
                    this.isOverflowedY_ = !1,
                    Q !== vn.SKIP_SETUP && (pe && this.configure_(pe),
                    this.setValue(Q),
                    oe && this.setValidator(oe))
                }
                configure_(Q) {
                    super.configure_(Q),
                    Q.maxLines && this.setMaxLines(Q.maxLines)
                }
                toXml(Q) {
                    return Q.textContent = this.getValue().replace(/\n/g, "&#10;"),
                    Q
                }
                fromXml(Q) {
                    this.setValue(Q.textContent.replace(/&#10;/g, `
`))
                }
                saveState() {
                    const Q = this.saveLegacyState(pp);
                    return Q !== null ? Q : this.getValue()
                }
                loadState(Q) {
                    this.loadLegacyState(vn, Q) || this.setValue(Q)
                }
                initView() {
                    this.createBorderRect_(),
                    this.textGroup = $t(bt.G, {
                        class: "blocklyEditableText"
                    }, this.fieldGroup_)
                }
                getDisplayText_() {
                    const Q = this.getSourceBlock();
                    if (!Q)
                        throw new Gn;
                    let oe = this.getText();
                    if (!oe)
                        return vn.NBSP;
                    const pe = oe.split(`
`);
                    oe = "";
                    const Ae = this.isOverflowedY_ ? this.maxLines_ : pe.length;
                    for (let Re = 0; Re < Ae; Re++) {
                        let Ue = pe[Re];
                        Ue.length > this.maxDisplayLength ? Ue = Ue.substring(0, this.maxDisplayLength - 4) + "..." : this.isOverflowedY_ && Re === Ae - 1 && (Ue = Ue.substring(0, Ue.length - 3) + "..."),
                        Ue = Ue.replace(/\s/g, vn.NBSP),
                        oe += Ue,
                        Re !== Ae - 1 && (oe += `
`)
                    }
                    return Q.RTL && (oe += "‏"),
                    oe
                }
                doValueUpdate_(Q) {
                    super.doValueUpdate_(Q),
                    this.value_ !== null && (this.isOverflowedY_ = this.value_.split(`
`).length > this.maxLines_)
                }
                render_() {
                    var Q = this.getSourceBlock();
                    if (!Q)
                        throw new Gn;
                    for (var oe, pe = this.textGroup; oe = pe.firstChild; )
                        pe.removeChild(oe);
                    oe = this.getDisplayText_().split(`
`);
                    let Ae = 0;
                    for (let Re = 0; Re < oe.length; Re++) {
                        const Ue = this.getConstants().FIELD_TEXT_HEIGHT + this.getConstants().FIELD_BORDER_RECT_Y_PADDING;
                        $t(bt.TEXT, {
                            class: "blocklyText blocklyMultilineText",
                            x: this.getConstants().FIELD_BORDER_RECT_X_PADDING,
                            y: Ae + this.getConstants().FIELD_BORDER_RECT_Y_PADDING,
                            dy: this.getConstants().FIELD_TEXT_BASELINE
                        }, pe).appendChild(document.createTextNode(oe[Re])),
                        Ae += Ue
                    }
                    this.isBeingEdited_ && (pe = this.htmlInput_,
                    this.isOverflowedY_ ? Ut(pe, "blocklyHtmlTextAreaInputOverflowedY") : yt(pe, "blocklyHtmlTextAreaInputOverflowedY")),
                    this.updateSize_(),
                    this.isBeingEdited_ && (Q.RTL ? setTimeout(this.resizeEditor_.bind(this), 0) : this.resizeEditor_(),
                    Q = this.htmlInput_,
                    this.isTextValid_ ? (yt(Q, "blocklyInvalidInput"),
                    Jn(Q, Xn.INVALID, !1)) : (Ut(Q, "blocklyInvalidInput"),
                    Jn(Q, Xn.INVALID, !0)))
                }
                updateSize_() {
                    var Q = this.textGroup.childNodes;
                    const oe = this.getConstants().FIELD_TEXT_FONTSIZE
                      , pe = this.getConstants().FIELD_TEXT_FONTWEIGHT
                      , Ae = this.getConstants().FIELD_TEXT_FONTFAMILY;
                    let Re = 0
                      , Ue = 0;
                    for (var tt = 0; tt < Q.length; tt++) {
                        var dt = Ft(Q[tt], oe, pe, Ae);
                        dt > Re && (Re = dt),
                        Ue += this.getConstants().FIELD_TEXT_HEIGHT + (0 < tt ? this.getConstants().FIELD_BORDER_RECT_Y_PADDING : 0)
                    }
                    if (this.isBeingEdited_) {
                        for (Q = String(this.value_).split(`
`),
                        tt = $t(bt.TEXT, {
                            class: "blocklyText blocklyMultilineText"
                        }),
                        dt = 0; dt < Q.length; dt++) {
                            Q[dt].length > this.maxDisplayLength && (Q[dt] = Q[dt].substring(0, this.maxDisplayLength)),
                            tt.textContent = Q[dt];
                            const wt = Ft(tt, oe, pe, Ae);
                            wt > Re && (Re = wt)
                        }
                        Re += this.htmlInput_.offsetWidth - this.htmlInput_.clientWidth
                    }
                    this.borderRect_ && (Ue += 2 * this.getConstants().FIELD_BORDER_RECT_Y_PADDING,
                    Re += 2 * this.getConstants().FIELD_BORDER_RECT_X_PADDING,
                    this.borderRect_.setAttribute("width", `${Re}`),
                    this.borderRect_.setAttribute("height", `${Ue}`)),
                    this.size_.width = Re,
                    this.size_.height = Ue,
                    this.positionBorderRect_()
                }
                showEditor_(Q, oe) {
                    super.showEditor_(Q, oe),
                    this.forceRerender()
                }
                widgetCreate_() {
                    const Q = Fo()
                      , oe = this.workspace_.getScale()
                      , pe = document.createElement("textarea");
                    pe.className = "blocklyHtmlInput blocklyHtmlTextAreaInput",
                    pe.setAttribute("spellcheck", String(this.spellcheck_));
                    var Ae = this.getConstants().FIELD_TEXT_FONTSIZE * oe + "pt";
                    Q.style.fontSize = Ae,
                    pe.style.fontSize = Ae,
                    pe.style.borderRadius = ha.BORDERRADIUS * oe + "px",
                    Ae = this.getConstants().FIELD_BORDER_RECT_X_PADDING * oe;
                    const Re = this.getConstants().FIELD_BORDER_RECT_Y_PADDING * oe / 2;
                    return pe.style.padding = Re + "px " + Ae + "px " + Re + "px " + Ae + "px",
                    Ae = this.getConstants().FIELD_TEXT_HEIGHT + this.getConstants().FIELD_BORDER_RECT_Y_PADDING,
                    pe.style.lineHeight = Ae * oe + "px",
                    Q.appendChild(pe),
                    pe.value = pe.defaultValue = this.getEditorText_(this.value_),
                    pe.setAttribute("data-untyped-default-value", String(this.value_)),
                    pe.setAttribute("data-old-value", ""),
                    Vd ? setTimeout(this.resizeEditor_.bind(this), 0) : this.resizeEditor_(),
                    this.bindInputEvents_(pe),
                    pe
                }
                setMaxLines(Q) {
                    typeof Q == "number" && 0 < Q && Q !== this.maxLines_ && (this.maxLines_ = Q,
                    this.forceRerender())
                }
                getMaxLines() {
                    return this.maxLines_
                }
                onHtmlInputKeyDown_(Q) {
                    Q.key !== "Enter" && super.onHtmlInputKeyDown_(Q)
                }
                static fromJson(Q) {
                    return new this(rr(Q.text),void 0,Q)
                }
            }
            ;
            Ur("field_multilinetext", pp),
            Qt(`
.blocklyHtmlTextAreaInput {
  font-family: monospace;
  resize: none;
  overflow: hidden;
  height: 100%;
  text-align: left;
}

.blocklyHtmlTextAreaInputOverflowedY {
  overflow-y: scroll;
}
`);
            var mp = class extends gl {
                constructor(Q, oe, pe, Ae, Re, Ue) {
                    super(vn.SKIP_SETUP),
                    this.min_ = -1 / 0,
                    this.max_ = 1 / 0,
                    this.precision_ = 0,
                    this.decimalPlaces = null,
                    this.spellcheck_ = !1,
                    Q !== vn.SKIP_SETUP && (Ue ? this.configure_(Ue) : this.setConstraints(oe, pe, Ae),
                    this.setValue(Q),
                    Re && this.setValidator(Re))
                }
                configure_(Q) {
                    super.configure_(Q),
                    this.setMinInternal(Q.min),
                    this.setMaxInternal(Q.max),
                    this.setPrecisionInternal(Q.precision)
                }
                setConstraints(Q, oe, pe) {
                    this.setMinInternal(Q),
                    this.setMaxInternal(oe),
                    this.setPrecisionInternal(pe),
                    this.setValue(this.getValue())
                }
                setMin(Q) {
                    this.setMinInternal(Q),
                    this.setValue(this.getValue())
                }
                setMinInternal(Q) {
                    Q == null ? this.min_ = -1 / 0 : (Q = Number(Q),
                    isNaN(Q) || (this.min_ = Q))
                }
                getMin() {
                    return this.min_
                }
                setMax(Q) {
                    this.setMaxInternal(Q),
                    this.setValue(this.getValue())
                }
                setMaxInternal(Q) {
                    Q == null ? this.max_ = 1 / 0 : (Q = Number(Q),
                    isNaN(Q) || (this.max_ = Q))
                }
                getMax() {
                    return this.max_
                }
                setPrecision(Q) {
                    this.setPrecisionInternal(Q),
                    this.setValue(this.getValue())
                }
                setPrecisionInternal(Q) {
                    this.precision_ = Number(Q) || 0;
                    let oe = String(this.precision_);
                    oe.indexOf("e") !== -1 && (oe = this.precision_.toLocaleString("en-US", {
                        maximumFractionDigits: 20
                    }));
                    const pe = oe.indexOf(".");
                    this.decimalPlaces = pe === -1 ? Q ? 0 : null : oe.length - pe - 1
                }
                getPrecision() {
                    return this.precision_
                }
                doClassValidation_(Q) {
                    return Q === null || (Q = `${Q}`.replace(/O/gi, "0"),
                    Q = Q.replace(/,/g, ""),
                    Q = Q.replace(/infinity/i, "Infinity"),
                    Q = Number(Q || 0),
                    isNaN(Q)) ? null : (Q = Math.min(Math.max(Q, this.min_), this.max_),
                    this.precision_ && isFinite(Q) && (Q = Math.round(Q / this.precision_) * this.precision_),
                    this.decimalPlaces !== null && (Q = Number(Q.toFixed(this.decimalPlaces))),
                    Q)
                }
                widgetCreate_() {
                    const Q = super.widgetCreate_();
                    return -1 / 0 < this.min_ && (Q.min = `${this.min_}`,
                    Jn(Q, Xn.VALUEMIN, this.min_)),
                    1 / 0 > this.max_ && (Q.max = `${this.max_}`,
                    Jn(Q, Xn.VALUEMAX, this.max_)),
                    Q
                }
                static fromJson(Q) {
                    return new this(Q.value,void 0,void 0,void 0,void 0,Q)
                }
            }
            ;
            Ur("field_number", mp),
            mp.prototype.DEFAULT_VALUE = 0;
            var El = class extends Cs {
                constructor(Q, oe, pe, Ae, Re) {
                    super(vn.SKIP_SETUP),
                    this.defaultType = "",
                    this.variableTypes = [],
                    this.variable = null,
                    this.SERIALIZABLE = !0,
                    this.menuGenerator_ = El.dropdownCreate,
                    this.defaultVariableName = typeof Q == "string" ? Q : "",
                    this.size_ = new Yn(0,0),
                    Q !== vn.SKIP_SETUP && (Re ? this.configure_(Re) : this.setTypes(pe, Ae),
                    oe && this.setValidator(oe))
                }
                configure_(Q) {
                    super.configure_(Q),
                    this.setTypes(Q.variableTypes, Q.defaultType)
                }
                initModel() {
                    var Q = this.getSourceBlock();
                    if (!Q)
                        throw new Gn;
                    this.variable || (Q = J.getOrCreateVariablePackage$$module$build$src$core$variables(Q.workspace, null, this.defaultVariableName, this.defaultType),
                    this.doValueUpdate_(Q.getId()))
                }
                shouldAddBorderRect_() {
                    const Q = this.getSourceBlock();
                    if (!Q)
                        throw new Gn;
                    return super.shouldAddBorderRect_() && (!this.getConstants().FIELD_DROPDOWN_NO_BORDER_RECT_SHADOW || Q.type !== "variables_get")
                }
                fromXml(Q) {
                    var oe = this.getSourceBlock();
                    if (!oe)
                        throw new Gn;
                    const pe = Q.getAttribute("id")
                      , Ae = Q.textContent
                      , Re = Q.getAttribute("variabletype") || Q.getAttribute("variableType") || "";
                    if (oe = J.getOrCreateVariablePackage$$module$build$src$core$variables(oe.workspace, pe, Ae, Re),
                    Re !== null && Re !== oe.type)
                        throw Error("Serialized variable type with id '" + oe.getId() + "' had type " + oe.type + ", and does not match variable field that references it: " + Es(Q) + ".");
                    this.setValue(oe.getId())
                }
                toXml(Q) {
                    return this.initModel(),
                    Q.id = this.variable.getId(),
                    Q.textContent = this.variable.name,
                    this.variable.type && Q.setAttribute("variabletype", this.variable.type),
                    Q
                }
                saveState(Q) {
                    var oe = this.saveLegacyState(El);
                    return oe !== null || (this.initModel(),
                    oe = {
                        id: this.variable.getId()
                    },
                    Q && (oe.name = this.variable.name,
                    oe.type = this.variable.type)),
                    oe
                }
                loadState(Q) {
                    const oe = this.getSourceBlock();
                    if (!oe)
                        throw new Gn;
                    this.loadLegacyState(El, Q) || (Q = J.getOrCreateVariablePackage$$module$build$src$core$variables(oe.workspace, Q.id || null, Q.name, Q.type || ""),
                    this.setValue(Q.getId()))
                }
                setSourceBlock(Q) {
                    if (Q.isShadow())
                        throw Error("Variable fields are not allowed to exist on shadow blocks.");
                    super.setSourceBlock(Q)
                }
                getValue() {
                    return this.variable ? this.variable.getId() : null
                }
                getText() {
                    return this.variable ? this.variable.name : ""
                }
                getVariable() {
                    return this.variable
                }
                getValidator() {
                    return this.variable ? this.validator_ : null
                }
                doClassValidation_(Q) {
                    if (Q === null)
                        return null;
                    var oe = this.getSourceBlock();
                    if (!oe)
                        throw new Gn;
                    return oe = J.getVariable$$module$build$src$core$variables(oe.workspace, Q),
                    oe ? (oe = oe.type,
                    this.typeIsAllowed(oe) ? Q : (console.warn("Variable type doesn't match this field!  Type was " + oe),
                    null)) : (console.warn("Variable id doesn't point to a real variable! ID was " + Q),
                    null)
                }
                doValueUpdate_(Q) {
                    const oe = this.getSourceBlock();
                    if (!oe)
                        throw new Gn;
                    this.variable = J.getVariable$$module$build$src$core$variables(oe.workspace, Q),
                    super.doValueUpdate_(Q)
                }
                typeIsAllowed(Q) {
                    const oe = this.getVariableTypes();
                    if (!oe)
                        return !0;
                    for (let pe = 0; pe < oe.length; pe++)
                        if (Q === oe[pe])
                            return !0;
                    return !1
                }
                getVariableTypes() {
                    var Q = this.variableTypes;
                    if (Q === null && this.sourceBlock_ && !this.sourceBlock_.isDeadOrDying())
                        return this.sourceBlock_.workspace.getVariableTypes();
                    if (Q = Q || [""],
                    Q.length === 0)
                        throw Q = this.getText(),
                        Error("'variableTypes' of field variable " + Q + " was an empty list");
                    return Q
                }
                setTypes(Q=null, oe="") {
                    if (Array.isArray(Q)) {
                        let pe = !1;
                        for (let Ae = 0; Ae < Q.length; Ae++)
                            Q[Ae] === oe && (pe = !0);
                        if (!pe)
                            throw Error("Invalid default type '" + oe + "' in the definition of a FieldVariable")
                    } else if (Q !== null)
                        throw Error("'variableTypes' was not an array in the definition of a FieldVariable");
                    this.defaultType = oe,
                    this.variableTypes = Q
                }
                refreshVariableName() {
                    this.forceRerender()
                }
                onItemSelected_(Q, oe) {
                    if (Q = oe.getValue(),
                    this.sourceBlock_ && !this.sourceBlock_.isDeadOrDying()) {
                        if (Q === Rh) {
                            J.renameVariable$$module$build$src$core$variables(this.sourceBlock_.workspace, this.variable);
                            return
                        }
                        if (Q === yh) {
                            this.sourceBlock_.workspace.deleteVariableById(this.variable.getId());
                            return
                        }
                    }
                    this.setValue(Q)
                }
                referencesVariables() {
                    return !0
                }
                static fromJson(Q) {
                    return new this(rr(Q.variable),void 0,void 0,void 0,Q)
                }
                static dropdownCreate() {
                    if (!this.variable)
                        throw Error("Tried to call dropdownCreate on a variable field with no variable selected.");
                    const Q = this.getText();
                    let oe = [];
                    if (this.sourceBlock_ && !this.sourceBlock_.isDeadOrDying())
                        for (var pe = this.getVariableTypes(), Ae = 0; Ae < pe.length; Ae++) {
                            const Re = this.sourceBlock_.workspace.getVariablesOfType(pe[Ae]);
                            oe = oe.concat(Re)
                        }
                    for (oe.sort(Xa.compareByName),
                    pe = [],
                    Ae = 0; Ae < oe.length; Ae++)
                        pe[Ae] = [oe[Ae].name, oe[Ae].getId()];
                    return pe.push([J.Msg$$module$build$src$core$msg.RENAME_VARIABLE, Rh]),
                    J.Msg$$module$build$src$core$msg.DELETE_VARIABLE && pe.push([J.Msg$$module$build$src$core$msg.DELETE_VARIABLE.replace("%1", Q), yh]),
                    pe
                }
            }
            ;
            Ur("field_variable", El);
            var ds = class {
                constructor(Q, oe, pe, Ae) {
                    this.workspace = Q,
                    this.targetWorkspace = oe,
                    this.isLabel_ = Ae,
                    this.onMouseUpWrapper = null,
                    this.height = this.width = 0,
                    this.svgText = this.svgGroup = null,
                    this.text = pe.text,
                    this.position = new Zt(0,0),
                    this.callbackKey = pe.callbackKey || pe.callbackkey,
                    this.cssClass = pe["web-class"] || null,
                    this.info = pe
                }
                createDom() {
                    var Q = this.isLabel_ ? "blocklyFlyoutLabel" : "blocklyFlyoutButton";
                    this.cssClass && (Q += " " + this.cssClass),
                    this.svgGroup = $t(bt.G, {
                        class: Q
                    }, this.workspace.getCanvas());
                    let oe;
                    this.isLabel_ || (oe = $t(bt.RECT, {
                        class: "blocklyFlyoutButtonShadow",
                        rx: ds.BORDER_RADIUS,
                        ry: ds.BORDER_RADIUS,
                        x: 1,
                        y: 1
                    }, this.svgGroup)),
                    Q = $t(bt.RECT, {
                        class: this.isLabel_ ? "blocklyFlyoutLabelBackground" : "blocklyFlyoutButtonBackground",
                        rx: ds.BORDER_RADIUS,
                        ry: ds.BORDER_RADIUS
                    }, this.svgGroup);
                    const pe = $t(bt.TEXT, {
                        class: this.isLabel_ ? "blocklyFlyoutLabelText" : "blocklyText",
                        x: 0,
                        y: 0,
                        "text-anchor": "middle"
                    }, this.svgGroup);
                    var Ae = rr(this.text);
                    this.workspace.RTL && (Ae += "‏"),
                    pe.textContent = Ae,
                    this.isLabel_ && (this.svgText = pe,
                    this.workspace.getThemeManager().subscribe(this.svgText, "flyoutForegroundColour", "fill"));
                    const Re = xn(pe, "fontSize")
                      , Ue = xn(pe, "fontWeight")
                      , tt = xn(pe, "fontFamily");
                    if (this.width = an(pe, Re, Ue, tt),
                    Ae = Sn(Ae, Re, Ue, tt),
                    this.height = Ae.height,
                    !this.isLabel_) {
                        this.width += 2 * ds.TEXT_MARGIN_X,
                        this.height += 2 * ds.TEXT_MARGIN_Y;
                        let dt;
                        (dt = oe) == null || dt.setAttribute("width", String(this.width));
                        let wt;
                        (wt = oe) == null || wt.setAttribute("height", String(this.height))
                    }
                    return Q.setAttribute("width", String(this.width)),
                    Q.setAttribute("height", String(this.height)),
                    pe.setAttribute("x", String(this.width / 2)),
                    pe.setAttribute("y", String(this.height / 2 - Ae.height / 2 + Ae.baseline)),
                    this.updateTransform(),
                    this.onMouseUpWrapper = vt(this.svgGroup, "pointerup", this, this.onMouseUp),
                    this.svgGroup
                }
                show() {
                    this.updateTransform(),
                    this.svgGroup.setAttribute("display", "block")
                }
                updateTransform() {
                    this.svgGroup.setAttribute("transform", "translate(" + this.position.x + "," + this.position.y + ")")
                }
                moveTo(Q, oe) {
                    this.position.x = Q,
                    this.position.y = oe,
                    this.updateTransform()
                }
                isLabel() {
                    return this.isLabel_
                }
                getPosition() {
                    return this.position
                }
                getButtonText() {
                    return this.text
                }
                getTargetWorkspace() {
                    return this.targetWorkspace
                }
                dispose() {
                    this.onMouseUpWrapper && Ct(this.onMouseUpWrapper),
                    this.svgGroup && Bt(this.svgGroup),
                    this.svgText && this.workspace.getThemeManager().unsubscribe(this.svgText)
                }
                onMouseUp(Q) {
                    (Q = this.targetWorkspace.getGesture(Q)) && Q.cancel(),
                    this.isLabel_ && this.callbackKey ? console.warn("Labels should not have callbacks. Label text: " + this.text) : this.isLabel_ || this.callbackKey && this.targetWorkspace.getButtonCallback(this.callbackKey) ? this.isLabel_ || (Q = this.targetWorkspace.getButtonCallback(this.callbackKey)) && Q(this) : console.warn("Buttons should have callbacks. Button text: " + this.text)
                }
            }
            ;
            ds.TEXT_MARGIN_X = 5,
            ds.TEXT_MARGIN_Y = 2,
            ds.BORDER_RADIUS = 4,
            Qt(`
.blocklyFlyoutButton {
  fill: #888;
  cursor: default;
}

.blocklyFlyoutButtonShadow {
  fill: #666;
}

.blocklyFlyoutButton:hover {
  fill: #aaa;
}

.blocklyFlyoutLabel {
  cursor: default;
}

.blocklyFlyoutLabelBackground {
  opacity: 0;
}
`);
            var fE = class extends np {
                constructor(Q, oe) {
                    super(Q),
                    this.flyout_ = oe
                }
                getBoundingBox_() {
                    let Q;
                    try {
                        Q = this.workspace_.getCanvas().getBBox()
                    } catch {
                        Q = {
                            height: 0,
                            y: 0,
                            width: 0,
                            x: 0
                        }
                    }
                    return Q
                }
                getContentMetrics(Q) {
                    const oe = this.getBoundingBox_();
                    return Q = Q ? 1 : this.workspace_.scale,
                    {
                        height: oe.height * Q,
                        width: oe.width * Q,
                        top: oe.y * Q,
                        left: oe.x * Q
                    }
                }
                getScrollMetrics(Q, oe, pe) {
                    return oe = pe || this.getContentMetrics(),
                    pe = this.flyout_.MARGIN * this.workspace_.scale,
                    Q = Q ? this.workspace_.scale : 1,
                    {
                        height: (oe.height + 2 * pe) / Q,
                        width: (oe.width + oe.left + pe) / Q,
                        top: 0,
                        left: 0
                    }
                }
            }
            , pa;
            (function(Q) {
                Q.BLOCK = "block",
                Q.BUTTON = "button"
            }
            )(pa || (pa = {}));
            var Hc = class extends Mc {
                constructor(Q) {
                    super(),
                    this.horizontalLayout = !1,
                    this.boundEvents = [],
                    this.filterWrapper = this.reflowWrapper = null,
                    this.mats = [],
                    this.buttons_ = [],
                    this.listeners = [],
                    this.permanentlyDisabled = [],
                    this.recycledBlocks = [],
                    this.autoClose = !0,
                    this.isVisible_ = !1,
                    this.containerVisible = !0,
                    this.CORNER_RADIUS = 8,
                    this.SCROLLBAR_MARGIN = 2.5,
                    this.height_ = this.width_ = 0,
                    this.dragAngleRange_ = 70,
                    this.svgGroup_ = this.svgBackground_ = null,
                    Q.setMetrics = this.setMetrics_.bind(this),
                    this.workspace_ = new cs(Q),
                    this.workspace_.setMetricsManager(new fE(this.workspace_,this)),
                    this.workspace_.internalIsFlyout = !0,
                    this.workspace_.setVisible(this.isVisible_),
                    this.id = rt(),
                    this.RTL = !!Q.RTL,
                    this.toolboxPosition_ = Q.toolboxPosition,
                    this.tabWidth_ = this.workspace_.getRenderer().getConstants().TAB_WIDTH,
                    this.rectMap_ = new WeakMap,
                    this.MARGIN = this.CORNER_RADIUS,
                    this.GAP_X = 3 * this.MARGIN,
                    this.GAP_Y = 3 * this.MARGIN
                }
                createDom(Q) {
                    return this.svgGroup_ = $t(Q, {
                        class: "blocklyFlyout"
                    }),
                    this.svgGroup_.style.display = "none",
                    this.svgBackground_ = $t(bt.PATH, {
                        class: "blocklyFlyoutBackground"
                    }, this.svgGroup_),
                    this.svgGroup_.appendChild(this.workspace_.createDom()),
                    this.workspace_.getThemeManager().subscribe(this.svgBackground_, "flyoutBackgroundColour", "fill"),
                    this.workspace_.getThemeManager().subscribe(this.svgBackground_, "flyoutOpacity", "fill-opacity"),
                    this.svgGroup_
                }
                init(Q) {
                    this.targetWorkspace = Q,
                    this.workspace_.targetWorkspace = Q,
                    this.workspace_.scrollbar = new tp(this.workspace_,this.horizontalLayout,!this.horizontalLayout,"blocklyFlyoutScrollbar",this.SCROLLBAR_MARGIN),
                    this.hide(),
                    this.boundEvents.push(vt(this.svgGroup_, "wheel", this, this.wheel_)),
                    this.filterWrapper = this.filterForCapacity.bind(this),
                    this.targetWorkspace.addChangeListener(this.filterWrapper),
                    this.boundEvents.push(vt(this.svgBackground_, "pointerdown", this, this.onMouseDown)),
                    this.workspace_.getGesture = this.targetWorkspace.getGesture.bind(this.targetWorkspace),
                    this.workspace_.setVariableMap(this.targetWorkspace.getVariableMap()),
                    this.workspace_.createPotentialVariableMap(),
                    Q.getComponentManager().addComponent({
                        component: this,
                        weight: 1,
                        capabilities: [dr.Capability.AUTOHIDEABLE, dr.Capability.DELETE_AREA, dr.Capability.DRAG_TARGET]
                    })
                }
                dispose() {
                    this.hide(),
                    this.targetWorkspace.getComponentManager().removeComponent(this.id);
                    for (const Q of this.boundEvents)
                        Ct(Q);
                    this.boundEvents.length = 0,
                    this.filterWrapper && this.targetWorkspace.removeChangeListener(this.filterWrapper),
                    this.workspace_ && (this.workspace_.getThemeManager().unsubscribe(this.svgBackground_),
                    this.workspace_.dispose()),
                    this.svgGroup_ && Bt(this.svgGroup_)
                }
                getWidth() {
                    return this.width_
                }
                getHeight() {
                    return this.height_
                }
                getFlyoutScale() {
                    return this.targetWorkspace.scale
                }
                getWorkspace() {
                    return this.workspace_
                }
                setAutoClose(Q) {
                    this.autoClose = Q,
                    this.targetWorkspace.recordDragTargets(),
                    this.targetWorkspace.resizeContents()
                }
                autoHide(Q) {
                    !Q && this.targetWorkspace.getFlyout(!0) === this && this.autoClose && this.hide()
                }
                isVisible() {
                    return this.isVisible_
                }
                setVisible(Q) {
                    const oe = Q !== this.isVisible();
                    this.isVisible_ = Q,
                    oe && (this.autoClose || this.targetWorkspace.recordDragTargets(),
                    this.updateDisplay())
                }
                setContainerVisible(Q) {
                    const oe = Q !== this.containerVisible;
                    this.containerVisible = Q,
                    oe && this.updateDisplay()
                }
                updateDisplay() {
                    let Q;
                    Q = this.containerVisible ? this.isVisible() : !1,
                    this.svgGroup_ && (this.svgGroup_.style.display = Q ? "block" : "none");
                    let oe;
                    (oe = this.workspace_.scrollbar) == null || oe.setContainerVisible(Q)
                }
                positionAt_(Q, oe, pe, Ae) {
                    let Re;
                    (Re = this.svgGroup_) == null || Re.setAttribute("width", `${Q}`);
                    let Ue;
                    (Ue = this.svgGroup_) == null || Ue.setAttribute("height", `${oe}`),
                    this.workspace_.setCachedParentSvgSize(Q, oe),
                    this.svgGroup_ && Ge(this.svgGroup_, "translate(" + pe + "px," + Ae + "px)"),
                    (Q = this.workspace_.scrollbar) && (Q.setOrigin(pe, Ae),
                    Q.resize(),
                    Q.hScroll && Q.hScroll.setPosition(Q.hScroll.position.x, Q.hScroll.position.y),
                    Q.vScroll && Q.vScroll.setPosition(Q.vScroll.position.x, Q.vScroll.position.y))
                }
                hide() {
                    if (this.isVisible()) {
                        this.setVisible(!1);
                        for (const Q of this.listeners)
                            Ct(Q);
                        this.listeners.length = 0,
                        this.reflowWrapper && (this.workspace_.removeChangeListener(this.reflowWrapper),
                        this.reflowWrapper = null)
                    }
                }
                show(Q) {
                    this.workspace_.setResizesEnabled(!1),
                    this.hide(),
                    this.clearOldBlocks(),
                    typeof Q == "string" && (Q = this.getDynamicCategoryContents(Q)),
                    this.setVisible(!0),
                    Q = fn(Q),
                    Q = this.createFlyoutInfo(Q),
                    gs(),
                    this.layout_(Q.contents, Q.gaps),
                    this.horizontalLayout ? this.height_ = 0 : this.width_ = 0,
                    this.workspace_.setResizesEnabled(!0),
                    this.reflow(),
                    this.filterForCapacity(),
                    this.position(),
                    this.reflowWrapper = this.reflow.bind(this),
                    this.workspace_.addChangeListener(this.reflowWrapper),
                    this.emptyRecycledBlocks()
                }
                createFlyoutInfo(Q) {
                    const oe = []
                      , pe = [];
                    this.permanentlyDisabled.length = 0;
                    const Ae = this.horizontalLayout ? this.GAP_X : this.GAP_Y;
                    for (const Re of Q) {
                        if ("custom"in Re) {
                            Q = this.getDynamicCategoryContents(Re.custom),
                            Q = fn(Q);
                            const {contents: Ue, gaps: tt} = this.createFlyoutInfo(Q);
                            oe.push(...Ue),
                            pe.push(...tt)
                        }
                        switch (Re.kind.toUpperCase()) {
                        case "BLOCK":
                            Q = Re;
                            const Ue = this.createFlyoutBlock(Q);
                            oe.push({
                                type: pa.BLOCK,
                                block: Ue
                            }),
                            this.addBlockGap(Q, pe, Ae);
                            break;
                        case "SEP":
                            this.addSeparatorGap(Re, pe, Ae);
                            break;
                        case "LABEL":
                            Q = this.createButton(Re, !0),
                            oe.push({
                                type: pa.BUTTON,
                                button: Q
                            }),
                            pe.push(Ae);
                            break;
                        case "BUTTON":
                            Q = this.createButton(Re, !1),
                            oe.push({
                                type: pa.BUTTON,
                                button: Q
                            }),
                            pe.push(Ae)
                        }
                    }
                    return {
                        contents: oe,
                        gaps: pe
                    }
                }
                getDynamicCategoryContents(Q) {
                    if (Q = this.workspace_.targetWorkspace.getToolboxCategoryCallback(Q),
                    typeof Q != "function")
                        throw TypeError("Couldn't find a callback function when opening a toolbox category.");
                    return Q(this.workspace_.targetWorkspace)
                }
                createButton(Q, oe) {
                    return new ds(this.workspace_,this.targetWorkspace,Q,oe)
                }
                createFlyoutBlock(Q) {
                    let oe;
                    return Q.blockxml ? (Q = typeof Q.blockxml == "string" ? J.textToDom$$module$build$src$core$utils$xml(Q.blockxml) : Q.blockxml,
                    (oe = this.getRecycledBlock(Q.getAttribute("type"))) || (oe = lo(Q, this.workspace_))) : (oe = this.getRecycledBlock(Q.type),
                    oe || (Q.enabled === void 0 && (Q.enabled = Q.disabled !== "true" && Q.disabled !== !0),
                    oe = Ri(Q, this.workspace_))),
                    oe.isEnabled() || this.permanentlyDisabled.push(oe),
                    oe
                }
                getRecycledBlock(Q) {
                    let oe = -1;
                    for (let pe = 0; pe < this.recycledBlocks.length; pe++)
                        if (this.recycledBlocks[pe].type === Q) {
                            oe = pe;
                            break
                        }
                    return oe === -1 ? void 0 : this.recycledBlocks.splice(oe, 1)[0]
                }
                addBlockGap(Q, oe, pe) {
                    let Ae;
                    Q.gap ? Ae = parseInt(String(Q.gap)) : Q.blockxml && (Q = typeof Q.blockxml == "string" ? J.textToDom$$module$build$src$core$utils$xml(Q.blockxml) : Q.blockxml,
                    Ae = parseInt(Q.getAttribute("gap"))),
                    oe.push(!Ae || isNaN(Ae) ? pe : Ae)
                }
                addSeparatorGap(Q, oe, pe) {
                    Q = parseInt(String(Q.gap)),
                    !isNaN(Q) && 0 < oe.length ? oe[oe.length - 1] = Q : oe.push(pe)
                }
                clearOldBlocks() {
                    var Q = this.workspace_.getTopBlocks(!1);
                    for (let pe = 0, Ae; Ae = Q[pe]; pe++)
                        this.blockIsRecyclable_(Ae) ? this.recycleBlock(Ae) : Ae.dispose(!1, !1);
                    for (Q = 0; Q < this.mats.length; Q++) {
                        const pe = this.mats[Q];
                        pe && (Ul(pe),
                        Bt(pe))
                    }
                    this.mats.length = 0;
                    for (let pe = 0, Ae; Ae = this.buttons_[pe]; pe++)
                        Ae.dispose();
                    this.buttons_.length = 0;
                    let oe;
                    (oe = this.workspace_.getPotentialVariableMap()) == null || oe.clear()
                }
                emptyRecycledBlocks() {
                    for (let Q = 0; Q < this.recycledBlocks.length; Q++)
                        this.recycledBlocks[Q].dispose();
                    this.recycledBlocks = []
                }
                blockIsRecyclable_(Q) {
                    return !1
                }
                recycleBlock(Q) {
                    const oe = Q.getRelativeToSurfaceXY();
                    Q.moveBy(-oe.x, -oe.y),
                    this.recycledBlocks.push(Q)
                }
                addBlockListeners_(Q, oe, pe) {
                    this.listeners.push(vt(Q, "pointerdown", null, this.blockMouseDown(oe))),
                    this.listeners.push(vt(pe, "pointerdown", null, this.blockMouseDown(oe))),
                    this.listeners.push(Jt(Q, "pointerenter", oe, oe.addSelect)),
                    this.listeners.push(Jt(Q, "pointerleave", oe, oe.removeSelect)),
                    this.listeners.push(Jt(pe, "pointerenter", oe, oe.addSelect)),
                    this.listeners.push(Jt(pe, "pointerleave", oe, oe.removeSelect))
                }
                blockMouseDown(Q) {
                    return oe => {
                        const pe = this.targetWorkspace.getGesture(oe);
                        pe && (pe.setStartBlock(Q),
                        pe.handleFlyoutStart(oe, this))
                    }
                }
                onMouseDown(Q) {
                    const oe = this.targetWorkspace.getGesture(Q);
                    oe && oe.handleFlyoutStart(Q, this)
                }
                isBlockCreatable(Q) {
                    return Q.isEnabled()
                }
                createBlock(Q) {
                    let oe = null;
                    J.disable$$module$build$src$core$events$utils();
                    var pe = this.targetWorkspace.getAllVariables();
                    this.targetWorkspace.setResizesEnabled(!1);
                    try {
                        oe = this.placeNewBlock(Q)
                    } finally {
                        J.enable$$module$build$src$core$events$utils()
                    }
                    if (this.targetWorkspace.hideChaff(),
                    Q = Ol(this.targetWorkspace, pe),
                    Ke()) {
                        for (J.setGroup$$module$build$src$core$events$utils(!0),
                        pe = 0; pe < Q.length; pe++) {
                            const Ae = Q[pe];
                            Ye(new (gt(go))(Ae))
                        }
                        Ye(new (gt(J.CREATE$$module$build$src$core$events$utils))(oe))
                    }
                    return this.autoClose ? this.hide() : this.filterForCapacity(),
                    oe
                }
                initFlyoutButton_(Q, oe, pe) {
                    const Ae = Q.createDom();
                    Q.moveTo(oe, pe),
                    Q.show(),
                    this.listeners.push(vt(Ae, "pointerdown", this, this.onMouseDown)),
                    this.buttons_.push(Q)
                }
                createRect_(Q, oe, pe, Ae, Re) {
                    return oe = $t(bt.RECT, {
                        "fill-opacity": 0,
                        x: oe,
                        y: pe,
                        height: Ae.height,
                        width: Ae.width
                    }),
                    oe.tooltip = Q,
                    Ni(oe),
                    this.workspace_.getCanvas().insertBefore(oe, Q.getSvgRoot()),
                    this.rectMap_.set(Q, oe),
                    this.mats[Re] = oe
                }
                moveRectToBlock_(Q, oe) {
                    const pe = oe.getHeightWidth();
                    Q.setAttribute("width", String(pe.width)),
                    Q.setAttribute("height", String(pe.height)),
                    oe = oe.getRelativeToSurfaceXY(),
                    Q.setAttribute("y", String(oe.y)),
                    Q.setAttribute("x", String(this.RTL ? oe.x - pe.width : oe.x))
                }
                filterForCapacity() {
                    const Q = this.workspace_.getTopBlocks(!1);
                    for (let oe = 0, pe; pe = Q[oe]; oe++)
                        if (this.permanentlyDisabled.indexOf(pe) === -1) {
                            const Ae = this.targetWorkspace.isCapacityAvailable(qe(pe));
                            for (; pe; )
                                pe.setEnabled(Ae),
                                pe = pe.getNextBlock()
                        }
                }
                reflow() {
                    this.reflowWrapper && this.workspace_.removeChangeListener(this.reflowWrapper),
                    this.reflowInternal_(),
                    this.reflowWrapper && this.workspace_.addChangeListener(this.reflowWrapper)
                }
                isScrollable() {
                    return this.workspace_.scrollbar ? this.workspace_.scrollbar.isVisible() : !1
                }
                placeNewBlock(Q) {
                    var oe = this.targetWorkspace;
                    if (!Q.getSvgRoot())
                        throw Error("oldBlock is not rendered");
                    const pe = Ts(Q, {
                        saveIds: !1
                    });
                    return oe.setResizesEnabled(!1),
                    oe = co(pe, oe),
                    this.positionNewBlock(Q, oe),
                    oe
                }
                positionNewBlock(Q, oe) {
                    const pe = this.targetWorkspace;
                    var Ae = pe.getOriginOffsetInPixels()
                      , Re = this.workspace_.getOriginOffsetInPixels();
                    Q = Q.getRelativeToSurfaceXY(),
                    Q.scale(this.workspace_.scale),
                    Re = Zt.sum(Re, Q),
                    Ae = Zt.difference(Re, Ae),
                    Ae.scale(1 / pe.scale),
                    oe.moveTo(new Zt(Ae.x,Ae.y))
                }
            }
            ;
            Hc.FlyoutItemType = pa;
            var gE = class extends Hc {
                constructor(Q) {
                    super(Q),
                    this.horizontalLayout = !0
                }
                setMetrics_(Q) {
                    if (this.isVisible()) {
                        var oe = this.workspace_.getMetricsManager()
                          , pe = oe.getScrollMetrics()
                          , Ae = oe.getViewMetrics();
                        oe = oe.getAbsoluteMetrics(),
                        typeof Q.x == "number" && (this.workspace_.scrollX = -(pe.left + (pe.width - Ae.width) * Q.x)),
                        this.workspace_.translate(this.workspace_.scrollX + oe.left, this.workspace_.scrollY + oe.top)
                    }
                }
                getX() {
                    return 0
                }
                getY() {
                    if (!this.isVisible())
                        return 0;
                    var Q = this.targetWorkspace.getMetricsManager();
                    const oe = Q.getAbsoluteMetrics()
                      , pe = Q.getViewMetrics();
                    Q = Q.getToolboxMetrics();
                    const Ae = this.toolboxPosition_ === In.TOP;
                    return this.targetWorkspace.toolboxPosition === this.toolboxPosition_ ? this.targetWorkspace.getToolbox() ? Ae ? Q.height : pe.height - this.height_ : Ae ? 0 : pe.height : Ae ? 0 : pe.height + oe.top - this.height_
                }
                position() {
                    if (this.isVisible() && this.targetWorkspace.isVisible()) {
                        var Q = this.targetWorkspace.getMetricsManager().getViewMetrics();
                        this.width_ = Q.width,
                        this.setBackgroundPath(Q.width - 2 * this.CORNER_RADIUS, this.height_ - this.CORNER_RADIUS),
                        Q = this.getX();
                        var oe = this.getY();
                        this.positionAt_(this.width_, this.height_, Q, oe)
                    }
                }
                setBackgroundPath(Q, oe) {
                    const pe = this.toolboxPosition_ === In.TOP
                      , Ae = ["M 0," + (pe ? 0 : this.CORNER_RADIUS)];
                    pe ? (Ae.push("h", Q + 2 * this.CORNER_RADIUS),
                    Ae.push("v", oe),
                    Ae.push("a", this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, 1, -this.CORNER_RADIUS, this.CORNER_RADIUS),
                    Ae.push("h", -Q),
                    Ae.push("a", this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, 1, -this.CORNER_RADIUS, -this.CORNER_RADIUS)) : (Ae.push("a", this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, 1, this.CORNER_RADIUS, -this.CORNER_RADIUS),
                    Ae.push("h", Q),
                    Ae.push("a", this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, 1, this.CORNER_RADIUS, this.CORNER_RADIUS),
                    Ae.push("v", oe),
                    Ae.push("h", -Q - 2 * this.CORNER_RADIUS)),
                    Ae.push("z"),
                    this.svgBackground_.setAttribute("d", Ae.join(" "))
                }
                scrollToStart() {
                    let Q;
                    (Q = this.workspace_.scrollbar) == null || Q.setX(this.RTL ? 1 / 0 : 0)
                }
                wheel_(Q) {
                    var oe = mn(Q);
                    if (oe = oe.x || oe.y) {
                        const pe = this.workspace_.getMetricsManager()
                          , Ae = pe.getScrollMetrics();
                        oe = pe.getViewMetrics().left - Ae.left + oe;
                        let Re;
                        (Re = this.workspace_.scrollbar) == null || Re.setX(oe),
                        Jr(),
                        ss()
                    }
                    Q.preventDefault(),
                    Q.stopPropagation()
                }
                layout_(Q, oe) {
                    this.workspace_.scale = this.targetWorkspace.scale;
                    const pe = this.MARGIN;
                    let Ae = pe + this.tabWidth_;
                    this.RTL && (Q = Q.reverse());
                    for (let dt = 0, wt; wt = Q[dt]; dt++)
                        if (wt.type === "block") {
                            var Re = wt.block
                              , Ue = Re.getDescendants(!1);
                            for (let zn = 0, jn; jn = Ue[zn]; zn++)
                                jn.isInFlyout = !0;
                            Ue = Re.getSvgRoot();
                            const sn = Re.getHeightWidth();
                            var tt = Re.outputConnection ? this.tabWidth_ : 0;
                            tt = this.RTL ? Ae + sn.width : Ae - tt,
                            Re.moveBy(tt, pe),
                            tt = this.createRect_(Re, tt, pe, sn, dt),
                            Ae += sn.width + oe[dt],
                            this.addBlockListeners_(Ue, Re, tt)
                        } else
                            wt.type === "button" && (Re = wt.button,
                            this.initFlyoutButton_(Re, Ae, pe),
                            Ae += Re.width + oe[dt])
                }
                isDragTowardWorkspace(Q) {
                    Q = Math.atan2(Q.y, Q.x) / Math.PI * 180;
                    const oe = this.dragAngleRange_;
                    return Q < 90 + oe && Q > 90 - oe || Q > -90 - oe && Q < -90 + oe
                }
                getClientRect() {
                    if (!this.svgGroup_ || this.autoClose || !this.isVisible())
                        return null;
                    const Q = this.svgGroup_.getBoundingClientRect()
                      , oe = Q.top;
                    return this.toolboxPosition_ === In.TOP ? new Vn(-1e9,oe + Q.height,-1e9,1e9) : new Vn(oe,1e9,-1e9,1e9)
                }
                reflowInternal_() {
                    this.workspace_.scale = this.getFlyoutScale();
                    let Q = 0;
                    const oe = this.workspace_.getTopBlocks(!1);
                    for (let Ae = 0, Re; Re = oe[Ae]; Ae++)
                        Q = Math.max(Q, Re.getHeightWidth().height);
                    const pe = this.buttons_;
                    for (let Ae = 0, Re; Re = pe[Ae]; Ae++)
                        Q = Math.max(Q, Re.height);
                    if (Q += 1.5 * this.MARGIN,
                    Q *= this.workspace_.scale,
                    Q += or.scrollbarThickness,
                    this.height_ !== Q) {
                        for (let Ae = 0, Re; Re = oe[Ae]; Ae++)
                            this.rectMap_.has(Re) && this.moveRectToBlock_(this.rectMap_.get(Re), Re);
                        this.targetWorkspace.scrollbar || this.autoClose || this.targetWorkspace.getFlyout() !== this || this.toolboxPosition_ !== In.TOP || this.targetWorkspace.translate(this.targetWorkspace.scrollX, this.targetWorkspace.scrollY + Q),
                        this.height_ = Q,
                        this.position(),
                        this.targetWorkspace.resizeContents(),
                        this.targetWorkspace.recordDragTargets()
                    }
                }
            }
            ;
            ne(Yt.FLYOUTS_HORIZONTAL_TOOLBOX, js, gE);
            var fp = class extends Hc {
                constructor(Q) {
                    super(Q)
                }
                setMetrics_(Q) {
                    if (this.isVisible()) {
                        var oe = this.workspace_.getMetricsManager()
                          , pe = oe.getScrollMetrics()
                          , Ae = oe.getViewMetrics();
                        oe = oe.getAbsoluteMetrics(),
                        typeof Q.y == "number" && (this.workspace_.scrollY = -(pe.top + (pe.height - Ae.height) * Q.y)),
                        this.workspace_.translate(this.workspace_.scrollX + oe.left, this.workspace_.scrollY + oe.top)
                    }
                }
                getX() {
                    if (!this.isVisible())
                        return 0;
                    var Q = this.targetWorkspace.getMetricsManager();
                    const oe = Q.getAbsoluteMetrics()
                      , pe = Q.getViewMetrics();
                    return Q = Q.getToolboxMetrics(),
                    this.targetWorkspace.toolboxPosition === this.toolboxPosition_ ? this.targetWorkspace.getToolbox() ? this.toolboxPosition_ === In.LEFT ? Q.width : pe.width - this.width_ : this.toolboxPosition_ === In.LEFT ? 0 : pe.width : this.toolboxPosition_ === In.LEFT ? 0 : pe.width + oe.left - this.width_
                }
                getY() {
                    return 0
                }
                position() {
                    if (this.isVisible() && this.targetWorkspace.isVisible()) {
                        var Q = this.targetWorkspace.getMetricsManager().getViewMetrics();
                        this.height_ = Q.height,
                        this.setBackgroundPath(this.width_ - this.CORNER_RADIUS, Q.height - 2 * this.CORNER_RADIUS),
                        Q = this.getX();
                        var oe = this.getY();
                        this.positionAt_(this.width_, this.height_, Q, oe)
                    }
                }
                setBackgroundPath(Q, oe) {
                    const pe = this.toolboxPosition_ === In.RIGHT;
                    var Ae = Q + this.CORNER_RADIUS;
                    Ae = ["M " + (pe ? Ae : 0) + ",0"],
                    Ae.push("h", pe ? -Q : Q),
                    Ae.push("a", this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, pe ? 0 : 1, pe ? -this.CORNER_RADIUS : this.CORNER_RADIUS, this.CORNER_RADIUS),
                    Ae.push("v", Math.max(0, oe)),
                    Ae.push("a", this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, pe ? 0 : 1, pe ? this.CORNER_RADIUS : -this.CORNER_RADIUS, this.CORNER_RADIUS),
                    Ae.push("h", pe ? Q : -Q),
                    Ae.push("z"),
                    this.svgBackground_.setAttribute("d", Ae.join(" "))
                }
                scrollToStart() {
                    let Q;
                    (Q = this.workspace_.scrollbar) == null || Q.setY(0)
                }
                wheel_(Q) {
                    var oe = mn(Q);
                    if (oe.y) {
                        const pe = this.workspace_.getMetricsManager()
                          , Ae = pe.getScrollMetrics();
                        oe = pe.getViewMetrics().top - Ae.top + oe.y;
                        let Re;
                        (Re = this.workspace_.scrollbar) == null || Re.setY(oe),
                        Jr(),
                        ss()
                    }
                    Q.preventDefault(),
                    Q.stopPropagation()
                }
                layout_(Q, oe) {
                    this.workspace_.scale = this.targetWorkspace.scale;
                    var pe = this.MARGIN;
                    const Ae = this.RTL ? pe : pe + this.tabWidth_;
                    for (let dt = 0, wt; wt = Q[dt]; dt++)
                        if (wt.type === "block") {
                            var Re = wt.block
                              , Ue = Re.getDescendants(!1);
                            for (let zn = 0, jn; jn = Ue[zn]; zn++)
                                jn.isInFlyout = !0;
                            Ue = Re.getSvgRoot();
                            const sn = Re.getHeightWidth();
                            var tt = Re.outputConnection ? Ae - this.tabWidth_ : Ae;
                            Re.moveBy(tt, pe),
                            tt = this.createRect_(Re, this.RTL ? tt - sn.width : tt, pe, sn, dt),
                            this.addBlockListeners_(Ue, Re, tt),
                            pe += sn.height + oe[dt]
                        } else
                            wt.type === "button" && (Re = wt.button,
                            this.initFlyoutButton_(Re, Ae, pe),
                            pe += Re.height + oe[dt])
                }
                isDragTowardWorkspace(Q) {
                    Q = Math.atan2(Q.y, Q.x) / Math.PI * 180;
                    const oe = this.dragAngleRange_;
                    return Q < oe && Q > -oe || Q < -180 + oe || Q > 180 - oe
                }
                getClientRect() {
                    if (!this.svgGroup_ || this.autoClose || !this.isVisible())
                        return null;
                    const Q = this.svgGroup_.getBoundingClientRect()
                      , oe = Q.left;
                    return this.toolboxPosition_ === In.LEFT ? new Vn(-1e9,1e9,-1e9,oe + Q.width) : new Vn(-1e9,1e9,oe,1e9)
                }
                reflowInternal_() {
                    this.workspace_.scale = this.getFlyoutScale();
                    let Q = 0;
                    var oe = this.workspace_.getTopBlocks(!1);
                    for (let Ae = 0, Re; Re = oe[Ae]; Ae++) {
                        var pe = Re.getHeightWidth().width;
                        Re.outputConnection && (pe -= this.tabWidth_),
                        Q = Math.max(Q, pe)
                    }
                    for (let Ae = 0, Re; Re = this.buttons_[Ae]; Ae++)
                        Q = Math.max(Q, Re.width);
                    if (Q += 1.5 * this.MARGIN + this.tabWidth_,
                    Q *= this.workspace_.scale,
                    Q += or.scrollbarThickness,
                    this.width_ !== Q) {
                        for (let Ae = 0, Re; Re = oe[Ae]; Ae++) {
                            if (this.RTL) {
                                pe = Re.getRelativeToSurfaceXY().x;
                                let Ue = Q / this.workspace_.scale - this.MARGIN;
                                Re.outputConnection || (Ue -= this.tabWidth_),
                                Re.moveBy(Ue - pe, 0)
                            }
                            this.rectMap_.has(Re) && this.moveRectToBlock_(this.rectMap_.get(Re), Re)
                        }
                        if (this.RTL)
                            for (let Ae = 0, Re; Re = this.buttons_[Ae]; Ae++)
                                oe = Re.getPosition().y,
                                Re.moveTo(Q / this.workspace_.scale - Re.width - this.MARGIN - this.tabWidth_, oe);
                        this.targetWorkspace.scrollbar || this.autoClose || this.targetWorkspace.getFlyout() !== this || this.toolboxPosition_ !== In.LEFT || this.targetWorkspace.translate(this.targetWorkspace.scrollX + Q, this.targetWorkspace.scrollY),
                        this.width_ = Q,
                        this.position(),
                        this.targetWorkspace.resizeContents(),
                        this.targetWorkspace.recordDragTargets()
                    }
                }
            }
            ;
            fp.registryName = "verticalFlyout",
            ne(Yt.FLYOUTS_VERTICAL_TOOLBOX, js, fp);
            var EE;
            J.CodeGenerator$$module$build$src$core$generator = class {
                constructor(Q) {
                    this.forBlock = Object.create(null),
                    this.FUNCTION_NAME_PLACEHOLDER_ = "{leCUI8hutHZI4480Dc}",
                    this.STATEMENT_SUFFIX = this.STATEMENT_PREFIX = this.INFINITE_LOOP_TRAP = null,
                    this.INDENT = "  ",
                    this.COMMENT_WRAP = 60,
                    this.ORDER_OVERRIDES = [],
                    this.isInitialized = null,
                    this.RESERVED_WORDS_ = "",
                    this.definitions_ = Object.create(null),
                    this.functionNames_ = Object.create(null),
                    this.nameDB_ = void 0,
                    this.name_ = Q,
                    this.FUNCTION_NAME_PLACEHOLDER_REGEXP_ = new RegExp(this.FUNCTION_NAME_PLACEHOLDER_,"g")
                }
                workspaceToCode(Q) {
                    Q || (console.warn("No workspace specified in workspaceToCode call.  Guessing."),
                    Q = ke());
                    var oe = [];
                    this.init(Q),
                    Q = Q.getTopBlocks(!0);
                    for (let pe = 0, Ae; Ae = Q[pe]; pe++) {
                        let Re = this.blockToCode(Ae);
                        Array.isArray(Re) && (Re = Re[0]),
                        Re && (Ae.outputConnection && (Re = this.scrubNakedValue(Re),
                        this.STATEMENT_PREFIX && !Ae.suppressPrefixSuffix && (Re = this.injectId(this.STATEMENT_PREFIX, Ae) + Re),
                        this.STATEMENT_SUFFIX && !Ae.suppressPrefixSuffix && (Re += this.injectId(this.STATEMENT_SUFFIX, Ae))),
                        oe.push(Re))
                    }
                    return oe = oe.join(`
`),
                    oe = this.finish(oe),
                    oe = oe.replace(/^\s+\n/, ""),
                    oe = oe.replace(/\n\s+$/, `
`),
                    oe = oe.replace(/[ \t]+\n/g, `
`)
                }
                prefixLines(Q, oe) {
                    return oe + Q.replace(/(?!\n$)\n/g, `
` + oe)
                }
                allNestedComments(Q) {
                    const oe = [];
                    Q = Q.getDescendants(!0);
                    for (let pe = 0; pe < Q.length; pe++) {
                        const Ae = Q[pe].getCommentText();
                        Ae && oe.push(Ae)
                    }
                    return oe.length && oe.push(""),
                    oe.join(`
`)
                }
                blockToCode(Q, oe) {
                    if (this.isInitialized === !1 && console.warn("CodeGenerator init was not called before blockToCode was called."),
                    !Q)
                        return "";
                    if (!Q.isEnabled())
                        return oe ? "" : this.blockToCode(Q.getNextBlock());
                    if (Q.isInsertionMarker())
                        return oe ? "" : this.blockToCode(Q.getChildren(!1)[0]);
                    var pe = this.forBlock[Q.type];
                    if (!pe && this[Q.type] && (zt("block generator functions on CodeGenerator objects", "10.0", "11.0", "the .forBlock[blockType] dictionary"),
                    pe = this[Q.type]),
                    typeof pe != "function")
                        throw Error(`${this.name_} generator does not know how to generate code for block type "${Q.type}".`);
                    if (pe = pe.call(Q, Q, this),
                    Array.isArray(pe)) {
                        if (!Q.outputConnection)
                            throw TypeError("Expecting string from statement block: " + Q.type);
                        return [this.scrub_(Q, pe[0], oe), pe[1]]
                    }
                    if (typeof pe == "string")
                        return this.STATEMENT_PREFIX && !Q.suppressPrefixSuffix && (pe = this.injectId(this.STATEMENT_PREFIX, Q) + pe),
                        this.STATEMENT_SUFFIX && !Q.suppressPrefixSuffix && (pe += this.injectId(this.STATEMENT_SUFFIX, Q)),
                        this.scrub_(Q, pe, oe);
                    if (pe === null)
                        return "";
                    throw SyntaxError("Invalid code generated: " + pe)
                }
                valueToCode(Q, oe, pe) {
                    if (isNaN(pe))
                        throw TypeError("Expecting valid order from block: " + Q.type);
                    var Ae = Q.getInputTargetBlock(oe);
                    if (!Ae || (oe = this.blockToCode(Ae),
                    oe === ""))
                        return "";
                    if (!Array.isArray(oe))
                        throw TypeError(`Expecting tuple from value block: ${Ae.type} See developers.google.com/blockly/guides/create-custom-blocks/generating-code for more information`);
                    if (Q = oe[0],
                    oe = oe[1],
                    isNaN(oe))
                        throw TypeError("Expecting valid order from value block: " + Ae.type);
                    if (!Q)
                        return "";
                    Ae = !1;
                    var Re = Math.floor(pe);
                    const Ue = Math.floor(oe);
                    if (Re <= Ue && (Re !== Ue || Re !== 0 && Re !== 99)) {
                        for (Ae = !0,
                        Re = 0; Re < this.ORDER_OVERRIDES.length; Re++)
                            if (this.ORDER_OVERRIDES[Re][0] === pe && this.ORDER_OVERRIDES[Re][1] === oe) {
                                Ae = !1;
                                break
                            }
                    }
                    return Ae && (Q = "(" + Q + ")"),
                    Q
                }
                statementToCode(Q, oe) {
                    if (Q = Q.getInputTargetBlock(oe),
                    oe = this.blockToCode(Q),
                    typeof oe != "string")
                        throw TypeError("Expecting code from statement block: " + (Q && Q.type));
                    return oe && (oe = this.prefixLines(oe, this.INDENT)),
                    oe
                }
                addLoopTrap(Q, oe) {
                    return this.INFINITE_LOOP_TRAP && (Q = this.prefixLines(this.injectId(this.INFINITE_LOOP_TRAP, oe), this.INDENT) + Q),
                    this.STATEMENT_SUFFIX && !oe.suppressPrefixSuffix && (Q = this.prefixLines(this.injectId(this.STATEMENT_SUFFIX, oe), this.INDENT) + Q),
                    this.STATEMENT_PREFIX && !oe.suppressPrefixSuffix && (Q += this.prefixLines(this.injectId(this.STATEMENT_PREFIX, oe), this.INDENT)),
                    Q
                }
                injectId(Q, oe) {
                    return oe = oe.id.replace(/\$/g, "$$$$"),
                    Q.replace(/%1/g, "'" + oe + "'")
                }
                addReservedWords(Q) {
                    this.RESERVED_WORDS_ += Q + ","
                }
                provideFunction_(Q, oe) {
                    if (!this.definitions_[Q]) {
                        const pe = this.nameDB_.getDistinctName(Q, J.NameType$$module$build$src$core$names.PROCEDURE);
                        this.functionNames_[Q] = pe,
                        Array.isArray(oe) && (oe = oe.join(`
`)),
                        oe = oe.trim().replace(this.FUNCTION_NAME_PLACEHOLDER_REGEXP_, pe);
                        let Ae;
                        for (; Ae !== oe; )
                            Ae = oe,
                            oe = oe.replace(/^(( {2})*) {2}/gm, "$1\0");
                        oe = oe.replace(/\0/g, this.INDENT),
                        this.definitions_[Q] = oe
                    }
                    return this.functionNames_[Q]
                }
                getVariableName(Q) {
                    return this.getName(Q, J.NameType$$module$build$src$core$names.VARIABLE)
                }
                getProcedureName(Q) {
                    return this.getName(Q, J.NameType$$module$build$src$core$names.PROCEDURE)
                }
                getName(Q, oe) {
                    if (!this.nameDB_)
                        throw Error("Name database is not defined. You must initialize `nameDB_` in your generator class and call `init` first.");
                    return this.nameDB_.getName(Q, oe)
                }
                init(Q) {
                    this.definitions_ = Object.create(null),
                    this.functionNames_ = Object.create(null)
                }
                scrub_(Q, oe, pe) {
                    return oe
                }
                finish(Q) {
                    return this.definitions_ = Object.create(null),
                    this.functionNames_ = Object.create(null),
                    Q
                }
                scrubNakedValue(Q) {
                    return Q
                }
            }
            ,
            EE = {},
            EE.CodeGenerator = J.CodeGenerator$$module$build$src$core$generator;
            var TE = !1
              , $o = {};
            $o.Align = J.Align$$module$build$src$core$inputs$align,
            $o.DummyInput = Ns,
            $o.EndRowInput = to,
            $o.Input = xs,
            $o.StatementInput = jr,
            $o.ValueInput = J.ValueInput$$module$build$src$core$inputs$value_input,
            $o.inputTypes = J.inputTypes$$module$build$src$core$inputs$input_types;
            var AE = class extends cl {
                constructor() {
                    super(),
                    this.FIELD_TEXT_BASELINE_CENTER = !1,
                    this.DARK_PATH_OFFSET = 1,
                    this.MAX_BOTTOM_WIDTH = 30,
                    this.STATEMENT_BOTTOM_SPACER = -this.NOTCH_HEIGHT / 2
                }
                getCSS_(Q) {
                    return super.getCSS_(Q).concat([`${Q} .blocklyInsertionMarker>.blocklyPathLight,`, `${Q} .blocklyInsertionMarker>.blocklyPathDark {`, `fill-opacity: ${this.INSERTION_MARKER_OPACITY};`, "stroke: none;", "}"])
                }
            }
              , _E = class {
                constructor(Q) {
                    this.inlineSteps_ = this.steps_ = "",
                    this.info_ = Q,
                    this.RTL_ = this.info_.RTL,
                    Q = Q.getRenderer(),
                    this.constants_ = Q.getConstants(),
                    this.highlightConstants_ = Q.getHighlightConstants(),
                    this.highlightOffset = this.highlightConstants_.OFFSET,
                    this.outsideCornerPaths_ = this.highlightConstants_.OUTSIDE_CORNER,
                    this.insideCornerPaths_ = this.highlightConstants_.INSIDE_CORNER,
                    this.puzzleTabPaths_ = this.highlightConstants_.PUZZLE_TAB,
                    this.notchPaths_ = this.highlightConstants_.NOTCH,
                    this.startPaths_ = this.highlightConstants_.START_HAT,
                    this.jaggedTeethPaths_ = this.highlightConstants_.JAGGED_TEETH
                }
                getPath() {
                    return this.steps_ + `
` + this.inlineSteps_
                }
                drawTopCorner(Q) {
                    this.steps_ += qn(Q.xPos, this.info_.startY);
                    for (let oe = 0, pe; pe = Q.elements[oe]; oe++)
                        Rt.isLeftSquareCorner(pe) ? this.steps_ += this.highlightConstants_.START_POINT : Rt.isLeftRoundedCorner(pe) ? this.steps_ += this.outsideCornerPaths_.topLeft(this.RTL_) : Rt.isPreviousConnection(pe) ? this.steps_ += this.notchPaths_.pathLeft : Rt.isHat(pe) ? this.steps_ += this.startPaths_.path(this.RTL_) : Rt.isSpacer(pe) && pe.width !== 0 && (this.steps_ += ln("H", pe.xPos + pe.width - this.highlightOffset));
                    this.steps_ += ln("H", Q.xPos + Q.width - this.highlightOffset)
                }
                drawJaggedEdge_(Q) {
                    this.info_.RTL && (this.steps_ += this.jaggedTeethPaths_.pathLeft + ln("v", Q.height - this.jaggedTeethPaths_.height - this.highlightOffset))
                }
                drawValueInput(Q) {
                    const oe = Q.getLastInput();
                    if (this.RTL_) {
                        const pe = Q.height - oe.connectionHeight;
                        this.steps_ += mr(oe.xPos + oe.width - this.highlightOffset, Q.yPos) + this.puzzleTabPaths_.pathDown(this.RTL_) + ln("v", pe)
                    } else
                        this.steps_ += mr(oe.xPos + oe.width, Q.yPos) + this.puzzleTabPaths_.pathDown(this.RTL_)
                }
                drawStatementInput(Q) {
                    const oe = Q.getLastInput();
                    if (oe)
                        if (this.RTL_) {
                            const pe = Q.height - 2 * this.insideCornerPaths_.height;
                            this.steps_ += mr(oe.xPos, Q.yPos) + this.insideCornerPaths_.pathTop(this.RTL_) + ln("v", pe) + this.insideCornerPaths_.pathBottom(this.RTL_) + As(Q.width - oe.xPos - this.insideCornerPaths_.width, 0)
                        } else
                            this.steps_ += mr(oe.xPos, Q.yPos + Q.height) + this.insideCornerPaths_.pathBottom(this.RTL_) + As(Q.width - oe.xPos - this.insideCornerPaths_.width, 0)
                }
                drawRightSideRow(Q) {
                    const oe = Q.xPos + Q.width - this.highlightOffset;
                    Q instanceof Fh && Q.followsStatement && (this.steps_ += ln("H", oe)),
                    this.RTL_ && (this.steps_ += ln("H", oe),
                    Q.height > this.highlightOffset && (this.steps_ += ln("V", Q.yPos + Q.height - this.highlightOffset)))
                }
                drawBottomRow(Q) {
                    if (this.RTL_)
                        this.steps_ += ln("V", Q.baseline - this.highlightOffset);
                    else {
                        const oe = this.info_.bottomRow.elements[0];
                        Rt.isLeftSquareCorner(oe) ? this.steps_ += mr(Q.xPos + this.highlightOffset, Q.baseline - this.highlightOffset) : Rt.isLeftRoundedCorner(oe) && (this.steps_ += mr(Q.xPos, Q.baseline),
                        this.steps_ += this.outsideCornerPaths_.bottomLeft())
                    }
                }
                drawLeft() {
                    var Q = this.info_.outputConnection;
                    Q && (Q = Q.connectionOffsetY + Q.height,
                    this.RTL_ ? this.steps_ += mr(this.info_.startX, Q) : (this.steps_ += mr(this.info_.startX + this.highlightOffset, this.info_.bottomRow.baseline - this.highlightOffset),
                    this.steps_ += ln("V", Q)),
                    this.steps_ += this.puzzleTabPaths_.pathUp(this.RTL_)),
                    this.RTL_ || (Q = this.info_.topRow,
                    Rt.isLeftRoundedCorner(Q.elements[0]) ? this.steps_ += ln("V", this.outsideCornerPaths_.height) : this.steps_ += ln("V", Q.capline + this.highlightOffset))
                }
                drawInlineInput(Q) {
                    const oe = this.highlightOffset
                      , pe = Q.xPos + Q.connectionWidth;
                    var Ae = Q.centerline - Q.height / 2;
                    const Re = Q.width - Q.connectionWidth
                      , Ue = Ae + oe;
                    this.RTL_ ? (Ae = Q.connectionOffsetY - oe,
                    Q = Q.height - (Q.connectionOffsetY + Q.connectionHeight) + oe,
                    this.inlineSteps_ += mr(pe - oe, Ue) + ln("v", Ae) + this.puzzleTabPaths_.pathDown(this.RTL_) + ln("v", Q) + ln("h", Re)) : this.inlineSteps_ += mr(Q.xPos + Q.width + oe, Ue) + ln("v", Q.height) + ln("h", -Re) + mr(pe, Ae + Q.connectionOffsetY) + this.puzzleTabPaths_.pathDown(this.RTL_)
                }
            }
              , SE = class extends ul {
                constructor(Q, oe) {
                    super(Q, oe),
                    this.highlighter_ = new _E(oe)
                }
                draw() {
                    this.drawOutline_(),
                    this.drawInternals_();
                    const Q = this.block_.pathObject;
                    Q.setPath(this.outlinePath_ + `
` + this.inlinePath_),
                    Q.setHighlightPath(this.highlighter_.getPath()),
                    this.info_.RTL && Q.flipRTL(),
                    this.recordSizeOnBlock_()
                }
                drawTop_() {
                    this.highlighter_.drawTopCorner(this.info_.topRow),
                    this.highlighter_.drawRightSideRow(this.info_.topRow),
                    super.drawTop_()
                }
                drawJaggedEdge_(Q) {
                    this.highlighter_.drawJaggedEdge_(Q),
                    super.drawJaggedEdge_(Q)
                }
                drawValueInput_(Q) {
                    this.highlighter_.drawValueInput(Q),
                    super.drawValueInput_(Q)
                }
                drawStatementInput_(Q) {
                    this.highlighter_.drawStatementInput(Q),
                    super.drawStatementInput_(Q)
                }
                drawRightSideRow_(Q) {
                    this.highlighter_.drawRightSideRow(Q),
                    this.outlinePath_ += ln("H", Q.xPos + Q.width) + ln("V", Q.yPos + Q.height)
                }
                drawBottom_() {
                    this.highlighter_.drawBottomRow(this.info_.bottomRow),
                    super.drawBottom_()
                }
                drawLeft_() {
                    this.highlighter_.drawLeft(),
                    super.drawLeft_()
                }
                drawInlineInput_(Q) {
                    this.highlighter_.drawInlineInput(Q),
                    super.drawInlineInput_(Q)
                }
                positionInlineInputConnection_(Q) {
                    const oe = Q.centerline - Q.height / 2;
                    if (Q.connectionModel) {
                        let pe = Q.xPos + Q.connectionWidth + this.constants_.DARK_PATH_OFFSET;
                        this.info_.RTL && (pe *= -1),
                        Q.connectionModel.setOffsetInBlock(pe, oe + Q.connectionOffsetY + this.constants_.DARK_PATH_OFFSET)
                    }
                }
                positionStatementInputConnection_(Q) {
                    const oe = Q.getLastInput();
                    if (oe != null && oe.connectionModel) {
                        let pe = Q.xPos + Q.statementEdge + oe.notchOffset;
                        pe = this.info_.RTL ? -1 * pe : pe + this.constants_.DARK_PATH_OFFSET,
                        oe.connectionModel.setOffsetInBlock(pe, Q.yPos + this.constants_.DARK_PATH_OFFSET)
                    }
                }
                positionExternalValueConnection_(Q) {
                    const oe = Q.getLastInput();
                    if (oe && oe.connectionModel) {
                        let pe = Q.xPos + Q.width + this.constants_.DARK_PATH_OFFSET;
                        this.info_.RTL && (pe *= -1),
                        oe.connectionModel.setOffsetInBlock(pe, Q.yPos)
                    }
                }
                positionNextConnection_() {
                    const Q = this.info_.bottomRow;
                    if (Q.connection) {
                        const oe = Q.connection
                          , pe = oe.xPos;
                        oe.connectionModel.setOffsetInBlock((this.info_.RTL ? -pe : pe) + this.constants_.DARK_PATH_OFFSET / 2, Q.baseline + this.constants_.DARK_PATH_OFFSET)
                    }
                }
            }
              , IE = class {
                constructor(Q) {
                    this.OFFSET = .5,
                    this.constantProvider = Q,
                    this.START_POINT = qn(this.OFFSET, this.OFFSET)
                }
                init() {
                    this.INSIDE_CORNER = this.makeInsideCorner(),
                    this.OUTSIDE_CORNER = this.makeOutsideCorner(),
                    this.PUZZLE_TAB = this.makePuzzleTab(),
                    this.NOTCH = this.makeNotch(),
                    this.JAGGED_TEETH = this.makeJaggedTeeth(),
                    this.START_HAT = this.makeStartHat()
                }
                makeInsideCorner() {
                    const Q = this.constantProvider.CORNER_RADIUS
                      , oe = this.OFFSET
                      , pe = (1 - Math.SQRT1_2) * (Q + oe) - oe
                      , Ae = qn(pe, pe) + sr("a", "0 0,0", Q, gn(-pe - oe, Q - pe))
                      , Re = sr("a", "0 0,0", Q + oe, gn(Q + oe, Q + oe))
                      , Ue = qn(pe, -pe) + sr("a", "0 0,0", Q + oe, gn(Q - pe, pe + oe));
                    return {
                        width: Q + oe,
                        height: Q,
                        pathTop(tt) {
                            return tt ? Ae : ""
                        },
                        pathBottom(tt) {
                            return tt ? Re : Ue
                        }
                    }
                }
                makeOutsideCorner() {
                    const Q = this.constantProvider.CORNER_RADIUS
                      , oe = this.OFFSET
                      , pe = (1 - Math.SQRT1_2) * (Q - oe) + oe
                      , Ae = qn(pe, pe) + sr("a", "0 0,1", Q - oe, gn(Q - pe, -pe + oe))
                      , Re = qn(oe, Q) + sr("a", "0 0,1", Q - oe, gn(Q, -Q + oe))
                      , Ue = -pe
                      , tt = qn(pe, Ue) + sr("a", "0 0,1", Q - oe, gn(-pe + oe, -Ue - Q));
                    return {
                        height: Q,
                        topLeft(dt) {
                            return dt ? Ae : Re
                        },
                        bottomLeft() {
                            return tt
                        }
                    }
                }
                makePuzzleTab() {
                    const Q = this.constantProvider.TAB_WIDTH
                      , oe = this.constantProvider.TAB_HEIGHT
                      , pe = qn(-2, -oe + 3.4) + As(-.45 * Q, -2.1)
                      , Ae = ln("v", 2.5) + qn(.97 * -Q, 2.5) + xr("q", [gn(.05 * -Q, 10), gn(.3 * Q, 9.5)]) + qn(.67 * Q, -1.9) + ln("v", 2.5)
                      , Re = ln("v", -1.5) + qn(-.92 * Q, -.5) + xr("q", [gn(-.19 * Q, -5.5), gn(0, -11)]) + qn(.92 * Q, 1)
                      , Ue = qn(-5, oe - .7) + As(.46 * Q, -2.1);
                    return {
                        width: Q,
                        height: oe,
                        pathUp(tt) {
                            return tt ? pe : Re
                        },
                        pathDown(tt) {
                            return tt ? Ae : Ue
                        }
                    }
                }
                makeNotch() {
                    return {
                        pathLeft: ln("h", this.OFFSET) + this.constantProvider.NOTCH.pathLeft
                    }
                }
                makeJaggedTeeth() {
                    return {
                        pathLeft: As(5.1, 2.6) + qn(-10.2, 6.8) + As(5.1, 2.6),
                        height: 12,
                        width: 10.2
                    }
                }
                makeStartHat() {
                    const Q = this.constantProvider.START_HAT.height
                      , oe = qn(25, -8.7) + xr("c", [gn(29.7, -6.2), gn(57.2, -.5), gn(75, 8.7)])
                      , pe = xr("c", [gn(17.8, -9.2), gn(45.3, -14.9), gn(75, -8.7)]) + mr(100.5, Q + .5);
                    return {
                        path(Ae) {
                            return Ae ? oe : pe
                        }
                    }
                }
            }
              , RE = class extends Bh {
                constructor(Q, oe) {
                    super(Q, oe),
                    this.constants_ = Q,
                    this.connectedBlock && (this.width += this.constants_.DARK_PATH_OFFSET,
                    this.height += this.constants_.DARK_PATH_OFFSET)
                }
            }
              , yE = class extends il {
                constructor(Q, oe) {
                    super(Q, oe),
                    this.constants_ = Q,
                    this.connectedBlock && (this.height += this.constants_.DARK_PATH_OFFSET)
                }
            }
              , bE = class extends ia {
                constructor(Q, oe) {
                    super(Q, oe),
                    this.renderer_ = Q
                }
                getRenderer() {
                    return this.renderer_
                }
                populateBottomRow_() {
                    super.populateBottomRow_(),
                    this.block_.inputList.length && this.block_.inputList[this.block_.inputList.length - 1]instanceof jr || (this.bottomRow.minHeight = this.constants_.MEDIUM_PADDING - this.constants_.DARK_PATH_OFFSET)
                }
                addInput_(Q, oe) {
                    this.isInline && Q instanceof J.ValueInput$$module$build$src$core$inputs$value_input ? (oe.elements.push(new RE(this.constants_,Q)),
                    oe.hasInlineInput = !0) : Q instanceof jr ? (oe.elements.push(new yE(this.constants_,Q)),
                    oe.hasStatement = !0) : Q instanceof J.ValueInput$$module$build$src$core$inputs$value_input ? (oe.elements.push(new Nc(this.constants_,Q)),
                    oe.hasExternalInput = !0) : (Q instanceof Ns || Q instanceof to) && (oe.minHeight = Math.max(oe.minHeight, this.constants_.DUMMY_INPUT_MIN_HEIGHT),
                    oe.hasDummyInput = !0),
                    this.isInline || oe.align !== null || (oe.align = Q.align)
                }
                addElemSpacing_() {
                    let Q = !1;
                    for (let pe = 0, Ae; Ae = this.rows[pe]; pe++)
                        Ae.hasExternalInput && (Q = !0);
                    for (let pe = 0, Ae; Ae = this.rows[pe]; pe++) {
                        var oe = Ae.elements;
                        if (Ae.elements = [],
                        Ae.startsWithElemSpacer() && Ae.elements.push(new Gr(this.constants_,this.getInRowSpacing_(null, oe[0]))),
                        oe.length) {
                            for (let Re = 0; Re < oe.length - 1; Re++) {
                                Ae.elements.push(oe[Re]);
                                const Ue = this.getInRowSpacing_(oe[Re], oe[Re + 1]);
                                Ae.elements.push(new Gr(this.constants_,Ue))
                            }
                            Ae.elements.push(oe[oe.length - 1]),
                            Ae.endsWithElemSpacer() && (oe = this.getInRowSpacing_(oe[oe.length - 1], null),
                            Q && Ae.hasDummyInput && (oe += this.constants_.TAB_WIDTH),
                            Ae.elements.push(new Gr(this.constants_,oe)))
                        }
                    }
                }
                getInRowSpacing_(Q, oe) {
                    if (!Q)
                        return oe && Rt.isField(oe) && oe.isEditable ? this.constants_.MEDIUM_PADDING : oe && Rt.isInlineInput(oe) ? this.constants_.MEDIUM_LARGE_PADDING : oe && Rt.isStatementInput(oe) ? this.constants_.STATEMENT_INPUT_PADDING_LEFT : this.constants_.LARGE_PADDING;
                    if (!Rt.isInput(Q) && (!oe || Rt.isStatementInput(oe)))
                        return Rt.isField(Q) && Q.isEditable ? this.constants_.MEDIUM_PADDING : Rt.isIcon(Q) ? 2 * this.constants_.LARGE_PADDING + 1 : Rt.isHat(Q) ? this.constants_.NO_PADDING : Rt.isPreviousOrNextConnection(Q) ? this.constants_.LARGE_PADDING : Rt.isLeftRoundedCorner(Q) ? this.constants_.MIN_BLOCK_WIDTH : Rt.isJaggedEdge(Q) ? this.constants_.NO_PADDING : this.constants_.LARGE_PADDING;
                    if (Rt.isInput(Q) && !oe) {
                        if (Rt.isExternalInput(Q))
                            return this.constants_.NO_PADDING;
                        if (Rt.isInlineInput(Q))
                            return this.constants_.LARGE_PADDING;
                        if (Rt.isStatementInput(Q))
                            return this.constants_.NO_PADDING
                    }
                    if (!Rt.isInput(Q) && oe && Rt.isInput(oe)) {
                        if (Rt.isField(Q) && Q.isEditable) {
                            if (Rt.isInlineInput(oe) || Rt.isExternalInput(oe))
                                return this.constants_.SMALL_PADDING
                        } else {
                            if (Rt.isInlineInput(oe) || Rt.isExternalInput(oe))
                                return this.constants_.MEDIUM_LARGE_PADDING;
                            if (Rt.isStatementInput(oe))
                                return this.constants_.LARGE_PADDING
                        }
                        return this.constants_.LARGE_PADDING - 1
                    }
                    if (Rt.isIcon(Q) && oe && !Rt.isInput(oe))
                        return this.constants_.LARGE_PADDING;
                    if (Rt.isInlineInput(Q) && oe && Rt.isField(oe))
                        return oe.isEditable ? this.constants_.MEDIUM_PADDING : this.constants_.LARGE_PADDING;
                    if (Rt.isLeftSquareCorner(Q) && oe) {
                        if (Rt.isHat(oe))
                            return this.constants_.NO_PADDING;
                        if (Rt.isPreviousConnection(oe))
                            return oe.notchOffset;
                        if (Rt.isNextConnection(oe))
                            return oe.notchOffset + (this.RTL ? 1 : -1) * this.constants_.DARK_PATH_OFFSET / 2
                    }
                    if (Rt.isLeftRoundedCorner(Q) && oe) {
                        if (Rt.isPreviousConnection(oe))
                            return oe.notchOffset - this.constants_.CORNER_RADIUS;
                        if (Rt.isNextConnection(oe))
                            return oe.notchOffset - this.constants_.CORNER_RADIUS + (this.RTL ? 1 : -1) * this.constants_.DARK_PATH_OFFSET / 2
                    }
                    return Rt.isField(Q) && oe && Rt.isField(oe) && Q.isEditable === oe.isEditable || oe && Rt.isJaggedEdge(oe) ? this.constants_.LARGE_PADDING : this.constants_.MEDIUM_PADDING
                }
                getSpacerRowHeight_(Q, oe) {
                    return Rt.isTopRow(Q) && Rt.isBottomRow(oe) ? this.constants_.EMPTY_BLOCK_SPACER_HEIGHT : Rt.isTopRow(Q) || Rt.isBottomRow(oe) ? this.constants_.NO_PADDING : Q.hasExternalInput && oe.hasExternalInput ? this.constants_.LARGE_PADDING : !Q.hasStatement && oe.hasStatement ? this.constants_.BETWEEN_STATEMENT_PADDING_Y : Q.hasStatement && oe.hasStatement || !Q.hasStatement && oe.hasDummyInput || Q.hasDummyInput ? this.constants_.LARGE_PADDING : this.constants_.MEDIUM_PADDING
                }
                getElemCenterline_(Q, oe) {
                    if (Rt.isSpacer(oe))
                        return Q.yPos + oe.height / 2;
                    if (Rt.isBottomRow(Q))
                        return Q = Q.yPos + Q.height - Q.descenderHeight,
                        Rt.isNextConnection(oe) ? Q + oe.height / 2 : Q - oe.height / 2;
                    if (Rt.isTopRow(Q))
                        return Rt.isHat(oe) ? Q.capline - oe.height / 2 : Q.capline + oe.height / 2;
                    let pe = Q.yPos;
                    return Rt.isField(oe) || Rt.isIcon(oe) ? (pe += oe.height / 2,
                    (Q.hasInlineInput || Q.hasStatement) && oe.height + this.constants_.TALL_INPUT_FIELD_OFFSET_Y <= Q.height && (pe += this.constants_.TALL_INPUT_FIELD_OFFSET_Y)) : pe = Rt.isInlineInput(oe) ? pe + oe.height / 2 : pe + Q.height / 2,
                    pe
                }
                alignRowElements_() {
                    if (this.isInline) {
                        var Q = 0
                          , oe = new WeakMap
                          , pe = null;
                        for (let Ae = this.rows.length - 1, Re; Re = this.rows[Ae]; Ae--)
                            oe.set(Re, Q),
                            Rt.isInputRow(Re) && (Re.hasStatement && this.alignStatementRow_(Re),
                            pe && pe.hasStatement && Re.width < pe.width ? oe.set(Re, pe.width) : Q = Re.hasStatement ? Re.width : Math.max(Q, Re.width),
                            pe = Re);
                        Q = 0;
                        for (let Ae = 0, Re; Re = this.rows[Ae]; Ae++)
                            Re.hasStatement ? Q = this.getDesiredRowWidth_(Re) : Rt.isSpacer(Re) ? Re.width = Math.max(Q, oe.get(Re)) : (pe = Re.width,
                            Q = Math.max(Q, oe.get(Re)) - pe,
                            0 < Q && this.addAlignmentPadding_(Re, Q),
                            Q = Re.width)
                    } else
                        super.alignRowElements_()
                }
                getDesiredRowWidth_(Q) {
                    return this.isInline && Q.hasStatement ? this.statementEdge + this.constants_.MAX_BOTTOM_WIDTH + this.startX : super.getDesiredRowWidth_(Q)
                }
                finalize_() {
                    let Q = 0
                      , oe = 0;
                    for (let Ae = 0, Re; Re = this.rows[Ae]; Ae++) {
                        Re.yPos = oe,
                        Re.xPos = this.startX,
                        oe += Re.height,
                        Q = Math.max(Q, Re.widthWithConnectedBlocks);
                        var pe = oe - this.topRow.ascenderHeight;
                        Re === this.bottomRow && pe < this.constants_.MIN_BLOCK_HEIGHT && (pe = this.constants_.MIN_BLOCK_HEIGHT - pe,
                        this.bottomRow.height += pe,
                        oe += pe),
                        this.recordElemPositions_(Re)
                    }
                    this.outputConnection && this.block_.nextConnection && this.block_.nextConnection.isConnected() && (pe = this.block_.nextConnection.targetBlock()) && (Q = Math.max(Q, pe.getHeightWidth().width - this.constants_.DARK_PATH_OFFSET)),
                    this.bottomRow.baseline = oe - this.bottomRow.descenderHeight,
                    this.widthWithChildren = Q + this.startX + this.constants_.DARK_PATH_OFFSET,
                    this.width += this.constants_.DARK_PATH_OFFSET,
                    this.height = oe + this.constants_.DARK_PATH_OFFSET,
                    this.startY = this.topRow.capline
                }
            }
              , $E = class extends Lc {
                constructor(Q, oe, pe) {
                    super(Q, oe, pe),
                    this.constants = pe,
                    this.colourDark = "#000000",
                    this.svgPathDark = $t(bt.PATH, {
                        class: "blocklyPathDark",
                        transform: "translate(1,1)"
                    }),
                    this.svgRoot.insertBefore(this.svgPathDark, this.svgPath),
                    this.svgPathLight = $t(bt.PATH, {
                        class: "blocklyPathLight"
                    }, this.svgRoot)
                }
                setPath(Q) {
                    this.svgPath.setAttribute("d", Q),
                    this.svgPathDark.setAttribute("d", Q)
                }
                setHighlightPath(Q) {
                    this.svgPathLight.setAttribute("d", Q)
                }
                flipRTL() {
                    this.svgPath.setAttribute("transform", "scale(-1 1)"),
                    this.svgPathLight.setAttribute("transform", "scale(-1 1)"),
                    this.svgPathDark.setAttribute("transform", "translate(1,1) scale(-1 1)")
                }
                applyColour(Q) {
                    if (this.svgPathLight.style.display = "",
                    this.svgPathDark.style.display = "",
                    !this.style.colourTertiary)
                        throw Error("The renderer did not properly initialize the tertiary colour of the block style");
                    this.svgPathLight.setAttribute("stroke", this.style.colourTertiary),
                    this.svgPathDark.setAttribute("fill", this.colourDark),
                    super.applyColour(Q),
                    this.svgPath.setAttribute("stroke", "none")
                }
                setStyle(Q) {
                    this.style = Q,
                    this.colourDark = Ho("#000", this.style.colourPrimary, .2) || this.colourDark
                }
                updateHighlighted(Q) {
                    Q ? (this.svgPath.setAttribute("filter", "url(#" + this.constants.embossFilterId + ")"),
                    this.svgPathLight.style.display = "none") : (this.svgPath.setAttribute("filter", "none"),
                    this.svgPathLight.style.display = "inline")
                }
                updateShadow_(Q) {
                    if (Q) {
                        if (this.svgPathLight.style.display = "none",
                        !this.style.colourSecondary)
                            throw Error("The renderer did not properly initialize the secondary colour of the block style block style");
                        this.svgPathDark.setAttribute("fill", this.style.colourSecondary),
                        this.svgPath.setAttribute("stroke", "none"),
                        this.svgPath.setAttribute("fill", this.style.colourSecondary)
                    }
                }
                updateDisabled_(Q) {
                    super.updateDisabled_(Q),
                    Q && this.svgPath.setAttribute("stroke", "none")
                }
            }
              , OE = class extends dl {
                constructor(Q) {
                    super(Q),
                    this.highlightConstants = null
                }
                init(Q, oe) {
                    super.init(Q, oe),
                    this.highlightConstants = this.makeHighlightConstants_(),
                    this.highlightConstants.init()
                }
                refreshDom(Q, oe) {
                    super.refreshDom(Q, oe),
                    this.getHighlightConstants().init()
                }
                makeConstants_() {
                    return new AE
                }
                makeRenderInfo_(Q) {
                    return new bE(this,Q)
                }
                makeDrawer_(Q, oe) {
                    return new SE(Q,oe)
                }
                makePathObject(Q, oe) {
                    return new $E(Q,oe,this.getConstants())
                }
                makeHighlightConstants_() {
                    return new IE(this.getConstants())
                }
                getHighlightConstants() {
                    if (!this.highlightConstants)
                        throw Error("Cannot access the highlight constants because init has not been called");
                    return this.highlightConstants
                }
            }
            ;
            Mi("geras", OE);
            var ks = {};
            ks.ConstantProvider = AE,
            ks.Drawer = SE,
            ks.HighlightConstantProvider = IE,
            ks.Highlighter = _E,
            ks.InlineInput = RE,
            ks.PathObject = $E,
            ks.RenderInfo = bE,
            ks.Renderer = OE,
            ks.StatementInput = yE;
            var CE = class extends cl {
                constructor() {
                    super(),
                    zt("Blockly.minimalist.ConstantProvider", "v10", "v11", "Blockly.blockRendering.ConstantProvider")
                }
            }
              , vE = class extends ul {
                constructor(Q, oe) {
                    super(Q, oe),
                    zt("Blockly.minimalist.Drawer", "v10", "v11", "Blockly.blockRendering.Drawer")
                }
            }
              , xE = class extends ia {
                constructor(Q, oe) {
                    super(Q, oe),
                    zt("Blockly.minimalist.RenderInfo", "v10", "v11", "Blockly.blockRendering.RenderInfo")
                }
                getRenderer() {
                    return this.renderer_
                }
            }
              , NE = class extends dl {
                constructor(Q) {
                    super(Q),
                    zt("Blockly.minimalist.Renderer", "v10", "v11", "Blockly.blockRendering.Renderer")
                }
                makeConstants_() {
                    return new CE
                }
                makeRenderInfo_(Q) {
                    return new xE(this,Q)
                }
                makeDrawer_(Q, oe) {
                    return new vE(Q,oe)
                }
            }
            ;
            Mi("minimalist", NE);
            var Tl = {};
            Tl.ConstantProvider = CE,
            Tl.Drawer = vE,
            Tl.RenderInfo = xE,
            Tl.Renderer = NE;
            var LE = class extends ia {
                constructor(Q, oe) {
                    super(Q, oe)
                }
                getRenderer() {
                    return this.renderer_
                }
                addElemSpacing_() {
                    let Q = !1;
                    for (var oe = 0; oe < this.rows.length; oe++)
                        if (this.rows[oe].hasExternalInput) {
                            Q = !0;
                            break
                        }
                    for (oe = 0; oe < this.rows.length; oe++) {
                        const Ae = this.rows[oe];
                        var pe = Ae.elements;
                        if (Ae.elements = [],
                        Ae.startsWithElemSpacer() && Ae.elements.push(new Gr(this.constants_,this.getInRowSpacing_(null, pe[0]))),
                        pe.length) {
                            for (let Re = 0; Re < pe.length - 1; Re++) {
                                Ae.elements.push(pe[Re]);
                                const Ue = this.getInRowSpacing_(pe[Re], pe[Re + 1]);
                                Ae.elements.push(new Gr(this.constants_,Ue))
                            }
                            Ae.elements.push(pe[pe.length - 1]),
                            Ae.endsWithElemSpacer() && (pe = this.getInRowSpacing_(pe[pe.length - 1], null),
                            Q && Ae.hasDummyInput && (pe += this.constants_.TAB_WIDTH),
                            Ae.elements.push(new Gr(this.constants_,pe)))
                        }
                    }
                }
                getInRowSpacing_(Q, oe) {
                    if (!Q)
                        return oe && Rt.isField(oe) && oe.isEditable ? this.constants_.MEDIUM_PADDING : oe && Rt.isInlineInput(oe) ? this.constants_.MEDIUM_LARGE_PADDING : oe && Rt.isStatementInput(oe) ? this.constants_.STATEMENT_INPUT_PADDING_LEFT : this.constants_.LARGE_PADDING;
                    if (!Rt.isInput(Q) && !oe)
                        return Rt.isField(Q) && Q.isEditable ? this.constants_.MEDIUM_PADDING : Rt.isIcon(Q) ? 2 * this.constants_.LARGE_PADDING + 1 : Rt.isHat(Q) ? this.constants_.NO_PADDING : Rt.isPreviousOrNextConnection(Q) ? this.constants_.LARGE_PADDING : Rt.isLeftRoundedCorner(Q) ? this.constants_.MIN_BLOCK_WIDTH : Rt.isJaggedEdge(Q) ? this.constants_.NO_PADDING : this.constants_.LARGE_PADDING;
                    if (Rt.isInput(Q) && !oe) {
                        if (Rt.isExternalInput(Q))
                            return this.constants_.NO_PADDING;
                        if (Rt.isInlineInput(Q))
                            return this.constants_.LARGE_PADDING;
                        if (Rt.isStatementInput(Q))
                            return this.constants_.NO_PADDING
                    }
                    if (!Rt.isInput(Q) && oe && Rt.isInput(oe)) {
                        if (Rt.isField(Q) && Q.isEditable) {
                            if (Rt.isInlineInput(oe) || Rt.isExternalInput(oe))
                                return this.constants_.SMALL_PADDING
                        } else {
                            if (Rt.isInlineInput(oe) || Rt.isExternalInput(oe))
                                return this.constants_.MEDIUM_LARGE_PADDING;
                            if (Rt.isStatementInput(oe))
                                return this.constants_.LARGE_PADDING
                        }
                        return this.constants_.LARGE_PADDING - 1
                    }
                    if (Rt.isIcon(Q) && oe && !Rt.isInput(oe))
                        return this.constants_.LARGE_PADDING;
                    if (Rt.isInlineInput(Q) && oe && Rt.isField(oe))
                        return oe.isEditable ? this.constants_.MEDIUM_PADDING : this.constants_.LARGE_PADDING;
                    if (Rt.isLeftSquareCorner(Q) && oe) {
                        if (Rt.isHat(oe))
                            return this.constants_.NO_PADDING;
                        if (Rt.isPreviousConnection(oe) || Rt.isNextConnection(oe))
                            return oe.notchOffset
                    }
                    return Rt.isLeftRoundedCorner(Q) && oe ? oe.notchOffset - this.constants_.CORNER_RADIUS : Rt.isField(Q) && oe && Rt.isField(oe) && Q.isEditable === oe.isEditable || oe && Rt.isJaggedEdge(oe) ? this.constants_.LARGE_PADDING : this.constants_.MEDIUM_PADDING
                }
                getSpacerRowHeight_(Q, oe) {
                    return Rt.isTopRow(Q) && Rt.isBottomRow(oe) ? this.constants_.EMPTY_BLOCK_SPACER_HEIGHT : Rt.isTopRow(Q) || Rt.isBottomRow(oe) ? this.constants_.NO_PADDING : Q.hasExternalInput && oe.hasExternalInput ? this.constants_.LARGE_PADDING : !Q.hasStatement && oe.hasStatement ? this.constants_.BETWEEN_STATEMENT_PADDING_Y : Q.hasStatement && oe.hasStatement || Q.hasDummyInput || oe.hasDummyInput ? this.constants_.LARGE_PADDING : this.constants_.MEDIUM_PADDING
                }
                getElemCenterline_(Q, oe) {
                    if (Rt.isSpacer(oe))
                        return Q.yPos + oe.height / 2;
                    if (Rt.isBottomRow(Q))
                        return Q = Q.yPos + Q.height - Q.descenderHeight,
                        Rt.isNextConnection(oe) ? Q + oe.height / 2 : Q - oe.height / 2;
                    if (Rt.isTopRow(Q))
                        return Rt.isHat(oe) ? Q.capline - oe.height / 2 : Q.capline + oe.height / 2;
                    let pe = Q.yPos;
                    return pe = Rt.isField(oe) && Q.hasStatement ? pe + (this.constants_.TALL_INPUT_FIELD_OFFSET_Y + oe.height / 2) : pe + Q.height / 2
                }
                finalize_() {
                    let Q = 0
                      , oe = 0;
                    for (var pe = 0; pe < this.rows.length; pe++) {
                        const Re = this.rows[pe];
                        Re.yPos = oe,
                        Re.xPos = this.startX,
                        oe += Re.height,
                        Q = Math.max(Q, Re.widthWithConnectedBlocks);
                        var Ae = oe - this.topRow.ascenderHeight;
                        Re === this.bottomRow && Ae < this.constants_.MIN_BLOCK_HEIGHT && (Ae = this.constants_.MIN_BLOCK_HEIGHT - Ae,
                        this.bottomRow.height += Ae,
                        oe += Ae),
                        this.recordElemPositions_(Re)
                    }
                    this.outputConnection && this.block_.nextConnection && this.block_.nextConnection.isConnected() && (pe = this.block_.nextConnection.targetBlock()) && (Q = Math.max(Q, pe.getHeightWidth().width)),
                    this.bottomRow.baseline = oe - this.bottomRow.descenderHeight,
                    this.widthWithChildren = Q + this.startX,
                    this.height = oe,
                    this.startY = this.topRow.capline
                }
            }
              , PE = class extends dl {
                constructor(Q) {
                    super(Q)
                }
                makeRenderInfo_(Q) {
                    return new LE(this,Q)
                }
            }
            ;
            Mi("thrasos", PE);
            var gp = {};
            gp.RenderInfo = LE,
            gp.Renderer = PE;
            var NT = {
                colour_blocks: {
                    colourPrimary: "#CF63CF",
                    colourSecondary: "#C94FC9",
                    colourTertiary: "#BD42BD"
                },
                list_blocks: {
                    colourPrimary: "#9966FF",
                    colourSecondary: "#855CD6",
                    colourTertiary: "#774DCB"
                },
                logic_blocks: {
                    colourPrimary: "#4C97FF",
                    colourSecondary: "#4280D7",
                    colourTertiary: "#3373CC"
                },
                loop_blocks: {
                    colourPrimary: "#0fBD8C",
                    colourSecondary: "#0DA57A",
                    colourTertiary: "#0B8E69"
                },
                math_blocks: {
                    colourPrimary: "#59C059",
                    colourSecondary: "#46B946",
                    colourTertiary: "#389438"
                },
                procedure_blocks: {
                    colourPrimary: "#FF6680",
                    colourSecondary: "#FF4D6A",
                    colourTertiary: "#FF3355"
                },
                text_blocks: {
                    colourPrimary: "#FFBF00",
                    colourSecondary: "#E6AC00",
                    colourTertiary: "#CC9900"
                },
                variable_blocks: {
                    colourPrimary: "#FF8C1A",
                    colourSecondary: "#FF8000",
                    colourTertiary: "#DB6E00"
                },
                variable_dynamic_blocks: {
                    colourPrimary: "#FF8C1A",
                    colourSecondary: "#FF8000",
                    colourTertiary: "#DB6E00"
                },
                hat_blocks: {
                    colourPrimary: "#4C97FF",
                    colourSecondary: "#4280D7",
                    colourTertiary: "#3373CC",
                    hat: "cap"
                }
            }
              , LT = {
                colour_category: {
                    colour: "#CF63CF"
                },
                list_category: {
                    colour: "#9966FF"
                },
                logic_category: {
                    colour: "#4C97FF"
                },
                loop_category: {
                    colour: "#0fBD8C"
                },
                math_category: {
                    colour: "#59C059"
                },
                procedure_category: {
                    colour: "#FF6680"
                },
                text_category: {
                    colour: "#FFBF00"
                },
                variable_category: {
                    colour: "#FF8C1A"
                },
                variable_dynamic_category: {
                    colour: "#FF8C1A"
                }
            }
              , PT = new ii("zelos",NT,LT)
              , MT = {
                Classic: bc,
                Zelos: PT
            }
              , Ep = class {
                constructor(Q, oe, pe) {
                    this.id_ = Q.toolboxitemid || at(),
                    this.level_ = (this.parent_ = pe || null) ? this.parent_.getLevel() + 1 : 0,
                    this.toolboxItemDef_ = Q,
                    this.parentToolbox_ = oe,
                    this.workspace_ = this.parentToolbox_.getWorkspace()
                }
                init() {}
                getDiv() {
                    return null
                }
                getClickTarget() {
                    return null
                }
                getId() {
                    return this.id_
                }
                getParent() {
                    return null
                }
                getLevel() {
                    return this.level_
                }
                isSelectable() {
                    return !1
                }
                isCollapsible() {
                    return !1
                }
                dispose() {}
                setVisible_(Q) {}
            }
              , hs = class extends Ep {
                constructor(Q, oe, pe) {
                    super(Q, oe, pe),
                    this.colour_ = this.name_ = "",
                    this.labelDom_ = this.iconDom_ = this.rowContents_ = this.rowDiv_ = this.htmlDiv_ = null,
                    this.isDisabled_ = this.isHidden_ = !1,
                    this.flyoutItems_ = [],
                    this.cssConfig_ = this.makeDefaultCssConfig_()
                }
                init() {
                    this.parseCategoryDef_(this.toolboxItemDef_),
                    this.parseContents_(this.toolboxItemDef_),
                    this.createDom_(),
                    this.toolboxItemDef_.hidden === "true" && this.hide()
                }
                makeDefaultCssConfig_() {
                    return {
                        container: "blocklyToolboxCategory",
                        row: "blocklyTreeRow",
                        rowcontentcontainer: "blocklyTreeRowContentContainer",
                        icon: "blocklyTreeIcon",
                        label: "blocklyTreeLabel",
                        contents: "blocklyToolboxContents",
                        selected: "blocklyTreeSelected",
                        openicon: "blocklyTreeIconOpen",
                        closedicon: "blocklyTreeIconClosed"
                    }
                }
                parseContents_(Q) {
                    if ("custom"in Q)
                        this.flyoutItems_ = Q.custom;
                    else if (Q = Q.contents)
                        for (let oe = 0; oe < Q.length; oe++) {
                            const pe = Q[oe];
                            Array.isArray(this.flyoutItems_) && this.flyoutItems_.push(pe)
                        }
                }
                parseCategoryDef_(Q) {
                    this.name_ = "name"in Q ? rr(Q.name) : "",
                    this.colour_ = this.getColour_(Q),
                    Object.assign(this.cssConfig_, Q.cssconfig || Q.cssConfig)
                }
                createDom_() {
                    this.htmlDiv_ = this.createContainer_(),
                    rs(this.htmlDiv_, Mr.TREEITEM),
                    Jn(this.htmlDiv_, Xn.SELECTED, !1),
                    Jn(this.htmlDiv_, Xn.LEVEL, this.level_ + 1),
                    this.rowDiv_ = this.createRowContainer_(),
                    this.rowDiv_.style.pointerEvents = "auto",
                    this.htmlDiv_.appendChild(this.rowDiv_),
                    this.rowContents_ = this.createRowContentsContainer_(),
                    this.rowContents_.style.pointerEvents = "none",
                    this.rowDiv_.appendChild(this.rowContents_),
                    this.iconDom_ = this.createIconDom_(),
                    rs(this.iconDom_, Mr.PRESENTATION),
                    this.rowContents_.appendChild(this.iconDom_),
                    this.labelDom_ = this.createLabelDom_(this.name_),
                    this.rowContents_.appendChild(this.labelDom_);
                    const Q = this.labelDom_.getAttribute("id");
                    return Q && Jn(this.htmlDiv_, Xn.LABELLEDBY, Q),
                    this.addColourBorder_(this.colour_),
                    this.htmlDiv_
                }
                createContainer_() {
                    const Q = document.createElement("div")
                      , oe = this.cssConfig_.container;
                    return oe && Ut(Q, oe),
                    Q
                }
                createRowContainer_() {
                    const Q = document.createElement("div");
                    var oe = this.cssConfig_.row;
                    return oe && Ut(Q, oe),
                    oe = `${hs.nestedPadding * this.getLevel()}px`,
                    this.workspace_.RTL ? Q.style.paddingRight = oe : Q.style.paddingLeft = oe,
                    Q
                }
                createRowContentsContainer_() {
                    const Q = document.createElement("div")
                      , oe = this.cssConfig_.rowcontentcontainer;
                    return oe && Ut(Q, oe),
                    Q
                }
                createIconDom_() {
                    const Q = document.createElement("span");
                    if (!this.parentToolbox_.isHorizontal()) {
                        const oe = this.cssConfig_.icon;
                        oe && Ut(Q, oe)
                    }
                    return Q.style.display = "inline-block",
                    Q
                }
                createLabelDom_(Q) {
                    const oe = document.createElement("span");
                    return oe.setAttribute("id", this.getId() + ".label"),
                    oe.textContent = Q,
                    (Q = this.cssConfig_.label) && Ut(oe, Q),
                    oe
                }
                refreshTheme() {
                    this.colour_ = this.getColour_(this.toolboxItemDef_),
                    this.addColourBorder_(this.colour_)
                }
                addColourBorder_(Q) {
                    Q && (Q = hs.borderWidth + "px solid " + (Q || "#ddd"),
                    this.workspace_.RTL ? this.rowDiv_.style.borderRight = Q : this.rowDiv_.style.borderLeft = Q)
                }
                getColour_(Q) {
                    const oe = Q.categorystyle || Q.categoryStyle;
                    if ((Q = Q.colour) && oe)
                        console.warn('Toolbox category "' + this.name_ + '" must not have both a style and a colour');
                    else {
                        if (oe)
                            return this.getColourfromStyle_(oe);
                        if (Q)
                            return this.parseColour_(Q)
                    }
                    return ""
                }
                getColourfromStyle_(Q) {
                    var oe = this.workspace_.getTheme();
                    if (Q && oe) {
                        if ((oe = oe.categoryStyles[Q]) && oe.colour)
                            return this.parseColour_(oe.colour);
                        console.warn('Style "' + Q + '" must exist and contain a colour value')
                    }
                    return ""
                }
                getClickTarget() {
                    return this.rowDiv_
                }
                parseColour_(Q) {
                    if (Q = rr(Q),
                    Q == null || Q === "")
                        return "";
                    var oe = Number(Q);
                    return isNaN(oe) ? (oe = ho(Q)) ? oe : (console.warn('Toolbox category "' + this.name_ + '" has unrecognized colour attribute: ' + Q),
                    "") : Vu(oe)
                }
                openIcon_(Q) {
                    if (Q) {
                        var oe = this.cssConfig_.closedicon;
                        oe && An(Q, oe),
                        (oe = this.cssConfig_.openicon) && Ut(Q, oe)
                    }
                }
                closeIcon_(Q) {
                    if (Q) {
                        var oe = this.cssConfig_.openicon;
                        oe && An(Q, oe),
                        (oe = this.cssConfig_.closedicon) && Ut(Q, oe)
                    }
                }
                setVisible_(Q) {
                    this.htmlDiv_.style.display = Q ? "block" : "none",
                    this.isHidden_ = !Q,
                    this.parentToolbox_.getSelectedItem() === this && this.parentToolbox_.clearSelection()
                }
                hide() {
                    this.setVisible_(!1)
                }
                show() {
                    this.setVisible_(!0)
                }
                isVisible() {
                    return !this.isHidden_ && this.allAncestorsExpanded_()
                }
                allAncestorsExpanded_() {
                    let Q = this;
                    for (; Q.getParent(); )
                        if (Q = Q.getParent(),
                        !Q.isExpanded())
                            return !1;
                    return !0
                }
                isSelectable() {
                    return this.isVisible() && !this.isDisabled_
                }
                onClick(Q) {}
                setSelected(Q) {
                    if (this.rowDiv_) {
                        var oe = this.cssConfig_.selected;
                        if (Q) {
                            const pe = this.parseColour_(hs.defaultBackgroundColour);
                            this.rowDiv_.style.backgroundColor = this.colour_ || pe,
                            oe && Ut(this.rowDiv_, oe)
                        } else
                            this.rowDiv_.style.backgroundColor = "",
                            oe && yt(this.rowDiv_, oe);
                        Jn(this.htmlDiv_, Xn.SELECTED, Q)
                    }
                }
                setDisabled(Q) {
                    this.isDisabled_ = Q,
                    this.getDiv().setAttribute("disabled", `${Q}`),
                    Q ? this.getDiv().setAttribute("disabled", "true") : this.getDiv().removeAttribute("disabled")
                }
                getName() {
                    return this.name_
                }
                getParent() {
                    return this.parent_
                }
                getDiv() {
                    return this.htmlDiv_
                }
                getContents() {
                    return this.flyoutItems_
                }
                updateFlyoutContents(Q) {
                    this.flyoutItems_ = [],
                    this.toolboxItemDef_ = typeof Q == "string" ? {
                        kind: this.toolboxItemDef_.kind,
                        custom: Q,
                        id: this.toolboxItemDef_.id,
                        categorystyle: this.toolboxItemDef_.categorystyle,
                        colour: this.toolboxItemDef_.colour,
                        cssconfig: this.toolboxItemDef_.cssconfig,
                        hidden: this.toolboxItemDef_.hidden
                    } : {
                        kind: this.toolboxItemDef_.kind,
                        name: "name"in this.toolboxItemDef_ ? this.toolboxItemDef_.name : "",
                        contents: fn(Q),
                        id: this.toolboxItemDef_.id,
                        categorystyle: this.toolboxItemDef_.categorystyle,
                        colour: this.toolboxItemDef_.colour,
                        cssconfig: this.toolboxItemDef_.cssconfig,
                        hidden: this.toolboxItemDef_.hidden
                    },
                    this.parseContents_(this.toolboxItemDef_)
                }
                dispose() {
                    Bt(this.htmlDiv_)
                }
            }
            ;
            hs.registrationName = "category",
            hs.nestedPadding = 19,
            hs.borderWidth = 8,
            hs.defaultBackgroundColour = "#57e",
            Qt(`
.blocklyTreeRow:not(.blocklyTreeSelected):hover {
  background-color: rgba(255, 255, 255, .2);
}

.blocklyToolboxDiv[layout="h"] .blocklyToolboxCategory {
  margin: 1px 5px 1px 0;
}

.blocklyToolboxDiv[dir="RTL"][layout="h"] .blocklyToolboxCategory {
  margin: 1px 0 1px 5px;
}

.blocklyTreeRow {
  height: 22px;
  line-height: 22px;
  margin-bottom: 3px;
  padding-right: 8px;
  white-space: nowrap;
}

.blocklyToolboxDiv[dir="RTL"] .blocklyTreeRow {
  margin-left: 8px;
  padding-right: 0;
}

.blocklyTreeIcon {
  background-image: url(<<<PATH>>>/sprites.png);
  height: 16px;
  vertical-align: middle;
  visibility: hidden;
  width: 16px;
}

.blocklyTreeIconClosed {
  background-position: -32px -1px;
}

.blocklyToolboxDiv[dir="RTL"] .blocklyTreeIconClosed {
  background-position: 0 -1px;
}

.blocklyTreeSelected>.blocklyTreeIconClosed {
  background-position: -32px -17px;
}

.blocklyToolboxDiv[dir="RTL"] .blocklyTreeSelected>.blocklyTreeIconClosed {
  background-position: 0 -17px;
}

.blocklyTreeIconOpen {
  background-position: -16px -1px;
}

.blocklyTreeSelected>.blocklyTreeIconOpen {
  background-position: -16px -17px;
}

.blocklyTreeLabel {
  cursor: default;
  font: 16px sans-serif;
  padding: 0 3px;
  vertical-align: middle;
}

.blocklyToolboxDelete .blocklyTreeLabel {
  cursor: url("<<<PATH>>>/handdelete.cur"), auto;
}

.blocklyTreeSelected .blocklyTreeLabel {
  color: #fff;
}
`),
            ne(Yt.TOOLBOX_ITEM, hs.registrationName, hs);
            var Al = class extends Ep {
                constructor(Q, oe) {
                    super(Q, oe),
                    this.cssConfig_ = {
                        container: "blocklyTreeSeparator"
                    },
                    this.htmlDiv_ = null,
                    Object.assign(this.cssConfig_, Q.cssconfig || Q.cssConfig)
                }
                init() {
                    this.createDom_()
                }
                createDom_() {
                    const Q = document.createElement("div")
                      , oe = this.cssConfig_.container;
                    return oe && Ut(Q, oe),
                    this.htmlDiv_ = Q
                }
                getDiv() {
                    return this.htmlDiv_
                }
                dispose() {
                    Bt(this.htmlDiv_)
                }
            }
            ;
            Al.registrationName = "sep",
            Qt(`
.blocklyTreeSeparator {
  border-bottom: solid #e5e5e5 1px;
  height: 0;
  margin: 5px 0;
}

.blocklyToolboxDiv[layout="h"] .blocklyTreeSeparator {
  border-right: solid #e5e5e5 1px;
  border-bottom: none;
  height: auto;
  margin: 0 5px 0 5px;
  padding: 5px 0;
  width: 0;
}
`),
            ne(Yt.TOOLBOX_ITEM, Al.registrationName, Al);
            var ma = class extends hs {
                constructor(Q, oe, pe) {
                    super(Q, oe, pe),
                    this.subcategoriesDiv_ = null,
                    this.expanded_ = !1,
                    this.toolboxItems_ = []
                }
                makeDefaultCssConfig_() {
                    const Q = super.makeDefaultCssConfig_();
                    return Q.contents = "blocklyToolboxContents",
                    Q
                }
                parseContents_(Q) {
                    if ("custom"in Q)
                        this.flyoutItems_ = Q.custom;
                    else {
                        const oe = Q.contents;
                        if (oe) {
                            this.flyoutItems_ = [],
                            Q = !0;
                            for (let pe = 0; pe < oe.length; pe++) {
                                const Ae = oe[pe];
                                !ge(Yt.TOOLBOX_ITEM, Ae.kind) || Ae.kind.toLowerCase() === Al.registrationName && Q ? (this.flyoutItems_.push(Ae),
                                Q = !0) : (this.createToolboxItem_(Ae),
                                Q = !1)
                            }
                        }
                    }
                }
                createToolboxItem_(Q) {
                    let oe = Q.kind;
                    oe.toUpperCase() === "CATEGORY" && Kn(Q) && (oe = ma.registrationName),
                    Q = new (Te(Yt.TOOLBOX_ITEM, oe))(Q,this.parentToolbox_,this),
                    this.toolboxItems_.push(Q)
                }
                init() {
                    super.init(),
                    this.setExpanded(this.toolboxItemDef_.expanded === "true" || this.toolboxItemDef_.expanded === !0)
                }
                createDom_() {
                    super.createDom_();
                    const Q = this.getChildToolboxItems();
                    return this.subcategoriesDiv_ = this.createSubCategoriesDom_(Q),
                    rs(this.subcategoriesDiv_, Mr.GROUP),
                    this.htmlDiv_.appendChild(this.subcategoriesDiv_),
                    this.closeIcon_(this.iconDom_),
                    Jn(this.htmlDiv_, Xn.EXPANDED, !1),
                    this.htmlDiv_
                }
                createIconDom_() {
                    const Q = document.createElement("span");
                    if (!this.parentToolbox_.isHorizontal()) {
                        const oe = this.cssConfig_.icon;
                        oe && Ut(Q, oe),
                        Q.style.visibility = "visible"
                    }
                    return Q.style.display = "inline-block",
                    Q
                }
                createSubCategoriesDom_(Q) {
                    const oe = document.createElement("div");
                    oe.style.display = "none";
                    var pe = this.cssConfig_.contents;
                    for (pe && Ut(oe, pe),
                    pe = 0; pe < Q.length; pe++) {
                        const Ae = Q[pe];
                        Ae.init();
                        const Re = Ae.getDiv();
                        if (oe.appendChild(Re),
                        Ae.getClickTarget) {
                            let Ue;
                            (Ue = Ae.getClickTarget()) == null || Ue.setAttribute("id", Ae.getId())
                        }
                    }
                    return oe
                }
                setExpanded(Q) {
                    if (this.expanded_ !== Q) {
                        if (this.expanded_ = Q)
                            this.subcategoriesDiv_.style.display = "block",
                            this.openIcon_(this.iconDom_);
                        else {
                            let oe;
                            (oe = this.parentToolbox_.getFlyout()) == null || oe.setVisible(!1),
                            this.subcategoriesDiv_.style.display = "none",
                            this.closeIcon_(this.iconDom_)
                        }
                        Jn(this.htmlDiv_, Xn.EXPANDED, Q),
                        this.parentToolbox_.handleToolboxItemResize()
                    }
                }
                setVisible_(Q) {
                    this.htmlDiv_.style.display = Q ? "block" : "none";
                    const oe = this.getChildToolboxItems();
                    for (let pe = 0; pe < oe.length; pe++)
                        oe[pe].setVisible_(Q);
                    this.isHidden_ = !Q,
                    this.parentToolbox_.getSelectedItem() === this && this.parentToolbox_.clearSelection()
                }
                isExpanded() {
                    return this.expanded_
                }
                isCollapsible() {
                    return !0
                }
                onClick(Q) {
                    this.toggleExpanded()
                }
                toggleExpanded() {
                    this.setExpanded(!this.expanded_)
                }
                getDiv() {
                    return this.htmlDiv_
                }
                getChildToolboxItems() {
                    return this.toolboxItems_
                }
            }
            ;
            ma.registrationName = "collapsibleCategory",
            ne(Yt.TOOLBOX_ITEM, ma.registrationName, ma);
            var ME = class extends Mc {
                constructor(Q) {
                    super(),
                    this.id = "toolbox",
                    this.contentsDiv_ = this.HtmlDiv = null,
                    this.isVisible_ = !1,
                    this.contents_ = [],
                    this.height_ = this.width_ = 0,
                    this.previouslySelectedItem_ = this.selectedItem_ = this.flyout_ = null,
                    this.boundEvents_ = [],
                    this.workspace_ = Q,
                    this.toolboxDef_ = Q.options.languageTree || {
                        contents: []
                    },
                    this.horizontalLayout_ = Q.options.horizontalLayout,
                    this.RTL = Q.options.RTL,
                    this.contentMap_ = Object.create(null),
                    this.toolboxPosition = Q.options.toolboxPosition
                }
                onShortcut(Q) {
                    return !1
                }
                init() {
                    var Q = this.workspace_;
                    const oe = Q.getParentSvg();
                    this.flyout_ = this.createFlyout_(),
                    this.HtmlDiv = this.createDom_(this.workspace_),
                    Wt(this.flyout_.createDom("svg"), oe),
                    this.setVisible(!0),
                    this.flyout_.init(Q),
                    this.render(this.toolboxDef_),
                    Q = Q.getThemeManager(),
                    Q.subscribe(this.HtmlDiv, "toolboxBackgroundColour", "background-color"),
                    Q.subscribe(this.HtmlDiv, "toolboxForegroundColour", "color"),
                    this.workspace_.getComponentManager().addComponent({
                        component: this,
                        weight: 1,
                        capabilities: [dr.Capability.AUTOHIDEABLE, dr.Capability.DELETE_AREA, dr.Capability.DRAG_TARGET]
                    })
                }
                createDom_(Q) {
                    Q = Q.getParentSvg();
                    const oe = this.createContainer_();
                    return this.contentsDiv_ = this.createContentsContainer_(),
                    this.contentsDiv_.tabIndex = 0,
                    rs(this.contentsDiv_, Mr.TREE),
                    oe.appendChild(this.contentsDiv_),
                    Q.parentNode.insertBefore(oe, Q),
                    this.attachEvents_(oe, this.contentsDiv_),
                    oe
                }
                createContainer_() {
                    const Q = document.createElement("div");
                    return Q.setAttribute("layout", this.isHorizontal() ? "h" : "v"),
                    Ut(Q, "blocklyToolboxDiv"),
                    Ut(Q, "blocklyNonSelectable"),
                    Q.setAttribute("dir", this.RTL ? "RTL" : "LTR"),
                    Q
                }
                createContentsContainer_() {
                    const Q = document.createElement("div");
                    return Ut(Q, "blocklyToolboxContents"),
                    this.isHorizontal() && (Q.style.flexDirection = "row"),
                    Q
                }
                attachEvents_(Q, oe) {
                    Q = vt(Q, "pointerdown", this, this.onClick_, !1),
                    this.boundEvents_.push(Q),
                    oe = vt(oe, "keydown", this, this.onKeyDown_, !1),
                    this.boundEvents_.push(oe)
                }
                onClick_(Q) {
                    if (nn(Q) || Q.target === this.HtmlDiv)
                        ke().hideChaff(!1);
                    else {
                        var oe = Q.target.getAttribute("id");
                        oe && (oe = this.getToolboxItemById(oe),
                        oe.isSelectable() && (this.setSelectedItem(oe),
                        oe.onClick(Q))),
                        ke().hideChaff(!0)
                    }
                    Kt()
                }
                onKeyDown_(Q) {
                    let oe = !1;
                    switch (Q.key) {
                    case "ArrowDown":
                        oe = this.selectNext_();
                        break;
                    case "ArrowUp":
                        oe = this.selectPrevious_();
                        break;
                    case "ArrowLeft":
                        oe = this.selectParent_();
                        break;
                    case "ArrowRight":
                        oe = this.selectChild_();
                        break;
                    case "Enter":
                    case " ":
                        this.selectedItem_ && this.selectedItem_.isCollapsible() && (this.selectedItem_.toggleExpanded(),
                        oe = !0);
                        break;
                    default:
                        oe = !1
                    }
                    !oe && this.selectedItem_ && this.selectedItem_.onKeyDown && (oe = this.selectedItem_.onKeyDown(Q)),
                    oe && Q.preventDefault()
                }
                createFlyout_() {
                    const Q = this.workspace_
                      , oe = new Qr({
                        parentWorkspace: Q,
                        rtl: Q.RTL,
                        oneBasedIndex: Q.options.oneBasedIndex,
                        horizontalLayout: Q.horizontalLayout,
                        renderer: Q.options.renderer,
                        rendererOverrides: Q.options.rendererOverrides,
                        move: {
                            scrollbars: !0
                        }
                    });
                    return oe.toolboxPosition = Q.options.toolboxPosition,
                    new (Q.horizontalLayout ? Ie(Yt.FLYOUTS_HORIZONTAL_TOOLBOX, Q.options, !0) : Ie(Yt.FLYOUTS_VERTICAL_TOOLBOX, Q.options, !0))(oe)
                }
                render(Q) {
                    this.toolboxDef_ = Q;
                    for (let oe = 0; oe < this.contents_.length; oe++) {
                        const pe = this.contents_[oe];
                        pe && pe.dispose()
                    }
                    this.contents_ = [],
                    this.contentMap_ = Object.create(null),
                    this.renderContents_(Q.contents),
                    this.position(),
                    this.handleToolboxItemResize()
                }
                renderContents_(Q) {
                    const oe = document.createDocumentFragment();
                    for (let pe = 0; pe < Q.length; pe++)
                        this.createToolboxItem_(Q[pe], oe);
                    this.contentsDiv_.appendChild(oe)
                }
                createToolboxItem_(Q, oe) {
                    var pe = Q.kind;
                    pe.toUpperCase() === "CATEGORY" && Kn(Q) && (pe = ma.registrationName),
                    (pe = Te(Yt.TOOLBOX_ITEM, pe.toLowerCase())) && (Q = new pe(Q,this),
                    Q.init(),
                    this.addToolboxItem_(Q),
                    (pe = Q.getDiv()) && oe.appendChild(pe),
                    Q.getClickTarget() && Q.getClickTarget().setAttribute("id", Q.getId()))
                }
                addToolboxItem_(Q) {
                    if (this.contents_.push(Q),
                    this.contentMap_[Q.getId()] = Q,
                    Q.isCollapsible()) {
                        Q = Q.getChildToolboxItems();
                        for (let oe = 0; oe < Q.length; oe++)
                            this.addToolboxItem_(Q[oe])
                    }
                }
                getToolboxItems() {
                    return this.contents_
                }
                addStyle(Q) {
                    Q && this.HtmlDiv && Ut(this.HtmlDiv, Q)
                }
                removeStyle(Q) {
                    Q && this.HtmlDiv && yt(this.HtmlDiv, Q)
                }
                getClientRect() {
                    if (!this.HtmlDiv || !this.isVisible_)
                        return null;
                    var Q = this.HtmlDiv.getBoundingClientRect();
                    const oe = Q.top
                      , pe = oe + Q.height
                      , Ae = Q.left;
                    return Q = Ae + Q.width,
                    this.toolboxPosition === In.TOP ? new Vn(-1e7,pe,-1e7,1e7) : this.toolboxPosition === In.BOTTOM ? new Vn(oe,1e7,-1e7,1e7) : this.toolboxPosition === In.LEFT ? new Vn(-1e7,1e7,-1e7,Q) : new Vn(-1e7,1e7,Ae,1e7)
                }
                wouldDelete(Q, oe) {
                    return Q instanceof Ls ? this.updateWouldDelete_(!Q.getParent() && Q.isDeletable()) : this.updateWouldDelete_(Q.isDeletable()),
                    this.wouldDelete_
                }
                onDragEnter(Q) {
                    this.updateCursorDeleteStyle_(!0)
                }
                onDragExit(Q) {
                    this.updateCursorDeleteStyle_(!1)
                }
                onDrop(Q) {
                    this.updateCursorDeleteStyle_(!1)
                }
                updateWouldDelete_(Q) {
                    Q !== this.wouldDelete_ && (this.updateCursorDeleteStyle_(!1),
                    this.wouldDelete_ = Q,
                    this.updateCursorDeleteStyle_(!0))
                }
                updateCursorDeleteStyle_(Q) {
                    const oe = this.wouldDelete_ ? "blocklyToolboxDelete" : "blocklyToolboxGrab";
                    Q ? this.addStyle(oe) : this.removeStyle(oe)
                }
                getToolboxItemById(Q) {
                    return this.contentMap_[Q] || null
                }
                getWidth() {
                    return this.width_
                }
                getHeight() {
                    return this.height_
                }
                getFlyout() {
                    return this.flyout_
                }
                getWorkspace() {
                    return this.workspace_
                }
                getSelectedItem() {
                    return this.selectedItem_
                }
                getPreviouslySelectedItem() {
                    return this.previouslySelectedItem_
                }
                isHorizontal() {
                    return this.horizontalLayout_
                }
                position() {
                    const Q = this.workspace_.getMetrics()
                      , oe = this.HtmlDiv;
                    oe && (this.horizontalLayout_ ? (oe.style.left = "0",
                    oe.style.height = "auto",
                    oe.style.width = "100%",
                    this.height_ = oe.offsetHeight,
                    this.width_ = Q.viewWidth,
                    this.toolboxPosition === In.TOP ? oe.style.top = "0" : oe.style.bottom = "0") : (this.toolboxPosition === In.RIGHT ? oe.style.right = "0" : oe.style.left = "0",
                    oe.style.height = "100%",
                    this.width_ = oe.offsetWidth,
                    this.height_ = Q.viewHeight),
                    this.flyout_.position())
                }
                handleToolboxItemResize() {
                    const Q = this.workspace_
                      , oe = this.HtmlDiv.getBoundingClientRect();
                    Q.translate(this.toolboxPosition === In.LEFT ? Q.scrollX + oe.width : Q.scrollX, this.toolboxPosition === In.TOP ? Q.scrollY + oe.height : Q.scrollY),
                    ze(Q)
                }
                clearSelection() {
                    this.setSelectedItem(null)
                }
                refreshTheme() {
                    for (let Q = 0; Q < this.contents_.length; Q++) {
                        const oe = this.contents_[Q];
                        oe.refreshTheme && oe.refreshTheme()
                    }
                }
                refreshSelection() {
                    this.selectedItem_ && this.selectedItem_.isSelectable() && this.selectedItem_.getContents().length && this.flyout_.show(this.selectedItem_.getContents())
                }
                setVisible(Q) {
                    this.isVisible_ !== Q && (this.HtmlDiv.style.display = Q ? "block" : "none",
                    this.isVisible_ = Q,
                    this.workspace_.recordDragTargets())
                }
                autoHide(Q) {
                    !Q && this.flyout_ && this.flyout_.autoClose && this.clearSelection()
                }
                setSelectedItem(Q) {
                    const oe = this.selectedItem_;
                    !Q && !oe || Q && !Cf(Q) || (this.shouldDeselectItem_(oe, Q) && oe !== null && this.deselectItem_(oe),
                    this.shouldSelectItem_(oe, Q) && Q !== null && this.selectItem_(oe, Q),
                    this.updateFlyout_(oe, Q),
                    this.fireSelectEvent_(oe, Q))
                }
                shouldDeselectItem_(Q, oe) {
                    return Q !== null && (!Q.isCollapsible() || Q !== oe)
                }
                shouldSelectItem_(Q, oe) {
                    return oe !== null && oe !== Q
                }
                deselectItem_(Q) {
                    this.selectedItem_ = null,
                    this.previouslySelectedItem_ = Q,
                    Q.setSelected(!1),
                    Jn(this.contentsDiv_, Xn.ACTIVEDESCENDANT, "")
                }
                selectItem_(Q, oe) {
                    this.selectedItem_ = oe,
                    this.previouslySelectedItem_ = Q,
                    oe.setSelected(!0),
                    Jn(this.contentsDiv_, Xn.ACTIVEDESCENDANT, oe.getId())
                }
                selectItemByPosition(Q) {
                    -1 < Q && Q < this.contents_.length && (Q = this.contents_[Q],
                    Q.isSelectable() && this.setSelectedItem(Q))
                }
                updateFlyout_(Q, oe) {
                    oe && (Q !== oe || oe.isCollapsible()) && oe.getContents().length ? (this.flyout_.show(oe.getContents()),
                    this.flyout_.scrollToStart()) : this.flyout_.hide()
                }
                fireSelectEvent_(Q, oe) {
                    const pe = Q && Q.getName();
                    let Ae = oe && oe.getName();
                    Q === oe && (Ae = null),
                    Q = new (gt(Hi))(pe,Ae,this.workspace_.id),
                    Ye(Q)
                }
                selectParent_() {
                    return this.selectedItem_ ? this.selectedItem_.isCollapsible() && this.selectedItem_.isExpanded() ? (this.selectedItem_.toggleExpanded(),
                    !0) : this.selectedItem_.getParent() && this.selectedItem_.getParent().isSelectable() ? (this.setSelectedItem(this.selectedItem_.getParent()),
                    !0) : !1 : !1
                }
                selectChild_() {
                    if (!this.selectedItem_ || !this.selectedItem_.isCollapsible())
                        return !1;
                    const Q = this.selectedItem_;
                    return Q.isExpanded() ? this.selectNext_() : Q.toggleExpanded(),
                    !0
                }
                selectNext_() {
                    if (!this.selectedItem_)
                        return !1;
                    let Q = this.contents_.indexOf(this.selectedItem_) + 1;
                    if (-1 < Q && Q < this.contents_.length) {
                        let oe = this.contents_[Q];
                        for (; oe && !oe.isSelectable(); )
                            oe = this.contents_[++Q];
                        if (oe && oe.isSelectable())
                            return this.setSelectedItem(oe),
                            !0
                    }
                    return !1
                }
                selectPrevious_() {
                    if (!this.selectedItem_)
                        return !1;
                    let Q = this.contents_.indexOf(this.selectedItem_) - 1;
                    if (-1 < Q && Q < this.contents_.length) {
                        let oe = this.contents_[Q];
                        for (; oe && !oe.isSelectable(); )
                            oe = this.contents_[--Q];
                        if (oe && oe.isSelectable())
                            return this.setSelectedItem(oe),
                            !0
                    }
                    return !1
                }
                dispose() {
                    this.workspace_.getComponentManager().removeComponent("toolbox"),
                    this.flyout_.dispose();
                    for (var Q = 0; Q < this.contents_.length; Q++)
                        this.contents_[Q].dispose();
                    for (Q = 0; Q < this.boundEvents_.length; Q++)
                        Ct(this.boundEvents_[Q]);
                    this.boundEvents_ = [],
                    this.contents_ = [],
                    this.HtmlDiv && (this.workspace_.getThemeManager().unsubscribe(this.HtmlDiv),
                    Bt(this.HtmlDiv))
                }
            }
            ;
            Qt(`
.blocklyToolboxDelete {
  cursor: url("<<<PATH>>>/handdelete.cur"), auto;
}

.blocklyToolboxGrab {
  cursor: url("<<<PATH>>>/handclosed.cur"), auto;
  cursor: grabbing;
  cursor: -webkit-grabbing;
}

/* Category tree in Toolbox. */
.blocklyToolboxDiv {
  background-color: #ddd;
  overflow-x: visible;
  overflow-y: auto;
  padding: 4px 0 4px 0;
  position: absolute;
  z-index: 70;  /* so blocks go under toolbox when dragging */
  -webkit-tap-highlight-color: transparent;  /* issue #1345 */
}

.blocklyToolboxContents {
  display: flex;
  flex-wrap: wrap;
  flex-direction: column;
}

.blocklyToolboxContents:focus {
  outline: none;
}
`),
            ne(Yt.TOOLBOX, js, ME);
            var kT = "10.3.0"
              , DT = J.Align$$module$build$src$core$inputs$align.LEFT
              , wT = J.Align$$module$build$src$core$inputs$align.CENTRE
              , BT = J.Align$$module$build$src$core$inputs$align.RIGHT
              , UT = pn.INPUT_VALUE
              , FT = pn.OUTPUT_VALUE
              , HT = pn.NEXT_STATEMENT
              , VT = pn.PREVIOUS_STATEMENT
              , GT = J.inputTypes$$module$build$src$core$inputs$input_types.DUMMY
              , jT = In.TOP
              , WT = In.BOTTOM
              , YT = In.LEFT
              , XT = In.RIGHT;
            hl.prototype.newBlock = function(Q, oe) {
                return new la(this,Q,oe)
            }
            ,
            cs.prototype.newBlock = function(Q, oe) {
                return new Ls(this,Q,oe)
            }
            ,
            cs.newTrashcan = function(Q) {
                return new qg(Q)
            }
            ,
            Er.prototype.showContextMenu = function(Q) {
                if (!this.workspace.options.readOnly) {
                    var oe = [];
                    this.isDeletable() && this.isMovable() && (oe.push(hu(this)),
                    oe.push(du(this))),
                    Pa(Q, oe, this.RTL)
                }
            }
            ,
            Zs.prototype.newWorkspaceSvg = function(Q) {
                return new cs(Q)
            }
            ,
            J.Names$$module$build$src$core$names.prototype.populateProcedures = function(Q) {
                Q = Kl(Q),
                Q = Q[0].concat(Q[1]);
                for (let oe = 0; oe < Q.length; oe++)
                    this.getName(Q[oe][0], J.Names$$module$build$src$core$names.NameType.PROCEDURE)
            }
            ;
            var zT = pn
              , Lt = {
                ALIGN_CENTRE: wT,
                ALIGN_LEFT: DT,
                ALIGN_RIGHT: BT
            };
            return Lt.ASTNode = jt,
            Lt.BasicCursor = pl,
            Lt.Block = la,
            Lt.BlockDragger = sE,
            Lt.BlockSvg = Ls,
            Lt.Blocks = Nr,
            Lt.Bubble = kn,
            Lt.BubbleDragger = _g,
            Lt.COLLAPSED_FIELD_NAME = Pc,
            Lt.COLLAPSED_INPUT_NAME = aa,
            Lt.COLLAPSE_CHARS = Sg,
            Lt.CodeGenerator = J.CodeGenerator$$module$build$src$core$generator,
            Lt.CollapsibleToolboxCategory = ma,
            Lt.ComponentManager = dr,
            Lt.Connection = Pn,
            Lt.ConnectionChecker = Yg,
            Lt.ConnectionDB = Ji,
            Lt.ConnectionType = pn,
            Lt.ContextMenu = Os,
            Lt.ContextMenuItems = $r,
            Lt.ContextMenuRegistry = Ln,
            Lt.Css = Xd,
            Lt.Cursor = Jh,
            Lt.DELETE_VARIABLE_ID = yh,
            Lt.DRAG_STACK = Ig,
            Lt.DUMMY_INPUT = GT,
            Lt.DeleteArea = Mc,
            Lt.DragTarget = Jg,
            Lt.DropDownDiv = Tr,
            Lt.Events = cn,
            Lt.Extensions = as,
            Lt.Field = vn,
            Lt.FieldAngle = $n,
            Lt.FieldCheckbox = hi,
            Lt.FieldColour = Yr,
            Lt.FieldDropdown = Cs,
            Lt.FieldImage = di,
            Lt.FieldLabel = ci,
            Lt.FieldLabelSerializable = mE,
            Lt.FieldMultilineInput = pp,
            Lt.FieldNumber = mp,
            Lt.FieldTextInput = ha,
            Lt.FieldVariable = El,
            Lt.Flyout = Hc,
            Lt.FlyoutButton = ds,
            Lt.FlyoutMetricsManager = fE,
            Lt.Generator = J.CodeGenerator$$module$build$src$core$generator,
            Lt.Gesture = Qs,
            Lt.Grid = vh,
            Lt.HorizontalFlyout = gE,
            Lt.INPUT_VALUE = UT,
            Lt.Input = xs,
            Lt.InsertionMarkerManager = Wr,
            Lt.Marker = zg,
            Lt.MarkerManager = rl,
            Lt.Menu = ph,
            Lt.MenuItem = mh,
            Lt.MetricsManager = np,
            Lt.Msg = J.Msg$$module$build$src$core$msg,
            Lt.NEXT_STATEMENT = HT,
            Lt.Names = J.Names$$module$build$src$core$names,
            Lt.OPPOSITE_TYPE = ri,
            Lt.OUTPUT_VALUE = FT,
            Lt.Options = Qr,
            Lt.PREVIOUS_STATEMENT = VT,
            Lt.PROCEDURE_CATEGORY_NAME = xc,
            Lt.Procedures = yr,
            Lt.RENAME_VARIABLE_ID = Rh,
            Lt.RenderedConnection = br,
            Lt.Scrollbar = or,
            Lt.ScrollbarPair = tp,
            Lt.ShortcutItems = Ms,
            Lt.ShortcutRegistry = Dn,
            Lt.TOOLBOX_AT_BOTTOM = WT,
            Lt.TOOLBOX_AT_LEFT = YT,
            Lt.TOOLBOX_AT_RIGHT = XT,
            Lt.TOOLBOX_AT_TOP = jT,
            Lt.TabNavigateCursor = Kg,
            Lt.Theme = ii,
            Lt.ThemeManager = Wg,
            Lt.Themes = MT,
            Lt.Toolbox = ME,
            Lt.ToolboxCategory = hs,
            Lt.ToolboxItem = Ep,
            Lt.ToolboxSeparator = Al,
            Lt.Tooltip = Hr,
            Lt.Touch = zo,
            Lt.Trashcan = qg,
            Lt.UnattachedFieldError = Gn,
            Lt.VARIABLE_CATEGORY_NAME = Zd,
            Lt.VARIABLE_DYNAMIC_CATEGORY_NAME = jh,
            Lt.VERSION = kT,
            Lt.VariableMap = Xh,
            Lt.VariableModel = Xa,
            Lt.Variables = gr,
            Lt.VariablesDynamic = ui,
            Lt.VerticalFlyout = fp,
            Lt.WidgetDiv = $s,
            Lt.Workspace = hl,
            Lt.WorkspaceAudio = Xg,
            Lt.WorkspaceComment = ys,
            Lt.WorkspaceCommentSvg = Er,
            Lt.WorkspaceDragger = Og,
            Lt.WorkspaceSvg = cs,
            Lt.Xml = Pr,
            Lt.ZoomControls = tg,
            Lt.blockAnimations = el,
            Lt.blockRendering = Bn,
            Lt.browserEvents = zs,
            Lt.bubbles = fl,
            Lt.bumpObjects = Bc,
            Lt.clipboard = ei,
            Lt.common = fr,
            Lt.config = J.config$$module$build$src$core$config,
            Lt.connectionTypes = zT,
            Lt.constants = _T,
            Lt.defineBlocksWithJsonArray = et,
            Lt.dialog = qo,
            Lt.fieldRegistry = Oc,
            Lt.geras = ks,
            Lt.getMainWorkspace = ke,
            Lt.getSelected = we,
            Lt.hasBubble = uo,
            Lt.hideChaff = vf,
            Lt.icons = Ro,
            Lt.inject = Af,
            Lt.inputTypes = J.inputTypes$$module$build$src$core$inputs$input_types,
            Lt.inputs = $o,
            Lt.isCopyable = Fa,
            Lt.isIcon = $f,
            Lt.isObservable = Wl,
            Lt.isPaster = Of,
            Lt.isSerializable = Nl,
            Lt.isVariableBackedParameterModel = io,
            Lt.minimalist = Tl,
            Lt.procedures = yr,
            Lt.registry = Ws,
            Lt.renderManagement = gc,
            Lt.serialization = xT,
            Lt.setLocale = qd,
            Lt.setParentContainer = Xe,
            Lt.svgResize = ze,
            Lt.thrasos = gp,
            Lt.uiPosition = Jo,
            Lt.utils = Zn,
            Lt.zelos = us,
            Object.defineProperties(Lt, {
                HSV_SATURATION: {
                    get: function() {
                        return zt("Blockly.HSV_SATURATION", "version 10", "version 11", "Blockly.utils.colour.getHsvSaturation()"),
                        Fl()
                    },
                    set: function(Q) {
                        zt("Blockly.HSV_SATURATION", "version 10", "version 11", "Blockly.utils.colour.setHsvSaturation()"),
                        Fu(Q)
                    }
                },
                HSV_VALUE: {
                    get: function() {
                        return zt("Blockly.HSV_VALUE", "version 10", "version 11", "Blockly.utils.colour.getHsvValue()"),
                        Hl()
                    },
                    set: function(Q) {
                        zt("Blockly.HSV_VALUE", "version 10", "version 11", "Blockly.utils.colour.setHsvValue()"),
                        Hu(Q)
                    }
                }
            }),
            "Blockly"in globalThis || (globalThis.Blockly = {
                Msg: ig
            }),
            Lt.__namespace__ = J,
            Lt
        })
    }(blockly_compressed)),
    blockly_compressed.exports
}
var hasRequiredBlockly;
function requireBlockly() {
    return hasRequiredBlockly || (hasRequiredBlockly = 1,
    function(V, X) {
        (function(J, ne) {
            V.exports = ne(requireBlockly_compressed())
        }
        )(commonjsGlobal, function(J) {
            /**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
            return J
        })
    }(blockly)),
    blockly.exports
}
var hasRequiredCoreBrowser;
function requireCoreBrowser() {
    return hasRequiredCoreBrowser || (hasRequiredCoreBrowser = 1,
    function(V, X) {
        (function(J, ne) {
            V.exports = ne(requireBlockly())
        }
        )(commonjsGlobal, function(J) {
            return J
        })
    }(coreBrowser)),
    coreBrowser.exports
}
var en = {
    exports: {}
}, hasRequiredEn;
function requireEn() {
    return hasRequiredEn || (hasRequiredEn = 1,
    function(V, X) {
        (function(J, ne) {
            V.exports = ne()
        }
        )(commonjsGlobal, function() {
            var J = J || {
                Msg: Object.create(null)
            };
            return J.Msg.ADD_COMMENT = "Add Comment",
            J.Msg.CANNOT_DELETE_VARIABLE_PROCEDURE = "Can't delete the variable '%1' because it's part of the definition of the function '%2'",
            J.Msg.CHANGE_VALUE_TITLE = "Change value:",
            J.Msg.CLEAN_UP = "Clean up Blocks",
            J.Msg.COLLAPSED_WARNINGS_WARNING = "Collapsed blocks contain warnings.",
            J.Msg.COLLAPSE_ALL = "Collapse Blocks",
            J.Msg.COLLAPSE_BLOCK = "Collapse Block",
            J.Msg.COLOUR_BLEND_COLOUR1 = "colour 1",
            J.Msg.COLOUR_BLEND_COLOUR2 = "colour 2",
            J.Msg.COLOUR_BLEND_HELPURL = "https://meyerweb.com/eric/tools/color-blend/#:::rgbp",
            J.Msg.COLOUR_BLEND_RATIO = "ratio",
            J.Msg.COLOUR_BLEND_TITLE = "blend",
            J.Msg.COLOUR_BLEND_TOOLTIP = "Blends two colours together with a given ratio (0.0 - 1.0).",
            J.Msg.COLOUR_PICKER_HELPURL = "https://en.wikipedia.org/wiki/Color",
            J.Msg.COLOUR_PICKER_TOOLTIP = "Choose a colour from the palette.",
            J.Msg.COLOUR_RANDOM_HELPURL = "http://randomcolour.com",
            J.Msg.COLOUR_RANDOM_TITLE = "random colour",
            J.Msg.COLOUR_RANDOM_TOOLTIP = "Choose a colour at random.",
            J.Msg.COLOUR_RGB_BLUE = "blue",
            J.Msg.COLOUR_RGB_GREEN = "green",
            J.Msg.COLOUR_RGB_HELPURL = "https://www.december.com/html/spec/colorpercompact.html",
            J.Msg.COLOUR_RGB_RED = "red",
            J.Msg.COLOUR_RGB_TITLE = "colour with",
            J.Msg.COLOUR_RGB_TOOLTIP = "Create a colour with the specified amount of red, green, and blue. All values must be between 0 and 100.",
            J.Msg.CONTROLS_FLOW_STATEMENTS_HELPURL = "https://github.com/google/blockly/wiki/Loops#loop-termination-blocks",
            J.Msg.CONTROLS_FLOW_STATEMENTS_OPERATOR_BREAK = "break out of loop",
            J.Msg.CONTROLS_FLOW_STATEMENTS_OPERATOR_CONTINUE = "continue with next iteration of loop",
            J.Msg.CONTROLS_FLOW_STATEMENTS_TOOLTIP_BREAK = "Break out of the containing loop.",
            J.Msg.CONTROLS_FLOW_STATEMENTS_TOOLTIP_CONTINUE = "Skip the rest of this loop, and continue with the next iteration.",
            J.Msg.CONTROLS_FLOW_STATEMENTS_WARNING = "Warning: This block may only be used within a loop.",
            J.Msg.CONTROLS_FOREACH_HELPURL = "https://github.com/google/blockly/wiki/Loops#for-each",
            J.Msg.CONTROLS_FOREACH_TITLE = "for each item %1 in list %2",
            J.Msg.CONTROLS_FOREACH_TOOLTIP = "For each item in a list, set the variable '%1' to the item, and then do some statements.",
            J.Msg.CONTROLS_FOR_HELPURL = "https://github.com/google/blockly/wiki/Loops#count-with",
            J.Msg.CONTROLS_FOR_TITLE = "count with %1 from %2 to %3 by %4",
            J.Msg.CONTROLS_FOR_TOOLTIP = "Have the variable '%1' take on the values from the start number to the end number, counting by the specified interval, and do the specified blocks.",
            J.Msg.CONTROLS_IF_ELSEIF_TOOLTIP = "Add a condition to the if block.",
            J.Msg.CONTROLS_IF_ELSE_TOOLTIP = "Add a final, catch-all condition to the if block.",
            J.Msg.CONTROLS_IF_HELPURL = "https://github.com/google/blockly/wiki/IfElse",
            J.Msg.CONTROLS_IF_IF_TOOLTIP = "Add, remove, or reorder sections to reconfigure this if block.",
            J.Msg.CONTROLS_IF_MSG_ELSE = "else",
            J.Msg.CONTROLS_IF_MSG_ELSEIF = "else if",
            J.Msg.CONTROLS_IF_MSG_IF = "if",
            J.Msg.CONTROLS_IF_TOOLTIP_1 = "If a value is true, then do some statements.",
            J.Msg.CONTROLS_IF_TOOLTIP_2 = "If a value is true, then do the first block of statements. Otherwise, do the second block of statements.",
            J.Msg.CONTROLS_IF_TOOLTIP_3 = "If the first value is true, then do the first block of statements. Otherwise, if the second value is true, do the second block of statements.",
            J.Msg.CONTROLS_IF_TOOLTIP_4 = "If the first value is true, then do the first block of statements. Otherwise, if the second value is true, do the second block of statements. If none of the values are true, do the last block of statements.",
            J.Msg.CONTROLS_REPEAT_HELPURL = "https://en.wikipedia.org/wiki/For_loop",
            J.Msg.CONTROLS_REPEAT_INPUT_DO = "do",
            J.Msg.CONTROLS_REPEAT_TITLE = "repeat %1 times",
            J.Msg.CONTROLS_REPEAT_TOOLTIP = "Do some statements several times.",
            J.Msg.CONTROLS_WHILEUNTIL_HELPURL = "https://github.com/google/blockly/wiki/Loops#repeat",
            J.Msg.CONTROLS_WHILEUNTIL_OPERATOR_UNTIL = "repeat until",
            J.Msg.CONTROLS_WHILEUNTIL_OPERATOR_WHILE = "repeat while",
            J.Msg.CONTROLS_WHILEUNTIL_TOOLTIP_UNTIL = "While a value is false, then do some statements.",
            J.Msg.CONTROLS_WHILEUNTIL_TOOLTIP_WHILE = "While a value is true, then do some statements.",
            J.Msg.DELETE_ALL_BLOCKS = "Delete all %1 blocks?",
            J.Msg.DELETE_BLOCK = "Delete Block",
            J.Msg.DELETE_VARIABLE = "Delete the '%1' variable",
            J.Msg.DELETE_VARIABLE_CONFIRMATION = "Delete %1 uses of the '%2' variable?",
            J.Msg.DELETE_X_BLOCKS = "Delete %1 Blocks",
            J.Msg.DIALOG_CANCEL = "Cancel",
            J.Msg.DIALOG_OK = "OK",
            J.Msg.DISABLE_BLOCK = "Disable Block",
            J.Msg.DUPLICATE_BLOCK = "Duplicate",
            J.Msg.DUPLICATE_COMMENT = "Duplicate Comment",
            J.Msg.ENABLE_BLOCK = "Enable Block",
            J.Msg.EXPAND_ALL = "Expand Blocks",
            J.Msg.EXPAND_BLOCK = "Expand Block",
            J.Msg.EXTERNAL_INPUTS = "External Inputs",
            J.Msg.HELP = "Help",
            J.Msg.INLINE_INPUTS = "Inline Inputs",
            J.Msg.LISTS_CREATE_EMPTY_HELPURL = "https://github.com/google/blockly/wiki/Lists#create-empty-list",
            J.Msg.LISTS_CREATE_EMPTY_TITLE = "create empty list",
            J.Msg.LISTS_CREATE_EMPTY_TOOLTIP = "Returns a list, of length 0, containing no data records",
            J.Msg.LISTS_CREATE_WITH_CONTAINER_TITLE_ADD = "list",
            J.Msg.LISTS_CREATE_WITH_CONTAINER_TOOLTIP = "Add, remove, or reorder sections to reconfigure this list block.",
            J.Msg.LISTS_CREATE_WITH_HELPURL = "https://github.com/google/blockly/wiki/Lists#create-list-with",
            J.Msg.LISTS_CREATE_WITH_INPUT_WITH = "create list with",
            J.Msg.LISTS_CREATE_WITH_ITEM_TOOLTIP = "Add an item to the list.",
            J.Msg.LISTS_CREATE_WITH_TOOLTIP = "Create a list with any number of items.",
            J.Msg.LISTS_GET_INDEX_FIRST = "first",
            J.Msg.LISTS_GET_INDEX_FROM_END = "# from end",
            J.Msg.LISTS_GET_INDEX_FROM_START = "#",
            J.Msg.LISTS_GET_INDEX_GET = "get",
            J.Msg.LISTS_GET_INDEX_GET_REMOVE = "get and remove",
            J.Msg.LISTS_GET_INDEX_LAST = "last",
            J.Msg.LISTS_GET_INDEX_RANDOM = "random",
            J.Msg.LISTS_GET_INDEX_REMOVE = "remove",
            J.Msg.LISTS_GET_INDEX_TAIL = "",
            J.Msg.LISTS_GET_INDEX_TOOLTIP_GET_FIRST = "Returns the first item in a list.",
            J.Msg.LISTS_GET_INDEX_TOOLTIP_GET_FROM = "Returns the item at the specified position in a list.",
            J.Msg.LISTS_GET_INDEX_TOOLTIP_GET_LAST = "Returns the last item in a list.",
            J.Msg.LISTS_GET_INDEX_TOOLTIP_GET_RANDOM = "Returns a random item in a list.",
            J.Msg.LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FIRST = "Removes and returns the first item in a list.",
            J.Msg.LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FROM = "Removes and returns the item at the specified position in a list.",
            J.Msg.LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_LAST = "Removes and returns the last item in a list.",
            J.Msg.LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_RANDOM = "Removes and returns a random item in a list.",
            J.Msg.LISTS_GET_INDEX_TOOLTIP_REMOVE_FIRST = "Removes the first item in a list.",
            J.Msg.LISTS_GET_INDEX_TOOLTIP_REMOVE_FROM = "Removes the item at the specified position in a list.",
            J.Msg.LISTS_GET_INDEX_TOOLTIP_REMOVE_LAST = "Removes the last item in a list.",
            J.Msg.LISTS_GET_INDEX_TOOLTIP_REMOVE_RANDOM = "Removes a random item in a list.",
            J.Msg.LISTS_GET_SUBLIST_END_FROM_END = "to # from end",
            J.Msg.LISTS_GET_SUBLIST_END_FROM_START = "to #",
            J.Msg.LISTS_GET_SUBLIST_END_LAST = "to last",
            J.Msg.LISTS_GET_SUBLIST_HELPURL = "https://github.com/google/blockly/wiki/Lists#getting-a-sublist",
            J.Msg.LISTS_GET_SUBLIST_START_FIRST = "get sub-list from first",
            J.Msg.LISTS_GET_SUBLIST_START_FROM_END = "get sub-list from # from end",
            J.Msg.LISTS_GET_SUBLIST_START_FROM_START = "get sub-list from #",
            J.Msg.LISTS_GET_SUBLIST_TAIL = "",
            J.Msg.LISTS_GET_SUBLIST_TOOLTIP = "Creates a copy of the specified portion of a list.",
            J.Msg.LISTS_INDEX_FROM_END_TOOLTIP = "%1 is the last item.",
            J.Msg.LISTS_INDEX_FROM_START_TOOLTIP = "%1 is the first item.",
            J.Msg.LISTS_INDEX_OF_FIRST = "find first occurrence of item",
            J.Msg.LISTS_INDEX_OF_HELPURL = "https://github.com/google/blockly/wiki/Lists#getting-items-from-a-list",
            J.Msg.LISTS_INDEX_OF_LAST = "find last occurrence of item",
            J.Msg.LISTS_INDEX_OF_TOOLTIP = "Returns the index of the first/last occurrence of the item in the list. Returns %1 if item is not found.",
            J.Msg.LISTS_INLIST = "in list",
            J.Msg.LISTS_ISEMPTY_HELPURL = "https://github.com/google/blockly/wiki/Lists#is-empty",
            J.Msg.LISTS_ISEMPTY_TITLE = "%1 is empty",
            J.Msg.LISTS_ISEMPTY_TOOLTIP = "Returns true if the list is empty.",
            J.Msg.LISTS_LENGTH_HELPURL = "https://github.com/google/blockly/wiki/Lists#length-of",
            J.Msg.LISTS_LENGTH_TITLE = "length of %1",
            J.Msg.LISTS_LENGTH_TOOLTIP = "Returns the length of a list.",
            J.Msg.LISTS_REPEAT_HELPURL = "https://github.com/google/blockly/wiki/Lists#create-list-with",
            J.Msg.LISTS_REPEAT_TITLE = "create list with item %1 repeated %2 times",
            J.Msg.LISTS_REPEAT_TOOLTIP = "Creates a list consisting of the given value repeated the specified number of times.",
            J.Msg.LISTS_REVERSE_HELPURL = "https://github.com/google/blockly/wiki/Lists#reversing-a-list",
            J.Msg.LISTS_REVERSE_MESSAGE0 = "reverse %1",
            J.Msg.LISTS_REVERSE_TOOLTIP = "Reverse a copy of a list.",
            J.Msg.LISTS_SET_INDEX_HELPURL = "https://github.com/google/blockly/wiki/Lists#in-list--set",
            J.Msg.LISTS_SET_INDEX_INPUT_TO = "as",
            J.Msg.LISTS_SET_INDEX_INSERT = "insert at",
            J.Msg.LISTS_SET_INDEX_SET = "set",
            J.Msg.LISTS_SET_INDEX_TOOLTIP_INSERT_FIRST = "Inserts the item at the start of a list.",
            J.Msg.LISTS_SET_INDEX_TOOLTIP_INSERT_FROM = "Inserts the item at the specified position in a list.",
            J.Msg.LISTS_SET_INDEX_TOOLTIP_INSERT_LAST = "Append the item to the end of a list.",
            J.Msg.LISTS_SET_INDEX_TOOLTIP_INSERT_RANDOM = "Inserts the item randomly in a list.",
            J.Msg.LISTS_SET_INDEX_TOOLTIP_SET_FIRST = "Sets the first item in a list.",
            J.Msg.LISTS_SET_INDEX_TOOLTIP_SET_FROM = "Sets the item at the specified position in a list.",
            J.Msg.LISTS_SET_INDEX_TOOLTIP_SET_LAST = "Sets the last item in a list.",
            J.Msg.LISTS_SET_INDEX_TOOLTIP_SET_RANDOM = "Sets a random item in a list.",
            J.Msg.LISTS_SORT_HELPURL = "https://github.com/google/blockly/wiki/Lists#sorting-a-list",
            J.Msg.LISTS_SORT_ORDER_ASCENDING = "ascending",
            J.Msg.LISTS_SORT_ORDER_DESCENDING = "descending",
            J.Msg.LISTS_SORT_TITLE = "sort %1 %2 %3",
            J.Msg.LISTS_SORT_TOOLTIP = "Sort a copy of a list.",
            J.Msg.LISTS_SORT_TYPE_IGNORECASE = "alphabetic, ignore case",
            J.Msg.LISTS_SORT_TYPE_NUMERIC = "numeric",
            J.Msg.LISTS_SORT_TYPE_TEXT = "alphabetic",
            J.Msg.LISTS_SPLIT_HELPURL = "https://github.com/google/blockly/wiki/Lists#splitting-strings-and-joining-lists",
            J.Msg.LISTS_SPLIT_LIST_FROM_TEXT = "make list from text",
            J.Msg.LISTS_SPLIT_TEXT_FROM_LIST = "make text from list",
            J.Msg.LISTS_SPLIT_TOOLTIP_JOIN = "Join a list of texts into one text, separated by a delimiter.",
            J.Msg.LISTS_SPLIT_TOOLTIP_SPLIT = "Split text into a list of texts, breaking at each delimiter.",
            J.Msg.LISTS_SPLIT_WITH_DELIMITER = "with delimiter",
            J.Msg.LOGIC_BOOLEAN_FALSE = "false",
            J.Msg.LOGIC_BOOLEAN_HELPURL = "https://github.com/google/blockly/wiki/Logic#values",
            J.Msg.LOGIC_BOOLEAN_TOOLTIP = "Returns either true or false.",
            J.Msg.LOGIC_BOOLEAN_TRUE = "true",
            J.Msg.LOGIC_COMPARE_HELPURL = "https://en.wikipedia.org/wiki/Inequality_(mathematics)",
            J.Msg.LOGIC_COMPARE_TOOLTIP_EQ = "Return true if both inputs equal each other.",
            J.Msg.LOGIC_COMPARE_TOOLTIP_GT = "Return true if the first input is greater than the second input.",
            J.Msg.LOGIC_COMPARE_TOOLTIP_GTE = "Return true if the first input is greater than or equal to the second input.",
            J.Msg.LOGIC_COMPARE_TOOLTIP_LT = "Return true if the first input is smaller than the second input.",
            J.Msg.LOGIC_COMPARE_TOOLTIP_LTE = "Return true if the first input is smaller than or equal to the second input.",
            J.Msg.LOGIC_COMPARE_TOOLTIP_NEQ = "Return true if both inputs are not equal to each other.",
            J.Msg.LOGIC_NEGATE_HELPURL = "https://github.com/google/blockly/wiki/Logic#not",
            J.Msg.LOGIC_NEGATE_TITLE = "not %1",
            J.Msg.LOGIC_NEGATE_TOOLTIP = "Returns true if the input is false. Returns false if the input is true.",
            J.Msg.LOGIC_NULL = "null",
            J.Msg.LOGIC_NULL_HELPURL = "https://en.wikipedia.org/wiki/Nullable_type",
            J.Msg.LOGIC_NULL_TOOLTIP = "Returns null.",
            J.Msg.LOGIC_OPERATION_AND = "and",
            J.Msg.LOGIC_OPERATION_HELPURL = "https://github.com/google/blockly/wiki/Logic#logical-operations",
            J.Msg.LOGIC_OPERATION_OR = "or",
            J.Msg.LOGIC_OPERATION_TOOLTIP_AND = "Return true if both inputs are true.",
            J.Msg.LOGIC_OPERATION_TOOLTIP_OR = "Return true if at least one of the inputs is true.",
            J.Msg.LOGIC_TERNARY_CONDITION = "test",
            J.Msg.LOGIC_TERNARY_HELPURL = "https://en.wikipedia.org/wiki/%3F:",
            J.Msg.LOGIC_TERNARY_IF_FALSE = "if false",
            J.Msg.LOGIC_TERNARY_IF_TRUE = "if true",
            J.Msg.LOGIC_TERNARY_TOOLTIP = "Check the condition in 'test'. If the condition is true, returns the 'if true' value; otherwise returns the 'if false' value.",
            J.Msg.MATH_ADDITION_SYMBOL = "+",
            J.Msg.MATH_ARITHMETIC_HELPURL = "https://en.wikipedia.org/wiki/Arithmetic",
            J.Msg.MATH_ARITHMETIC_TOOLTIP_ADD = "Return the sum of the two numbers.",
            J.Msg.MATH_ARITHMETIC_TOOLTIP_DIVIDE = "Return the quotient of the two numbers.",
            J.Msg.MATH_ARITHMETIC_TOOLTIP_MINUS = "Return the difference of the two numbers.",
            J.Msg.MATH_ARITHMETIC_TOOLTIP_MULTIPLY = "Return the product of the two numbers.",
            J.Msg.MATH_ARITHMETIC_TOOLTIP_POWER = "Return the first number raised to the power of the second number.",
            J.Msg.MATH_ATAN2_HELPURL = "https://en.wikipedia.org/wiki/Atan2",
            J.Msg.MATH_ATAN2_TITLE = "atan2 of X:%1 Y:%2",
            J.Msg.MATH_ATAN2_TOOLTIP = "Return the arctangent of point (X, Y) in degrees from -180 to 180.",
            J.Msg.MATH_CHANGE_HELPURL = "https://en.wikipedia.org/wiki/Programming_idiom#Incrementing_a_counter",
            J.Msg.MATH_CHANGE_TITLE = "change %1 by %2",
            J.Msg.MATH_CHANGE_TOOLTIP = "Add a number to variable '%1'.",
            J.Msg.MATH_CONSTANT_HELPURL = "https://en.wikipedia.org/wiki/Mathematical_constant",
            J.Msg.MATH_CONSTANT_TOOLTIP = "Return one of the common constants: π (3.141…), e (2.718…), φ (1.618…), sqrt(2) (1.414…), sqrt(½) (0.707…), or ∞ (infinity).",
            J.Msg.MATH_CONSTRAIN_HELPURL = "https://en.wikipedia.org/wiki/Clamping_(graphics)",
            J.Msg.MATH_CONSTRAIN_TITLE = "constrain %1 low %2 high %3",
            J.Msg.MATH_CONSTRAIN_TOOLTIP = "Constrain a number to be between the specified limits (inclusive).",
            J.Msg.MATH_DIVISION_SYMBOL = "÷",
            J.Msg.MATH_IS_DIVISIBLE_BY = "is divisible by",
            J.Msg.MATH_IS_EVEN = "is even",
            J.Msg.MATH_IS_NEGATIVE = "is negative",
            J.Msg.MATH_IS_ODD = "is odd",
            J.Msg.MATH_IS_POSITIVE = "is positive",
            J.Msg.MATH_IS_PRIME = "is prime",
            J.Msg.MATH_IS_TOOLTIP = "Check if a number is an even, odd, prime, whole, positive, negative, or if it is divisible by certain number. Returns true or false.",
            J.Msg.MATH_IS_WHOLE = "is whole",
            J.Msg.MATH_MODULO_HELPURL = "https://en.wikipedia.org/wiki/Modulo_operation",
            J.Msg.MATH_MODULO_TITLE = "remainder of %1 ÷ %2",
            J.Msg.MATH_MODULO_TOOLTIP = "Return the remainder from dividing the two numbers.",
            J.Msg.MATH_MULTIPLICATION_SYMBOL = "×",
            J.Msg.MATH_NUMBER_HELPURL = "https://en.wikipedia.org/wiki/Number",
            J.Msg.MATH_NUMBER_TOOLTIP = "A number.",
            J.Msg.MATH_ONLIST_HELPURL = "",
            J.Msg.MATH_ONLIST_OPERATOR_AVERAGE = "average of list",
            J.Msg.MATH_ONLIST_OPERATOR_MAX = "max of list",
            J.Msg.MATH_ONLIST_OPERATOR_MEDIAN = "median of list",
            J.Msg.MATH_ONLIST_OPERATOR_MIN = "min of list",
            J.Msg.MATH_ONLIST_OPERATOR_MODE = "modes of list",
            J.Msg.MATH_ONLIST_OPERATOR_RANDOM = "random item of list",
            J.Msg.MATH_ONLIST_OPERATOR_STD_DEV = "standard deviation of list",
            J.Msg.MATH_ONLIST_OPERATOR_SUM = "sum of list",
            J.Msg.MATH_ONLIST_TOOLTIP_AVERAGE = "Return the average (arithmetic mean) of the numeric values in the list.",
            J.Msg.MATH_ONLIST_TOOLTIP_MAX = "Return the largest number in the list.",
            J.Msg.MATH_ONLIST_TOOLTIP_MEDIAN = "Return the median number in the list.",
            J.Msg.MATH_ONLIST_TOOLTIP_MIN = "Return the smallest number in the list.",
            J.Msg.MATH_ONLIST_TOOLTIP_MODE = "Return a list of the most common item(s) in the list.",
            J.Msg.MATH_ONLIST_TOOLTIP_RANDOM = "Return a random element from the list.",
            J.Msg.MATH_ONLIST_TOOLTIP_STD_DEV = "Return the standard deviation of the list.",
            J.Msg.MATH_ONLIST_TOOLTIP_SUM = "Return the sum of all the numbers in the list.",
            J.Msg.MATH_POWER_SYMBOL = "^",
            J.Msg.MATH_RANDOM_FLOAT_HELPURL = "https://en.wikipedia.org/wiki/Random_number_generation",
            J.Msg.MATH_RANDOM_FLOAT_TITLE_RANDOM = "random fraction",
            J.Msg.MATH_RANDOM_FLOAT_TOOLTIP = "Return a random fraction between 0.0 (inclusive) and 1.0 (exclusive).",
            J.Msg.MATH_RANDOM_INT_HELPURL = "https://en.wikipedia.org/wiki/Random_number_generation",
            J.Msg.MATH_RANDOM_INT_TITLE = "random integer from %1 to %2",
            J.Msg.MATH_RANDOM_INT_TOOLTIP = "Return a random integer between the two specified limits, inclusive.",
            J.Msg.MATH_ROUND_HELPURL = "https://en.wikipedia.org/wiki/Rounding",
            J.Msg.MATH_ROUND_OPERATOR_ROUND = "round",
            J.Msg.MATH_ROUND_OPERATOR_ROUNDDOWN = "round down",
            J.Msg.MATH_ROUND_OPERATOR_ROUNDUP = "round up",
            J.Msg.MATH_ROUND_TOOLTIP = "Round a number up or down.",
            J.Msg.MATH_SINGLE_HELPURL = "https://en.wikipedia.org/wiki/Square_root",
            J.Msg.MATH_SINGLE_OP_ABSOLUTE = "absolute",
            J.Msg.MATH_SINGLE_OP_ROOT = "square root",
            J.Msg.MATH_SINGLE_TOOLTIP_ABS = "Return the absolute value of a number.",
            J.Msg.MATH_SINGLE_TOOLTIP_EXP = "Return e to the power of a number.",
            J.Msg.MATH_SINGLE_TOOLTIP_LN = "Return the natural logarithm of a number.",
            J.Msg.MATH_SINGLE_TOOLTIP_LOG10 = "Return the base 10 logarithm of a number.",
            J.Msg.MATH_SINGLE_TOOLTIP_NEG = "Return the negation of a number.",
            J.Msg.MATH_SINGLE_TOOLTIP_POW10 = "Return 10 to the power of a number.",
            J.Msg.MATH_SINGLE_TOOLTIP_ROOT = "Return the square root of a number.",
            J.Msg.MATH_SUBTRACTION_SYMBOL = "-",
            J.Msg.MATH_TRIG_ACOS = "acos",
            J.Msg.MATH_TRIG_ASIN = "asin",
            J.Msg.MATH_TRIG_ATAN = "atan",
            J.Msg.MATH_TRIG_COS = "cos",
            J.Msg.MATH_TRIG_HELPURL = "https://en.wikipedia.org/wiki/Trigonometric_functions",
            J.Msg.MATH_TRIG_SIN = "sin",
            J.Msg.MATH_TRIG_TAN = "tan",
            J.Msg.MATH_TRIG_TOOLTIP_ACOS = "Return the arccosine of a number.",
            J.Msg.MATH_TRIG_TOOLTIP_ASIN = "Return the arcsine of a number.",
            J.Msg.MATH_TRIG_TOOLTIP_ATAN = "Return the arctangent of a number.",
            J.Msg.MATH_TRIG_TOOLTIP_COS = "Return the cosine of a degree (not radian).",
            J.Msg.MATH_TRIG_TOOLTIP_SIN = "Return the sine of a degree (not radian).",
            J.Msg.MATH_TRIG_TOOLTIP_TAN = "Return the tangent of a degree (not radian).",
            J.Msg.NEW_COLOUR_VARIABLE = "Create colour variable...",
            J.Msg.NEW_NUMBER_VARIABLE = "Create number variable...",
            J.Msg.NEW_STRING_VARIABLE = "Create string variable...",
            J.Msg.NEW_VARIABLE = "Create variable...",
            J.Msg.NEW_VARIABLE_TITLE = "New variable name:",
            J.Msg.NEW_VARIABLE_TYPE_TITLE = "New variable type:",
            J.Msg.ORDINAL_NUMBER_SUFFIX = "",
            J.Msg.PROCEDURES_ALLOW_STATEMENTS = "allow statements",
            J.Msg.PROCEDURES_BEFORE_PARAMS = "with:",
            J.Msg.PROCEDURES_CALLNORETURN_HELPURL = "https://en.wikipedia.org/wiki/Subroutine",
            J.Msg.PROCEDURES_CALLNORETURN_TOOLTIP = "Run the user-defined function '%1'.",
            J.Msg.PROCEDURES_CALLRETURN_HELPURL = "https://en.wikipedia.org/wiki/Subroutine",
            J.Msg.PROCEDURES_CALLRETURN_TOOLTIP = "Run the user-defined function '%1' and use its output.",
            J.Msg.PROCEDURES_CALL_BEFORE_PARAMS = "with:",
            J.Msg.PROCEDURES_CREATE_DO = "Create '%1'",
            J.Msg.PROCEDURES_DEFNORETURN_COMMENT = "Describe this function...",
            J.Msg.PROCEDURES_DEFNORETURN_DO = "",
            J.Msg.PROCEDURES_DEFNORETURN_HELPURL = "https://en.wikipedia.org/wiki/Subroutine",
            J.Msg.PROCEDURES_DEFNORETURN_PROCEDURE = "do something",
            J.Msg.PROCEDURES_DEFNORETURN_TITLE = "to",
            J.Msg.PROCEDURES_DEFNORETURN_TOOLTIP = "Creates a function with no output.",
            J.Msg.PROCEDURES_DEFRETURN_HELPURL = "https://en.wikipedia.org/wiki/Subroutine",
            J.Msg.PROCEDURES_DEFRETURN_RETURN = "return",
            J.Msg.PROCEDURES_DEFRETURN_TOOLTIP = "Creates a function with an output.",
            J.Msg.PROCEDURES_DEF_DUPLICATE_WARNING = "Warning: This function has duplicate parameters.",
            J.Msg.PROCEDURES_HIGHLIGHT_DEF = "Highlight function definition",
            J.Msg.PROCEDURES_IFRETURN_HELPURL = "https://c2.com/cgi/wiki?GuardClause",
            J.Msg.PROCEDURES_IFRETURN_TOOLTIP = "If a value is true, then return a second value.",
            J.Msg.PROCEDURES_IFRETURN_WARNING = "Warning: This block may be used only within a function definition.",
            J.Msg.PROCEDURES_MUTATORARG_TITLE = "input name:",
            J.Msg.PROCEDURES_MUTATORARG_TOOLTIP = "Add an input to the function.",
            J.Msg.PROCEDURES_MUTATORCONTAINER_TITLE = "inputs",
            J.Msg.PROCEDURES_MUTATORCONTAINER_TOOLTIP = "Add, remove, or reorder inputs to this function.",
            J.Msg.REDO = "Redo",
            J.Msg.REMOVE_COMMENT = "Remove Comment",
            J.Msg.RENAME_VARIABLE = "Rename variable...",
            J.Msg.RENAME_VARIABLE_TITLE = "Rename all '%1' variables to:",
            J.Msg.TEXT_APPEND_HELPURL = "https://github.com/google/blockly/wiki/Text#text-modification",
            J.Msg.TEXT_APPEND_TITLE = "to %1 append text %2",
            J.Msg.TEXT_APPEND_TOOLTIP = "Append some text to variable '%1'.",
            J.Msg.TEXT_CHANGECASE_HELPURL = "https://github.com/google/blockly/wiki/Text#adjusting-text-case",
            J.Msg.TEXT_CHANGECASE_OPERATOR_LOWERCASE = "to lower case",
            J.Msg.TEXT_CHANGECASE_OPERATOR_TITLECASE = "to Title Case",
            J.Msg.TEXT_CHANGECASE_OPERATOR_UPPERCASE = "to UPPER CASE",
            J.Msg.TEXT_CHANGECASE_TOOLTIP = "Return a copy of the text in a different case.",
            J.Msg.TEXT_CHARAT_FIRST = "get first letter",
            J.Msg.TEXT_CHARAT_FROM_END = "get letter # from end",
            J.Msg.TEXT_CHARAT_FROM_START = "get letter #",
            J.Msg.TEXT_CHARAT_HELPURL = "https://github.com/google/blockly/wiki/Text#extracting-text",
            J.Msg.TEXT_CHARAT_LAST = "get last letter",
            J.Msg.TEXT_CHARAT_RANDOM = "get random letter",
            J.Msg.TEXT_CHARAT_TAIL = "",
            J.Msg.TEXT_CHARAT_TITLE = "in text %1 %2",
            J.Msg.TEXT_CHARAT_TOOLTIP = "Returns the letter at the specified position.",
            J.Msg.TEXT_COUNT_HELPURL = "https://github.com/google/blockly/wiki/Text#counting-substrings",
            J.Msg.TEXT_COUNT_MESSAGE0 = "count %1 in %2",
            J.Msg.TEXT_COUNT_TOOLTIP = "Count how many times some text occurs within some other text.",
            J.Msg.TEXT_CREATE_JOIN_ITEM_TOOLTIP = "Add an item to the text.",
            J.Msg.TEXT_CREATE_JOIN_TITLE_JOIN = "join",
            J.Msg.TEXT_CREATE_JOIN_TOOLTIP = "Add, remove, or reorder sections to reconfigure this text block.",
            J.Msg.TEXT_GET_SUBSTRING_END_FROM_END = "to letter # from end",
            J.Msg.TEXT_GET_SUBSTRING_END_FROM_START = "to letter #",
            J.Msg.TEXT_GET_SUBSTRING_END_LAST = "to last letter",
            J.Msg.TEXT_GET_SUBSTRING_HELPURL = "https://github.com/google/blockly/wiki/Text#extracting-a-region-of-text",
            J.Msg.TEXT_GET_SUBSTRING_INPUT_IN_TEXT = "in text",
            J.Msg.TEXT_GET_SUBSTRING_START_FIRST = "get substring from first letter",
            J.Msg.TEXT_GET_SUBSTRING_START_FROM_END = "get substring from letter # from end",
            J.Msg.TEXT_GET_SUBSTRING_START_FROM_START = "get substring from letter #",
            J.Msg.TEXT_GET_SUBSTRING_TAIL = "",
            J.Msg.TEXT_GET_SUBSTRING_TOOLTIP = "Returns a specified portion of the text.",
            J.Msg.TEXT_INDEXOF_HELPURL = "https://github.com/google/blockly/wiki/Text#finding-text",
            J.Msg.TEXT_INDEXOF_OPERATOR_FIRST = "find first occurrence of text",
            J.Msg.TEXT_INDEXOF_OPERATOR_LAST = "find last occurrence of text",
            J.Msg.TEXT_INDEXOF_TITLE = "in text %1 %2 %3",
            J.Msg.TEXT_INDEXOF_TOOLTIP = "Returns the index of the first/last occurrence of the first text in the second text. Returns %1 if text is not found.",
            J.Msg.TEXT_ISEMPTY_HELPURL = "https://github.com/google/blockly/wiki/Text#checking-for-empty-text",
            J.Msg.TEXT_ISEMPTY_TITLE = "%1 is empty",
            J.Msg.TEXT_ISEMPTY_TOOLTIP = "Returns true if the provided text is empty.",
            J.Msg.TEXT_JOIN_HELPURL = "https://github.com/google/blockly/wiki/Text#text-creation",
            J.Msg.TEXT_JOIN_TITLE_CREATEWITH = "create text with",
            J.Msg.TEXT_JOIN_TOOLTIP = "Create a piece of text by joining together any number of items.",
            J.Msg.TEXT_LENGTH_HELPURL = "https://github.com/google/blockly/wiki/Text#text-modification",
            J.Msg.TEXT_LENGTH_TITLE = "length of %1",
            J.Msg.TEXT_LENGTH_TOOLTIP = "Returns the number of letters (including spaces) in the provided text.",
            J.Msg.TEXT_PRINT_HELPURL = "https://github.com/google/blockly/wiki/Text#printing-text",
            J.Msg.TEXT_PRINT_TITLE = "print %1",
            J.Msg.TEXT_PRINT_TOOLTIP = "Print the specified text, number or other value.",
            J.Msg.TEXT_PROMPT_HELPURL = "https://github.com/google/blockly/wiki/Text#getting-input-from-the-user",
            J.Msg.TEXT_PROMPT_TOOLTIP_NUMBER = "Prompt for user for a number.",
            J.Msg.TEXT_PROMPT_TOOLTIP_TEXT = "Prompt for user for some text.",
            J.Msg.TEXT_PROMPT_TYPE_NUMBER = "prompt for number with message",
            J.Msg.TEXT_PROMPT_TYPE_TEXT = "prompt for text with message",
            J.Msg.TEXT_REPLACE_HELPURL = "https://github.com/google/blockly/wiki/Text#replacing-substrings",
            J.Msg.TEXT_REPLACE_MESSAGE0 = "replace %1 with %2 in %3",
            J.Msg.TEXT_REPLACE_TOOLTIP = "Replace all occurances of some text within some other text.",
            J.Msg.TEXT_REVERSE_HELPURL = "https://github.com/google/blockly/wiki/Text#reversing-text",
            J.Msg.TEXT_REVERSE_MESSAGE0 = "reverse %1",
            J.Msg.TEXT_REVERSE_TOOLTIP = "Reverses the order of the characters in the text.",
            J.Msg.TEXT_TEXT_HELPURL = "https://en.wikipedia.org/wiki/String_(computer_science)",
            J.Msg.TEXT_TEXT_TOOLTIP = "A letter, word, or line of text.",
            J.Msg.TEXT_TRIM_HELPURL = "https://github.com/google/blockly/wiki/Text#trimming-removing-spaces",
            J.Msg.TEXT_TRIM_OPERATOR_BOTH = "trim spaces from both sides of",
            J.Msg.TEXT_TRIM_OPERATOR_LEFT = "trim spaces from left side of",
            J.Msg.TEXT_TRIM_OPERATOR_RIGHT = "trim spaces from right side of",
            J.Msg.TEXT_TRIM_TOOLTIP = "Return a copy of the text with spaces removed from one or both ends.",
            J.Msg.TODAY = "Today",
            J.Msg.UNDO = "Undo",
            J.Msg.UNNAMED_KEY = "unnamed",
            J.Msg.VARIABLES_DEFAULT_NAME = "item",
            J.Msg.VARIABLES_GET_CREATE_SET = "Create 'set %1'",
            J.Msg.VARIABLES_GET_HELPURL = "https://github.com/google/blockly/wiki/Variables#get",
            J.Msg.VARIABLES_GET_TOOLTIP = "Returns the value of this variable.",
            J.Msg.VARIABLES_SET = "set %1 to %2",
            J.Msg.VARIABLES_SET_CREATE_GET = "Create 'get %1'",
            J.Msg.VARIABLES_SET_HELPURL = "https://github.com/google/blockly/wiki/Variables#set",
            J.Msg.VARIABLES_SET_TOOLTIP = "Sets this variable to be equal to the input.",
            J.Msg.VARIABLE_ALREADY_EXISTS = "A variable named '%1' already exists.",
            J.Msg.VARIABLE_ALREADY_EXISTS_FOR_ANOTHER_TYPE = "A variable named '%1' already exists for another type: '%2'.",
            J.Msg.WORKSPACE_ARIA_LABEL = "Blockly Workspace",
            J.Msg.WORKSPACE_COMMENT_DEFAULT_TEXT = "Say something...",
            J.Msg.CONTROLS_FOREACH_INPUT_DO = J.Msg.CONTROLS_REPEAT_INPUT_DO,
            J.Msg.CONTROLS_FOR_INPUT_DO = J.Msg.CONTROLS_REPEAT_INPUT_DO,
            J.Msg.CONTROLS_IF_ELSEIF_TITLE_ELSEIF = J.Msg.CONTROLS_IF_MSG_ELSEIF,
            J.Msg.CONTROLS_IF_ELSE_TITLE_ELSE = J.Msg.CONTROLS_IF_MSG_ELSE,
            J.Msg.CONTROLS_IF_IF_TITLE_IF = J.Msg.CONTROLS_IF_MSG_IF,
            J.Msg.CONTROLS_IF_MSG_THEN = J.Msg.CONTROLS_REPEAT_INPUT_DO,
            J.Msg.CONTROLS_WHILEUNTIL_INPUT_DO = J.Msg.CONTROLS_REPEAT_INPUT_DO,
            J.Msg.LISTS_CREATE_WITH_ITEM_TITLE = J.Msg.VARIABLES_DEFAULT_NAME,
            J.Msg.LISTS_GET_INDEX_HELPURL = J.Msg.LISTS_INDEX_OF_HELPURL,
            J.Msg.LISTS_GET_INDEX_INPUT_IN_LIST = J.Msg.LISTS_INLIST,
            J.Msg.LISTS_GET_SUBLIST_INPUT_IN_LIST = J.Msg.LISTS_INLIST,
            J.Msg.LISTS_INDEX_OF_INPUT_IN_LIST = J.Msg.LISTS_INLIST,
            J.Msg.LISTS_SET_INDEX_INPUT_IN_LIST = J.Msg.LISTS_INLIST,
            J.Msg.MATH_CHANGE_TITLE_ITEM = J.Msg.VARIABLES_DEFAULT_NAME,
            J.Msg.PROCEDURES_DEFRETURN_COMMENT = J.Msg.PROCEDURES_DEFNORETURN_COMMENT,
            J.Msg.PROCEDURES_DEFRETURN_DO = J.Msg.PROCEDURES_DEFNORETURN_DO,
            J.Msg.PROCEDURES_DEFRETURN_PROCEDURE = J.Msg.PROCEDURES_DEFNORETURN_PROCEDURE,
            J.Msg.PROCEDURES_DEFRETURN_TITLE = J.Msg.PROCEDURES_DEFNORETURN_TITLE,
            J.Msg.TEXT_APPEND_VARIABLE = J.Msg.VARIABLES_DEFAULT_NAME,
            J.Msg.TEXT_CREATE_JOIN_ITEM_TITLE_ITEM = J.Msg.VARIABLES_DEFAULT_NAME,
            J.Msg.MATH_HUE = "230",
            J.Msg.LOOPS_HUE = "120",
            J.Msg.LISTS_HUE = "260",
            J.Msg.LOGIC_HUE = "210",
            J.Msg.VARIABLES_HUE = "330",
            J.Msg.TEXTS_HUE = "160",
            J.Msg.PROCEDURES_HUE = "290",
            J.Msg.COLOUR_HUE = "20",
            J.Msg.VARIABLES_DYNAMIC_HUE = "310",
            J.Msg
        })
    }(en)),
    en.exports
}
var blocks = {
    exports: {}
}, blocks_compressed = {
    exports: {}
}, hasRequiredBlocks_compressed;
function requireBlocks_compressed() {
    return hasRequiredBlocks_compressed || (hasRequiredBlocks_compressed = 1,
    function(V, X) {
        (function(J, ne) {
            V.exports = ne(requireBlockly_compressed())
        }
        )(commonjsGlobal, function(J) {
            var ne = J.__namespace__
              , ue = ne.createBlockDefinitionsFromJsonArray$$module$build$src$core$common([{
                type: "variables_get_dynamic",
                message0: "%1",
                args0: [{
                    type: "field_variable",
                    name: "VAR",
                    variable: "%{BKY_VARIABLES_DEFAULT_NAME}"
                }],
                output: null,
                style: "variable_dynamic_blocks",
                helpUrl: "%{BKY_VARIABLES_GET_HELPURL}",
                tooltip: "%{BKY_VARIABLES_GET_TOOLTIP}",
                extensions: ["contextMenu_variableDynamicSetterGetter"]
            }, {
                type: "variables_set_dynamic",
                message0: "%{BKY_VARIABLES_SET}",
                args0: [{
                    type: "field_variable",
                    name: "VAR",
                    variable: "%{BKY_VARIABLES_DEFAULT_NAME}"
                }, {
                    type: "input_value",
                    name: "VALUE"
                }],
                previousStatement: null,
                nextStatement: null,
                style: "variable_dynamic_blocks",
                tooltip: "%{BKY_VARIABLES_SET_TOOLTIP}",
                helpUrl: "%{BKY_VARIABLES_SET_HELPURL}",
                extensions: ["contextMenu_variableDynamicSetterGetter"]
            }])
              , ce = {
                customContextMenu: function(Ge) {
                    if (this.isInFlyout)
                        (this.type === "variables_get_dynamic" || this.type === "variables_get_reporter_dynamic") && (ht = {
                            text: ne.Msg$$module$build$src$core$msg.RENAME_VARIABLE,
                            enabled: !0,
                            callback: me(this)
                        },
                        At = this.getField("VAR").getText(),
                        At = {
                            text: ne.Msg$$module$build$src$core$msg.DELETE_VARIABLE.replace("%1", At),
                            enabled: !0,
                            callback: ge(this)
                        },
                        Ge.unshift(ht),
                        Ge.unshift(At));
                    else {
                        if (this.type === "variables_get_dynamic")
                            var st = "variables_set_dynamic"
                              , ht = ne.Msg$$module$build$src$core$msg.VARIABLES_GET_CREATE_SET;
                        else
                            st = "variables_get_dynamic",
                            ht = ne.Msg$$module$build$src$core$msg.VARIABLES_SET_CREATE_GET;
                        var At = this.getField("VAR");
                        st = {
                            type: st,
                            fields: {
                                VAR: At.saveState(!0)
                            }
                        },
                        Ge.push({
                            enabled: 0 < this.workspace.remainingCapacity(),
                            text: ht.replace("%1", At.getText()),
                            callback: ne.callbackFactory$$module$build$src$core$contextmenu(this, st)
                        })
                    }
                },
                onchange: function(Ge) {
                    Ge = this.getFieldValue("VAR"),
                    Ge = ne.getVariable$$module$build$src$core$variables(this.workspace, Ge),
                    this.type === "variables_get_dynamic" ? this.outputConnection.setCheck(Ge.type) : this.getInput("VALUE").connection.setCheck(Ge.type)
                }
            }
              , me = function(Ge) {
                return function() {
                    const st = Ge.workspace
                      , ht = Ge.getField("VAR").getVariable();
                    ne.renameVariable$$module$build$src$core$variables(st, ht)
                }
            }
              , ge = function(Ge) {
                return function() {
                    const st = Ge.workspace
                      , ht = Ge.getField("VAR").getVariable();
                    st.deleteVariableById(ht.getId()),
                    st.refreshToolboxSelection()
                }
            };
            ne.registerMixin$$module$build$src$core$extensions("contextMenu_variableDynamicSetterGetter", ce),
            ne.defineBlocks$$module$build$src$core$common(ue);
            var Te = {
                blocks: ue
            }
              , _e = ne.createBlockDefinitionsFromJsonArray$$module$build$src$core$common([{
                type: "variables_get",
                message0: "%1",
                args0: [{
                    type: "field_variable",
                    name: "VAR",
                    variable: "%{BKY_VARIABLES_DEFAULT_NAME}"
                }],
                output: null,
                style: "variable_blocks",
                helpUrl: "%{BKY_VARIABLES_GET_HELPURL}",
                tooltip: "%{BKY_VARIABLES_GET_TOOLTIP}",
                extensions: ["contextMenu_variableSetterGetter"]
            }, {
                type: "variables_set",
                message0: "%{BKY_VARIABLES_SET}",
                args0: [{
                    type: "field_variable",
                    name: "VAR",
                    variable: "%{BKY_VARIABLES_DEFAULT_NAME}"
                }, {
                    type: "input_value",
                    name: "VALUE"
                }],
                previousStatement: null,
                nextStatement: null,
                style: "variable_blocks",
                tooltip: "%{BKY_VARIABLES_SET_TOOLTIP}",
                helpUrl: "%{BKY_VARIABLES_SET_HELPURL}",
                extensions: ["contextMenu_variableSetterGetter"]
            }])
              , Se = {
                customContextMenu: function(Ge) {
                    if (this.isInFlyout)
                        (this.type === "variables_get" || this.type === "variables_get_reporter") && (ht = {
                            text: ne.Msg$$module$build$src$core$msg.RENAME_VARIABLE,
                            enabled: !0,
                            callback: Ie(this)
                        },
                        At = this.getField("VAR").getText(),
                        At = {
                            text: ne.Msg$$module$build$src$core$msg.DELETE_VARIABLE.replace("%1", At),
                            enabled: !0,
                            callback: ye(this)
                        },
                        Ge.unshift(ht),
                        Ge.unshift(At));
                    else {
                        if (this.type === "variables_get")
                            var st = "variables_set"
                              , ht = ne.Msg$$module$build$src$core$msg.VARIABLES_GET_CREATE_SET;
                        else
                            st = "variables_get",
                            ht = ne.Msg$$module$build$src$core$msg.VARIABLES_SET_CREATE_GET;
                        var At = this.getField("VAR");
                        st = {
                            type: st,
                            fields: {
                                VAR: At.saveState(!0)
                            }
                        },
                        Ge.push({
                            enabled: 0 < this.workspace.remainingCapacity(),
                            text: ht.replace("%1", At.getText()),
                            callback: ne.callbackFactory$$module$build$src$core$contextmenu(this, st)
                        })
                    }
                }
            }
              , Ie = function(Ge) {
                return function() {
                    const st = Ge.workspace
                      , ht = Ge.getField("VAR").getVariable();
                    ne.renameVariable$$module$build$src$core$variables(st, ht)
                }
            }
              , ye = function(Ge) {
                return function() {
                    const st = Ge.workspace
                      , ht = Ge.getField("VAR").getVariable();
                    st.deleteVariableById(ht.getId()),
                    st.refreshToolboxSelection()
                }
            };
            ne.registerMixin$$module$build$src$core$extensions("contextMenu_variableSetterGetter", Se),
            ne.defineBlocks$$module$build$src$core$common(_e);
            var $e = {
                blocks: _e
            }
              , Ne = ne.createBlockDefinitionsFromJsonArray$$module$build$src$core$common([{
                type: "text",
                message0: "%1",
                args0: [{
                    type: "field_input",
                    name: "TEXT",
                    text: ""
                }],
                output: "String",
                style: "text_blocks",
                helpUrl: "%{BKY_TEXT_TEXT_HELPURL}",
                tooltip: "%{BKY_TEXT_TEXT_TOOLTIP}",
                extensions: ["text_quotes", "parent_tooltip_when_inline"]
            }, {
                type: "text_multiline",
                message0: "%1 %2",
                args0: [{
                    type: "field_image",
                    src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAARCAYAAADpPU2iAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAdhgAAHYYBXaITgQAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMS42/U4J6AAAAP1JREFUOE+Vks0KQUEYhjmRIja4ABtZ2dm5A3t3Ia6AUm7CylYuQRaUhZSlLZJiQbFAyRnPN33y01HOW08z8873zpwzM4F3GWOCruvGIE4/rLaV+Nq1hVGMBqzhqlxgCys4wJA65xnogMHsQ5lujnYHTejBBCK2mE4abjCgMGhNxHgDFWjDSG07kdfVa2pZMf4ZyMAdWmpZMfYOsLiDMYMjlMB+K613QISRhTnITnsYg5yUd0DETmEoMlkFOeIT/A58iyK5E18BuTBfgYXfwNJv4P9/oEBerLylOnRhygmGdPpTTBZAPkde61lbQe4moWUvYUZYLfUNftIY4zwA5X2Z9AYnQrEAAAAASUVORK5CYII=",
                    width: 12,
                    height: 17,
                    alt: "¶"
                }, {
                    type: "field_multilinetext",
                    name: "TEXT",
                    text: ""
                }],
                output: "String",
                style: "text_blocks",
                helpUrl: "%{BKY_TEXT_TEXT_HELPURL}",
                tooltip: "%{BKY_TEXT_TEXT_TOOLTIP}",
                extensions: ["parent_tooltip_when_inline"]
            }, {
                type: "text_join",
                message0: "",
                output: "String",
                style: "text_blocks",
                helpUrl: "%{BKY_TEXT_JOIN_HELPURL}",
                tooltip: "%{BKY_TEXT_JOIN_TOOLTIP}",
                mutator: "text_join_mutator"
            }, {
                type: "text_create_join_container",
                message0: "%{BKY_TEXT_CREATE_JOIN_TITLE_JOIN} %1 %2",
                args0: [{
                    type: "input_dummy"
                }, {
                    type: "input_statement",
                    name: "STACK"
                }],
                style: "text_blocks",
                tooltip: "%{BKY_TEXT_CREATE_JOIN_TOOLTIP}",
                enableContextMenu: !1
            }, {
                type: "text_create_join_item",
                message0: "%{BKY_TEXT_CREATE_JOIN_ITEM_TITLE_ITEM}",
                previousStatement: null,
                nextStatement: null,
                style: "text_blocks",
                tooltip: "%{BKY_TEXT_CREATE_JOIN_ITEM_TOOLTIP}",
                enableContextMenu: !1
            }, {
                type: "text_append",
                message0: "%{BKY_TEXT_APPEND_TITLE}",
                args0: [{
                    type: "field_variable",
                    name: "VAR",
                    variable: "%{BKY_TEXT_APPEND_VARIABLE}"
                }, {
                    type: "input_value",
                    name: "TEXT"
                }],
                previousStatement: null,
                nextStatement: null,
                style: "text_blocks",
                extensions: ["text_append_tooltip"]
            }, {
                type: "text_length",
                message0: "%{BKY_TEXT_LENGTH_TITLE}",
                args0: [{
                    type: "input_value",
                    name: "VALUE",
                    check: ["String", "Array"]
                }],
                output: "Number",
                style: "text_blocks",
                tooltip: "%{BKY_TEXT_LENGTH_TOOLTIP}",
                helpUrl: "%{BKY_TEXT_LENGTH_HELPURL}"
            }, {
                type: "text_isEmpty",
                message0: "%{BKY_TEXT_ISEMPTY_TITLE}",
                args0: [{
                    type: "input_value",
                    name: "VALUE",
                    check: ["String", "Array"]
                }],
                output: "Boolean",
                style: "text_blocks",
                tooltip: "%{BKY_TEXT_ISEMPTY_TOOLTIP}",
                helpUrl: "%{BKY_TEXT_ISEMPTY_HELPURL}"
            }, {
                type: "text_indexOf",
                message0: "%{BKY_TEXT_INDEXOF_TITLE}",
                args0: [{
                    type: "input_value",
                    name: "VALUE",
                    check: "String"
                }, {
                    type: "field_dropdown",
                    name: "END",
                    options: [["%{BKY_TEXT_INDEXOF_OPERATOR_FIRST}", "FIRST"], ["%{BKY_TEXT_INDEXOF_OPERATOR_LAST}", "LAST"]]
                }, {
                    type: "input_value",
                    name: "FIND",
                    check: "String"
                }],
                output: "Number",
                style: "text_blocks",
                helpUrl: "%{BKY_TEXT_INDEXOF_HELPURL}",
                inputsInline: !0,
                extensions: ["text_indexOf_tooltip"]
            }, {
                type: "text_charAt",
                message0: "%{BKY_TEXT_CHARAT_TITLE}",
                args0: [{
                    type: "input_value",
                    name: "VALUE",
                    check: "String"
                }, {
                    type: "field_dropdown",
                    name: "WHERE",
                    options: [["%{BKY_TEXT_CHARAT_FROM_START}", "FROM_START"], ["%{BKY_TEXT_CHARAT_FROM_END}", "FROM_END"], ["%{BKY_TEXT_CHARAT_FIRST}", "FIRST"], ["%{BKY_TEXT_CHARAT_LAST}", "LAST"], ["%{BKY_TEXT_CHARAT_RANDOM}", "RANDOM"]]
                }],
                output: "String",
                style: "text_blocks",
                helpUrl: "%{BKY_TEXT_CHARAT_HELPURL}",
                inputsInline: !0,
                mutator: "text_charAt_mutator"
            }])
              , ve = {
                init: function() {
                    this.WHERE_OPTIONS_1 = [[ne.Msg$$module$build$src$core$msg.TEXT_GET_SUBSTRING_START_FROM_START, "FROM_START"], [ne.Msg$$module$build$src$core$msg.TEXT_GET_SUBSTRING_START_FROM_END, "FROM_END"], [ne.Msg$$module$build$src$core$msg.TEXT_GET_SUBSTRING_START_FIRST, "FIRST"]],
                    this.WHERE_OPTIONS_2 = [[ne.Msg$$module$build$src$core$msg.TEXT_GET_SUBSTRING_END_FROM_START, "FROM_START"], [ne.Msg$$module$build$src$core$msg.TEXT_GET_SUBSTRING_END_FROM_END, "FROM_END"], [ne.Msg$$module$build$src$core$msg.TEXT_GET_SUBSTRING_END_LAST, "LAST"]],
                    this.setHelpUrl(ne.Msg$$module$build$src$core$msg.TEXT_GET_SUBSTRING_HELPURL),
                    this.setStyle("text_blocks"),
                    this.appendValueInput("STRING").setCheck("String").appendField(ne.Msg$$module$build$src$core$msg.TEXT_GET_SUBSTRING_INPUT_IN_TEXT),
                    this.appendDummyInput("AT1"),
                    this.appendDummyInput("AT2"),
                    ne.Msg$$module$build$src$core$msg.TEXT_GET_SUBSTRING_TAIL && this.appendDummyInput("TAIL").appendField(ne.Msg$$module$build$src$core$msg.TEXT_GET_SUBSTRING_TAIL),
                    this.setInputsInline(!0),
                    this.setOutput(!0, "String"),
                    this.updateAt_(1, !0),
                    this.updateAt_(2, !0),
                    this.setTooltip(ne.Msg$$module$build$src$core$msg.TEXT_GET_SUBSTRING_TOOLTIP)
                },
                mutationToDom: function() {
                    const Ge = ne.createElement$$module$build$src$core$utils$xml("mutation");
                    var st = this.getInput("AT1")instanceof ne.ValueInput$$module$build$src$core$inputs$value_input;
                    return Ge.setAttribute("at1", `${st}`),
                    st = this.getInput("AT2")instanceof ne.ValueInput$$module$build$src$core$inputs$value_input,
                    Ge.setAttribute("at2", `${st}`),
                    Ge
                },
                domToMutation: function(Ge) {
                    const st = Ge.getAttribute("at1") === "true";
                    Ge = Ge.getAttribute("at2") === "true",
                    this.updateAt_(1, st),
                    this.updateAt_(2, Ge)
                },
                updateAt_: function(Ge, st) {
                    this.removeInput("AT" + Ge),
                    this.removeInput("ORDINAL" + Ge, !0),
                    st ? (this.appendValueInput("AT" + Ge).setCheck("Number"),
                    ne.Msg$$module$build$src$core$msg.ORDINAL_NUMBER_SUFFIX && this.appendDummyInput("ORDINAL" + Ge).appendField(ne.Msg$$module$build$src$core$msg.ORDINAL_NUMBER_SUFFIX)) : this.appendDummyInput("AT" + Ge),
                    Ge === 2 && ne.Msg$$module$build$src$core$msg.TEXT_GET_SUBSTRING_TAIL && (this.removeInput("TAIL", !0),
                    this.appendDummyInput("TAIL").appendField(ne.Msg$$module$build$src$core$msg.TEXT_GET_SUBSTRING_TAIL));
                    const ht = ne.fromJson$$module$build$src$core$field_registry({
                        type: "field_dropdown",
                        options: this["WHERE_OPTIONS_" + Ge]
                    });
                    ht.setValidator(function(At) {
                        const Ft = At === "FROM_START" || At === "FROM_END";
                        if (Ft !== st) {
                            const an = this.getSourceBlock();
                            return an.updateAt_(Ge, Ft),
                            an.setFieldValue(At, "WHERE" + Ge),
                            null
                        }
                    }),
                    this.getInput("AT" + Ge).appendField(ht, "WHERE" + Ge),
                    Ge === 1 && (this.moveInputBefore("AT1", "AT2"),
                    this.getInput("ORDINAL1") && this.moveInputBefore("ORDINAL1", "AT2"))
                }
            };
            Ne.text_getSubstring = ve,
            Ne.text_changeCase = {
                init: function() {
                    const Ge = [[ne.Msg$$module$build$src$core$msg.TEXT_CHANGECASE_OPERATOR_UPPERCASE, "UPPERCASE"], [ne.Msg$$module$build$src$core$msg.TEXT_CHANGECASE_OPERATOR_LOWERCASE, "LOWERCASE"], [ne.Msg$$module$build$src$core$msg.TEXT_CHANGECASE_OPERATOR_TITLECASE, "TITLECASE"]];
                    this.setHelpUrl(ne.Msg$$module$build$src$core$msg.TEXT_CHANGECASE_HELPURL),
                    this.setStyle("text_blocks"),
                    this.appendValueInput("TEXT").setCheck("String").appendField(ne.fromJson$$module$build$src$core$field_registry({
                        type: "field_dropdown",
                        options: Ge
                    }), "CASE"),
                    this.setOutput(!0, "String"),
                    this.setTooltip(ne.Msg$$module$build$src$core$msg.TEXT_CHANGECASE_TOOLTIP)
                }
            },
            Ne.text_trim = {
                init: function() {
                    const Ge = [[ne.Msg$$module$build$src$core$msg.TEXT_TRIM_OPERATOR_BOTH, "BOTH"], [ne.Msg$$module$build$src$core$msg.TEXT_TRIM_OPERATOR_LEFT, "LEFT"], [ne.Msg$$module$build$src$core$msg.TEXT_TRIM_OPERATOR_RIGHT, "RIGHT"]];
                    this.setHelpUrl(ne.Msg$$module$build$src$core$msg.TEXT_TRIM_HELPURL),
                    this.setStyle("text_blocks"),
                    this.appendValueInput("TEXT").setCheck("String").appendField(ne.fromJson$$module$build$src$core$field_registry({
                        type: "field_dropdown",
                        options: Ge
                    }), "MODE"),
                    this.setOutput(!0, "String"),
                    this.setTooltip(ne.Msg$$module$build$src$core$msg.TEXT_TRIM_TOOLTIP)
                }
            },
            Ne.text_print = {
                init: function() {
                    this.jsonInit({
                        message0: ne.Msg$$module$build$src$core$msg.TEXT_PRINT_TITLE,
                        args0: [{
                            type: "input_value",
                            name: "TEXT"
                        }],
                        previousStatement: null,
                        nextStatement: null,
                        style: "text_blocks",
                        tooltip: ne.Msg$$module$build$src$core$msg.TEXT_PRINT_TOOLTIP,
                        helpUrl: ne.Msg$$module$build$src$core$msg.TEXT_PRINT_HELPURL
                    })
                }
            };
            var ke = {
                updateType_: function(Ge) {
                    this.outputConnection.setCheck(Ge === "NUMBER" ? "Number" : "String")
                },
                mutationToDom: function() {
                    const Ge = ne.createElement$$module$build$src$core$utils$xml("mutation");
                    return Ge.setAttribute("type", this.getFieldValue("TYPE")),
                    Ge
                },
                domToMutation: function(Ge) {
                    this.updateType_(Ge.getAttribute("type"))
                }
            };
            Ne.text_prompt_ext = Object.assign({}, ke, {
                init: function() {
                    var Ge = [[ne.Msg$$module$build$src$core$msg.TEXT_PROMPT_TYPE_TEXT, "TEXT"], [ne.Msg$$module$build$src$core$msg.TEXT_PROMPT_TYPE_NUMBER, "NUMBER"]];
                    this.setHelpUrl(ne.Msg$$module$build$src$core$msg.TEXT_PROMPT_HELPURL),
                    this.setStyle("text_blocks"),
                    Ge = ne.fromJson$$module$build$src$core$field_registry({
                        type: "field_dropdown",
                        options: Ge
                    }),
                    Ge.setValidator(st => {
                        this.updateType_(st)
                    }
                    ),
                    this.appendValueInput("TEXT").appendField(Ge, "TYPE"),
                    this.setOutput(!0, "String"),
                    this.setTooltip( () => this.getFieldValue("TYPE") === "TEXT" ? ne.Msg$$module$build$src$core$msg.TEXT_PROMPT_TOOLTIP_TEXT : ne.Msg$$module$build$src$core$msg.TEXT_PROMPT_TOOLTIP_NUMBER)
                }
            });
            var xe = Object.assign({}, ke, {
                init: function() {
                    this.mixin(we);
                    var Ge = [[ne.Msg$$module$build$src$core$msg.TEXT_PROMPT_TYPE_TEXT, "TEXT"], [ne.Msg$$module$build$src$core$msg.TEXT_PROMPT_TYPE_NUMBER, "NUMBER"]];
                    this.setHelpUrl(ne.Msg$$module$build$src$core$msg.TEXT_PROMPT_HELPURL),
                    this.setStyle("text_blocks"),
                    Ge = ne.fromJson$$module$build$src$core$field_registry({
                        type: "field_dropdown",
                        options: Ge
                    }),
                    Ge.setValidator(st => {
                        this.updateType_(st)
                    }
                    ),
                    this.appendDummyInput().appendField(Ge, "TYPE").appendField(this.newQuote_(!0)).appendField(ne.fromJson$$module$build$src$core$field_registry({
                        type: "field_input",
                        text: ""
                    }), "TEXT").appendField(this.newQuote_(!1)),
                    this.setOutput(!0, "String"),
                    this.setTooltip( () => this.getFieldValue("TYPE") === "TEXT" ? ne.Msg$$module$build$src$core$msg.TEXT_PROMPT_TOOLTIP_TEXT : ne.Msg$$module$build$src$core$msg.TEXT_PROMPT_TOOLTIP_NUMBER)
                }
            });
            Ne.text_prompt = xe,
            Ne.text_count = {
                init: function() {
                    this.jsonInit({
                        message0: ne.Msg$$module$build$src$core$msg.TEXT_COUNT_MESSAGE0,
                        args0: [{
                            type: "input_value",
                            name: "SUB",
                            check: "String"
                        }, {
                            type: "input_value",
                            name: "TEXT",
                            check: "String"
                        }],
                        output: "Number",
                        inputsInline: !0,
                        style: "text_blocks",
                        tooltip: ne.Msg$$module$build$src$core$msg.TEXT_COUNT_TOOLTIP,
                        helpUrl: ne.Msg$$module$build$src$core$msg.TEXT_COUNT_HELPURL
                    })
                }
            },
            Ne.text_replace = {
                init: function() {
                    this.jsonInit({
                        message0: ne.Msg$$module$build$src$core$msg.TEXT_REPLACE_MESSAGE0,
                        args0: [{
                            type: "input_value",
                            name: "FROM",
                            check: "String"
                        }, {
                            type: "input_value",
                            name: "TO",
                            check: "String"
                        }, {
                            type: "input_value",
                            name: "TEXT",
                            check: "String"
                        }],
                        output: "String",
                        inputsInline: !0,
                        style: "text_blocks",
                        tooltip: ne.Msg$$module$build$src$core$msg.TEXT_REPLACE_TOOLTIP,
                        helpUrl: ne.Msg$$module$build$src$core$msg.TEXT_REPLACE_HELPURL
                    })
                }
            },
            Ne.text_reverse = {
                init: function() {
                    this.jsonInit({
                        message0: ne.Msg$$module$build$src$core$msg.TEXT_REVERSE_MESSAGE0,
                        args0: [{
                            type: "input_value",
                            name: "TEXT",
                            check: "String"
                        }],
                        output: "String",
                        inputsInline: !0,
                        style: "text_blocks",
                        tooltip: ne.Msg$$module$build$src$core$msg.TEXT_REVERSE_TOOLTIP,
                        helpUrl: ne.Msg$$module$build$src$core$msg.TEXT_REVERSE_HELPURL
                    })
                }
            };
            var we = {
                QUOTE_IMAGE_LEFT_DATAURI: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAKCAQAAAAqJXdxAAAAn0lEQVQI1z3OMa5BURSF4f/cQhAKjUQhuQmFNwGJEUi0RKN5rU7FHKhpjEH3TEMtkdBSCY1EIv8r7nFX9e29V7EBAOvu7RPjwmWGH/VuF8CyN9/OAdvqIXYLvtRaNjx9mMTDyo+NjAN1HNcl9ZQ5oQMM3dgDUqDo1l8DzvwmtZN7mnD+PkmLa+4mhrxVA9fRowBWmVBhFy5gYEjKMfz9AylsaRRgGzvZAAAAAElFTkSuQmCC",
                QUOTE_IMAGE_RIGHT_DATAURI: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAKCAQAAAAqJXdxAAAAqUlEQVQI1z3KvUpCcRiA8ef9E4JNHhI0aFEacm1o0BsI0Slx8wa8gLauoDnoBhq7DcfWhggONDmJJgqCPA7neJ7p934EOOKOnM8Q7PDElo/4x4lFb2DmuUjcUzS3URnGib9qaPNbuXvBO3sGPHJDRG6fGVdMSeWDP2q99FQdFrz26Gu5Tq7dFMzUvbXy8KXeAj57cOklgA+u1B5AoslLtGIHQMaCVnwDnADZIFIrXsoXrgAAAABJRU5ErkJggg==",
                QUOTE_IMAGE_WIDTH: 12,
                QUOTE_IMAGE_HEIGHT: 12,
                quoteField_: function(Ge) {
                    for (let st = 0, ht; ht = this.inputList[st]; st++)
                        for (let At = 0, Ft; Ft = ht.fieldRow[At]; At++)
                            if (Ge === Ft.name) {
                                ht.insertFieldAt(At, this.newQuote_(!0)),
                                ht.insertFieldAt(At + 2, this.newQuote_(!1));
                                return
                            }
                    console.warn('field named "' + Ge + '" not found in ' + this.toDevString())
                },
                newQuote_: function(Ge) {
                    return Ge = this.RTL ? !Ge : Ge,
                    ne.fromJson$$module$build$src$core$field_registry({
                        type: "field_image",
                        src: Ge ? this.QUOTE_IMAGE_LEFT_DATAURI : this.QUOTE_IMAGE_RIGHT_DATAURI,
                        width: this.QUOTE_IMAGE_WIDTH,
                        height: this.QUOTE_IMAGE_HEIGHT,
                        alt: Ge ? "“" : "”"
                    })
                }
            }
              , Fe = function() {
                this.mixin(we),
                this.quoteField_("TEXT")
            }
              , je = {
                itemCount_: 0,
                mutationToDom: function() {
                    const Ge = ne.createElement$$module$build$src$core$utils$xml("mutation");
                    return Ge.setAttribute("items", `${this.itemCount_}`),
                    Ge
                },
                domToMutation: function(Ge) {
                    this.itemCount_ = parseInt(Ge.getAttribute("items"), 10),
                    this.updateShape_()
                },
                saveExtraState: function() {
                    return {
                        itemCount: this.itemCount_
                    }
                },
                loadExtraState: function(Ge) {
                    this.itemCount_ = Ge.itemCount,
                    this.updateShape_()
                },
                decompose: function(Ge) {
                    const st = Ge.newBlock("text_create_join_container");
                    st.initSvg();
                    let ht = st.getInput("STACK").connection;
                    for (let At = 0; At < this.itemCount_; At++) {
                        const Ft = Ge.newBlock("text_create_join_item");
                        Ft.initSvg(),
                        ht.connect(Ft.previousConnection),
                        ht = Ft.nextConnection
                    }
                    return st
                },
                compose: function(Ge) {
                    var st = Ge.getInputTargetBlock("STACK");
                    for (Ge = []; st; )
                        st.isInsertionMarker() || Ge.push(st.valueConnection_),
                        st = st.getNextBlock();
                    for (st = 0; st < this.itemCount_; st++) {
                        const ht = this.getInput("ADD" + st).connection.targetConnection;
                        ht && Ge.indexOf(ht) === -1 && ht.disconnect()
                    }
                    for (this.itemCount_ = Ge.length,
                    this.updateShape_(),
                    st = 0; st < this.itemCount_; st++) {
                        let ht;
                        (ht = Ge[st]) == null || ht.reconnect(this, "ADD" + st)
                    }
                },
                saveConnections: function(Ge) {
                    Ge = Ge.getInputTargetBlock("STACK");
                    let st = 0;
                    for (; Ge; ) {
                        if (Ge.isInsertionMarker()) {
                            Ge = Ge.getNextBlock();
                            continue
                        }
                        const ht = this.getInput("ADD" + st);
                        Ge.valueConnection_ = ht && ht.connection.targetConnection,
                        Ge = Ge.getNextBlock(),
                        st++
                    }
                },
                updateShape_: function() {
                    this.itemCount_ && this.getInput("EMPTY") ? this.removeInput("EMPTY") : this.itemCount_ || this.getInput("EMPTY") || this.appendDummyInput("EMPTY").appendField(this.newQuote_(!0)).appendField(this.newQuote_(!1));
                    for (var Ge = 0; Ge < this.itemCount_; Ge++)
                        if (!this.getInput("ADD" + Ge)) {
                            const st = this.appendValueInput("ADD" + Ge).setAlign(ne.Align$$module$build$src$core$inputs$align.RIGHT);
                            Ge === 0 && st.appendField(ne.Msg$$module$build$src$core$msg.TEXT_JOIN_TITLE_CREATEWITH)
                        }
                    for (Ge = this.itemCount_; this.getInput("ADD" + Ge); Ge++)
                        this.removeInput("ADD" + Ge)
                }
            }
              , Xe = function() {
                this.mixin(we),
                this.itemCount_ = 2,
                this.updateShape_(),
                this.setMutator(new ne.MutatorIcon$$module$build$src$core$icons$mutator_icon(["text_create_join_item"],this))
            };
            ne.register$$module$build$src$core$extensions("text_append_tooltip", ne.buildTooltipWithFieldText$$module$build$src$core$extensions("%{BKY_TEXT_APPEND_TOOLTIP}", "VAR"));
            var ze = function() {
                this.setTooltip( () => ne.Msg$$module$build$src$core$msg.TEXT_INDEXOF_TOOLTIP.replace("%1", this.workspace.options.oneBasedIndex ? "0" : "-1"))
            }
              , qe = {
                isAt_: !1,
                mutationToDom: function() {
                    const Ge = ne.createElement$$module$build$src$core$utils$xml("mutation");
                    return Ge.setAttribute("at", `${this.isAt_}`),
                    Ge
                },
                domToMutation: function(Ge) {
                    Ge = Ge.getAttribute("at") !== "false",
                    this.updateAt_(Ge)
                },
                updateAt_: function(Ge) {
                    this.removeInput("AT", !0),
                    this.removeInput("ORDINAL", !0),
                    Ge && (this.appendValueInput("AT").setCheck("Number"),
                    ne.Msg$$module$build$src$core$msg.ORDINAL_NUMBER_SUFFIX && this.appendDummyInput("ORDINAL").appendField(ne.Msg$$module$build$src$core$msg.ORDINAL_NUMBER_SUFFIX)),
                    ne.Msg$$module$build$src$core$msg.TEXT_CHARAT_TAIL && (this.removeInput("TAIL", !0),
                    this.appendDummyInput("TAIL").appendField(ne.Msg$$module$build$src$core$msg.TEXT_CHARAT_TAIL)),
                    this.isAt_ = Ge
                }
            }
              , Ze = function() {
                this.getField("WHERE").setValidator(function(Ge) {
                    Ge = Ge === "FROM_START" || Ge === "FROM_END";
                    const st = this.getSourceBlock();
                    Ge !== st.isAt_ && st.updateAt_(Ge)
                }),
                this.updateAt_(!0),
                this.setTooltip( () => {
                    var Ge = this.getFieldValue("WHERE");
                    let st = ne.Msg$$module$build$src$core$msg.TEXT_CHARAT_TOOLTIP;
                    return (Ge === "FROM_START" || Ge === "FROM_END") && (Ge = Ge === "FROM_START" ? ne.Msg$$module$build$src$core$msg.LISTS_INDEX_FROM_START_TOOLTIP : ne.Msg$$module$build$src$core$msg.LISTS_INDEX_FROM_END_TOOLTIP) && (st += "  " + Ge.replace("%1", this.workspace.options.oneBasedIndex ? "#1" : "#0")),
                    st
                }
                )
            };
            ne.register$$module$build$src$core$extensions("text_indexOf_tooltip", ze),
            ne.register$$module$build$src$core$extensions("text_quotes", Fe),
            ne.registerMixin$$module$build$src$core$extensions("quote_image_mixin", we),
            ne.registerMutator$$module$build$src$core$extensions("text_join_mutator", je, Xe),
            ne.registerMutator$$module$build$src$core$extensions("text_charAt_mutator", qe, Ze),
            ne.defineBlocks$$module$build$src$core$common(Ne);
            var et = {
                blocks: Ne
            }
              , it = {}
              , at = {
                setStatements_: function(Ge) {
                    this.hasStatements_ !== Ge && (Ge ? (this.appendStatementInput("STACK").appendField(ne.Msg$$module$build$src$core$msg.PROCEDURES_DEFNORETURN_DO),
                    this.getInput("RETURN") && this.moveInputBefore("STACK", "RETURN")) : this.removeInput("STACK", !0),
                    this.hasStatements_ = Ge)
                },
                updateParams_: function() {
                    let Ge = "";
                    this.arguments_.length && (Ge = ne.Msg$$module$build$src$core$msg.PROCEDURES_BEFORE_PARAMS + " " + this.arguments_.join(", ")),
                    ne.disable$$module$build$src$core$events$utils();
                    try {
                        this.setFieldValue(Ge, "PARAMS")
                    } finally {
                        ne.enable$$module$build$src$core$events$utils()
                    }
                },
                mutationToDom: function(Ge) {
                    const st = ne.createElement$$module$build$src$core$utils$xml("mutation");
                    Ge && st.setAttribute("name", this.getFieldValue("NAME"));
                    for (let ht = 0; ht < this.argumentVarModels_.length; ht++) {
                        const At = ne.createElement$$module$build$src$core$utils$xml("arg")
                          , Ft = this.argumentVarModels_[ht];
                        At.setAttribute("name", Ft.name),
                        At.setAttribute("varid", Ft.getId()),
                        Ge && this.paramIds_ && At.setAttribute("paramId", this.paramIds_[ht]),
                        st.appendChild(At)
                    }
                    return this.hasStatements_ || st.setAttribute("statements", "false"),
                    st
                },
                domToMutation: function(Ge) {
                    this.arguments_ = [],
                    this.argumentVarModels_ = [];
                    for (let ht = 0, At; At = Ge.childNodes[ht]; ht++)
                        if (At.nodeName.toLowerCase() === "arg") {
                            var st = At;
                            const Ft = st.getAttribute("name");
                            st = st.getAttribute("varid") || st.getAttribute("varId"),
                            this.arguments_.push(Ft),
                            st = ne.getOrCreateVariablePackage$$module$build$src$core$variables(this.workspace, st, Ft, ""),
                            st !== null ? this.argumentVarModels_.push(st) : console.log(`Failed to create a variable named "${Ft}", ignoring.`)
                        }
                    this.updateParams_(),
                    ne.mutateCallers$$module$build$src$core$procedures(this),
                    this.setStatements_(Ge.getAttribute("statements") !== "false")
                },
                saveExtraState: function() {
                    if (!this.argumentVarModels_.length && this.hasStatements_)
                        return null;
                    const Ge = Object.create(null);
                    if (this.argumentVarModels_.length) {
                        Ge.params = [];
                        for (let st = 0; st < this.argumentVarModels_.length; st++)
                            Ge.params.push({
                                name: this.argumentVarModels_[st].name,
                                id: this.argumentVarModels_[st].getId()
                            })
                    }
                    return this.hasStatements_ || (Ge.hasStatements = !1),
                    Ge
                },
                loadExtraState: function(Ge) {
                    if (this.arguments_ = [],
                    this.argumentVarModels_ = [],
                    Ge.params)
                        for (let ht = 0; ht < Ge.params.length; ht++) {
                            var st = Ge.params[ht];
                            st = ne.getOrCreateVariablePackage$$module$build$src$core$variables(this.workspace, st.id, st.name, ""),
                            this.arguments_.push(st.name),
                            this.argumentVarModels_.push(st)
                        }
                    this.updateParams_(),
                    ne.mutateCallers$$module$build$src$core$procedures(this),
                    this.setStatements_(Ge.hasStatements !== !1)
                },
                decompose: function(Ge) {
                    const st = ne.createElement$$module$build$src$core$utils$xml("block");
                    st.setAttribute("type", "procedures_mutatorcontainer");
                    var ht = ne.createElement$$module$build$src$core$utils$xml("statement");
                    ht.setAttribute("name", "STACK"),
                    st.appendChild(ht);
                    for (let Ft = 0; Ft < this.arguments_.length; Ft++) {
                        const an = ne.createElement$$module$build$src$core$utils$xml("block");
                        an.setAttribute("type", "procedures_mutatorarg");
                        var At = ne.createElement$$module$build$src$core$utils$xml("field");
                        At.setAttribute("name", "NAME");
                        const Sn = ne.createTextNode$$module$build$src$core$utils$xml(this.arguments_[Ft]);
                        At.appendChild(Sn),
                        an.appendChild(At),
                        At = ne.createElement$$module$build$src$core$utils$xml("next"),
                        an.appendChild(At),
                        ht.appendChild(an),
                        ht = At
                    }
                    return Ge = ne.domToBlock$$module$build$src$core$xml(st, Ge),
                    this.type === "procedures_defreturn" ? Ge.setFieldValue(this.hasStatements_, "STATEMENTS") : Ge.removeInput("STATEMENT_INPUT"),
                    ne.mutateCallers$$module$build$src$core$procedures(this),
                    Ge
                },
                compose: function(Ge) {
                    this.arguments_ = [],
                    this.paramIds_ = [],
                    this.argumentVarModels_ = [];
                    let st = Ge.getInputTargetBlock("STACK");
                    for (; st && !st.isInsertionMarker(); ) {
                        var ht = st.getFieldValue("NAME");
                        this.arguments_.push(ht),
                        ht = this.workspace.getVariable(ht, ""),
                        this.argumentVarModels_.push(ht),
                        this.paramIds_.push(st.id),
                        st = st.nextConnection && st.nextConnection.targetBlock()
                    }
                    if (this.updateParams_(),
                    ne.mutateCallers$$module$build$src$core$procedures(this),
                    Ge = Ge.getFieldValue("STATEMENTS"),
                    Ge !== null && (Ge = Ge === "TRUE",
                    this.hasStatements_ !== Ge))
                        if (Ge) {
                            this.setStatements_(!0);
                            var At;
                            (At = this.statementConnection_) == null || At.reconnect(this, "STACK"),
                            this.statementConnection_ = null
                        } else
                            At = this.getInput("STACK").connection,
                            (this.statementConnection_ = At.targetConnection) && (At = At.targetBlock(),
                            At.unplug(),
                            At.bumpNeighbours()),
                            this.setStatements_(!1)
                },
                getVars: function() {
                    return this.arguments_
                },
                getVarModels: function() {
                    return this.argumentVarModels_
                },
                renameVarById: function(Ge, st) {
                    var ht = this.workspace.getVariableById(Ge);
                    if (ht.type === "") {
                        ht = ht.name,
                        st = this.workspace.getVariableById(st);
                        var At = !1;
                        for (let Ft = 0; Ft < this.argumentVarModels_.length; Ft++)
                            this.argumentVarModels_[Ft].getId() === Ge && (this.arguments_[Ft] = st.name,
                            this.argumentVarModels_[Ft] = st,
                            At = !0);
                        At && (this.displayRenamedVar_(ht, st.name),
                        ne.mutateCallers$$module$build$src$core$procedures(this))
                    }
                },
                updateVarName: function(Ge) {
                    const st = Ge.name;
                    let ht = !1, At;
                    for (let Ft = 0; Ft < this.argumentVarModels_.length; Ft++)
                        this.argumentVarModels_[Ft].getId() === Ge.getId() && (At = this.arguments_[Ft],
                        this.arguments_[Ft] = st,
                        ht = !0);
                    ht && (this.displayRenamedVar_(At, st),
                    ne.mutateCallers$$module$build$src$core$procedures(this))
                },
                displayRenamedVar_: function(Ge, st) {
                    this.updateParams_();
                    var ht = this.getIcon(ne.MutatorIcon$$module$build$src$core$icons$mutator_icon.TYPE);
                    if (ht && ht.bubbleIsVisible()) {
                        ht = ht.getWorkspace().getAllBlocks(!1);
                        for (let At = 0, Ft; Ft = ht[At]; At++)
                            Ft.type === "procedures_mutatorarg" && ne.Names$$module$build$src$core$names.equals(Ge, Ft.getFieldValue("NAME")) && Ft.setFieldValue(st, "NAME")
                    }
                },
                customContextMenu: function(Ge) {
                    if (!this.isInFlyout) {
                        var st = this.getFieldValue("NAME")
                          , ht = {
                            type: this.callType_,
                            extraState: {
                                name: st,
                                params: this.arguments_
                            }
                        };
                        if (Ge.push({
                            enabled: !0,
                            text: ne.Msg$$module$build$src$core$msg.PROCEDURES_CREATE_DO.replace("%1", st),
                            callback: ne.callbackFactory$$module$build$src$core$contextmenu(this, ht)
                        }),
                        !this.isCollapsed())
                            for (st = 0; st < this.argumentVarModels_.length; st++) {
                                ht = this.argumentVarModels_[st];
                                const At = {
                                    type: "variables_get",
                                    fields: {
                                        VAR: {
                                            name: ht.name,
                                            id: ht.getId(),
                                            type: ht.type
                                        }
                                    }
                                };
                                Ge.push({
                                    enabled: !0,
                                    text: ne.Msg$$module$build$src$core$msg.VARIABLES_SET_CREATE_GET.replace("%1", ht.name),
                                    callback: ne.callbackFactory$$module$build$src$core$contextmenu(this, At)
                                })
                            }
                    }
                }
            };
            it.procedures_defnoreturn = Object.assign({}, at, {
                init: function() {
                    var Ge = ne.findLegalName$$module$build$src$core$procedures("", this);
                    Ge = ne.fromJson$$module$build$src$core$field_registry({
                        type: "field_input",
                        text: Ge
                    }),
                    Ge.setValidator(ne.rename$$module$build$src$core$procedures),
                    Ge.setSpellcheck(!1),
                    this.appendDummyInput().appendField(ne.Msg$$module$build$src$core$msg.PROCEDURES_DEFNORETURN_TITLE).appendField(Ge, "NAME").appendField("", "PARAMS"),
                    this.setMutator(new ne.MutatorIcon$$module$build$src$core$icons$mutator_icon(["procedures_mutatorarg"],this)),
                    (this.workspace.options.comments || this.workspace.options.parentWorkspace && this.workspace.options.parentWorkspace.options.comments) && ne.Msg$$module$build$src$core$msg.PROCEDURES_DEFNORETURN_COMMENT && this.setCommentText(ne.Msg$$module$build$src$core$msg.PROCEDURES_DEFNORETURN_COMMENT),
                    this.setStyle("procedure_blocks"),
                    this.setTooltip(ne.Msg$$module$build$src$core$msg.PROCEDURES_DEFNORETURN_TOOLTIP),
                    this.setHelpUrl(ne.Msg$$module$build$src$core$msg.PROCEDURES_DEFNORETURN_HELPURL),
                    this.arguments_ = [],
                    this.argumentVarModels_ = [],
                    this.setStatements_(!0),
                    this.statementConnection_ = null
                },
                getProcedureDef: function() {
                    return [this.getFieldValue("NAME"), this.arguments_, !1]
                },
                callType_: "procedures_callnoreturn"
            }),
            it.procedures_defreturn = Object.assign({}, at, {
                init: function() {
                    var Ge = ne.findLegalName$$module$build$src$core$procedures("", this);
                    Ge = ne.fromJson$$module$build$src$core$field_registry({
                        type: "field_input",
                        text: Ge
                    }),
                    Ge.setValidator(ne.rename$$module$build$src$core$procedures),
                    Ge.setSpellcheck(!1),
                    this.appendDummyInput().appendField(ne.Msg$$module$build$src$core$msg.PROCEDURES_DEFRETURN_TITLE).appendField(Ge, "NAME").appendField("", "PARAMS"),
                    this.appendValueInput("RETURN").setAlign(ne.Align$$module$build$src$core$inputs$input.RIGHT).appendField(ne.Msg$$module$build$src$core$msg.PROCEDURES_DEFRETURN_RETURN),
                    this.setMutator(new ne.MutatorIcon$$module$build$src$core$icons$mutator_icon(["procedures_mutatorarg"],this)),
                    (this.workspace.options.comments || this.workspace.options.parentWorkspace && this.workspace.options.parentWorkspace.options.comments) && ne.Msg$$module$build$src$core$msg.PROCEDURES_DEFRETURN_COMMENT && this.setCommentText(ne.Msg$$module$build$src$core$msg.PROCEDURES_DEFRETURN_COMMENT),
                    this.setStyle("procedure_blocks"),
                    this.setTooltip(ne.Msg$$module$build$src$core$msg.PROCEDURES_DEFRETURN_TOOLTIP),
                    this.setHelpUrl(ne.Msg$$module$build$src$core$msg.PROCEDURES_DEFRETURN_HELPURL),
                    this.arguments_ = [],
                    this.argumentVarModels_ = [],
                    this.setStatements_(!0),
                    this.statementConnection_ = null
                },
                getProcedureDef: function() {
                    return [this.getFieldValue("NAME"), this.arguments_, !0]
                },
                callType_: "procedures_callreturn"
            });
            var rt = {
                init: function() {
                    this.appendDummyInput().appendField(ne.Msg$$module$build$src$core$msg.PROCEDURES_MUTATORCONTAINER_TITLE),
                    this.appendStatementInput("STACK"),
                    this.appendDummyInput("STATEMENT_INPUT").appendField(ne.Msg$$module$build$src$core$msg.PROCEDURES_ALLOW_STATEMENTS).appendField(ne.fromJson$$module$build$src$core$field_registry({
                        type: "field_checkbox",
                        checked: !0
                    }), "STATEMENTS"),
                    this.setStyle("procedure_blocks"),
                    this.setTooltip(ne.Msg$$module$build$src$core$msg.PROCEDURES_MUTATORCONTAINER_TOOLTIP),
                    this.contextMenu = !1
                }
            };
            it.procedures_mutatorcontainer = rt;
            var ft = {
                init: function() {
                    const Ge = ne.fromJson$$module$build$src$core$field_registry({
                        type: "field_input",
                        text: ne.DEFAULT_ARG$$module$build$src$core$procedures
                    });
                    Ge.setValidator(this.validator_),
                    Ge.oldShowEditorFn_ = Ge.showEditor_,
                    Ge.showEditor_ = function() {
                        this.createdVariables_ = [],
                        this.oldShowEditorFn_()
                    }
                    ,
                    this.appendDummyInput().appendField(ne.Msg$$module$build$src$core$msg.PROCEDURES_MUTATORARG_TITLE).appendField(Ge, "NAME"),
                    this.setPreviousStatement(!0),
                    this.setNextStatement(!0),
                    this.setStyle("procedure_blocks"),
                    this.setTooltip(ne.Msg$$module$build$src$core$msg.PROCEDURES_MUTATORARG_TOOLTIP),
                    this.contextMenu = !1,
                    Ge.onFinishEditing_ = this.deleteIntermediateVars_,
                    Ge.createdVariables_ = [],
                    Ge.onFinishEditing_("x")
                },
                validator_: function(Ge) {
                    var st = this.getSourceBlock();
                    const ht = st.workspace.getRootWorkspace();
                    if (Ge = Ge.replace(/[\s\xa0]+/g, " ").replace(/^ | $/g, ""),
                    !Ge)
                        return null;
                    const At = (st.workspace.targetWorkspace || st.workspace).getAllBlocks(!1)
                      , Ft = Ge.toLowerCase();
                    for (let an = 0; an < At.length; an++) {
                        if (At[an].id === this.getSourceBlock().id)
                            continue;
                        const Sn = At[an].getFieldValue("NAME");
                        if (Sn && Sn.toLowerCase() === Ft)
                            return null
                    }
                    return st.isInFlyout || ((st = ht.getVariable(Ge, "")) && st.name !== Ge && ht.renameVariableById(st.getId(), Ge),
                    st || (st = ht.createVariable(Ge, "")) && this.createdVariables_ && this.createdVariables_.push(st)),
                    Ge
                },
                deleteIntermediateVars_: function(Ge) {
                    const st = this.getSourceBlock().workspace.getRootWorkspace();
                    if (st)
                        for (let ht = 0; ht < this.createdVariables_.length; ht++) {
                            const At = this.createdVariables_[ht];
                            At.name !== Ge && st.deleteVariableById(At.getId())
                        }
                }
            };
            it.procedures_mutatorarg = ft;
            var St = {
                getProcedureCall: function() {
                    return this.getFieldValue("NAME")
                },
                renameProcedure: function(Ge, st) {
                    ne.Names$$module$build$src$core$names.equals(Ge, this.getProcedureCall()) && (this.setFieldValue(st, "NAME"),
                    this.setTooltip((this.outputConnection ? ne.Msg$$module$build$src$core$msg.PROCEDURES_CALLRETURN_TOOLTIP : ne.Msg$$module$build$src$core$msg.PROCEDURES_CALLNORETURN_TOOLTIP).replace("%1", st)))
                },
                setProcedureParameters_: function(Ge, st) {
                    var ht = ne.getDefinition$$module$build$src$core$procedures(this.getProcedureCall(), this.workspace);
                    if ((ht = (ht = ht && ht.getIcon(ne.MutatorIcon$$module$build$src$core$icons$mutator_icon.TYPE)) && ht.bubbleIsVisible()) ? this.setCollapsed(!1) : (this.quarkConnections_ = {},
                    this.quarkIds_ = null),
                    Ge.join(`
`) === this.arguments_.join(`
`))
                        this.quarkIds_ = st;
                    else {
                        if (st.length !== Ge.length)
                            throw RangeError("paramNames and paramIds must be the same length.");
                        this.quarkIds_ || (this.quarkConnections_ = {},
                        this.quarkIds_ = []);
                        for (let Ft = 0; Ft < this.arguments_.length; Ft++) {
                            var At = this.getInput("ARG" + Ft);
                            At && (At = At.connection.targetConnection,
                            this.quarkConnections_[this.quarkIds_[Ft]] = At,
                            ht && At && st.indexOf(this.quarkIds_[Ft]) === -1 && (At.disconnect(),
                            At.getSourceBlock().bumpNeighbours()))
                        }
                        for (this.arguments_ = [].concat(Ge),
                        this.argumentVarModels_ = [],
                        Ge = 0; Ge < this.arguments_.length; Ge++)
                            ht = ne.getOrCreateVariablePackage$$module$build$src$core$variables(this.workspace, null, this.arguments_[Ge], ""),
                            this.argumentVarModels_.push(ht);
                        if (this.updateShape_(),
                        this.quarkIds_ = st) {
                            for (st = 0; st < this.arguments_.length; st++)
                                if (Ge = this.quarkIds_[st],
                                Ge in this.quarkConnections_) {
                                    let Ft;
                                    (Ft = this.quarkConnections_[Ge]) != null && Ft.reconnect(this, "ARG" + st) || delete this.quarkConnections_[Ge]
                                }
                        }
                    }
                },
                updateShape_: function() {
                    for (var Ge = 0; Ge < this.arguments_.length; Ge++) {
                        var st = this.getField("ARGNAME" + Ge);
                        if (st) {
                            ne.disable$$module$build$src$core$events$utils();
                            try {
                                st.setValue(this.arguments_[Ge])
                            } finally {
                                ne.enable$$module$build$src$core$events$utils()
                            }
                        } else
                            st = ne.fromJson$$module$build$src$core$field_registry({
                                type: "field_label",
                                text: this.arguments_[Ge]
                            }),
                            this.appendValueInput("ARG" + Ge).setAlign(ne.Align$$module$build$src$core$inputs$input.RIGHT).appendField(st, "ARGNAME" + Ge).init()
                    }
                    for (Ge = this.arguments_.length; this.getInput("ARG" + Ge); Ge++)
                        this.removeInput("ARG" + Ge);
                    (Ge = this.getInput("TOPROW")) && (this.arguments_.length ? this.getField("WITH") || (Ge.appendField(ne.Msg$$module$build$src$core$msg.PROCEDURES_CALL_BEFORE_PARAMS, "WITH"),
                    Ge.init()) : this.getField("WITH") && Ge.removeField("WITH"))
                },
                mutationToDom: function() {
                    const Ge = ne.createElement$$module$build$src$core$utils$xml("mutation");
                    Ge.setAttribute("name", this.getProcedureCall());
                    for (let st = 0; st < this.arguments_.length; st++) {
                        const ht = ne.createElement$$module$build$src$core$utils$xml("arg");
                        ht.setAttribute("name", this.arguments_[st]),
                        Ge.appendChild(ht)
                    }
                    return Ge
                },
                domToMutation: function(Ge) {
                    var st = Ge.getAttribute("name");
                    this.renameProcedure(this.getProcedureCall(), st),
                    st = [];
                    const ht = [];
                    for (let At = 0, Ft; Ft = Ge.childNodes[At]; At++)
                        Ft.nodeName.toLowerCase() === "arg" && (st.push(Ft.getAttribute("name")),
                        ht.push(Ft.getAttribute("paramId")));
                    this.setProcedureParameters_(st, ht)
                },
                saveExtraState: function() {
                    const Ge = Object.create(null);
                    return Ge.name = this.getProcedureCall(),
                    this.arguments_.length && (Ge.params = this.arguments_),
                    Ge
                },
                loadExtraState: function(Ge) {
                    if (this.renameProcedure(this.getProcedureCall(), Ge.name),
                    Ge = Ge.params) {
                        const st = [];
                        st.length = Ge.length,
                        st.fill(null),
                        this.setProcedureParameters_(Ge, st)
                    }
                },
                getVars: function() {
                    return this.arguments_
                },
                getVarModels: function() {
                    return this.argumentVarModels_
                },
                onchange: function(Ge) {
                    if (this.workspace && !this.workspace.isFlyout && Ge.recordUndo)
                        if (Ge.type === ne.CREATE$$module$build$src$core$events$utils && Ge.ids.indexOf(this.id) !== -1) {
                            var st = this.getProcedureCall();
                            if (st = ne.getDefinition$$module$build$src$core$procedures(st, this.workspace),
                            !st || st.type === this.defType_ && JSON.stringify(st.getVars()) === JSON.stringify(this.arguments_) || (st = null),
                            !st) {
                                ne.setGroup$$module$build$src$core$events$utils(Ge.group),
                                Ge = ne.createElement$$module$build$src$core$utils$xml("xml"),
                                st = ne.createElement$$module$build$src$core$utils$xml("block"),
                                st.setAttribute("type", this.defType_);
                                var ht = this.getRelativeToSurfaceXY()
                                  , At = ht.y + 2 * ne.config$$module$build$src$core$config.snapRadius;
                                st.setAttribute("x", `${ht.x + ne.config$$module$build$src$core$config.snapRadius * (this.RTL ? -1 : 1)}`),
                                st.setAttribute("y", `${At}`),
                                ht = this.mutationToDom(),
                                st.appendChild(ht),
                                ht = ne.createElement$$module$build$src$core$utils$xml("field"),
                                ht.setAttribute("name", "NAME"),
                                At = this.getProcedureCall();
                                const Ft = ne.findLegalName$$module$build$src$core$procedures(At, this);
                                At !== Ft && this.renameProcedure(At, Ft),
                                ht.appendChild(ne.createTextNode$$module$build$src$core$utils$xml(At)),
                                st.appendChild(ht),
                                Ge.appendChild(st),
                                ne.domToWorkspace$$module$build$src$core$xml(Ge, this.workspace),
                                ne.setGroup$$module$build$src$core$events$utils(!1)
                            }
                        } else
                            Ge.type === ne.DELETE$$module$build$src$core$events$utils ? (st = this.getProcedureCall(),
                            ne.getDefinition$$module$build$src$core$procedures(st, this.workspace) || (ne.setGroup$$module$build$src$core$events$utils(Ge.group),
                            this.dispose(!0),
                            ne.setGroup$$module$build$src$core$events$utils(!1))) : Ge.type === ne.CHANGE$$module$build$src$core$events$utils && Ge.element === "disabled" && (st = this.getProcedureCall(),
                            (st = ne.getDefinition$$module$build$src$core$procedures(st, this.workspace)) && st.id === Ge.blockId && ((st = ne.getGroup$$module$build$src$core$events$utils()) && console.log("Saw an existing group while responding to a definition change"),
                            ne.setGroup$$module$build$src$core$events$utils(Ge.group),
                            Ge.newValue ? (this.previousEnabledState_ = this.isEnabled(),
                            this.setEnabled(!1)) : this.setEnabled(this.previousEnabledState_),
                            ne.setGroup$$module$build$src$core$events$utils(st)))
                },
                customContextMenu: function(Ge) {
                    if (this.workspace.isMovable()) {
                        var st = this.getProcedureCall()
                          , ht = this.workspace;
                        Ge.push({
                            enabled: !0,
                            text: ne.Msg$$module$build$src$core$msg.PROCEDURES_HIGHLIGHT_DEF,
                            callback: function() {
                                const At = ne.getDefinition$$module$build$src$core$procedures(st, ht);
                                At && (ht.centerOnBlock(At.id),
                                At.select())
                            }
                        })
                    }
                }
            };
            it.procedures_callnoreturn = Object.assign({}, St, {
                init: function() {
                    this.appendDummyInput("TOPROW").appendField("", "NAME"),
                    this.setPreviousStatement(!0),
                    this.setNextStatement(!0),
                    this.setStyle("procedure_blocks"),
                    this.setHelpUrl(ne.Msg$$module$build$src$core$msg.PROCEDURES_CALLNORETURN_HELPURL),
                    this.arguments_ = [],
                    this.argumentVarModels_ = [],
                    this.quarkConnections_ = {},
                    this.quarkIds_ = null,
                    this.previousEnabledState_ = !0
                },
                defType_: "procedures_defnoreturn"
            }),
            it.procedures_callreturn = Object.assign({}, St, {
                init: function() {
                    this.appendDummyInput("TOPROW").appendField("", "NAME"),
                    this.setOutput(!0),
                    this.setStyle("procedure_blocks"),
                    this.setHelpUrl(ne.Msg$$module$build$src$core$msg.PROCEDURES_CALLRETURN_HELPURL),
                    this.arguments_ = [],
                    this.argumentVarModels_ = [],
                    this.quarkConnections_ = {},
                    this.quarkIds_ = null,
                    this.previousEnabledState_ = !0
                },
                defType_: "procedures_defreturn"
            });
            var Ye = {
                init: function() {
                    this.appendValueInput("CONDITION").setCheck("Boolean").appendField(ne.Msg$$module$build$src$core$msg.CONTROLS_IF_MSG_IF),
                    this.appendValueInput("VALUE").appendField(ne.Msg$$module$build$src$core$msg.PROCEDURES_DEFRETURN_RETURN),
                    this.setInputsInline(!0),
                    this.setPreviousStatement(!0),
                    this.setNextStatement(!0),
                    this.setStyle("procedure_blocks"),
                    this.setTooltip(ne.Msg$$module$build$src$core$msg.PROCEDURES_IFRETURN_TOOLTIP),
                    this.setHelpUrl(ne.Msg$$module$build$src$core$msg.PROCEDURES_IFRETURN_HELPURL),
                    this.hasReturnValue_ = !0
                },
                mutationToDom: function() {
                    const Ge = ne.createElement$$module$build$src$core$utils$xml("mutation");
                    return Ge.setAttribute("value", String(Number(this.hasReturnValue_))),
                    Ge
                },
                domToMutation: function(Ge) {
                    this.hasReturnValue_ = Ge.getAttribute("value") === "1",
                    this.hasReturnValue_ || (this.removeInput("VALUE"),
                    this.appendDummyInput("VALUE").appendField(ne.Msg$$module$build$src$core$msg.PROCEDURES_DEFRETURN_RETURN))
                },
                onchange: function(Ge) {
                    if (!(this.workspace.isDragging && this.workspace.isDragging() || Ge.type !== ne.MOVE$$module$build$src$core$events$utils)) {
                        var st = !1
                          , ht = this;
                        do {
                            if (this.FUNCTION_TYPES.indexOf(ht.type) !== -1) {
                                st = !0;
                                break
                            }
                            ht = ht.getSurroundParent()
                        } while (ht);
                        st ? (ht.type === "procedures_defnoreturn" && this.hasReturnValue_ ? (this.removeInput("VALUE"),
                        this.appendDummyInput("VALUE").appendField(ne.Msg$$module$build$src$core$msg.PROCEDURES_DEFRETURN_RETURN),
                        this.hasReturnValue_ = !1) : ht.type !== "procedures_defreturn" || this.hasReturnValue_ || (this.removeInput("VALUE"),
                        this.appendValueInput("VALUE").appendField(ne.Msg$$module$build$src$core$msg.PROCEDURES_DEFRETURN_RETURN),
                        this.hasReturnValue_ = !0),
                        this.setWarningText(null)) : this.setWarningText(ne.Msg$$module$build$src$core$msg.PROCEDURES_IFRETURN_WARNING),
                        this.isInFlyout || (ht = ne.getGroup$$module$build$src$core$events$utils(),
                        ne.setGroup$$module$build$src$core$events$utils(Ge.group),
                        this.setEnabled(st),
                        ne.setGroup$$module$build$src$core$events$utils(ht))
                    }
                },
                FUNCTION_TYPES: ["procedures_defnoreturn", "procedures_defreturn"]
            };
            it.procedures_ifreturn = Ye,
            ne.defineBlocks$$module$build$src$core$common(it);
            var We = {
                blocks: it
            }
              , nt = ne.createBlockDefinitionsFromJsonArray$$module$build$src$core$common([{
                type: "math_number",
                message0: "%1",
                args0: [{
                    type: "field_number",
                    name: "NUM",
                    value: 0
                }],
                output: "Number",
                helpUrl: "%{BKY_MATH_NUMBER_HELPURL}",
                style: "math_blocks",
                tooltip: "%{BKY_MATH_NUMBER_TOOLTIP}",
                extensions: ["parent_tooltip_when_inline"]
            }, {
                type: "math_arithmetic",
                message0: "%1 %2 %3",
                args0: [{
                    type: "input_value",
                    name: "A",
                    check: "Number"
                }, {
                    type: "field_dropdown",
                    name: "OP",
                    options: [["%{BKY_MATH_ADDITION_SYMBOL}", "ADD"], ["%{BKY_MATH_SUBTRACTION_SYMBOL}", "MINUS"], ["%{BKY_MATH_MULTIPLICATION_SYMBOL}", "MULTIPLY"], ["%{BKY_MATH_DIVISION_SYMBOL}", "DIVIDE"], ["%{BKY_MATH_POWER_SYMBOL}", "POWER"]]
                }, {
                    type: "input_value",
                    name: "B",
                    check: "Number"
                }],
                inputsInline: !0,
                output: "Number",
                style: "math_blocks",
                helpUrl: "%{BKY_MATH_ARITHMETIC_HELPURL}",
                extensions: ["math_op_tooltip"]
            }, {
                type: "math_single",
                message0: "%1 %2",
                args0: [{
                    type: "field_dropdown",
                    name: "OP",
                    options: [["%{BKY_MATH_SINGLE_OP_ROOT}", "ROOT"], ["%{BKY_MATH_SINGLE_OP_ABSOLUTE}", "ABS"], ["-", "NEG"], ["ln", "LN"], ["log10", "LOG10"], ["e^", "EXP"], ["10^", "POW10"]]
                }, {
                    type: "input_value",
                    name: "NUM",
                    check: "Number"
                }],
                output: "Number",
                style: "math_blocks",
                helpUrl: "%{BKY_MATH_SINGLE_HELPURL}",
                extensions: ["math_op_tooltip"]
            }, {
                type: "math_trig",
                message0: "%1 %2",
                args0: [{
                    type: "field_dropdown",
                    name: "OP",
                    options: [["%{BKY_MATH_TRIG_SIN}", "SIN"], ["%{BKY_MATH_TRIG_COS}", "COS"], ["%{BKY_MATH_TRIG_TAN}", "TAN"], ["%{BKY_MATH_TRIG_ASIN}", "ASIN"], ["%{BKY_MATH_TRIG_ACOS}", "ACOS"], ["%{BKY_MATH_TRIG_ATAN}", "ATAN"]]
                }, {
                    type: "input_value",
                    name: "NUM",
                    check: "Number"
                }],
                output: "Number",
                style: "math_blocks",
                helpUrl: "%{BKY_MATH_TRIG_HELPURL}",
                extensions: ["math_op_tooltip"]
            }, {
                type: "math_constant",
                message0: "%1",
                args0: [{
                    type: "field_dropdown",
                    name: "CONSTANT",
                    options: [["π", "PI"], ["e", "E"], ["φ", "GOLDEN_RATIO"], ["sqrt(2)", "SQRT2"], ["sqrt(½)", "SQRT1_2"], ["∞", "INFINITY"]]
                }],
                output: "Number",
                style: "math_blocks",
                tooltip: "%{BKY_MATH_CONSTANT_TOOLTIP}",
                helpUrl: "%{BKY_MATH_CONSTANT_HELPURL}"
            }, {
                type: "math_number_property",
                message0: "%1 %2",
                args0: [{
                    type: "input_value",
                    name: "NUMBER_TO_CHECK",
                    check: "Number"
                }, {
                    type: "field_dropdown",
                    name: "PROPERTY",
                    options: [["%{BKY_MATH_IS_EVEN}", "EVEN"], ["%{BKY_MATH_IS_ODD}", "ODD"], ["%{BKY_MATH_IS_PRIME}", "PRIME"], ["%{BKY_MATH_IS_WHOLE}", "WHOLE"], ["%{BKY_MATH_IS_POSITIVE}", "POSITIVE"], ["%{BKY_MATH_IS_NEGATIVE}", "NEGATIVE"], ["%{BKY_MATH_IS_DIVISIBLE_BY}", "DIVISIBLE_BY"]]
                }],
                inputsInline: !0,
                output: "Boolean",
                style: "math_blocks",
                tooltip: "%{BKY_MATH_IS_TOOLTIP}",
                mutator: "math_is_divisibleby_mutator"
            }, {
                type: "math_change",
                message0: "%{BKY_MATH_CHANGE_TITLE}",
                args0: [{
                    type: "field_variable",
                    name: "VAR",
                    variable: "%{BKY_MATH_CHANGE_TITLE_ITEM}"
                }, {
                    type: "input_value",
                    name: "DELTA",
                    check: "Number"
                }],
                previousStatement: null,
                nextStatement: null,
                style: "variable_blocks",
                helpUrl: "%{BKY_MATH_CHANGE_HELPURL}",
                extensions: ["math_change_tooltip"]
            }, {
                type: "math_round",
                message0: "%1 %2",
                args0: [{
                    type: "field_dropdown",
                    name: "OP",
                    options: [["%{BKY_MATH_ROUND_OPERATOR_ROUND}", "ROUND"], ["%{BKY_MATH_ROUND_OPERATOR_ROUNDUP}", "ROUNDUP"], ["%{BKY_MATH_ROUND_OPERATOR_ROUNDDOWN}", "ROUNDDOWN"]]
                }, {
                    type: "input_value",
                    name: "NUM",
                    check: "Number"
                }],
                output: "Number",
                style: "math_blocks",
                helpUrl: "%{BKY_MATH_ROUND_HELPURL}",
                tooltip: "%{BKY_MATH_ROUND_TOOLTIP}"
            }, {
                type: "math_on_list",
                message0: "%1 %2",
                args0: [{
                    type: "field_dropdown",
                    name: "OP",
                    options: [["%{BKY_MATH_ONLIST_OPERATOR_SUM}", "SUM"], ["%{BKY_MATH_ONLIST_OPERATOR_MIN}", "MIN"], ["%{BKY_MATH_ONLIST_OPERATOR_MAX}", "MAX"], ["%{BKY_MATH_ONLIST_OPERATOR_AVERAGE}", "AVERAGE"], ["%{BKY_MATH_ONLIST_OPERATOR_MEDIAN}", "MEDIAN"], ["%{BKY_MATH_ONLIST_OPERATOR_MODE}", "MODE"], ["%{BKY_MATH_ONLIST_OPERATOR_STD_DEV}", "STD_DEV"], ["%{BKY_MATH_ONLIST_OPERATOR_RANDOM}", "RANDOM"]]
                }, {
                    type: "input_value",
                    name: "LIST",
                    check: "Array"
                }],
                output: "Number",
                style: "math_blocks",
                helpUrl: "%{BKY_MATH_ONLIST_HELPURL}",
                mutator: "math_modes_of_list_mutator",
                extensions: ["math_op_tooltip"]
            }, {
                type: "math_modulo",
                message0: "%{BKY_MATH_MODULO_TITLE}",
                args0: [{
                    type: "input_value",
                    name: "DIVIDEND",
                    check: "Number"
                }, {
                    type: "input_value",
                    name: "DIVISOR",
                    check: "Number"
                }],
                inputsInline: !0,
                output: "Number",
                style: "math_blocks",
                tooltip: "%{BKY_MATH_MODULO_TOOLTIP}",
                helpUrl: "%{BKY_MATH_MODULO_HELPURL}"
            }, {
                type: "math_constrain",
                message0: "%{BKY_MATH_CONSTRAIN_TITLE}",
                args0: [{
                    type: "input_value",
                    name: "VALUE",
                    check: "Number"
                }, {
                    type: "input_value",
                    name: "LOW",
                    check: "Number"
                }, {
                    type: "input_value",
                    name: "HIGH",
                    check: "Number"
                }],
                inputsInline: !0,
                output: "Number",
                style: "math_blocks",
                tooltip: "%{BKY_MATH_CONSTRAIN_TOOLTIP}",
                helpUrl: "%{BKY_MATH_CONSTRAIN_HELPURL}"
            }, {
                type: "math_random_int",
                message0: "%{BKY_MATH_RANDOM_INT_TITLE}",
                args0: [{
                    type: "input_value",
                    name: "FROM",
                    check: "Number"
                }, {
                    type: "input_value",
                    name: "TO",
                    check: "Number"
                }],
                inputsInline: !0,
                output: "Number",
                style: "math_blocks",
                tooltip: "%{BKY_MATH_RANDOM_INT_TOOLTIP}",
                helpUrl: "%{BKY_MATH_RANDOM_INT_HELPURL}"
            }, {
                type: "math_random_float",
                message0: "%{BKY_MATH_RANDOM_FLOAT_TITLE_RANDOM}",
                output: "Number",
                style: "math_blocks",
                tooltip: "%{BKY_MATH_RANDOM_FLOAT_TOOLTIP}",
                helpUrl: "%{BKY_MATH_RANDOM_FLOAT_HELPURL}"
            }, {
                type: "math_atan2",
                message0: "%{BKY_MATH_ATAN2_TITLE}",
                args0: [{
                    type: "input_value",
                    name: "X",
                    check: "Number"
                }, {
                    type: "input_value",
                    name: "Y",
                    check: "Number"
                }],
                inputsInline: !0,
                output: "Number",
                style: "math_blocks",
                tooltip: "%{BKY_MATH_ATAN2_TOOLTIP}",
                helpUrl: "%{BKY_MATH_ATAN2_HELPURL}"
            }])
              , ct = {
                ADD: "%{BKY_MATH_ARITHMETIC_TOOLTIP_ADD}",
                MINUS: "%{BKY_MATH_ARITHMETIC_TOOLTIP_MINUS}",
                MULTIPLY: "%{BKY_MATH_ARITHMETIC_TOOLTIP_MULTIPLY}",
                DIVIDE: "%{BKY_MATH_ARITHMETIC_TOOLTIP_DIVIDE}",
                POWER: "%{BKY_MATH_ARITHMETIC_TOOLTIP_POWER}",
                ROOT: "%{BKY_MATH_SINGLE_TOOLTIP_ROOT}",
                ABS: "%{BKY_MATH_SINGLE_TOOLTIP_ABS}",
                NEG: "%{BKY_MATH_SINGLE_TOOLTIP_NEG}",
                LN: "%{BKY_MATH_SINGLE_TOOLTIP_LN}",
                LOG10: "%{BKY_MATH_SINGLE_TOOLTIP_LOG10}",
                EXP: "%{BKY_MATH_SINGLE_TOOLTIP_EXP}",
                POW10: "%{BKY_MATH_SINGLE_TOOLTIP_POW10}",
                SIN: "%{BKY_MATH_TRIG_TOOLTIP_SIN}",
                COS: "%{BKY_MATH_TRIG_TOOLTIP_COS}",
                TAN: "%{BKY_MATH_TRIG_TOOLTIP_TAN}",
                ASIN: "%{BKY_MATH_TRIG_TOOLTIP_ASIN}",
                ACOS: "%{BKY_MATH_TRIG_TOOLTIP_ACOS}",
                ATAN: "%{BKY_MATH_TRIG_TOOLTIP_ATAN}",
                SUM: "%{BKY_MATH_ONLIST_TOOLTIP_SUM}",
                MIN: "%{BKY_MATH_ONLIST_TOOLTIP_MIN}",
                MAX: "%{BKY_MATH_ONLIST_TOOLTIP_MAX}",
                AVERAGE: "%{BKY_MATH_ONLIST_TOOLTIP_AVERAGE}",
                MEDIAN: "%{BKY_MATH_ONLIST_TOOLTIP_MEDIAN}",
                MODE: "%{BKY_MATH_ONLIST_TOOLTIP_MODE}",
                STD_DEV: "%{BKY_MATH_ONLIST_TOOLTIP_STD_DEV}",
                RANDOM: "%{BKY_MATH_ONLIST_TOOLTIP_RANDOM}"
            };
            ne.register$$module$build$src$core$extensions("math_op_tooltip", ne.buildTooltipForDropdown$$module$build$src$core$extensions("OP", ct));
            var Et = {
                mutationToDom: function() {
                    const Ge = ne.createElement$$module$build$src$core$utils$xml("mutation")
                      , st = this.getFieldValue("PROPERTY") === "DIVISIBLE_BY";
                    return Ge.setAttribute("divisor_input", String(st)),
                    Ge
                },
                domToMutation: function(Ge) {
                    Ge = Ge.getAttribute("divisor_input") === "true",
                    this.updateShape_(Ge)
                },
                updateShape_: function(Ge) {
                    const st = this.getInput("DIVISOR");
                    Ge ? st || this.appendValueInput("DIVISOR").setCheck("Number") : st && this.removeInput("DIVISOR")
                }
            }
              , Ke = function() {
                this.getField("PROPERTY").setValidator(function(Ge) {
                    Ge = Ge === "DIVISIBLE_BY",
                    this.getSourceBlock().updateShape_(Ge)
                })
            };
            ne.registerMutator$$module$build$src$core$extensions("math_is_divisibleby_mutator", Et, Ke),
            ne.register$$module$build$src$core$extensions("math_change_tooltip", ne.buildTooltipWithFieldText$$module$build$src$core$extensions("%{BKY_MATH_CHANGE_TOOLTIP}", "VAR"));
            var mt = {
                updateType_: function(Ge) {
                    Ge === "MODE" ? this.outputConnection.setCheck("Array") : this.outputConnection.setCheck("Number")
                },
                mutationToDom: function() {
                    const Ge = ne.createElement$$module$build$src$core$utils$xml("mutation");
                    return Ge.setAttribute("op", this.getFieldValue("OP")),
                    Ge
                },
                domToMutation: function(Ge) {
                    if (Ge = Ge.getAttribute("op"),
                    Ge === null)
                        throw new TypeError("xmlElement had no op attribute");
                    this.updateType_(Ge)
                }
            }
              , lt = function() {
                this.getField("OP").setValidator((function(Ge) {
                    this.updateType_(Ge)
                }
                ).bind(this))
            };
            ne.registerMutator$$module$build$src$core$extensions("math_modes_of_list_mutator", mt, lt),
            ne.defineBlocks$$module$build$src$core$common(nt);
            var Qe = {
                blocks: nt
            }
              , gt = ne.createBlockDefinitionsFromJsonArray$$module$build$src$core$common([{
                type: "controls_repeat_ext",
                message0: "%{BKY_CONTROLS_REPEAT_TITLE}",
                args0: [{
                    type: "input_value",
                    name: "TIMES",
                    check: "Number"
                }],
                message1: "%{BKY_CONTROLS_REPEAT_INPUT_DO} %1",
                args1: [{
                    type: "input_statement",
                    name: "DO"
                }],
                previousStatement: null,
                nextStatement: null,
                style: "loop_blocks",
                tooltip: "%{BKY_CONTROLS_REPEAT_TOOLTIP}",
                helpUrl: "%{BKY_CONTROLS_REPEAT_HELPURL}"
            }, {
                type: "controls_repeat",
                message0: "%{BKY_CONTROLS_REPEAT_TITLE}",
                args0: [{
                    type: "field_number",
                    name: "TIMES",
                    value: 10,
                    min: 0,
                    precision: 1
                }],
                message1: "%{BKY_CONTROLS_REPEAT_INPUT_DO} %1",
                args1: [{
                    type: "input_statement",
                    name: "DO"
                }],
                previousStatement: null,
                nextStatement: null,
                style: "loop_blocks",
                tooltip: "%{BKY_CONTROLS_REPEAT_TOOLTIP}",
                helpUrl: "%{BKY_CONTROLS_REPEAT_HELPURL}"
            }, {
                type: "controls_whileUntil",
                message0: "%1 %2",
                args0: [{
                    type: "field_dropdown",
                    name: "MODE",
                    options: [["%{BKY_CONTROLS_WHILEUNTIL_OPERATOR_WHILE}", "WHILE"], ["%{BKY_CONTROLS_WHILEUNTIL_OPERATOR_UNTIL}", "UNTIL"]]
                }, {
                    type: "input_value",
                    name: "BOOL",
                    check: "Boolean"
                }],
                message1: "%{BKY_CONTROLS_REPEAT_INPUT_DO} %1",
                args1: [{
                    type: "input_statement",
                    name: "DO"
                }],
                previousStatement: null,
                nextStatement: null,
                style: "loop_blocks",
                helpUrl: "%{BKY_CONTROLS_WHILEUNTIL_HELPURL}",
                extensions: ["controls_whileUntil_tooltip"]
            }, {
                type: "controls_for",
                message0: "%{BKY_CONTROLS_FOR_TITLE}",
                args0: [{
                    type: "field_variable",
                    name: "VAR",
                    variable: null
                }, {
                    type: "input_value",
                    name: "FROM",
                    check: "Number",
                    align: "RIGHT"
                }, {
                    type: "input_value",
                    name: "TO",
                    check: "Number",
                    align: "RIGHT"
                }, {
                    type: "input_value",
                    name: "BY",
                    check: "Number",
                    align: "RIGHT"
                }],
                message1: "%{BKY_CONTROLS_REPEAT_INPUT_DO} %1",
                args1: [{
                    type: "input_statement",
                    name: "DO"
                }],
                inputsInline: !0,
                previousStatement: null,
                nextStatement: null,
                style: "loop_blocks",
                helpUrl: "%{BKY_CONTROLS_FOR_HELPURL}",
                extensions: ["contextMenu_newGetVariableBlock", "controls_for_tooltip"]
            }, {
                type: "controls_forEach",
                message0: "%{BKY_CONTROLS_FOREACH_TITLE}",
                args0: [{
                    type: "field_variable",
                    name: "VAR",
                    variable: null
                }, {
                    type: "input_value",
                    name: "LIST",
                    check: "Array"
                }],
                message1: "%{BKY_CONTROLS_REPEAT_INPUT_DO} %1",
                args1: [{
                    type: "input_statement",
                    name: "DO"
                }],
                previousStatement: null,
                nextStatement: null,
                style: "loop_blocks",
                helpUrl: "%{BKY_CONTROLS_FOREACH_HELPURL}",
                extensions: ["contextMenu_newGetVariableBlock", "controls_forEach_tooltip"]
            }, {
                type: "controls_flow_statements",
                message0: "%1",
                args0: [{
                    type: "field_dropdown",
                    name: "FLOW",
                    options: [["%{BKY_CONTROLS_FLOW_STATEMENTS_OPERATOR_BREAK}", "BREAK"], ["%{BKY_CONTROLS_FLOW_STATEMENTS_OPERATOR_CONTINUE}", "CONTINUE"]]
                }],
                previousStatement: null,
                style: "loop_blocks",
                helpUrl: "%{BKY_CONTROLS_FLOW_STATEMENTS_HELPURL}",
                suppressPrefixSuffix: !0,
                extensions: ["controls_flow_tooltip", "controls_flow_in_loop_check"]
            }])
              , Nt = {
                WHILE: "%{BKY_CONTROLS_WHILEUNTIL_TOOLTIP_WHILE}",
                UNTIL: "%{BKY_CONTROLS_WHILEUNTIL_TOOLTIP_UNTIL}"
            };
            ne.register$$module$build$src$core$extensions("controls_whileUntil_tooltip", ne.buildTooltipForDropdown$$module$build$src$core$extensions("MODE", Nt));
            var Gt = {
                BREAK: "%{BKY_CONTROLS_FLOW_STATEMENTS_TOOLTIP_BREAK}",
                CONTINUE: "%{BKY_CONTROLS_FLOW_STATEMENTS_TOOLTIP_CONTINUE}"
            };
            ne.register$$module$build$src$core$extensions("controls_flow_tooltip", ne.buildTooltipForDropdown$$module$build$src$core$extensions("FLOW", Gt));
            var Ht = {
                customContextMenu: function(Ge) {
                    if (!this.isInFlyout) {
                        var st = this.getField("VAR")
                          , ht = st.getVariable().name;
                        this.isCollapsed() || ht === null || (st = {
                            type: "variables_get",
                            fields: {
                                VAR: st.saveState(!0)
                            }
                        },
                        Ge.push({
                            enabled: !0,
                            text: ne.Msg$$module$build$src$core$msg.VARIABLES_SET_CREATE_GET.replace("%1", ht),
                            callback: ne.callbackFactory$$module$build$src$core$contextmenu(this, st)
                        }))
                    }
                }
            };
            ne.registerMixin$$module$build$src$core$extensions("contextMenu_newGetVariableBlock", Ht),
            ne.register$$module$build$src$core$extensions("controls_for_tooltip", ne.buildTooltipWithFieldText$$module$build$src$core$extensions("%{BKY_CONTROLS_FOR_TOOLTIP}", "VAR")),
            ne.register$$module$build$src$core$extensions("controls_forEach_tooltip", ne.buildTooltipWithFieldText$$module$build$src$core$extensions("%{BKY_CONTROLS_FOREACH_TOOLTIP}", "VAR"));
            var Kt = new Set(["controls_repeat", "controls_repeat_ext", "controls_forEach", "controls_for", "controls_whileUntil"])
              , Ot = {
                getSurroundLoop: function() {
                    let Ge = this;
                    do {
                        if (Kt.has(Ge.type))
                            return Ge;
                        Ge = Ge.getSurroundParent()
                    } while (Ge);
                    return null
                },
                onchange: function(Ge) {
                    var st = this.workspace;
                    if (st.isDragging && !st.isDragging() && Ge.type === ne.MOVE$$module$build$src$core$events$utils && (st = !!this.getSurroundLoop(),
                    this.setWarningText(st ? null : ne.Msg$$module$build$src$core$msg.CONTROLS_FLOW_STATEMENTS_WARNING),
                    !this.isInFlyout)) {
                        const ht = ne.getGroup$$module$build$src$core$events$utils();
                        ne.setGroup$$module$build$src$core$events$utils(Ge.group),
                        this.setEnabled(st),
                        ne.setGroup$$module$build$src$core$events$utils(ht)
                    }
                }
            };
            ne.registerMixin$$module$build$src$core$extensions("controls_flow_in_loop_check", Ot),
            ne.defineBlocks$$module$build$src$core$common(gt);
            var kt = {
                blocks: gt,
                loopTypes: Kt
            }
              , Xt = ne.createBlockDefinitionsFromJsonArray$$module$build$src$core$common([{
                type: "logic_boolean",
                message0: "%1",
                args0: [{
                    type: "field_dropdown",
                    name: "BOOL",
                    options: [["%{BKY_LOGIC_BOOLEAN_TRUE}", "TRUE"], ["%{BKY_LOGIC_BOOLEAN_FALSE}", "FALSE"]]
                }],
                output: "Boolean",
                style: "logic_blocks",
                tooltip: "%{BKY_LOGIC_BOOLEAN_TOOLTIP}",
                helpUrl: "%{BKY_LOGIC_BOOLEAN_HELPURL}"
            }, {
                type: "controls_if",
                message0: "%{BKY_CONTROLS_IF_MSG_IF} %1",
                args0: [{
                    type: "input_value",
                    name: "IF0",
                    check: "Boolean"
                }],
                message1: "%{BKY_CONTROLS_IF_MSG_THEN} %1",
                args1: [{
                    type: "input_statement",
                    name: "DO0"
                }],
                previousStatement: null,
                nextStatement: null,
                style: "logic_blocks",
                helpUrl: "%{BKY_CONTROLS_IF_HELPURL}",
                suppressPrefixSuffix: !0,
                mutator: "controls_if_mutator",
                extensions: ["controls_if_tooltip"]
            }, {
                type: "controls_ifelse",
                message0: "%{BKY_CONTROLS_IF_MSG_IF} %1",
                args0: [{
                    type: "input_value",
                    name: "IF0",
                    check: "Boolean"
                }],
                message1: "%{BKY_CONTROLS_IF_MSG_THEN} %1",
                args1: [{
                    type: "input_statement",
                    name: "DO0"
                }],
                message2: "%{BKY_CONTROLS_IF_MSG_ELSE} %1",
                args2: [{
                    type: "input_statement",
                    name: "ELSE"
                }],
                previousStatement: null,
                nextStatement: null,
                style: "logic_blocks",
                tooltip: "%{BKYCONTROLS_IF_TOOLTIP_2}",
                helpUrl: "%{BKY_CONTROLS_IF_HELPURL}",
                suppressPrefixSuffix: !0,
                extensions: ["controls_if_tooltip"]
            }, {
                type: "logic_compare",
                message0: "%1 %2 %3",
                args0: [{
                    type: "input_value",
                    name: "A"
                }, {
                    type: "field_dropdown",
                    name: "OP",
                    options: [["=", "EQ"], ["≠", "NEQ"], ["‏<", "LT"], ["‏≤", "LTE"], ["‏>", "GT"], ["‏≥", "GTE"]]
                }, {
                    type: "input_value",
                    name: "B"
                }],
                inputsInline: !0,
                output: "Boolean",
                style: "logic_blocks",
                helpUrl: "%{BKY_LOGIC_COMPARE_HELPURL}",
                extensions: ["logic_compare", "logic_op_tooltip"]
            }, {
                type: "logic_operation",
                message0: "%1 %2 %3",
                args0: [{
                    type: "input_value",
                    name: "A",
                    check: "Boolean"
                }, {
                    type: "field_dropdown",
                    name: "OP",
                    options: [["%{BKY_LOGIC_OPERATION_AND}", "AND"], ["%{BKY_LOGIC_OPERATION_OR}", "OR"]]
                }, {
                    type: "input_value",
                    name: "B",
                    check: "Boolean"
                }],
                inputsInline: !0,
                output: "Boolean",
                style: "logic_blocks",
                helpUrl: "%{BKY_LOGIC_OPERATION_HELPURL}",
                extensions: ["logic_op_tooltip"]
            }, {
                type: "logic_negate",
                message0: "%{BKY_LOGIC_NEGATE_TITLE}",
                args0: [{
                    type: "input_value",
                    name: "BOOL",
                    check: "Boolean"
                }],
                output: "Boolean",
                style: "logic_blocks",
                tooltip: "%{BKY_LOGIC_NEGATE_TOOLTIP}",
                helpUrl: "%{BKY_LOGIC_NEGATE_HELPURL}"
            }, {
                type: "logic_null",
                message0: "%{BKY_LOGIC_NULL}",
                output: null,
                style: "logic_blocks",
                tooltip: "%{BKY_LOGIC_NULL_TOOLTIP}",
                helpUrl: "%{BKY_LOGIC_NULL_HELPURL}"
            }, {
                type: "logic_ternary",
                message0: "%{BKY_LOGIC_TERNARY_CONDITION} %1",
                args0: [{
                    type: "input_value",
                    name: "IF",
                    check: "Boolean"
                }],
                message1: "%{BKY_LOGIC_TERNARY_IF_TRUE} %1",
                args1: [{
                    type: "input_value",
                    name: "THEN"
                }],
                message2: "%{BKY_LOGIC_TERNARY_IF_FALSE} %1",
                args2: [{
                    type: "input_value",
                    name: "ELSE"
                }],
                output: null,
                style: "logic_blocks",
                tooltip: "%{BKY_LOGIC_TERNARY_TOOLTIP}",
                helpUrl: "%{BKY_LOGIC_TERNARY_HELPURL}",
                extensions: ["logic_ternary"]
            }, {
                type: "controls_if_if",
                message0: "%{BKY_CONTROLS_IF_IF_TITLE_IF}",
                nextStatement: null,
                enableContextMenu: !1,
                style: "logic_blocks",
                tooltip: "%{BKY_CONTROLS_IF_IF_TOOLTIP}"
            }, {
                type: "controls_if_elseif",
                message0: "%{BKY_CONTROLS_IF_ELSEIF_TITLE_ELSEIF}",
                previousStatement: null,
                nextStatement: null,
                enableContextMenu: !1,
                style: "logic_blocks",
                tooltip: "%{BKY_CONTROLS_IF_ELSEIF_TOOLTIP}"
            }, {
                type: "controls_if_else",
                message0: "%{BKY_CONTROLS_IF_ELSE_TITLE_ELSE}",
                previousStatement: null,
                enableContextMenu: !1,
                style: "logic_blocks",
                tooltip: "%{BKY_CONTROLS_IF_ELSE_TOOLTIP}"
            }])
              , vt = {
                EQ: "%{BKY_LOGIC_COMPARE_TOOLTIP_EQ}",
                NEQ: "%{BKY_LOGIC_COMPARE_TOOLTIP_NEQ}",
                LT: "%{BKY_LOGIC_COMPARE_TOOLTIP_LT}",
                LTE: "%{BKY_LOGIC_COMPARE_TOOLTIP_LTE}",
                GT: "%{BKY_LOGIC_COMPARE_TOOLTIP_GT}",
                GTE: "%{BKY_LOGIC_COMPARE_TOOLTIP_GTE}",
                AND: "%{BKY_LOGIC_OPERATION_TOOLTIP_AND}",
                OR: "%{BKY_LOGIC_OPERATION_TOOLTIP_OR}"
            };
            ne.register$$module$build$src$core$extensions("logic_op_tooltip", ne.buildTooltipForDropdown$$module$build$src$core$extensions("OP", vt));
            var Jt = {
                elseifCount_: 0,
                elseCount_: 0,
                mutationToDom: function() {
                    if (!this.elseifCount_ && !this.elseCount_)
                        return null;
                    const Ge = ne.createElement$$module$build$src$core$utils$xml("mutation");
                    return this.elseifCount_ && Ge.setAttribute("elseif", String(this.elseifCount_)),
                    this.elseCount_ && Ge.setAttribute("else", "1"),
                    Ge
                },
                domToMutation: function(Ge) {
                    this.elseifCount_ = parseInt(Ge.getAttribute("elseif"), 10) || 0,
                    this.elseCount_ = parseInt(Ge.getAttribute("else"), 10) || 0,
                    this.rebuildShape_()
                },
                saveExtraState: function() {
                    if (!this.elseifCount_ && !this.elseCount_)
                        return null;
                    const Ge = Object.create(null);
                    return this.elseifCount_ && (Ge.elseIfCount = this.elseifCount_),
                    this.elseCount_ && (Ge.hasElse = !0),
                    Ge
                },
                loadExtraState: function(Ge) {
                    this.elseifCount_ = Ge.elseIfCount || 0,
                    this.elseCount_ = Ge.hasElse ? 1 : 0,
                    this.updateShape_()
                },
                decompose: function(Ge) {
                    const st = Ge.newBlock("controls_if_if");
                    st.initSvg();
                    let ht = st.nextConnection;
                    for (let At = 1; At <= this.elseifCount_; At++) {
                        const Ft = Ge.newBlock("controls_if_elseif");
                        Ft.initSvg(),
                        ht.connect(Ft.previousConnection),
                        ht = Ft.nextConnection
                    }
                    return this.elseCount_ && (Ge = Ge.newBlock("controls_if_else"),
                    Ge.initSvg(),
                    ht.connect(Ge.previousConnection)),
                    st
                },
                compose: function(Ge) {
                    Ge = Ge.nextConnection.targetBlock(),
                    this.elseCount_ = this.elseifCount_ = 0;
                    const st = [null]
                      , ht = [null];
                    let At = null;
                    for (; Ge; ) {
                        if (!Ge.isInsertionMarker())
                            switch (Ge.type) {
                            case "controls_if_elseif":
                                this.elseifCount_++,
                                st.push(Ge.valueConnection_),
                                ht.push(Ge.statementConnection_);
                                break;
                            case "controls_if_else":
                                this.elseCount_++,
                                At = Ge.statementConnection_;
                                break;
                            default:
                                throw TypeError("Unknown block type: " + Ge.type)
                            }
                        Ge = Ge.getNextBlock()
                    }
                    this.updateShape_(),
                    this.reconnectChildBlocks_(st, ht, At)
                },
                saveConnections: function(Ge) {
                    Ge = Ge.nextConnection.targetBlock();
                    let st = 1;
                    for (; Ge; ) {
                        if (!Ge.isInsertionMarker())
                            switch (Ge.type) {
                            case "controls_if_elseif":
                                var ht = this.getInput("IF" + st);
                                const At = this.getInput("DO" + st);
                                Ge.valueConnection_ = ht && ht.connection.targetConnection,
                                Ge.statementConnection_ = At && At.connection.targetConnection,
                                st++;
                                break;
                            case "controls_if_else":
                                ht = this.getInput("ELSE"),
                                Ge.statementConnection_ = ht && ht.connection.targetConnection;
                                break;
                            default:
                                throw TypeError("Unknown block type: " + Ge.type)
                            }
                        Ge = Ge.getNextBlock()
                    }
                },
                rebuildShape_: function() {
                    const Ge = [null]
                      , st = [null];
                    let ht = null;
                    this.getInput("ELSE") && (ht = this.getInput("ELSE").connection.targetConnection);
                    for (let At = 1; this.getInput("IF" + At); At++) {
                        const Ft = this.getInput("IF" + At)
                          , an = this.getInput("DO" + At);
                        Ge.push(Ft.connection.targetConnection),
                        st.push(an.connection.targetConnection)
                    }
                    this.updateShape_(),
                    this.reconnectChildBlocks_(Ge, st, ht)
                },
                updateShape_: function() {
                    this.getInput("ELSE") && this.removeInput("ELSE");
                    for (var Ge = 1; this.getInput("IF" + Ge); Ge++)
                        this.removeInput("IF" + Ge),
                        this.removeInput("DO" + Ge);
                    for (Ge = 1; Ge <= this.elseifCount_; Ge++)
                        this.appendValueInput("IF" + Ge).setCheck("Boolean").appendField(ne.Msg$$module$build$src$core$msg.CONTROLS_IF_MSG_ELSEIF),
                        this.appendStatementInput("DO" + Ge).appendField(ne.Msg$$module$build$src$core$msg.CONTROLS_IF_MSG_THEN);
                    this.elseCount_ && this.appendStatementInput("ELSE").appendField(ne.Msg$$module$build$src$core$msg.CONTROLS_IF_MSG_ELSE)
                },
                reconnectChildBlocks_: function(Ge, st, ht) {
                    for (let At = 1; At <= this.elseifCount_; At++) {
                        let Ft;
                        (Ft = Ge[At]) == null || Ft.reconnect(this, "IF" + At);
                        let an;
                        (an = st[At]) == null || an.reconnect(this, "DO" + At)
                    }
                    ht == null || ht.reconnect(this, "ELSE")
                }
            };
            ne.registerMutator$$module$build$src$core$extensions("controls_if_mutator", Jt, null, ["controls_if_elseif", "controls_if_else"]);
            var Ct = function() {
                this.setTooltip((function() {
                    if (this.elseifCount_ || this.elseCount_) {
                        if (!this.elseifCount_ && this.elseCount_)
                            return ne.Msg$$module$build$src$core$msg.CONTROLS_IF_TOOLTIP_2;
                        if (this.elseifCount_ && !this.elseCount_)
                            return ne.Msg$$module$build$src$core$msg.CONTROLS_IF_TOOLTIP_3;
                        if (this.elseifCount_ && this.elseCount_)
                            return ne.Msg$$module$build$src$core$msg.CONTROLS_IF_TOOLTIP_4
                    } else
                        return ne.Msg$$module$build$src$core$msg.CONTROLS_IF_TOOLTIP_1;
                    return ""
                }
                ).bind(this))
            };
            ne.register$$module$build$src$core$extensions("controls_if_tooltip", Ct);
            var Mt = {
                onchange: function(Ge) {
                    this.prevBlocks_ || (this.prevBlocks_ = [null, null]);
                    var st = this.getInputTargetBlock("A");
                    const ht = this.getInputTargetBlock("B");
                    st && ht && !this.workspace.connectionChecker.doTypeChecks(st.outputConnection, ht.outputConnection) && (ne.setGroup$$module$build$src$core$events$utils(Ge.group),
                    Ge = this.prevBlocks_[0],
                    Ge !== st && (st.unplug(),
                    !Ge || Ge.isDisposed() || Ge.isShadow() || this.getInput("A").connection.connect(Ge.outputConnection)),
                    st = this.prevBlocks_[1],
                    st !== ht && (ht.unplug(),
                    !st || st.isDisposed() || st.isShadow() || this.getInput("B").connection.connect(st.outputConnection)),
                    this.bumpNeighbours(),
                    ne.setGroup$$module$build$src$core$events$utils(!1)),
                    this.prevBlocks_[0] = this.getInputTargetBlock("A"),
                    this.prevBlocks_[1] = this.getInputTargetBlock("B")
                }
            }
              , nn = function() {
                this.mixin(Mt)
            };
            ne.register$$module$build$src$core$extensions("logic_compare", nn);
            var tn = {
                prevParentConnection_: null,
                onchange: function(Ge) {
                    const st = this.getInputTargetBlock("THEN")
                      , ht = this.getInputTargetBlock("ELSE")
                      , At = this.outputConnection.targetConnection;
                    if ((st || ht) && At)
                        for (let Ft = 0; 2 > Ft; Ft++) {
                            const an = Ft === 1 ? st : ht;
                            an && !an.workspace.connectionChecker.doTypeChecks(an.outputConnection, At) && (ne.setGroup$$module$build$src$core$events$utils(Ge.group),
                            At === this.prevParentConnection_ ? (this.unplug(),
                            At.getSourceBlock().bumpNeighbours()) : (an.unplug(),
                            an.bumpNeighbours()),
                            ne.setGroup$$module$build$src$core$events$utils(!1))
                        }
                    this.prevParentConnection_ = At
                }
            };
            ne.registerMixin$$module$build$src$core$extensions("logic_ternary", tn),
            ne.defineBlocks$$module$build$src$core$common(Xt);
            var mn = ne.createBlockDefinitionsFromJsonArray$$module$build$src$core$common([{
                type: "lists_create_empty",
                message0: "%{BKY_LISTS_CREATE_EMPTY_TITLE}",
                output: "Array",
                style: "list_blocks",
                tooltip: "%{BKY_LISTS_CREATE_EMPTY_TOOLTIP}",
                helpUrl: "%{BKY_LISTS_CREATE_EMPTY_HELPURL}"
            }, {
                type: "lists_repeat",
                message0: "%{BKY_LISTS_REPEAT_TITLE}",
                args0: [{
                    type: "input_value",
                    name: "ITEM"
                }, {
                    type: "input_value",
                    name: "NUM",
                    check: "Number"
                }],
                output: "Array",
                style: "list_blocks",
                tooltip: "%{BKY_LISTS_REPEAT_TOOLTIP}",
                helpUrl: "%{BKY_LISTS_REPEAT_HELPURL}"
            }, {
                type: "lists_reverse",
                message0: "%{BKY_LISTS_REVERSE_MESSAGE0}",
                args0: [{
                    type: "input_value",
                    name: "LIST",
                    check: "Array"
                }],
                output: "Array",
                inputsInline: !0,
                style: "list_blocks",
                tooltip: "%{BKY_LISTS_REVERSE_TOOLTIP}",
                helpUrl: "%{BKY_LISTS_REVERSE_HELPURL}"
            }, {
                type: "lists_isEmpty",
                message0: "%{BKY_LISTS_ISEMPTY_TITLE}",
                args0: [{
                    type: "input_value",
                    name: "VALUE",
                    check: ["String", "Array"]
                }],
                output: "Boolean",
                style: "list_blocks",
                tooltip: "%{BKY_LISTS_ISEMPTY_TOOLTIP}",
                helpUrl: "%{BKY_LISTS_ISEMPTY_HELPURL}"
            }, {
                type: "lists_length",
                message0: "%{BKY_LISTS_LENGTH_TITLE}",
                args0: [{
                    type: "input_value",
                    name: "VALUE",
                    check: ["String", "Array"]
                }],
                output: "Number",
                style: "list_blocks",
                tooltip: "%{BKY_LISTS_LENGTH_TOOLTIP}",
                helpUrl: "%{BKY_LISTS_LENGTH_HELPURL}"
            }])
              , dn = {
                init: function() {
                    this.setHelpUrl(ne.Msg$$module$build$src$core$msg.LISTS_CREATE_WITH_HELPURL),
                    this.setStyle("list_blocks"),
                    this.itemCount_ = 3,
                    this.updateShape_(),
                    this.setOutput(!0, "Array"),
                    this.setMutator(new ne.MutatorIcon$$module$build$src$core$icons$mutator_icon(["lists_create_with_item"],this)),
                    this.setTooltip(ne.Msg$$module$build$src$core$msg.LISTS_CREATE_WITH_TOOLTIP)
                },
                mutationToDom: function() {
                    const Ge = ne.createElement$$module$build$src$core$utils$xml("mutation");
                    return Ge.setAttribute("items", String(this.itemCount_)),
                    Ge
                },
                domToMutation: function(Ge) {
                    if (Ge = Ge.getAttribute("items"),
                    !Ge)
                        throw new TypeError("element did not have items");
                    this.itemCount_ = parseInt(Ge, 10),
                    this.updateShape_()
                },
                saveExtraState: function() {
                    return {
                        itemCount: this.itemCount_
                    }
                },
                loadExtraState: function(Ge) {
                    this.itemCount_ = Ge.itemCount,
                    this.updateShape_()
                },
                decompose: function(Ge) {
                    const st = Ge.newBlock("lists_create_with_container");
                    st.initSvg();
                    let ht = st.getInput("STACK").connection;
                    for (let At = 0; At < this.itemCount_; At++) {
                        const Ft = Ge.newBlock("lists_create_with_item");
                        if (Ft.initSvg(),
                        !Ft.previousConnection)
                            throw Error("itemBlock has no previousConnection");
                        ht.connect(Ft.previousConnection),
                        ht = Ft.nextConnection
                    }
                    return st
                },
                compose: function(Ge) {
                    var st = Ge.getInputTargetBlock("STACK");
                    for (Ge = []; st; )
                        st.isInsertionMarker() || Ge.push(st.valueConnection_),
                        st = st.getNextBlock();
                    for (st = 0; st < this.itemCount_; st++) {
                        const ht = this.getInput("ADD" + st).connection.targetConnection;
                        ht && Ge.indexOf(ht) === -1 && ht.disconnect()
                    }
                    for (this.itemCount_ = Ge.length,
                    this.updateShape_(),
                    st = 0; st < this.itemCount_; st++) {
                        let ht;
                        (ht = Ge[st]) == null || ht.reconnect(this, "ADD" + st)
                    }
                },
                saveConnections: function(Ge) {
                    Ge = Ge.getInputTargetBlock("STACK");
                    let st = 0;
                    for (; Ge; ) {
                        if (Ge.isInsertionMarker()) {
                            Ge = Ge.getNextBlock();
                            continue
                        }
                        const ht = this.getInput("ADD" + st);
                        let At;
                        Ge.valueConnection_ = (At = ht) == null ? void 0 : At.connection.targetConnection,
                        Ge = Ge.getNextBlock(),
                        st++
                    }
                },
                updateShape_: function() {
                    this.itemCount_ && this.getInput("EMPTY") ? this.removeInput("EMPTY") : this.itemCount_ || this.getInput("EMPTY") || this.appendDummyInput("EMPTY").appendField(ne.Msg$$module$build$src$core$msg.LISTS_CREATE_EMPTY_TITLE);
                    for (var Ge = 0; Ge < this.itemCount_; Ge++)
                        if (!this.getInput("ADD" + Ge)) {
                            const st = this.appendValueInput("ADD" + Ge).setAlign(ne.Align$$module$build$src$core$inputs$align.RIGHT);
                            Ge === 0 && st.appendField(ne.Msg$$module$build$src$core$msg.LISTS_CREATE_WITH_INPUT_WITH)
                        }
                    for (Ge = this.itemCount_; this.getInput("ADD" + Ge); Ge++)
                        this.removeInput("ADD" + Ge)
                }
            };
            mn.lists_create_with = dn;
            var Qt = {
                init: function() {
                    this.setStyle("list_blocks"),
                    this.appendDummyInput().appendField(ne.Msg$$module$build$src$core$msg.LISTS_CREATE_WITH_CONTAINER_TITLE_ADD),
                    this.appendStatementInput("STACK"),
                    this.setTooltip(ne.Msg$$module$build$src$core$msg.LISTS_CREATE_WITH_CONTAINER_TOOLTIP),
                    this.contextMenu = !1
                }
            };
            mn.lists_create_with_container = Qt;
            var on = {
                init: function() {
                    this.setStyle("list_blocks"),
                    this.appendDummyInput().appendField(ne.Msg$$module$build$src$core$msg.LISTS_CREATE_WITH_ITEM_TITLE),
                    this.setPreviousStatement(!0),
                    this.setNextStatement(!0),
                    this.setTooltip(ne.Msg$$module$build$src$core$msg.LISTS_CREATE_WITH_ITEM_TOOLTIP),
                    this.contextMenu = !1
                }
            };
            mn.lists_create_with_item = on;
            var zt = {
                init: function() {
                    var Ge = [[ne.Msg$$module$build$src$core$msg.LISTS_INDEX_OF_FIRST, "FIRST"], [ne.Msg$$module$build$src$core$msg.LISTS_INDEX_OF_LAST, "LAST"]];
                    if (this.setHelpUrl(ne.Msg$$module$build$src$core$msg.LISTS_INDEX_OF_HELPURL),
                    this.setStyle("list_blocks"),
                    this.setOutput(!0, "Number"),
                    this.appendValueInput("VALUE").setCheck("Array").appendField(ne.Msg$$module$build$src$core$msg.LISTS_INDEX_OF_INPUT_IN_LIST),
                    Ge = ne.fromJson$$module$build$src$core$field_registry({
                        type: "field_dropdown",
                        options: Ge
                    }),
                    !Ge)
                        throw Error("field_dropdown not found");
                    this.appendValueInput("FIND").appendField(Ge, "END"),
                    this.setInputsInline(!0),
                    this.setTooltip( () => ne.Msg$$module$build$src$core$msg.LISTS_INDEX_OF_TOOLTIP.replace("%1", this.workspace.options.oneBasedIndex ? "0" : "-1"))
                }
            };
            mn.lists_indexOf = zt;
            var $t = {
                init: function() {
                    var Ge = [[ne.Msg$$module$build$src$core$msg.LISTS_GET_INDEX_GET, "GET"], [ne.Msg$$module$build$src$core$msg.LISTS_GET_INDEX_GET_REMOVE, "GET_REMOVE"], [ne.Msg$$module$build$src$core$msg.LISTS_GET_INDEX_REMOVE, "REMOVE"]];
                    this.WHERE_OPTIONS = [[ne.Msg$$module$build$src$core$msg.LISTS_GET_INDEX_FROM_START, "FROM_START"], [ne.Msg$$module$build$src$core$msg.LISTS_GET_INDEX_FROM_END, "FROM_END"], [ne.Msg$$module$build$src$core$msg.LISTS_GET_INDEX_FIRST, "FIRST"], [ne.Msg$$module$build$src$core$msg.LISTS_GET_INDEX_LAST, "LAST"], [ne.Msg$$module$build$src$core$msg.LISTS_GET_INDEX_RANDOM, "RANDOM"]],
                    this.setHelpUrl(ne.Msg$$module$build$src$core$msg.LISTS_GET_INDEX_HELPURL),
                    this.setStyle("list_blocks"),
                    Ge = ne.fromJson$$module$build$src$core$field_registry({
                        type: "field_dropdown",
                        options: Ge
                    }),
                    Ge.setValidator(function(st) {
                        st = st === "REMOVE",
                        this.getSourceBlock().updateStatement_(st)
                    }),
                    this.appendValueInput("VALUE").setCheck("Array").appendField(ne.Msg$$module$build$src$core$msg.LISTS_GET_INDEX_INPUT_IN_LIST),
                    this.appendDummyInput().appendField(Ge, "MODE").appendField("", "SPACE"),
                    this.appendDummyInput("AT"),
                    ne.Msg$$module$build$src$core$msg.LISTS_GET_INDEX_TAIL && this.appendDummyInput("TAIL").appendField(ne.Msg$$module$build$src$core$msg.LISTS_GET_INDEX_TAIL),
                    this.setInputsInline(!0),
                    this.setOutput(!0),
                    this.updateAt_(!0),
                    this.setTooltip( () => {
                        const st = this.getFieldValue("MODE")
                          , ht = this.getFieldValue("WHERE");
                        let At = "";
                        switch (st + " " + ht) {
                        case "GET FROM_START":
                        case "GET FROM_END":
                            At = ne.Msg$$module$build$src$core$msg.LISTS_GET_INDEX_TOOLTIP_GET_FROM;
                            break;
                        case "GET FIRST":
                            At = ne.Msg$$module$build$src$core$msg.LISTS_GET_INDEX_TOOLTIP_GET_FIRST;
                            break;
                        case "GET LAST":
                            At = ne.Msg$$module$build$src$core$msg.LISTS_GET_INDEX_TOOLTIP_GET_LAST;
                            break;
                        case "GET RANDOM":
                            At = ne.Msg$$module$build$src$core$msg.LISTS_GET_INDEX_TOOLTIP_GET_RANDOM;
                            break;
                        case "GET_REMOVE FROM_START":
                        case "GET_REMOVE FROM_END":
                            At = ne.Msg$$module$build$src$core$msg.LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FROM;
                            break;
                        case "GET_REMOVE FIRST":
                            At = ne.Msg$$module$build$src$core$msg.LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FIRST;
                            break;
                        case "GET_REMOVE LAST":
                            At = ne.Msg$$module$build$src$core$msg.LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_LAST;
                            break;
                        case "GET_REMOVE RANDOM":
                            At = ne.Msg$$module$build$src$core$msg.LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_RANDOM;
                            break;
                        case "REMOVE FROM_START":
                        case "REMOVE FROM_END":
                            At = ne.Msg$$module$build$src$core$msg.LISTS_GET_INDEX_TOOLTIP_REMOVE_FROM;
                            break;
                        case "REMOVE FIRST":
                            At = ne.Msg$$module$build$src$core$msg.LISTS_GET_INDEX_TOOLTIP_REMOVE_FIRST;
                            break;
                        case "REMOVE LAST":
                            At = ne.Msg$$module$build$src$core$msg.LISTS_GET_INDEX_TOOLTIP_REMOVE_LAST;
                            break;
                        case "REMOVE RANDOM":
                            At = ne.Msg$$module$build$src$core$msg.LISTS_GET_INDEX_TOOLTIP_REMOVE_RANDOM
                        }
                        return (ht === "FROM_START" || ht === "FROM_END") && (At += "  " + (ht === "FROM_START" ? ne.Msg$$module$build$src$core$msg.LISTS_INDEX_FROM_START_TOOLTIP : ne.Msg$$module$build$src$core$msg.LISTS_INDEX_FROM_END_TOOLTIP).replace("%1", this.workspace.options.oneBasedIndex ? "#1" : "#0")),
                        At
                    }
                    )
                },
                mutationToDom: function() {
                    const Ge = ne.createElement$$module$build$src$core$utils$xml("mutation");
                    Ge.setAttribute("statement", String(!this.outputConnection));
                    const st = this.getInput("AT")instanceof ne.ValueInput$$module$build$src$core$inputs$value_input;
                    return Ge.setAttribute("at", String(st)),
                    Ge
                },
                domToMutation: function(Ge) {
                    const st = Ge.getAttribute("statement") === "true";
                    this.updateStatement_(st),
                    Ge = Ge.getAttribute("at") !== "false",
                    this.updateAt_(Ge)
                },
                saveExtraState: function() {
                    return this.outputConnection ? null : {
                        isStatement: !0
                    }
                },
                loadExtraState: function(Ge) {
                    Ge.isStatement ? this.updateStatement_(!0) : typeof Ge == "string" && this.domToMutation(ne.textToDom$$module$build$src$core$utils$xml(Ge))
                },
                updateStatement_: function(Ge) {
                    Ge !== !this.outputConnection && (this.unplug(!0, !0),
                    Ge ? (this.setOutput(!1),
                    this.setPreviousStatement(!0),
                    this.setNextStatement(!0)) : (this.setPreviousStatement(!1),
                    this.setNextStatement(!1),
                    this.setOutput(!0)))
                },
                updateAt_: function(Ge) {
                    this.removeInput("AT"),
                    this.removeInput("ORDINAL", !0),
                    Ge ? (this.appendValueInput("AT").setCheck("Number"),
                    ne.Msg$$module$build$src$core$msg.ORDINAL_NUMBER_SUFFIX && this.appendDummyInput("ORDINAL").appendField(ne.Msg$$module$build$src$core$msg.ORDINAL_NUMBER_SUFFIX)) : this.appendDummyInput("AT");
                    const st = ne.fromJson$$module$build$src$core$field_registry({
                        type: "field_dropdown",
                        options: this.WHERE_OPTIONS
                    });
                    st.setValidator(function(ht) {
                        const At = ht === "FROM_START" || ht === "FROM_END";
                        if (At !== Ge) {
                            const Ft = this.getSourceBlock();
                            return Ft.updateAt_(At),
                            Ft.setFieldValue(ht, "WHERE"),
                            null
                        }
                    }),
                    this.getInput("AT").appendField(st, "WHERE"),
                    ne.Msg$$module$build$src$core$msg.LISTS_GET_INDEX_TAIL && this.moveInputBefore("TAIL", null)
                }
            };
            mn.lists_getIndex = $t;
            var Ut = {
                init: function() {
                    var Ge = [[ne.Msg$$module$build$src$core$msg.LISTS_SET_INDEX_SET, "SET"], [ne.Msg$$module$build$src$core$msg.LISTS_SET_INDEX_INSERT, "INSERT"]];
                    this.WHERE_OPTIONS = [[ne.Msg$$module$build$src$core$msg.LISTS_GET_INDEX_FROM_START, "FROM_START"], [ne.Msg$$module$build$src$core$msg.LISTS_GET_INDEX_FROM_END, "FROM_END"], [ne.Msg$$module$build$src$core$msg.LISTS_GET_INDEX_FIRST, "FIRST"], [ne.Msg$$module$build$src$core$msg.LISTS_GET_INDEX_LAST, "LAST"], [ne.Msg$$module$build$src$core$msg.LISTS_GET_INDEX_RANDOM, "RANDOM"]],
                    this.setHelpUrl(ne.Msg$$module$build$src$core$msg.LISTS_SET_INDEX_HELPURL),
                    this.setStyle("list_blocks"),
                    this.appendValueInput("LIST").setCheck("Array").appendField(ne.Msg$$module$build$src$core$msg.LISTS_SET_INDEX_INPUT_IN_LIST),
                    Ge = ne.fromJson$$module$build$src$core$field_registry({
                        type: "field_dropdown",
                        options: Ge
                    }),
                    this.appendDummyInput().appendField(Ge, "MODE").appendField("", "SPACE"),
                    this.appendDummyInput("AT"),
                    this.appendValueInput("TO").appendField(ne.Msg$$module$build$src$core$msg.LISTS_SET_INDEX_INPUT_TO),
                    this.setInputsInline(!0),
                    this.setPreviousStatement(!0),
                    this.setNextStatement(!0),
                    this.setTooltip(ne.Msg$$module$build$src$core$msg.LISTS_SET_INDEX_TOOLTIP),
                    this.updateAt_(!0),
                    this.setTooltip( () => {
                        const st = this.getFieldValue("MODE")
                          , ht = this.getFieldValue("WHERE");
                        let At = "";
                        switch (st + " " + ht) {
                        case "SET FROM_START":
                        case "SET FROM_END":
                            At = ne.Msg$$module$build$src$core$msg.LISTS_SET_INDEX_TOOLTIP_SET_FROM;
                            break;
                        case "SET FIRST":
                            At = ne.Msg$$module$build$src$core$msg.LISTS_SET_INDEX_TOOLTIP_SET_FIRST;
                            break;
                        case "SET LAST":
                            At = ne.Msg$$module$build$src$core$msg.LISTS_SET_INDEX_TOOLTIP_SET_LAST;
                            break;
                        case "SET RANDOM":
                            At = ne.Msg$$module$build$src$core$msg.LISTS_SET_INDEX_TOOLTIP_SET_RANDOM;
                            break;
                        case "INSERT FROM_START":
                        case "INSERT FROM_END":
                            At = ne.Msg$$module$build$src$core$msg.LISTS_SET_INDEX_TOOLTIP_INSERT_FROM;
                            break;
                        case "INSERT FIRST":
                            At = ne.Msg$$module$build$src$core$msg.LISTS_SET_INDEX_TOOLTIP_INSERT_FIRST;
                            break;
                        case "INSERT LAST":
                            At = ne.Msg$$module$build$src$core$msg.LISTS_SET_INDEX_TOOLTIP_INSERT_LAST;
                            break;
                        case "INSERT RANDOM":
                            At = ne.Msg$$module$build$src$core$msg.LISTS_SET_INDEX_TOOLTIP_INSERT_RANDOM
                        }
                        return (ht === "FROM_START" || ht === "FROM_END") && (At += "  " + ne.Msg$$module$build$src$core$msg.LISTS_INDEX_FROM_START_TOOLTIP.replace("%1", this.workspace.options.oneBasedIndex ? "#1" : "#0")),
                        At
                    }
                    )
                },
                mutationToDom: function() {
                    const Ge = ne.createElement$$module$build$src$core$utils$xml("mutation")
                      , st = this.getInput("AT")instanceof ne.ValueInput$$module$build$src$core$inputs$value_input;
                    return Ge.setAttribute("at", String(st)),
                    Ge
                },
                domToMutation: function(Ge) {
                    Ge = Ge.getAttribute("at") !== "false",
                    this.updateAt_(Ge)
                },
                saveExtraState: function() {
                    return null
                },
                loadExtraState: function() {},
                updateAt_: function(Ge) {
                    this.removeInput("AT"),
                    this.removeInput("ORDINAL", !0),
                    Ge ? (this.appendValueInput("AT").setCheck("Number"),
                    ne.Msg$$module$build$src$core$msg.ORDINAL_NUMBER_SUFFIX && this.appendDummyInput("ORDINAL").appendField(ne.Msg$$module$build$src$core$msg.ORDINAL_NUMBER_SUFFIX)) : this.appendDummyInput("AT");
                    const st = ne.fromJson$$module$build$src$core$field_registry({
                        type: "field_dropdown",
                        options: this.WHERE_OPTIONS
                    });
                    st.setValidator(function(ht) {
                        const At = ht === "FROM_START" || ht === "FROM_END";
                        if (At !== Ge) {
                            const Ft = this.getSourceBlock();
                            return Ft.updateAt_(At),
                            Ft.setFieldValue(ht, "WHERE"),
                            null
                        }
                    }),
                    this.moveInputBefore("AT", "TO"),
                    this.getInput("ORDINAL") && this.moveInputBefore("ORDINAL", "TO"),
                    this.getInput("AT").appendField(st, "WHERE")
                }
            };
            mn.lists_setIndex = Ut;
            var An = {
                init: function() {
                    this.WHERE_OPTIONS_1 = [[ne.Msg$$module$build$src$core$msg.LISTS_GET_SUBLIST_START_FROM_START, "FROM_START"], [ne.Msg$$module$build$src$core$msg.LISTS_GET_SUBLIST_START_FROM_END, "FROM_END"], [ne.Msg$$module$build$src$core$msg.LISTS_GET_SUBLIST_START_FIRST, "FIRST"]],
                    this.WHERE_OPTIONS_2 = [[ne.Msg$$module$build$src$core$msg.LISTS_GET_SUBLIST_END_FROM_START, "FROM_START"], [ne.Msg$$module$build$src$core$msg.LISTS_GET_SUBLIST_END_FROM_END, "FROM_END"], [ne.Msg$$module$build$src$core$msg.LISTS_GET_SUBLIST_END_LAST, "LAST"]],
                    this.setHelpUrl(ne.Msg$$module$build$src$core$msg.LISTS_GET_SUBLIST_HELPURL),
                    this.setStyle("list_blocks"),
                    this.appendValueInput("LIST").setCheck("Array").appendField(ne.Msg$$module$build$src$core$msg.LISTS_GET_SUBLIST_INPUT_IN_LIST),
                    this.appendDummyInput("AT1"),
                    this.appendDummyInput("AT2"),
                    ne.Msg$$module$build$src$core$msg.LISTS_GET_SUBLIST_TAIL && this.appendDummyInput("TAIL").appendField(ne.Msg$$module$build$src$core$msg.LISTS_GET_SUBLIST_TAIL),
                    this.setInputsInline(!0),
                    this.setOutput(!0, "Array"),
                    this.updateAt_(1, !0),
                    this.updateAt_(2, !0),
                    this.setTooltip(ne.Msg$$module$build$src$core$msg.LISTS_GET_SUBLIST_TOOLTIP)
                },
                mutationToDom: function() {
                    const Ge = ne.createElement$$module$build$src$core$utils$xml("mutation");
                    var st = this.getInput("AT1")instanceof ne.ValueInput$$module$build$src$core$inputs$value_input;
                    return Ge.setAttribute("at1", String(st)),
                    st = this.getInput("AT2")instanceof ne.ValueInput$$module$build$src$core$inputs$value_input,
                    Ge.setAttribute("at2", String(st)),
                    Ge
                },
                domToMutation: function(Ge) {
                    const st = Ge.getAttribute("at1") === "true";
                    Ge = Ge.getAttribute("at2") === "true",
                    this.updateAt_(1, st),
                    this.updateAt_(2, Ge)
                },
                saveExtraState: function() {
                    return null
                },
                loadExtraState: function() {},
                updateAt_: function(Ge, st) {
                    this.removeInput("AT" + Ge),
                    this.removeInput("ORDINAL" + Ge, !0),
                    st ? (this.appendValueInput("AT" + Ge).setCheck("Number"),
                    ne.Msg$$module$build$src$core$msg.ORDINAL_NUMBER_SUFFIX && this.appendDummyInput("ORDINAL" + Ge).appendField(ne.Msg$$module$build$src$core$msg.ORDINAL_NUMBER_SUFFIX)) : this.appendDummyInput("AT" + Ge);
                    const ht = ne.fromJson$$module$build$src$core$field_registry({
                        type: "field_dropdown",
                        options: this["WHERE_OPTIONS_" + Ge]
                    });
                    ht.setValidator(function(At) {
                        const Ft = At === "FROM_START" || At === "FROM_END";
                        if (Ft !== st) {
                            const an = this.getSourceBlock();
                            return an.updateAt_(Ge, Ft),
                            an.setFieldValue(At, "WHERE" + Ge),
                            null
                        }
                    }),
                    this.getInput("AT" + Ge).appendField(ht, "WHERE" + Ge),
                    Ge === 1 && (this.moveInputBefore("AT1", "AT2"),
                    this.getInput("ORDINAL1") && this.moveInputBefore("ORDINAL1", "AT2")),
                    ne.Msg$$module$build$src$core$msg.LISTS_GET_SUBLIST_TAIL && this.moveInputBefore("TAIL", null)
                }
            };
            mn.lists_getSublist = An,
            mn.lists_sort = {
                init: function() {
                    this.jsonInit({
                        message0: "%{BKY_LISTS_SORT_TITLE}",
                        args0: [{
                            type: "field_dropdown",
                            name: "TYPE",
                            options: [["%{BKY_LISTS_SORT_TYPE_NUMERIC}", "NUMERIC"], ["%{BKY_LISTS_SORT_TYPE_TEXT}", "TEXT"], ["%{BKY_LISTS_SORT_TYPE_IGNORECASE}", "IGNORE_CASE"]]
                        }, {
                            type: "field_dropdown",
                            name: "DIRECTION",
                            options: [["%{BKY_LISTS_SORT_ORDER_ASCENDING}", "1"], ["%{BKY_LISTS_SORT_ORDER_DESCENDING}", "-1"]]
                        }, {
                            type: "input_value",
                            name: "LIST",
                            check: "Array"
                        }],
                        output: "Array",
                        style: "list_blocks",
                        tooltip: "%{BKY_LISTS_SORT_TOOLTIP}",
                        helpUrl: "%{BKY_LISTS_SORT_HELPURL}"
                    })
                }
            },
            mn.lists_split = {
                init: function() {
                    const Ge = ne.fromJson$$module$build$src$core$field_registry({
                        type: "field_dropdown",
                        options: [[ne.Msg$$module$build$src$core$msg.LISTS_SPLIT_LIST_FROM_TEXT, "SPLIT"], [ne.Msg$$module$build$src$core$msg.LISTS_SPLIT_TEXT_FROM_LIST, "JOIN"]]
                    });
                    if (!Ge)
                        throw Error("field_dropdown not found");
                    Ge.setValidator(st => {
                        this.updateType_(st)
                    }
                    ),
                    this.setHelpUrl(ne.Msg$$module$build$src$core$msg.LISTS_SPLIT_HELPURL),
                    this.setStyle("list_blocks"),
                    this.appendValueInput("INPUT").setCheck("String").appendField(Ge, "MODE"),
                    this.appendValueInput("DELIM").setCheck("String").appendField(ne.Msg$$module$build$src$core$msg.LISTS_SPLIT_WITH_DELIMITER),
                    this.setInputsInline(!0),
                    this.setOutput(!0, "Array"),
                    this.setTooltip( () => {
                        const st = this.getFieldValue("MODE");
                        if (st === "SPLIT")
                            return ne.Msg$$module$build$src$core$msg.LISTS_SPLIT_TOOLTIP_SPLIT;
                        if (st === "JOIN")
                            return ne.Msg$$module$build$src$core$msg.LISTS_SPLIT_TOOLTIP_JOIN;
                        throw Error("Unknown mode: " + st)
                    }
                    )
                },
                updateType_: function(Ge) {
                    if (this.getFieldValue("MODE") !== Ge) {
                        const st = this.getInput("INPUT").connection;
                        st.setShadowDom(null);
                        const ht = st.targetBlock();
                        ht && (st.disconnect(),
                        ht.isShadow() ? ht.dispose(!1) : this.bumpNeighbours())
                    }
                    Ge === "SPLIT" ? (this.outputConnection.setCheck("Array"),
                    this.getInput("INPUT").setCheck("String")) : (this.outputConnection.setCheck("String"),
                    this.getInput("INPUT").setCheck("Array"))
                },
                mutationToDom: function() {
                    const Ge = ne.createElement$$module$build$src$core$utils$xml("mutation");
                    return Ge.setAttribute("mode", this.getFieldValue("MODE")),
                    Ge
                },
                domToMutation: function(Ge) {
                    this.updateType_(Ge.getAttribute("mode"))
                },
                saveExtraState: function() {
                    return null
                },
                loadExtraState: function() {}
            },
            ne.defineBlocks$$module$build$src$core$common(mn);
            var yt = {
                blocks: mn
            }
              , Dt = ne.createBlockDefinitionsFromJsonArray$$module$build$src$core$common([{
                type: "colour_picker",
                message0: "%1",
                args0: [{
                    type: "field_colour",
                    name: "COLOUR",
                    colour: "#ff0000"
                }],
                output: "Colour",
                helpUrl: "%{BKY_COLOUR_PICKER_HELPURL}",
                style: "colour_blocks",
                tooltip: "%{BKY_COLOUR_PICKER_TOOLTIP}",
                extensions: ["parent_tooltip_when_inline"]
            }, {
                type: "colour_random",
                message0: "%{BKY_COLOUR_RANDOM_TITLE}",
                output: "Colour",
                helpUrl: "%{BKY_COLOUR_RANDOM_HELPURL}",
                style: "colour_blocks",
                tooltip: "%{BKY_COLOUR_RANDOM_TOOLTIP}"
            }, {
                type: "colour_rgb",
                message0: "%{BKY_COLOUR_RGB_TITLE} %{BKY_COLOUR_RGB_RED} %1 %{BKY_COLOUR_RGB_GREEN} %2 %{BKY_COLOUR_RGB_BLUE} %3",
                args0: [{
                    type: "input_value",
                    name: "RED",
                    check: "Number",
                    align: "RIGHT"
                }, {
                    type: "input_value",
                    name: "GREEN",
                    check: "Number",
                    align: "RIGHT"
                }, {
                    type: "input_value",
                    name: "BLUE",
                    check: "Number",
                    align: "RIGHT"
                }],
                output: "Colour",
                helpUrl: "%{BKY_COLOUR_RGB_HELPURL}",
                style: "colour_blocks",
                tooltip: "%{BKY_COLOUR_RGB_TOOLTIP}"
            }, {
                type: "colour_blend",
                message0: "%{BKY_COLOUR_BLEND_TITLE} %{BKY_COLOUR_BLEND_COLOUR1} %1 %{BKY_COLOUR_BLEND_COLOUR2} %2 %{BKY_COLOUR_BLEND_RATIO} %3",
                args0: [{
                    type: "input_value",
                    name: "COLOUR1",
                    check: "Colour",
                    align: "RIGHT"
                }, {
                    type: "input_value",
                    name: "COLOUR2",
                    check: "Colour",
                    align: "RIGHT"
                }, {
                    type: "input_value",
                    name: "RATIO",
                    check: "Number",
                    align: "RIGHT"
                }],
                output: "Colour",
                helpUrl: "%{BKY_COLOUR_BLEND_HELPURL}",
                style: "colour_blocks",
                tooltip: "%{BKY_COLOUR_BLEND_TOOLTIP}"
            }]);
            ne.defineBlocks$$module$build$src$core$common(Dt);
            var Bt = {
                blocks: Dt
            }
              , Wt = Object.assign({}, Dt, mn, Xt, gt, nt, it, _e, ue)
              , ut = {
                blocks: Wt,
                colour: Bt,
                lists: yt,
                loops: kt,
                math: Qe,
                procedures: We,
                texts: et,
                variables: $e,
                variablesDynamic: Te
            };
            return ut.__namespace__ = ne,
            ut
        })
    }(blocks_compressed)),
    blocks_compressed.exports
}
var hasRequiredBlocks;
function requireBlocks() {
    return hasRequiredBlocks || (hasRequiredBlocks = 1,
    function(V, X) {
        (function(J, ne) {
            V.exports = ne(requireBlocks_compressed())
        }
        )(commonjsGlobal, function(J) {
            /**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
            return J
        })
    }(blocks)),
    blocks.exports
}
var javascript = {
    exports: {}
}, javascript_compressed = {
    exports: {}
}, hasRequiredJavascript_compressed;
function requireJavascript_compressed() {
    return hasRequiredJavascript_compressed || (hasRequiredJavascript_compressed = 1,
    function(V, X) {
        (function(J, ne) {
            V.exports = ne(requireBlockly_compressed())
        }
        )(commonjsGlobal, function(J) {
            var ne = J.__namespace__, ue = function(Be, Je) {
                return [Je.quote_(Be.getFieldValue("COLOUR")), ut.ATOMIC]
            }, ce = function(Be, Je) {
                return [Je.provideFunction_("colourRandom", `
function ${Je.FUNCTION_NAME_PLACEHOLDER_}() {
  var num = Math.floor(Math.random() * Math.pow(2, 24));
  return '#' + ('00000' + num.toString(16)).substr(-6);
}
`) + "()", ut.FUNCTION_CALL]
            }, me = function(Be, Je) {
                const ot = Je.valueToCode(Be, "RED", ut.NONE) || 0
                  , pt = Je.valueToCode(Be, "GREEN", ut.NONE) || 0;
                return Be = Je.valueToCode(Be, "BLUE", ut.NONE) || 0,
                [Je.provideFunction_("colourRgb", `
function ${Je.FUNCTION_NAME_PLACEHOLDER_}(r, g, b) {
  r = Math.max(Math.min(Number(r), 100), 0) * 2.55;
  g = Math.max(Math.min(Number(g), 100), 0) * 2.55;
  b = Math.max(Math.min(Number(b), 100), 0) * 2.55;
  r = ('0' + (Math.round(r) || 0).toString(16)).slice(-2);
  g = ('0' + (Math.round(g) || 0).toString(16)).slice(-2);
  b = ('0' + (Math.round(b) || 0).toString(16)).slice(-2);
  return '#' + r + g + b;
}
`) + "(" + ot + ", " + pt + ", " + Be + ")", ut.FUNCTION_CALL]
            }, ge = function(Be, Je) {
                const ot = Je.valueToCode(Be, "COLOUR1", ut.NONE) || "'#000000'"
                  , pt = Je.valueToCode(Be, "COLOUR2", ut.NONE) || "'#000000'";
                return Be = Je.valueToCode(Be, "RATIO", ut.NONE) || .5,
                [Je.provideFunction_("colourBlend", `
function ${Je.FUNCTION_NAME_PLACEHOLDER_}(c1, c2, ratio) {
  ratio = Math.max(Math.min(Number(ratio), 1), 0);
  var r1 = parseInt(c1.substring(1, 3), 16);
  var g1 = parseInt(c1.substring(3, 5), 16);
  var b1 = parseInt(c1.substring(5, 7), 16);
  var r2 = parseInt(c2.substring(1, 3), 16);
  var g2 = parseInt(c2.substring(3, 5), 16);
  var b2 = parseInt(c2.substring(5, 7), 16);
  var r = Math.round(r1 * (1 - ratio) + r2 * ratio);
  var g = Math.round(g1 * (1 - ratio) + g2 * ratio);
  var b = Math.round(b1 * (1 - ratio) + b2 * ratio);
  r = ('0' + (r || 0).toString(16)).slice(-2);
  g = ('0' + (g || 0).toString(16)).slice(-2);
  b = ('0' + (b || 0).toString(16)).slice(-2);
  return '#' + r + g + b;
}
`) + "(" + ot + ", " + pt + ", " + Be + ")", ut.FUNCTION_CALL]
            }, Te = function(Be, Je) {
                return ["[]", ut.ATOMIC]
            }, _e = function(Be, Je) {
                const ot = Array(Be.itemCount_);
                for (let pt = 0; pt < Be.itemCount_; pt++)
                    ot[pt] = Je.valueToCode(Be, "ADD" + pt, ut.NONE) || "null";
                return ["[" + ot.join(", ") + "]", ut.ATOMIC]
            }, Se = function(Be, Je) {
                const ot = Je.provideFunction_("listsRepeat", `
function ${Je.FUNCTION_NAME_PLACEHOLDER_}(value, n) {
  var array = [];
  for (var i = 0; i < n; i++) {
    array[i] = value;
  }
  return array;
}
`)
                  , pt = Je.valueToCode(Be, "ITEM", ut.NONE) || "null";
                return Be = Je.valueToCode(Be, "NUM", ut.NONE) || "0",
                [ot + "(" + pt + ", " + Be + ")", ut.FUNCTION_CALL]
            }, Ie = function(Be, Je) {
                return [(Je.valueToCode(Be, "VALUE", ut.MEMBER) || "[]") + ".length", ut.MEMBER]
            }, ye = function(Be, Je) {
                return ["!" + (Je.valueToCode(Be, "VALUE", ut.MEMBER) || "[]") + ".length", ut.LOGICAL_NOT]
            }, $e = function(Be, Je) {
                const ot = Be.getFieldValue("END") === "FIRST" ? "indexOf" : "lastIndexOf"
                  , pt = Je.valueToCode(Be, "FIND", ut.NONE) || "''";
                return Je = (Je.valueToCode(Be, "VALUE", ut.MEMBER) || "[]") + "." + ot + "(" + pt + ")",
                Be.workspace.options.oneBasedIndex ? [Je + " + 1", ut.ADDITION] : [Je, ut.FUNCTION_CALL]
            }, Ne = function(Be, Je) {
                const ot = Be.getFieldValue("MODE") || "GET"
                  , pt = Be.getFieldValue("WHERE") || "FROM_START";
                var xt = Je.valueToCode(Be, "VALUE", pt === "RANDOM" ? ut.NONE : ut.MEMBER) || "[]";
                switch (pt) {
                case "FIRST":
                    if (ot === "GET")
                        return [xt + "[0]", ut.MEMBER];
                    if (ot === "GET_REMOVE")
                        return [xt + ".shift()", ut.MEMBER];
                    if (ot === "REMOVE")
                        return xt + `.shift();
`;
                    break;
                case "LAST":
                    if (ot === "GET")
                        return [xt + ".slice(-1)[0]", ut.MEMBER];
                    if (ot === "GET_REMOVE")
                        return [xt + ".pop()", ut.MEMBER];
                    if (ot === "REMOVE")
                        return xt + `.pop();
`;
                    break;
                case "FROM_START":
                    if (Be = Je.getAdjusted(Be, "AT"),
                    ot === "GET")
                        return [xt + "[" + Be + "]", ut.MEMBER];
                    if (ot === "GET_REMOVE")
                        return [xt + ".splice(" + Be + ", 1)[0]", ut.FUNCTION_CALL];
                    if (ot === "REMOVE")
                        return xt + ".splice(" + Be + `, 1);
`;
                    break;
                case "FROM_END":
                    if (Be = Je.getAdjusted(Be, "AT", 1, !0),
                    ot === "GET")
                        return [xt + ".slice(" + Be + ")[0]", ut.FUNCTION_CALL];
                    if (ot === "GET_REMOVE")
                        return [xt + ".splice(" + Be + ", 1)[0]", ut.FUNCTION_CALL];
                    if (ot === "REMOVE")
                        return xt + ".splice(" + Be + ", 1);";
                    break;
                case "RANDOM":
                    if (xt = Je.provideFunction_("listsGetRandomItem", `
function ${Je.FUNCTION_NAME_PLACEHOLDER_}(list, remove) {
  var x = Math.floor(Math.random() * list.length);
  if (remove) {
    return list.splice(x, 1)[0];
  } else {
    return list[x];
  }
}
`) + "(" + xt + ", " + (ot !== "GET") + ")",
                    ot === "GET" || ot === "GET_REMOVE")
                        return [xt, ut.FUNCTION_CALL];
                    if (ot === "REMOVE")
                        return xt + `;
`
                }
                throw Error("Unhandled combination (lists_getIndex).")
            }, ve = function(Be, Je) {
                function ot() {
                    if (pt.match(/^\w+$/))
                        return "";
                    const qt = Je.nameDB_.getDistinctName("tmpList", ne.NameType$$module$build$src$core$names.VARIABLE)
                      , rn = "var " + qt + " = " + pt + `;
`;
                    return pt = qt,
                    rn
                }
                let pt = Je.valueToCode(Be, "LIST", ut.MEMBER) || "[]";
                const xt = Be.getFieldValue("MODE") || "GET";
                var Vt = Be.getFieldValue("WHERE") || "FROM_START";
                const Pt = Je.valueToCode(Be, "TO", ut.ASSIGNMENT) || "null";
                switch (Vt) {
                case "FIRST":
                    if (xt === "SET")
                        return pt + "[0] = " + Pt + `;
`;
                    if (xt === "INSERT")
                        return pt + ".unshift(" + Pt + `);
`;
                    break;
                case "LAST":
                    if (xt === "SET")
                        return ot() + (pt + "[" + pt + ".length - 1] = " + Pt + `;
`);
                    if (xt === "INSERT")
                        return pt + ".push(" + Pt + `);
`;
                    break;
                case "FROM_START":
                    if (Be = Je.getAdjusted(Be, "AT"),
                    xt === "SET")
                        return pt + "[" + Be + "] = " + Pt + `;
`;
                    if (xt === "INSERT")
                        return pt + ".splice(" + Be + ", 0, " + Pt + `);
`;
                    break;
                case "FROM_END":
                    if (Be = Je.getAdjusted(Be, "AT", 1, !1, ut.SUBTRACTION),
                    Vt = ot(),
                    xt === "SET")
                        return Vt + (pt + "[" + pt + ".length - " + Be + "] = " + Pt + `;
`);
                    if (xt === "INSERT")
                        return Vt + (pt + ".splice(" + pt + ".length - " + Be + ", 0, " + Pt + `);
`);
                    break;
                case "RANDOM":
                    if (Be = ot(),
                    Vt = Je.nameDB_.getDistinctName("tmpX", ne.NameType$$module$build$src$core$names.VARIABLE),
                    Be += "var " + Vt + " = Math.floor(Math.random() * " + pt + `.length);
`,
                    xt === "SET")
                        return Be + (pt + "[" + Vt + "] = " + Pt + `;
`);
                    if (xt === "INSERT")
                        return Be + (pt + ".splice(" + Vt + ", 0, " + Pt + `);
`)
                }
                throw Error("Unhandled combination (lists_setIndex).")
            }, ke = function(Be, Je) {
                var ot = {
                    FIRST: "First",
                    LAST: "Last",
                    FROM_START: "FromStart",
                    FROM_END: "FromEnd"
                }
                  , pt = Je.valueToCode(Be, "LIST", ut.MEMBER) || "[]";
                const xt = Be.getFieldValue("WHERE1")
                  , Vt = Be.getFieldValue("WHERE2");
                if (xt === "FIRST" && Vt === "LAST")
                    pt += ".slice(0)";
                else if (pt.match(/^\w+$/) || xt !== "FROM_END" && Vt === "FROM_START") {
                    switch (xt) {
                    case "FROM_START":
                        ot = Je.getAdjusted(Be, "AT1");
                        break;
                    case "FROM_END":
                        ot = Je.getAdjusted(Be, "AT1", 1, !1, ut.SUBTRACTION),
                        ot = pt + ".length - " + ot;
                        break;
                    case "FIRST":
                        ot = "0";
                        break;
                    default:
                        throw Error("Unhandled option (lists_getSublist).")
                    }
                    switch (Vt) {
                    case "FROM_START":
                        Je = Je.getAdjusted(Be, "AT2", 1);
                        break;
                    case "FROM_END":
                        Je = Je.getAdjusted(Be, "AT2", 0, !1, ut.SUBTRACTION),
                        Je = pt + ".length - " + Je;
                        break;
                    case "LAST":
                        Je = pt + ".length";
                        break;
                    default:
                        throw Error("Unhandled option (lists_getSublist).")
                    }
                    pt = pt + ".slice(" + ot + ", " + Je + ")"
                } else {
                    const Pt = Je.getAdjusted(Be, "AT1");
                    Be = Je.getAdjusted(Be, "AT2"),
                    pt = Je.provideFunction_("subsequence" + ot[xt] + ot[Vt], `
function ${Je.FUNCTION_NAME_PLACEHOLDER_}(sequence${xt === "FROM_END" || xt === "FROM_START" ? ", at1" : ""}${Vt === "FROM_END" || Vt === "FROM_START" ? ", at2" : ""}) {
  var start = ${ht("sequence", xt, "at1")};
  var end = ${ht("sequence", Vt, "at2")} + 1;
  return sequence.slice(start, end);
}
`) + "(" + pt + (xt === "FROM_END" || xt === "FROM_START" ? ", " + Pt : "") + (Vt === "FROM_END" || Vt === "FROM_START" ? ", " + Be : "") + ")"
                }
                return [pt, ut.FUNCTION_CALL]
            }, xe = function(Be, Je) {
                const ot = Je.valueToCode(Be, "LIST", ut.FUNCTION_CALL) || "[]"
                  , pt = Be.getFieldValue("DIRECTION") === "1" ? 1 : -1;
                return Be = Be.getFieldValue("TYPE"),
                Je = Je.provideFunction_("listsGetSortCompare", `
function ${Je.FUNCTION_NAME_PLACEHOLDER_}(type, direction) {
  var compareFuncs = {
    'NUMERIC': function(a, b) {
        return Number(a) - Number(b); },
    'TEXT': function(a, b) {
        return String(a) > String(b) ? 1 : -1; },
    'IGNORE_CASE': function(a, b) {
        return String(a).toLowerCase() > String(b).toLowerCase() ? 1 : -1; },
  };
  var compare = compareFuncs[type];
  return function(a, b) { return compare(a, b) * direction; };
}
      `),
                [ot + ".slice().sort(" + Je + '("' + Be + '", ' + pt + "))", ut.FUNCTION_CALL]
            }, we = function(Be, Je) {
                let ot = Je.valueToCode(Be, "INPUT", ut.MEMBER);
                if (Je = Je.valueToCode(Be, "DELIM", ut.NONE) || "''",
                Be = Be.getFieldValue("MODE"),
                Be === "SPLIT")
                    ot || (ot = "''"),
                    Be = "split";
                else if (Be === "JOIN")
                    ot || (ot = "[]"),
                    Be = "join";
                else
                    throw Error("Unknown mode: " + Be);
                return [ot + "." + Be + "(" + Je + ")", ut.FUNCTION_CALL]
            }, Fe = function(Be, Je) {
                return [(Je.valueToCode(Be, "LIST", ut.FUNCTION_CALL) || "[]") + ".slice().reverse()", ut.FUNCTION_CALL]
            }, je = function(Be, Je) {
                var ot = 0;
                let pt = "";
                Je.STATEMENT_PREFIX && (pt += Je.injectId(Je.STATEMENT_PREFIX, Be));
                do {
                    const xt = Je.valueToCode(Be, "IF" + ot, ut.NONE) || "false";
                    let Vt = Je.statementToCode(Be, "DO" + ot);
                    Je.STATEMENT_SUFFIX && (Vt = Je.prefixLines(Je.injectId(Je.STATEMENT_SUFFIX, Be), Je.INDENT) + Vt),
                    pt += (0 < ot ? " else " : "") + "if (" + xt + `) {
` + Vt + "}",
                    ot++
                } while (Be.getInput("IF" + ot));
                return (Be.getInput("ELSE") || Je.STATEMENT_SUFFIX) && (ot = Je.statementToCode(Be, "ELSE"),
                Je.STATEMENT_SUFFIX && (ot = Je.prefixLines(Je.injectId(Je.STATEMENT_SUFFIX, Be), Je.INDENT) + ot),
                pt += ` else {
` + ot + "}"),
                pt + `
`
            }, Xe = function(Be, Je) {
                const ot = {
                    EQ: "==",
                    NEQ: "!=",
                    LT: "<",
                    LTE: "<=",
                    GT: ">",
                    GTE: ">="
                }[Be.getFieldValue("OP")]
                  , pt = ot === "==" || ot === "!=" ? ut.EQUALITY : ut.RELATIONAL
                  , xt = Je.valueToCode(Be, "A", pt) || "0";
                return Be = Je.valueToCode(Be, "B", pt) || "0",
                [xt + " " + ot + " " + Be, pt]
            }, ze = function(Be, Je) {
                const ot = Be.getFieldValue("OP") === "AND" ? "&&" : "||"
                  , pt = ot === "&&" ? ut.LOGICAL_AND : ut.LOGICAL_OR;
                let xt = Je.valueToCode(Be, "A", pt);
                return Be = Je.valueToCode(Be, "B", pt),
                xt || Be ? (Je = ot === "&&" ? "true" : "false",
                xt || (xt = Je),
                Be || (Be = Je)) : Be = xt = "false",
                [xt + " " + ot + " " + Be, pt]
            }, qe = function(Be, Je) {
                const ot = ut.LOGICAL_NOT;
                return ["!" + (Je.valueToCode(Be, "BOOL", ot) || "true"), ot]
            }, Ze = function(Be, Je) {
                return [Be.getFieldValue("BOOL") === "TRUE" ? "true" : "false", ut.ATOMIC]
            }, et = function(Be, Je) {
                return ["null", ut.ATOMIC]
            }, it = function(Be, Je) {
                const ot = Je.valueToCode(Be, "IF", ut.CONDITIONAL) || "false"
                  , pt = Je.valueToCode(Be, "THEN", ut.CONDITIONAL) || "null";
                return Be = Je.valueToCode(Be, "ELSE", ut.CONDITIONAL) || "null",
                [ot + " ? " + pt + " : " + Be, ut.CONDITIONAL]
            }, at = function(Be, Je) {
                let ot;
                ot = Be.getField("TIMES") ? String(Number(Be.getFieldValue("TIMES"))) : Je.valueToCode(Be, "TIMES", ut.ASSIGNMENT) || "0";
                let pt = Je.statementToCode(Be, "DO");
                pt = Je.addLoopTrap(pt, Be),
                Be = "";
                const xt = Je.nameDB_.getDistinctName("count", ne.NameType$$module$build$src$core$names.VARIABLE);
                let Vt = ot;
                return ot.match(/^\w+$/) || ne.isNumber$$module$build$src$core$utils$string(ot) || (Vt = Je.nameDB_.getDistinctName("repeat_end", ne.NameType$$module$build$src$core$names.VARIABLE),
                Be += "var " + Vt + " = " + ot + `;
`),
                Be + ("for (var " + xt + " = 0; " + xt + " < " + Vt + "; " + xt + `++) {
` + pt + `}
`)
            }, rt = function(Be, Je) {
                const ot = Be.getFieldValue("MODE") === "UNTIL";
                let pt = Je.valueToCode(Be, "BOOL", ot ? ut.LOGICAL_NOT : ut.NONE) || "false"
                  , xt = Je.statementToCode(Be, "DO");
                return xt = Je.addLoopTrap(xt, Be),
                ot && (pt = "!" + pt),
                "while (" + pt + `) {
` + xt + `}
`
            }, ft = function(Be, Je) {
                var ot = Je.getVariableName(Be.getFieldValue("VAR"))
                  , pt = Je.valueToCode(Be, "FROM", ut.ASSIGNMENT) || "0"
                  , xt = Je.valueToCode(Be, "TO", ut.ASSIGNMENT) || "0";
                const Vt = Je.valueToCode(Be, "BY", ut.ASSIGNMENT) || "1";
                let Pt = Je.statementToCode(Be, "DO");
                if (Pt = Je.addLoopTrap(Pt, Be),
                ne.isNumber$$module$build$src$core$utils$string(pt) && ne.isNumber$$module$build$src$core$utils$string(xt) && ne.isNumber$$module$build$src$core$utils$string(Vt))
                    Je = Number(pt) <= Number(xt),
                    Be = "for (" + ot + " = " + pt + "; " + ot + (Je ? " <= " : " >= ") + xt + "; " + ot,
                    ot = Math.abs(Number(Vt)),
                    Be = ot === 1 ? Be + (Je ? "++" : "--") : Be + ((Je ? " += " : " -= ") + ot),
                    Be += `) {
` + Pt + `}
`;
                else {
                    Be = "";
                    let qt = pt;
                    pt.match(/^\w+$/) || ne.isNumber$$module$build$src$core$utils$string(pt) || (qt = Je.nameDB_.getDistinctName(ot + "_start", ne.NameType$$module$build$src$core$names.VARIABLE),
                    Be += "var " + qt + " = " + pt + `;
`),
                    pt = xt,
                    xt.match(/^\w+$/) || ne.isNumber$$module$build$src$core$utils$string(xt) || (pt = Je.nameDB_.getDistinctName(ot + "_end", ne.NameType$$module$build$src$core$names.VARIABLE),
                    Be += "var " + pt + " = " + xt + `;
`),
                    xt = Je.nameDB_.getDistinctName(ot + "_inc", ne.NameType$$module$build$src$core$names.VARIABLE),
                    Be += "var " + xt + " = ",
                    Be = ne.isNumber$$module$build$src$core$utils$string(Vt) ? Be + (Math.abs(Number(Vt)) + `;
`) : Be + ("Math.abs(" + Vt + `);
`),
                    Be += "if (" + qt + " > " + pt + `) {
`,
                    Be += Je.INDENT + xt + " = -" + xt + `;
`,
                    Be = Be + `}
for (` + (ot + " = " + qt + "; " + xt + " >= 0 ? " + ot + " <= " + pt + " : " + ot + " >= " + pt + "; " + ot + " += " + xt + `) {
` + Pt + `}
`)
                }
                return Be
            }, St = function(Be, Je) {
                const ot = Je.getVariableName(Be.getFieldValue("VAR"));
                var pt = Je.valueToCode(Be, "LIST", ut.ASSIGNMENT) || "[]";
                let xt = Je.statementToCode(Be, "DO");
                xt = Je.addLoopTrap(xt, Be),
                Be = "";
                let Vt = pt;
                return pt.match(/^\w+$/) || (Vt = Je.nameDB_.getDistinctName(ot + "_list", ne.NameType$$module$build$src$core$names.VARIABLE),
                Be += "var " + Vt + " = " + pt + `;
`),
                pt = Je.nameDB_.getDistinctName(ot + "_index", ne.NameType$$module$build$src$core$names.VARIABLE),
                xt = Je.INDENT + ot + " = " + Vt + "[" + pt + `];
` + xt,
                Be + ("for (var " + pt + " in " + Vt + `) {
` + xt + `}
`)
            }, Ye = function(Be, Je) {
                let ot = "";
                if (Je.STATEMENT_PREFIX && (ot += Je.injectId(Je.STATEMENT_PREFIX, Be)),
                Je.STATEMENT_SUFFIX && (ot += Je.injectId(Je.STATEMENT_SUFFIX, Be)),
                Je.STATEMENT_PREFIX) {
                    const pt = Be.getSurroundLoop();
                    pt && !pt.suppressPrefixSuffix && (ot += Je.injectId(Je.STATEMENT_PREFIX, pt))
                }
                switch (Be.getFieldValue("FLOW")) {
                case "BREAK":
                    return ot + `break;
`;
                case "CONTINUE":
                    return ot + `continue;
`
                }
                throw Error("Unknown flow statement.")
            }, We = function(Be, Je) {
                return Be = Number(Be.getFieldValue("NUM")),
                [String(Be), 0 <= Be ? ut.ATOMIC : ut.UNARY_NEGATION]
            }, nt = function(Be, Je) {
                var ot = {
                    ADD: [" + ", ut.ADDITION],
                    MINUS: [" - ", ut.SUBTRACTION],
                    MULTIPLY: [" * ", ut.MULTIPLICATION],
                    DIVIDE: [" / ", ut.DIVISION],
                    POWER: [null, ut.NONE]
                }[Be.getFieldValue("OP")];
                const pt = ot[0];
                ot = ot[1];
                const xt = Je.valueToCode(Be, "A", ot) || "0";
                return Be = Je.valueToCode(Be, "B", ot) || "0",
                pt ? [xt + pt + Be, ot] : ["Math.pow(" + xt + ", " + Be + ")", ut.FUNCTION_CALL]
            }, ct = function(Be, Je) {
                const ot = Be.getFieldValue("OP");
                let pt;
                if (ot === "NEG")
                    return Be = Je.valueToCode(Be, "NUM", ut.UNARY_NEGATION) || "0",
                    Be[0] === "-" && (Be = " " + Be),
                    ["-" + Be, ut.UNARY_NEGATION];
                switch (Be = ot === "SIN" || ot === "COS" || ot === "TAN" ? Je.valueToCode(Be, "NUM", ut.DIVISION) || "0" : Je.valueToCode(Be, "NUM", ut.NONE) || "0",
                ot) {
                case "ABS":
                    pt = "Math.abs(" + Be + ")";
                    break;
                case "ROOT":
                    pt = "Math.sqrt(" + Be + ")";
                    break;
                case "LN":
                    pt = "Math.log(" + Be + ")";
                    break;
                case "EXP":
                    pt = "Math.exp(" + Be + ")";
                    break;
                case "POW10":
                    pt = "Math.pow(10," + Be + ")";
                    break;
                case "ROUND":
                    pt = "Math.round(" + Be + ")";
                    break;
                case "ROUNDUP":
                    pt = "Math.ceil(" + Be + ")";
                    break;
                case "ROUNDDOWN":
                    pt = "Math.floor(" + Be + ")";
                    break;
                case "SIN":
                    pt = "Math.sin(" + Be + " / 180 * Math.PI)";
                    break;
                case "COS":
                    pt = "Math.cos(" + Be + " / 180 * Math.PI)";
                    break;
                case "TAN":
                    pt = "Math.tan(" + Be + " / 180 * Math.PI)"
                }
                if (pt)
                    return [pt, ut.FUNCTION_CALL];
                switch (ot) {
                case "LOG10":
                    pt = "Math.log(" + Be + ") / Math.log(10)";
                    break;
                case "ASIN":
                    pt = "Math.asin(" + Be + ") / Math.PI * 180";
                    break;
                case "ACOS":
                    pt = "Math.acos(" + Be + ") / Math.PI * 180";
                    break;
                case "ATAN":
                    pt = "Math.atan(" + Be + ") / Math.PI * 180";
                    break;
                default:
                    throw Error("Unknown math operator: " + ot)
                }
                return [pt, ut.DIVISION]
            }, Et = function(Be, Je) {
                return {
                    PI: ["Math.PI", ut.MEMBER],
                    E: ["Math.E", ut.MEMBER],
                    GOLDEN_RATIO: ["(1 + Math.sqrt(5)) / 2", ut.DIVISION],
                    SQRT2: ["Math.SQRT2", ut.MEMBER],
                    SQRT1_2: ["Math.SQRT1_2", ut.MEMBER],
                    INFINITY: ["Infinity", ut.ATOMIC]
                }[Be.getFieldValue("CONSTANT")]
            }, Ke = function(Be, Je) {
                var ot = {
                    EVEN: [" % 2 === 0", ut.MODULUS, ut.EQUALITY],
                    ODD: [" % 2 === 1", ut.MODULUS, ut.EQUALITY],
                    WHOLE: [" % 1 === 0", ut.MODULUS, ut.EQUALITY],
                    POSITIVE: [" > 0", ut.RELATIONAL, ut.RELATIONAL],
                    NEGATIVE: [" < 0", ut.RELATIONAL, ut.RELATIONAL],
                    DIVISIBLE_BY: [null, ut.MODULUS, ut.EQUALITY],
                    PRIME: [null, ut.NONE, ut.FUNCTION_CALL]
                };
                const pt = Be.getFieldValue("PROPERTY")
                  , [xt,Vt,Pt] = ot[pt];
                return ot = Je.valueToCode(Be, "NUMBER_TO_CHECK", Vt) || "0",
                pt === "PRIME" ? Be = Je.provideFunction_("mathIsPrime", `
function ${Je.FUNCTION_NAME_PLACEHOLDER_}(n) {
  // https://en.wikipedia.org/wiki/Primality_test#Naive_methods
  if (n == 2 || n == 3) {
    return true;
  }
  // False if n is NaN, negative, is 1, or not whole.
  // And false if n is divisible by 2 or 3.
  if (isNaN(n) || n <= 1 || n % 1 !== 0 || n % 2 === 0 || n % 3 === 0) {
    return false;
  }
  // Check all the numbers of form 6k +/- 1, up to sqrt(n).
  for (var x = 6; x <= Math.sqrt(n) + 1; x += 6) {
    if (n % (x - 1) === 0 || n % (x + 1) === 0) {
      return false;
    }
  }
  return true;
}
`) + "(" + ot + ")" : pt === "DIVISIBLE_BY" ? (Be = Je.valueToCode(Be, "DIVISOR", ut.MODULUS) || "0",
                Be = ot + " % " + Be + " === 0") : Be = ot + xt,
                [Be, Pt]
            }, mt = function(Be, Je) {
                const ot = Je.valueToCode(Be, "DELTA", ut.ADDITION) || "0";
                return Be = Je.getVariableName(Be.getFieldValue("VAR")),
                Be + " = (typeof " + Be + " === 'number' ? " + Be + " : 0) + " + ot + `;
`
            }, lt = function(Be, Je) {
                var ot = Be.getFieldValue("OP");
                switch (ot) {
                case "SUM":
                    Be = Je.valueToCode(Be, "LIST", ut.MEMBER) || "[]",
                    Be += ".reduce(function(x, y) {return x + y;}, 0)";
                    break;
                case "MIN":
                    Be = Je.valueToCode(Be, "LIST", ut.NONE) || "[]",
                    Be = "Math.min.apply(null, " + Be + ")";
                    break;
                case "MAX":
                    Be = Je.valueToCode(Be, "LIST", ut.NONE) || "[]",
                    Be = "Math.max.apply(null, " + Be + ")";
                    break;
                case "AVERAGE":
                    ot = Je.provideFunction_("mathMean", `
function ${Je.FUNCTION_NAME_PLACEHOLDER_}(myList) {
  return myList.reduce(function(x, y) {return x + y;}, 0) / myList.length;
}
`),
                    Be = Je.valueToCode(Be, "LIST", ut.NONE) || "[]",
                    Be = ot + "(" + Be + ")";
                    break;
                case "MEDIAN":
                    ot = Je.provideFunction_("mathMedian", `
function ${Je.FUNCTION_NAME_PLACEHOLDER_}(myList) {
  var localList = myList.filter(function (x) {return typeof x === 'number';});
  if (!localList.length) return null;
  localList.sort(function(a, b) {return b - a;});
  if (localList.length % 2 === 0) {
    return (localList[localList.length / 2 - 1] + localList[localList.length / 2]) / 2;
  } else {
    return localList[(localList.length - 1) / 2];
  }
}
`),
                    Be = Je.valueToCode(Be, "LIST", ut.NONE) || "[]",
                    Be = ot + "(" + Be + ")";
                    break;
                case "MODE":
                    ot = Je.provideFunction_("mathModes", `
function ${Je.FUNCTION_NAME_PLACEHOLDER_}(values) {
  var modes = [];
  var counts = [];
  var maxCount = 0;
  for (var i = 0; i < values.length; i++) {
    var value = values[i];
    var found = false;
    var thisCount;
    for (var j = 0; j < counts.length; j++) {
      if (counts[j][0] === value) {
        thisCount = ++counts[j][1];
        found = true;
        break;
      }
    }
    if (!found) {
      counts.push([value, 1]);
      thisCount = 1;
    }
    maxCount = Math.max(thisCount, maxCount);
  }
  for (var j = 0; j < counts.length; j++) {
    if (counts[j][1] === maxCount) {
        modes.push(counts[j][0]);
    }
  }
  return modes;
}
`),
                    Be = Je.valueToCode(Be, "LIST", ut.NONE) || "[]",
                    Be = ot + "(" + Be + ")";
                    break;
                case "STD_DEV":
                    ot = Je.provideFunction_("mathStandardDeviation", `
function ${Je.FUNCTION_NAME_PLACEHOLDER_}(numbers) {
  var n = numbers.length;
  if (!n) return null;
  var mean = numbers.reduce(function(x, y) {return x + y;}) / n;
  var variance = 0;
  for (var j = 0; j < n; j++) {
    variance += Math.pow(numbers[j] - mean, 2);
  }
  variance = variance / n;
  return Math.sqrt(variance);
}
`),
                    Be = Je.valueToCode(Be, "LIST", ut.NONE) || "[]",
                    Be = ot + "(" + Be + ")";
                    break;
                case "RANDOM":
                    ot = Je.provideFunction_("mathRandomList", `
function ${Je.FUNCTION_NAME_PLACEHOLDER_}(list) {
  var x = Math.floor(Math.random() * list.length);
  return list[x];
}
`),
                    Be = Je.valueToCode(Be, "LIST", ut.NONE) || "[]",
                    Be = ot + "(" + Be + ")";
                    break;
                default:
                    throw Error("Unknown operator: " + ot)
                }
                return [Be, ut.FUNCTION_CALL]
            }, Qe = function(Be, Je) {
                const ot = Je.valueToCode(Be, "DIVIDEND", ut.MODULUS) || "0";
                return Be = Je.valueToCode(Be, "DIVISOR", ut.MODULUS) || "0",
                [ot + " % " + Be, ut.MODULUS]
            }, gt = function(Be, Je) {
                const ot = Je.valueToCode(Be, "VALUE", ut.NONE) || "0"
                  , pt = Je.valueToCode(Be, "LOW", ut.NONE) || "0";
                return Be = Je.valueToCode(Be, "HIGH", ut.NONE) || "Infinity",
                ["Math.min(Math.max(" + ot + ", " + pt + "), " + Be + ")", ut.FUNCTION_CALL]
            }, Nt = function(Be, Je) {
                const ot = Je.valueToCode(Be, "FROM", ut.NONE) || "0";
                return Be = Je.valueToCode(Be, "TO", ut.NONE) || "0",
                [Je.provideFunction_("mathRandomInt", `
function ${Je.FUNCTION_NAME_PLACEHOLDER_}(a, b) {
  if (a > b) {
    // Swap a and b to ensure a is smaller.
    var c = a;
    a = b;
    b = c;
  }
  return Math.floor(Math.random() * (b - a + 1) + a);
}
`) + "(" + ot + ", " + Be + ")", ut.FUNCTION_CALL]
            }, Gt = function(Be, Je) {
                return ["Math.random()", ut.FUNCTION_CALL]
            }, Ht = function(Be, Je) {
                const ot = Je.valueToCode(Be, "X", ut.NONE) || "0";
                return ["Math.atan2(" + (Je.valueToCode(Be, "Y", ut.NONE) || "0") + ", " + ot + ") / Math.PI * 180", ut.DIVISION]
            }, Kt = function(Be, Je) {
                const ot = Je.getProcedureName(Be.getFieldValue("NAME"));
                var pt = "";
                Je.STATEMENT_PREFIX && (pt += Je.injectId(Je.STATEMENT_PREFIX, Be)),
                Je.STATEMENT_SUFFIX && (pt += Je.injectId(Je.STATEMENT_SUFFIX, Be)),
                pt && (pt = Je.prefixLines(pt, Je.INDENT));
                let xt = "";
                Je.INFINITE_LOOP_TRAP && (xt = Je.prefixLines(Je.injectId(Je.INFINITE_LOOP_TRAP, Be), Je.INDENT));
                const Vt = Je.statementToCode(Be, "STACK");
                let Pt = Je.valueToCode(Be, "RETURN", ut.NONE) || ""
                  , qt = "";
                Vt && Pt && (qt = pt),
                Pt && (Pt = Je.INDENT + "return " + Pt + `;
`);
                const rn = []
                  , un = Be.getVars();
                for (let fn = 0; fn < un.length; fn++)
                    rn[fn] = Je.getVariableName(un[fn]);
                return pt = "function " + ot + "(" + rn.join(", ") + `) {
` + pt + xt + Vt + qt + Pt + "}",
                pt = Je.scrub_(Be, pt),
                Je.definitions_["%" + ot] = pt,
                null
            }, Ot = function(Be, Je) {
                const ot = Je.getProcedureName(Be.getFieldValue("NAME"))
                  , pt = []
                  , xt = Be.getVars();
                for (let Vt = 0; Vt < xt.length; Vt++)
                    pt[Vt] = Je.valueToCode(Be, "ARG" + Vt, ut.NONE) || "null";
                return [ot + "(" + pt.join(", ") + ")", ut.FUNCTION_CALL]
            }, kt = function(Be, Je) {
                return Je.forBlock.procedures_callreturn(Be, Je)[0] + `;
`
            }, Xt = function(Be, Je) {
                let ot = "if (" + (Je.valueToCode(Be, "CONDITION", ut.NONE) || "false") + `) {
`;
                return Je.STATEMENT_SUFFIX && (ot += Je.prefixLines(Je.injectId(Je.STATEMENT_SUFFIX, Be), Je.INDENT)),
                Be.hasReturnValue_ ? (Be = Je.valueToCode(Be, "VALUE", ut.NONE) || "null",
                ot += Je.INDENT + "return " + Be + `;
`) : ot += Je.INDENT + `return;
`,
                ot + `}
`
            }, vt = function(Be, Je) {
                return [Je.quote_(Be.getFieldValue("TEXT")), ut.ATOMIC]
            }, Jt = function(Be, Je) {
                return Be = Je.multiline_quote_(Be.getFieldValue("TEXT")),
                Je = Be.indexOf("+") !== -1 ? ut.ADDITION : ut.ATOMIC,
                [Be, Je]
            }, Ct = function(Be, Je) {
                switch (Be.itemCount_) {
                case 0:
                    return ["''", ut.ATOMIC];
                case 1:
                    return Be = Je.valueToCode(Be, "ADD0", ut.NONE) || "''",
                    yn(Be);
                case 2:
                    var ot = Je.valueToCode(Be, "ADD0", ut.NONE) || "''";
                    return Be = Je.valueToCode(Be, "ADD1", ut.NONE) || "''",
                    [yn(ot)[0] + " + " + yn(Be)[0], ut.ADDITION];
                default:
                    ot = Array(Be.itemCount_);
                    for (let pt = 0; pt < Be.itemCount_; pt++)
                        ot[pt] = Je.valueToCode(Be, "ADD" + pt, ut.NONE) || "''";
                    return ["[" + ot.join(",") + "].join('')", ut.FUNCTION_CALL]
                }
            }, Mt = function(Be, Je) {
                const ot = Je.getVariableName(Be.getFieldValue("VAR"));
                return Be = Je.valueToCode(Be, "TEXT", ut.NONE) || "''",
                ot + " += " + yn(Be)[0] + `;
`
            }, nn = function(Be, Je) {
                return [(Je.valueToCode(Be, "VALUE", ut.MEMBER) || "''") + ".length", ut.MEMBER]
            }, tn = function(Be, Je) {
                return ["!" + (Je.valueToCode(Be, "VALUE", ut.MEMBER) || "''") + ".length", ut.LOGICAL_NOT]
            }, mn = function(Be, Je) {
                const ot = Be.getFieldValue("END") === "FIRST" ? "indexOf" : "lastIndexOf"
                  , pt = Je.valueToCode(Be, "FIND", ut.NONE) || "''";
                return Je = (Je.valueToCode(Be, "VALUE", ut.MEMBER) || "''") + "." + ot + "(" + pt + ")",
                Be.workspace.options.oneBasedIndex ? [Je + " + 1", ut.ADDITION] : [Je, ut.FUNCTION_CALL]
            }, dn = function(Be, Je) {
                const ot = Be.getFieldValue("WHERE") || "FROM_START"
                  , pt = Je.valueToCode(Be, "VALUE", ot === "RANDOM" ? ut.NONE : ut.MEMBER) || "''";
                switch (ot) {
                case "FIRST":
                    return [pt + ".charAt(0)", ut.FUNCTION_CALL];
                case "LAST":
                    return [pt + ".slice(-1)", ut.FUNCTION_CALL];
                case "FROM_START":
                    return Be = Je.getAdjusted(Be, "AT"),
                    [pt + ".charAt(" + Be + ")", ut.FUNCTION_CALL];
                case "FROM_END":
                    return Be = Je.getAdjusted(Be, "AT", 1, !0),
                    [pt + ".slice(" + Be + ").charAt(0)", ut.FUNCTION_CALL];
                case "RANDOM":
                    return [Je.provideFunction_("textRandomLetter", `
function ${Je.FUNCTION_NAME_PLACEHOLDER_}(text) {
  var x = Math.floor(Math.random() * text.length);
  return text[x];
}
`) + "(" + pt + ")", ut.FUNCTION_CALL]
                }
                throw Error("Unhandled option (text_charAt).")
            }, Qt = function(Be, Je) {
                var ot = {
                    FIRST: "First",
                    LAST: "Last",
                    FROM_START: "FromStart",
                    FROM_END: "FromEnd"
                };
                const pt = Be.getFieldValue("WHERE1")
                  , xt = Be.getFieldValue("WHERE2");
                var Vt = pt !== "FROM_END" && pt !== "LAST" && xt !== "FROM_END" && xt !== "LAST"
                  , Pt = Je.valueToCode(Be, "STRING", Vt ? ut.MEMBER : ut.NONE) || "''";
                if (pt === "FIRST" && xt === "LAST")
                    return [Pt, ut.NONE];
                if (Pt.match(/^'?\w+'?$/) || Vt) {
                    switch (pt) {
                    case "FROM_START":
                        ot = Je.getAdjusted(Be, "AT1");
                        break;
                    case "FROM_END":
                        ot = Je.getAdjusted(Be, "AT1", 1, !1, ut.SUBTRACTION),
                        ot = Pt + ".length - " + ot;
                        break;
                    case "FIRST":
                        ot = "0";
                        break;
                    default:
                        throw Error("Unhandled option (text_getSubstring).")
                    }
                    switch (xt) {
                    case "FROM_START":
                        Je = Je.getAdjusted(Be, "AT2", 1);
                        break;
                    case "FROM_END":
                        Je = Je.getAdjusted(Be, "AT2", 0, !1, ut.SUBTRACTION),
                        Je = Pt + ".length - " + Je;
                        break;
                    case "LAST":
                        Je = Pt + ".length";
                        break;
                    default:
                        throw Error("Unhandled option (text_getSubstring).")
                    }
                    Pt = Pt + ".slice(" + ot + ", " + Je + ")"
                } else
                    Vt = Je.getAdjusted(Be, "AT1"),
                    Be = Je.getAdjusted(Be, "AT2"),
                    Pt = Je.provideFunction_("subsequence" + ot[pt] + ot[xt], `
function ${Je.FUNCTION_NAME_PLACEHOLDER_}(sequence${pt === "FROM_END" || pt === "FROM_START" ? ", at1" : ""}${xt === "FROM_END" || xt === "FROM_START" ? ", at2" : ""}) {
  var start = ${xn("sequence", pt, "at1")};
  var end = ${xn("sequence", xt, "at2")} + 1;
  return sequence.slice(start, end);
}
`) + "(" + Pt + (pt === "FROM_END" || pt === "FROM_START" ? ", " + Vt : "") + (xt === "FROM_END" || xt === "FROM_START" ? ", " + Be : "") + ")";
                return [Pt, ut.FUNCTION_CALL]
            }, on = function(Be, Je) {
                const ot = {
                    UPPERCASE: ".toUpperCase()",
                    LOWERCASE: ".toLowerCase()",
                    TITLECASE: null
                }[Be.getFieldValue("CASE")];
                return Be = Je.valueToCode(Be, "TEXT", ot ? ut.MEMBER : ut.NONE) || "''",
                [ot ? Be + ot : Je.provideFunction_("textToTitleCase", `
function ${Je.FUNCTION_NAME_PLACEHOLDER_}(str) {
  return str.replace(/\\S+/g,
      function(txt) {return txt[0].toUpperCase() + txt.substring(1).toLowerCase();});
}
`) + "(" + Be + ")", ut.FUNCTION_CALL]
            }, zt = function(Be, Je) {
                const ot = {
                    LEFT: ".replace(/^[\\s\\xa0]+/, '')",
                    RIGHT: ".replace(/[\\s\\xa0]+$/, '')",
                    BOTH: ".trim()"
                }[Be.getFieldValue("MODE")];
                return [(Je.valueToCode(Be, "TEXT", ut.MEMBER) || "''") + ot, ut.FUNCTION_CALL]
            }, $t = function(Be, Je) {
                return "window.alert(" + (Je.valueToCode(Be, "TEXT", ut.NONE) || "''") + `);
`
            }, Ut = function(Be, Je) {
                return Je = "window.prompt(" + (Be.getField("TEXT") ? Je.quote_(Be.getFieldValue("TEXT")) : Je.valueToCode(Be, "TEXT", ut.NONE) || "''") + ")",
                Be.getFieldValue("TYPE") === "NUMBER" && (Je = "Number(" + Je + ")"),
                [Je, ut.FUNCTION_CALL]
            }, An = function(Be, Je) {
                const ot = Je.valueToCode(Be, "TEXT", ut.NONE) || "''";
                return Be = Je.valueToCode(Be, "SUB", ut.NONE) || "''",
                [Je.provideFunction_("textCount", `
function ${Je.FUNCTION_NAME_PLACEHOLDER_}(haystack, needle) {
  if (needle.length === 0) {
    return haystack.length + 1;
  } else {
    return haystack.split(needle).length - 1;
  }
}
`) + "(" + ot + ", " + Be + ")", ut.FUNCTION_CALL]
            }, yt = function(Be, Je) {
                const ot = Je.valueToCode(Be, "TEXT", ut.NONE) || "''"
                  , pt = Je.valueToCode(Be, "FROM", ut.NONE) || "''";
                return Be = Je.valueToCode(Be, "TO", ut.NONE) || "''",
                [Je.provideFunction_("textReplace", `
function ${Je.FUNCTION_NAME_PLACEHOLDER_}(haystack, needle, replacement) {
  needle = needle.replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, '\\\\$1')
                 .replace(/\\x08/g, '\\\\x08');
  return haystack.replace(new RegExp(needle, 'g'), replacement);
}
`) + "(" + ot + ", " + pt + ", " + Be + ")", ut.FUNCTION_CALL]
            }, Dt = function(Be, Je) {
                return [(Je.valueToCode(Be, "TEXT", ut.MEMBER) || "''") + ".split('').reverse().join('')", ut.FUNCTION_CALL]
            }, Bt = function(Be, Je) {
                return [Je.getVariableName(Be.getFieldValue("VAR")), ut.ATOMIC]
            }, Wt = function(Be, Je) {
                const ot = Je.valueToCode(Be, "VALUE", ut.ASSIGNMENT) || "0";
                return Je.getVariableName(Be.getFieldValue("VAR")) + " = " + ot + `;
`
            }, ut;
            (function(Be) {
                Be[Be.ATOMIC = 0] = "ATOMIC",
                Be[Be.NEW = 1.1] = "NEW",
                Be[Be.MEMBER = 1.2] = "MEMBER",
                Be[Be.FUNCTION_CALL = 2] = "FUNCTION_CALL",
                Be[Be.INCREMENT = 3] = "INCREMENT",
                Be[Be.DECREMENT = 3] = "DECREMENT",
                Be[Be.BITWISE_NOT = 4.1] = "BITWISE_NOT",
                Be[Be.UNARY_PLUS = 4.2] = "UNARY_PLUS",
                Be[Be.UNARY_NEGATION = 4.3] = "UNARY_NEGATION",
                Be[Be.LOGICAL_NOT = 4.4] = "LOGICAL_NOT",
                Be[Be.TYPEOF = 4.5] = "TYPEOF",
                Be[Be.VOID = 4.6] = "VOID",
                Be[Be.DELETE = 4.7] = "DELETE",
                Be[Be.AWAIT = 4.8] = "AWAIT",
                Be[Be.EXPONENTIATION = 5] = "EXPONENTIATION",
                Be[Be.MULTIPLICATION = 5.1] = "MULTIPLICATION",
                Be[Be.DIVISION = 5.2] = "DIVISION",
                Be[Be.MODULUS = 5.3] = "MODULUS",
                Be[Be.SUBTRACTION = 6.1] = "SUBTRACTION",
                Be[Be.ADDITION = 6.2] = "ADDITION",
                Be[Be.BITWISE_SHIFT = 7] = "BITWISE_SHIFT",
                Be[Be.RELATIONAL = 8] = "RELATIONAL",
                Be[Be.IN = 8] = "IN",
                Be[Be.INSTANCEOF = 8] = "INSTANCEOF",
                Be[Be.EQUALITY = 9] = "EQUALITY",
                Be[Be.BITWISE_AND = 10] = "BITWISE_AND",
                Be[Be.BITWISE_XOR = 11] = "BITWISE_XOR",
                Be[Be.BITWISE_OR = 12] = "BITWISE_OR",
                Be[Be.LOGICAL_AND = 13] = "LOGICAL_AND",
                Be[Be.LOGICAL_OR = 14] = "LOGICAL_OR",
                Be[Be.CONDITIONAL = 15] = "CONDITIONAL",
                Be[Be.ASSIGNMENT = 16] = "ASSIGNMENT",
                Be[Be.YIELD = 17] = "YIELD",
                Be[Be.COMMA = 18] = "COMMA",
                Be[Be.NONE = 99] = "NONE"
            }
            )(ut || (ut = {}));
            var Ge = class extends ne.CodeGenerator$$module$build$src$core$generator {
                constructor(Be="JavaScript") {
                    super(Be),
                    this.ORDER_OVERRIDES = [[ut.FUNCTION_CALL, ut.MEMBER], [ut.FUNCTION_CALL, ut.FUNCTION_CALL], [ut.MEMBER, ut.MEMBER], [ut.MEMBER, ut.FUNCTION_CALL], [ut.LOGICAL_NOT, ut.LOGICAL_NOT], [ut.MULTIPLICATION, ut.MULTIPLICATION], [ut.ADDITION, ut.ADDITION], [ut.LOGICAL_AND, ut.LOGICAL_AND], [ut.LOGICAL_OR, ut.LOGICAL_OR]],
                    this.isInitialized = !1;
                    for (const Je in ut)
                        Be = ut[Je],
                        typeof Be != "string" && (this["ORDER_" + Je] = Be);
                    this.addReservedWords("break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,in,instanceof,new,return,super,switch,this,throw,try,typeof,var,void,while,with,yield,enum,implements,interface,let,package,private,protected,public,static,await,null,true,false,arguments," + Object.getOwnPropertyNames(globalThis).join(","))
                }
                init(Be) {
                    super.init(Be),
                    this.nameDB_ ? this.nameDB_.reset() : this.nameDB_ = new ne.Names$$module$build$src$core$names(this.RESERVED_WORDS_),
                    this.nameDB_.setVariableMap(Be.getVariableMap()),
                    this.nameDB_.populateVariables(Be),
                    this.nameDB_.populateProcedures(Be);
                    const Je = [];
                    var ot = ne.allDeveloperVariables$$module$build$src$core$variables(Be);
                    for (let pt = 0; pt < ot.length; pt++)
                        Je.push(this.nameDB_.getName(ot[pt], ne.NameType$$module$build$src$core$names.DEVELOPER_VARIABLE));
                    for (Be = ne.allUsedVarModels$$module$build$src$core$variables(Be),
                    ot = 0; ot < Be.length; ot++)
                        Je.push(this.nameDB_.getName(Be[ot].getId(), ne.NameType$$module$build$src$core$names.VARIABLE));
                    Je.length && (this.definitions_.variables = "var " + Je.join(", ") + ";"),
                    this.isInitialized = !0
                }
                finish(Be) {
                    const Je = Object.values(this.definitions_);
                    return super.finish(Be),
                    this.isInitialized = !1,
                    this.nameDB_.reset(),
                    Je.join(`

`) + `


` + Be
                }
                scrubNakedValue(Be) {
                    return Be + `;
`
                }
                quote_(Be) {
                    return Be = Be.replace(/\\/g, "\\\\").replace(/\n/g, `\\
`).replace(/'/g, "\\'"),
                    "'" + Be + "'"
                }
                multiline_quote_(Be) {
                    return Be.split(/\n/g).map(this.quote_).join(` + '\\n' +
`)
                }
                scrub_(Be, Je, ot=!1) {
                    let pt = "";
                    if (!Be.outputConnection || !Be.outputConnection.targetConnection) {
                        var xt = Be.getCommentText();
                        xt && (xt = ne.wrap$$module$build$src$core$utils$string(xt, this.COMMENT_WRAP - 3),
                        pt += this.prefixLines(xt + `
`, "// "));
                        for (let Vt = 0; Vt < Be.inputList.length; Vt++)
                            Be.inputList[Vt].type === ne.inputTypes$$module$build$src$core$inputs$input_types.VALUE && (xt = Be.inputList[Vt].connection.targetBlock()) && (xt = this.allNestedComments(xt)) && (pt += this.prefixLines(xt, "// "))
                    }
                    return Be = Be.nextConnection && Be.nextConnection.targetBlock(),
                    ot = ot ? "" : this.blockToCode(Be),
                    pt + Je + ot
                }
                getAdjusted(Be, Je, ot=0, pt=!1, xt=ut.NONE) {
                    Be.workspace.options.oneBasedIndex && ot--;
                    const Vt = Be.workspace.options.oneBasedIndex ? "1" : "0";
                    let Pt = xt;
                    return 0 < ot ? Pt = ut.ADDITION : 0 > ot ? Pt = ut.SUBTRACTION : pt && (Pt = ut.UNARY_NEGATION),
                    Be = this.valueToCode(Be, Je, Pt) || Vt,
                    ot === 0 && !pt ? Be : ne.isNumber$$module$build$src$core$utils$string(Be) ? (Be = String(Number(Be) + ot),
                    pt && (Be = String(-Number(Be))),
                    Be) : (0 < ot ? Be = `${Be} + ${ot}` : 0 > ot && (Be = `${Be} - ${-ot}`),
                    pt && (Be = ot ? `-(${Be})` : `-${Be}`),
                    Math.floor(xt) >= Math.floor(Pt) && (Be = `(${Be})`),
                    Be)
                }
            }
              , st = {};
            st.colour_blend = ge,
            st.colour_picker = ue,
            st.colour_random = ce,
            st.colour_rgb = me;
            var ht = function(Be, Je, ot) {
                return Je === "FIRST" ? "0" : Je === "FROM_END" ? Be + ".length - 1 - " + ot : Je === "LAST" ? Be + ".length - 1" : ot
            }
              , At = {};
            At.lists_create_empty = Te,
            At.lists_create_with = _e,
            At.lists_getIndex = Ne,
            At.lists_getSublist = ke,
            At.lists_indexOf = $e,
            At.lists_isEmpty = ye,
            At.lists_length = Ie,
            At.lists_repeat = Se,
            At.lists_reverse = Fe,
            At.lists_setIndex = ve,
            At.lists_sort = xe,
            At.lists_split = we;
            var Ft = {};
            Ft.controls_if = je,
            Ft.controls_ifelse = je,
            Ft.logic_boolean = Ze,
            Ft.logic_compare = Xe,
            Ft.logic_negate = qe,
            Ft.logic_null = et,
            Ft.logic_operation = ze,
            Ft.logic_ternary = it;
            var an = {};
            an.controls_flow_statements = Ye,
            an.controls_for = ft,
            an.controls_forEach = St,
            an.controls_repeat = at,
            an.controls_repeat_ext = at,
            an.controls_whileUntil = rt;
            var Sn = {};
            Sn.math_arithmetic = nt,
            Sn.math_atan2 = Ht,
            Sn.math_change = mt,
            Sn.math_constant = Et,
            Sn.math_constrain = gt,
            Sn.math_modulo = Qe,
            Sn.math_number = We,
            Sn.math_number_property = Ke,
            Sn.math_on_list = lt,
            Sn.math_random_float = Gt,
            Sn.math_random_int = Nt,
            Sn.math_round = ct,
            Sn.math_single = ct,
            Sn.math_trig = ct;
            var Rn = {};
            Rn.procedures_callnoreturn = kt,
            Rn.procedures_callreturn = Ot,
            Rn.procedures_defnoreturn = Kt,
            Rn.procedures_defreturn = Kt,
            Rn.procedures_ifreturn = Xt;
            var ts = /^\s*'([^']|\\')*'\s*$/
              , yn = function(Be) {
                return ts.test(Be) ? [Be, ut.ATOMIC] : ["String(" + Be + ")", ut.FUNCTION_CALL]
            }
              , xn = function(Be, Je, ot) {
                return Je === "FIRST" ? "0" : Je === "FROM_END" ? Be + ".length - 1 - " + ot : Je === "LAST" ? Be + ".length - 1" : ot
            }
              , En = {};
            En.text = vt,
            En.text_append = Mt,
            En.text_changeCase = on,
            En.text_charAt = dn,
            En.text_count = An,
            En.text_getSubstring = Qt,
            En.text_indexOf = mn,
            En.text_isEmpty = tn,
            En.text_join = Ct,
            En.text_length = nn,
            En.text_multiline = Jt,
            En.text_print = $t,
            En.text_prompt = Ut,
            En.text_prompt_ext = Ut,
            En.text_replace = yt,
            En.text_reverse = Dt,
            En.text_trim = zt;
            var wn = {};
            wn.variables_get = Bt,
            wn.variables_set = Wt;
            var Qn = {};
            Qn.variables_get_dynamic = Bt,
            Qn.variables_set_dynamic = Wt;
            var pr = new Ge
              , ar = Object.assign({}, st, At, Ft, an, Sn, Rn, En, wn, Qn);
            for (const Be in ar)
                pr.forBlock[Be] = ar[Be];
            var _t = {};
            return _t.JavascriptGenerator = Ge,
            _t.Order = ut,
            _t.javascriptGenerator = pr,
            _t.__namespace__ = ne,
            _t
        })
    }(javascript_compressed)),
    javascript_compressed.exports
}
var hasRequiredJavascript;
function requireJavascript() {
    return hasRequiredJavascript || (hasRequiredJavascript = 1,
    function(V, X) {
        (function(J, ne) {
            V.exports = ne(requireCoreBrowser(), requireJavascript_compressed())
        }
        )(commonjsGlobal, function(J, ne) {
            /**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
            return ne
        })
    }(javascript)),
    javascript.exports
}
var hasRequiredBrowser;
function requireBrowser() {
    return hasRequiredBrowser || (hasRequiredBrowser = 1,
    function(V, X) {
        (function(J, ne) {
            V.exports = ne(requireCoreBrowser(), requireEn(), requireBlocks(), requireJavascript())
        }
        )(commonjsGlobal, function(J, ne, ue, ce) {
            return J.setLocale(ne),
            J
        })
    }(browser$1)),
    browser$1.exports
}
(function(V, X) {
    (function(J, ne) {
        V.exports = ne(requireBrowser())
    }
    )(commonjsGlobal, function(J) {
        /**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
        return J
    })
}
)(blockly$1);
var blocklyExports = blockly$1.exports;
const Blockly = getDefaultExportFromCjs(blocklyExports)
  , VARIABLES_DEFAULT_NAME = "VARIABLES_DEFAULT_NAME"
  , UNNAMED_KEY = "UNNAMED_KEY"
  , TODAY = "TODAY"
  , DUPLICATE_BLOCK = "DUPLICATE_BLOCK"
  , ADD_COMMENT = "ADD_COMMENT"
  , REMOVE_COMMENT = "REMOVE_COMMENT"
  , DUPLICATE_COMMENT = "DUPLICATE_COMMENT"
  , EXTERNAL_INPUTS = "EXTERNAL_INPUTS"
  , INLINE_INPUTS = "INLINE_INPUTS"
  , DELETE_BLOCK = "DELETE_BLOCK"
  , DELETE_X_BLOCKS = "DELETE_X_BLOCKS"
  , DELETE_ALL_BLOCKS = "DELETE_ALL_BLOCKS"
  , CLEAN_UP = "CLEAN_UP"
  , COLLAPSE_BLOCK = "COLLAPSE_BLOCK"
  , COLLAPSE_ALL = "COLLAPSE_ALL"
  , EXPAND_BLOCK = "EXPAND_BLOCK"
  , EXPAND_ALL = "EXPAND_ALL"
  , DISABLE_BLOCK = "DISABLE_BLOCK"
  , ENABLE_BLOCK = "ENABLE_BLOCK"
  , HELP = "HELP"
  , UNDO = "UNDO"
  , REDO = "REDO"
  , CHANGE_VALUE_TITLE = "CHANGE_VALUE_TITLE"
  , RENAME_VARIABLE = "RENAME_VARIABLE"
  , RENAME_VARIABLE_TITLE = "RENAME_VARIABLE_TITLE"
  , NEW_VARIABLE = "NEW_VARIABLE"
  , NEW_STRING_VARIABLE = "NEW_STRING_VARIABLE"
  , NEW_NUMBER_VARIABLE = "NEW_NUMBER_VARIABLE"
  , NEW_COLOUR_VARIABLE = "NEW_COLOUR_VARIABLE"
  , NEW_VARIABLE_TYPE_TITLE = "NEW_VARIABLE_TYPE_TITLE"
  , NEW_VARIABLE_TITLE = "NEW_VARIABLE_TITLE"
  , VARIABLE_ALREADY_EXISTS = "VARIABLE_ALREADY_EXISTS"
  , VARIABLE_ALREADY_EXISTS_FOR_ANOTHER_TYPE = "VARIABLE_ALREADY_EXISTS_FOR_ANOTHER_TYPE"
  , DELETE_VARIABLE_CONFIRMATION = "DELETE_VARIABLE_CONFIRMATION"
  , CANNOT_DELETE_VARIABLE_PROCEDURE = "CANNOT_DELETE_VARIABLE_PROCEDURE"
  , DELETE_VARIABLE = "DELETE_VARIABLE"
  , COLOUR_PICKER_HELPURL = "COLOUR_PICKER_HELPURL"
  , COLOUR_PICKER_TOOLTIP = "COLOUR_PICKER_TOOLTIP"
  , COLOUR_RANDOM_HELPURL = "COLOUR_RANDOM_HELPURL"
  , COLOUR_RANDOM_TITLE = "COLOUR_RANDOM_TITLE"
  , COLOUR_RANDOM_TOOLTIP = "COLOUR_RANDOM_TOOLTIP"
  , COLOUR_RGB_HELPURL = "COLOUR_RGB_HELPURL"
  , COLOUR_RGB_TITLE = "COLOUR_RGB_TITLE"
  , COLOUR_RGB_RED = "COLOUR_RGB_RED"
  , COLOUR_RGB_GREEN = "COLOUR_RGB_GREEN"
  , COLOUR_RGB_BLUE = "COLOUR_RGB_BLUE"
  , COLOUR_RGB_TOOLTIP = "COLOUR_RGB_TOOLTIP"
  , COLOUR_BLEND_HELPURL = "COLOUR_BLEND_HELPURL"
  , COLOUR_BLEND_TITLE = "COLOUR_BLEND_TITLE"
  , COLOUR_BLEND_COLOUR1 = "COLOUR_BLEND_COLOUR1"
  , COLOUR_BLEND_COLOUR2 = "COLOUR_BLEND_COLOUR2"
  , COLOUR_BLEND_RATIO = "COLOUR_BLEND_RATIO"
  , COLOUR_BLEND_TOOLTIP = "COLOUR_BLEND_TOOLTIP"
  , CONTROLS_REPEAT_HELPURL = "CONTROLS_REPEAT_HELPURL"
  , CONTROLS_REPEAT_TITLE = "CONTROLS_REPEAT_TITLE"
  , CONTROLS_REPEAT_INPUT_DO = "CONTROLS_REPEAT_INPUT_DO"
  , CONTROLS_REPEAT_TOOLTIP = "CONTROLS_REPEAT_TOOLTIP"
  , CONTROLS_WHILEUNTIL_HELPURL = "CONTROLS_WHILEUNTIL_HELPURL"
  , CONTROLS_WHILEUNTIL_OPERATOR_WHILE = "CONTROLS_WHILEUNTIL_OPERATOR_WHILE"
  , CONTROLS_WHILEUNTIL_OPERATOR_UNTIL = "CONTROLS_WHILEUNTIL_OPERATOR_UNTIL"
  , CONTROLS_WHILEUNTIL_TOOLTIP_WHILE = "CONTROLS_WHILEUNTIL_TOOLTIP_WHILE"
  , CONTROLS_WHILEUNTIL_TOOLTIP_UNTIL = "CONTROLS_WHILEUNTIL_TOOLTIP_UNTIL"
  , CONTROLS_FOR_HELPURL = "CONTROLS_FOR_HELPURL"
  , CONTROLS_FOR_TOOLTIP = "CONTROLS_FOR_TOOLTIP"
  , CONTROLS_FOR_TITLE = "CONTROLS_FOR_TITLE"
  , CONTROLS_FOREACH_HELPURL = "CONTROLS_FOREACH_HELPURL"
  , CONTROLS_FOREACH_TITLE = "CONTROLS_FOREACH_TITLE"
  , CONTROLS_FOREACH_TOOLTIP = "CONTROLS_FOREACH_TOOLTIP"
  , CONTROLS_FLOW_STATEMENTS_HELPURL = "CONTROLS_FLOW_STATEMENTS_HELPURL"
  , CONTROLS_FLOW_STATEMENTS_OPERATOR_BREAK = "CONTROLS_FLOW_STATEMENTS_OPERATOR_BREAK"
  , CONTROLS_FLOW_STATEMENTS_OPERATOR_CONTINUE = "CONTROLS_FLOW_STATEMENTS_OPERATOR_CONTINUE"
  , CONTROLS_FLOW_STATEMENTS_TOOLTIP_BREAK = "CONTROLS_FLOW_STATEMENTS_TOOLTIP_BREAK"
  , CONTROLS_FLOW_STATEMENTS_TOOLTIP_CONTINUE = "CONTROLS_FLOW_STATEMENTS_TOOLTIP_CONTINUE"
  , CONTROLS_FLOW_STATEMENTS_WARNING = "CONTROLS_FLOW_STATEMENTS_WARNING"
  , CONTROLS_IF_HELPURL = "CONTROLS_IF_HELPURL"
  , CONTROLS_IF_TOOLTIP_1 = "CONTROLS_IF_TOOLTIP_1"
  , CONTROLS_IF_TOOLTIP_2 = "CONTROLS_IF_TOOLTIP_2"
  , CONTROLS_IF_TOOLTIP_3 = "CONTROLS_IF_TOOLTIP_3"
  , CONTROLS_IF_TOOLTIP_4 = "CONTROLS_IF_TOOLTIP_4"
  , CONTROLS_IF_MSG_IF = "CONTROLS_IF_MSG_IF"
  , CONTROLS_IF_MSG_ELSEIF = "CONTROLS_IF_MSG_ELSEIF"
  , CONTROLS_IF_MSG_ELSE = "CONTROLS_IF_MSG_ELSE"
  , CONTROLS_IF_IF_TOOLTIP = "CONTROLS_IF_IF_TOOLTIP"
  , CONTROLS_IF_ELSEIF_TOOLTIP = "CONTROLS_IF_ELSEIF_TOOLTIP"
  , CONTROLS_IF_ELSE_TOOLTIP = "CONTROLS_IF_ELSE_TOOLTIP"
  , IOS_OK = "IOS_OK"
  , IOS_CANCEL = "IOS_CANCEL"
  , IOS_ERROR = "IOS_ERROR"
  , IOS_PROCEDURES_INPUTS = "IOS_PROCEDURES_INPUTS"
  , IOS_PROCEDURES_ADD_INPUT = "IOS_PROCEDURES_ADD_INPUT"
  , IOS_PROCEDURES_ALLOW_STATEMENTS = "IOS_PROCEDURES_ALLOW_STATEMENTS"
  , IOS_PROCEDURES_DUPLICATE_INPUTS_ERROR = "IOS_PROCEDURES_DUPLICATE_INPUTS_ERROR"
  , IOS_VARIABLES_ADD_VARIABLE = "IOS_VARIABLES_ADD_VARIABLE"
  , IOS_VARIABLES_ADD_BUTTON = "IOS_VARIABLES_ADD_BUTTON"
  , IOS_VARIABLES_RENAME_BUTTON = "IOS_VARIABLES_RENAME_BUTTON"
  , IOS_VARIABLES_DELETE_BUTTON = "IOS_VARIABLES_DELETE_BUTTON"
  , IOS_VARIABLES_VARIABLE_NAME = "IOS_VARIABLES_VARIABLE_NAME"
  , IOS_VARIABLES_EMPTY_NAME_ERROR = "IOS_VARIABLES_EMPTY_NAME_ERROR"
  , LOGIC_COMPARE_HELPURL = "LOGIC_COMPARE_HELPURL"
  , LOGIC_COMPARE_TOOLTIP_EQ = "LOGIC_COMPARE_TOOLTIP_EQ"
  , LOGIC_COMPARE_TOOLTIP_NEQ = "LOGIC_COMPARE_TOOLTIP_NEQ"
  , LOGIC_COMPARE_TOOLTIP_LT = "LOGIC_COMPARE_TOOLTIP_LT"
  , LOGIC_COMPARE_TOOLTIP_LTE = "LOGIC_COMPARE_TOOLTIP_LTE"
  , LOGIC_COMPARE_TOOLTIP_GT = "LOGIC_COMPARE_TOOLTIP_GT"
  , LOGIC_COMPARE_TOOLTIP_GTE = "LOGIC_COMPARE_TOOLTIP_GTE"
  , LOGIC_OPERATION_HELPURL = "LOGIC_OPERATION_HELPURL"
  , LOGIC_OPERATION_TOOLTIP_AND = "LOGIC_OPERATION_TOOLTIP_AND"
  , LOGIC_OPERATION_AND = "LOGIC_OPERATION_AND"
  , LOGIC_OPERATION_TOOLTIP_OR = "LOGIC_OPERATION_TOOLTIP_OR"
  , LOGIC_OPERATION_OR = "LOGIC_OPERATION_OR"
  , LOGIC_NEGATE_HELPURL = "LOGIC_NEGATE_HELPURL"
  , LOGIC_NEGATE_TITLE = "LOGIC_NEGATE_TITLE"
  , LOGIC_NEGATE_TOOLTIP = "LOGIC_NEGATE_TOOLTIP"
  , LOGIC_BOOLEAN_HELPURL = "LOGIC_BOOLEAN_HELPURL"
  , LOGIC_BOOLEAN_TRUE = "LOGIC_BOOLEAN_TRUE"
  , LOGIC_BOOLEAN_FALSE = "LOGIC_BOOLEAN_FALSE"
  , LOGIC_BOOLEAN_TOOLTIP = "LOGIC_BOOLEAN_TOOLTIP"
  , LOGIC_NULL_HELPURL = "LOGIC_NULL_HELPURL"
  , LOGIC_NULL = "LOGIC_NULL"
  , LOGIC_NULL_TOOLTIP = "LOGIC_NULL_TOOLTIP"
  , LOGIC_TERNARY_HELPURL = "LOGIC_TERNARY_HELPURL"
  , LOGIC_TERNARY_CONDITION = "LOGIC_TERNARY_CONDITION"
  , LOGIC_TERNARY_IF_TRUE = "LOGIC_TERNARY_IF_TRUE"
  , LOGIC_TERNARY_IF_FALSE = "LOGIC_TERNARY_IF_FALSE"
  , LOGIC_TERNARY_TOOLTIP = "LOGIC_TERNARY_TOOLTIP"
  , MATH_NUMBER_HELPURL = "MATH_NUMBER_HELPURL"
  , MATH_NUMBER_TOOLTIP = "MATH_NUMBER_TOOLTIP"
  , MATH_ADDITION_SYMBOL = "MATH_ADDITION_SYMBOL"
  , MATH_SUBTRACTION_SYMBOL = "MATH_SUBTRACTION_SYMBOL"
  , MATH_DIVISION_SYMBOL = "MATH_DIVISION_SYMBOL"
  , MATH_MULTIPLICATION_SYMBOL = "MATH_MULTIPLICATION_SYMBOL"
  , MATH_POWER_SYMBOL = "MATH_POWER_SYMBOL"
  , MATH_TRIG_SIN = "MATH_TRIG_SIN"
  , MATH_TRIG_COS = "MATH_TRIG_COS"
  , MATH_TRIG_TAN = "MATH_TRIG_TAN"
  , MATH_TRIG_ASIN = "MATH_TRIG_ASIN"
  , MATH_TRIG_ACOS = "MATH_TRIG_ACOS"
  , MATH_TRIG_ATAN = "MATH_TRIG_ATAN"
  , MATH_ARITHMETIC_HELPURL = "MATH_ARITHMETIC_HELPURL"
  , MATH_ARITHMETIC_TOOLTIP_ADD = "MATH_ARITHMETIC_TOOLTIP_ADD"
  , MATH_ARITHMETIC_TOOLTIP_MINUS = "MATH_ARITHMETIC_TOOLTIP_MINUS"
  , MATH_ARITHMETIC_TOOLTIP_MULTIPLY = "MATH_ARITHMETIC_TOOLTIP_MULTIPLY"
  , MATH_ARITHMETIC_TOOLTIP_DIVIDE = "MATH_ARITHMETIC_TOOLTIP_DIVIDE"
  , MATH_ARITHMETIC_TOOLTIP_POWER = "MATH_ARITHMETIC_TOOLTIP_POWER"
  , MATH_SINGLE_HELPURL = "MATH_SINGLE_HELPURL"
  , MATH_SINGLE_OP_ROOT = "MATH_SINGLE_OP_ROOT"
  , MATH_SINGLE_TOOLTIP_ROOT = "MATH_SINGLE_TOOLTIP_ROOT"
  , MATH_SINGLE_OP_ABSOLUTE = "MATH_SINGLE_OP_ABSOLUTE"
  , MATH_SINGLE_TOOLTIP_ABS = "MATH_SINGLE_TOOLTIP_ABS"
  , MATH_SINGLE_TOOLTIP_NEG = "MATH_SINGLE_TOOLTIP_NEG"
  , MATH_SINGLE_TOOLTIP_LN = "MATH_SINGLE_TOOLTIP_LN"
  , MATH_SINGLE_TOOLTIP_LOG10 = "MATH_SINGLE_TOOLTIP_LOG10"
  , MATH_SINGLE_TOOLTIP_EXP = "MATH_SINGLE_TOOLTIP_EXP"
  , MATH_SINGLE_TOOLTIP_POW10 = "MATH_SINGLE_TOOLTIP_POW10"
  , MATH_TRIG_HELPURL = "MATH_TRIG_HELPURL"
  , MATH_TRIG_TOOLTIP_SIN = "MATH_TRIG_TOOLTIP_SIN"
  , MATH_TRIG_TOOLTIP_COS = "MATH_TRIG_TOOLTIP_COS"
  , MATH_TRIG_TOOLTIP_TAN = "MATH_TRIG_TOOLTIP_TAN"
  , MATH_TRIG_TOOLTIP_ASIN = "MATH_TRIG_TOOLTIP_ASIN"
  , MATH_TRIG_TOOLTIP_ACOS = "MATH_TRIG_TOOLTIP_ACOS"
  , MATH_TRIG_TOOLTIP_ATAN = "MATH_TRIG_TOOLTIP_ATAN"
  , MATH_CONSTANT_HELPURL = "MATH_CONSTANT_HELPURL"
  , MATH_CONSTANT_TOOLTIP = "MATH_CONSTANT_TOOLTIP"
  , MATH_IS_EVEN = "MATH_IS_EVEN"
  , MATH_IS_ODD = "MATH_IS_ODD"
  , MATH_IS_PRIME = "MATH_IS_PRIME"
  , MATH_IS_WHOLE = "MATH_IS_WHOLE"
  , MATH_IS_POSITIVE = "MATH_IS_POSITIVE"
  , MATH_IS_NEGATIVE = "MATH_IS_NEGATIVE"
  , MATH_IS_DIVISIBLE_BY = "MATH_IS_DIVISIBLE_BY"
  , MATH_IS_TOOLTIP = "MATH_IS_TOOLTIP"
  , MATH_CHANGE_HELPURL = "MATH_CHANGE_HELPURL"
  , MATH_CHANGE_TITLE = "MATH_CHANGE_TITLE"
  , MATH_CHANGE_TOOLTIP = "MATH_CHANGE_TOOLTIP"
  , MATH_ROUND_HELPURL = "MATH_ROUND_HELPURL"
  , MATH_ROUND_TOOLTIP = "MATH_ROUND_TOOLTIP"
  , MATH_ROUND_OPERATOR_ROUND = "MATH_ROUND_OPERATOR_ROUND"
  , MATH_ROUND_OPERATOR_ROUNDUP = "MATH_ROUND_OPERATOR_ROUNDUP"
  , MATH_ROUND_OPERATOR_ROUNDDOWN = "MATH_ROUND_OPERATOR_ROUNDDOWN"
  , MATH_ONLIST_HELPURL = "MATH_ONLIST_HELPURL"
  , MATH_ONLIST_OPERATOR_SUM = "MATH_ONLIST_OPERATOR_SUM"
  , MATH_ONLIST_TOOLTIP_SUM = "MATH_ONLIST_TOOLTIP_SUM"
  , MATH_ONLIST_OPERATOR_MIN = "MATH_ONLIST_OPERATOR_MIN"
  , MATH_ONLIST_TOOLTIP_MIN = "MATH_ONLIST_TOOLTIP_MIN"
  , MATH_ONLIST_OPERATOR_MAX = "MATH_ONLIST_OPERATOR_MAX"
  , MATH_ONLIST_TOOLTIP_MAX = "MATH_ONLIST_TOOLTIP_MAX"
  , MATH_ONLIST_OPERATOR_AVERAGE = "MATH_ONLIST_OPERATOR_AVERAGE"
  , MATH_ONLIST_TOOLTIP_AVERAGE = "MATH_ONLIST_TOOLTIP_AVERAGE"
  , MATH_ONLIST_OPERATOR_MEDIAN = "MATH_ONLIST_OPERATOR_MEDIAN"
  , MATH_ONLIST_TOOLTIP_MEDIAN = "MATH_ONLIST_TOOLTIP_MEDIAN"
  , MATH_ONLIST_OPERATOR_MODE = "MATH_ONLIST_OPERATOR_MODE"
  , MATH_ONLIST_TOOLTIP_MODE = "MATH_ONLIST_TOOLTIP_MODE"
  , MATH_ONLIST_OPERATOR_STD_DEV = "MATH_ONLIST_OPERATOR_STD_DEV"
  , MATH_ONLIST_TOOLTIP_STD_DEV = "MATH_ONLIST_TOOLTIP_STD_DEV"
  , MATH_ONLIST_OPERATOR_RANDOM = "MATH_ONLIST_OPERATOR_RANDOM"
  , MATH_ONLIST_TOOLTIP_RANDOM = "MATH_ONLIST_TOOLTIP_RANDOM"
  , MATH_MODULO_HELPURL = "MATH_MODULO_HELPURL"
  , MATH_MODULO_TITLE = "MATH_MODULO_TITLE"
  , MATH_MODULO_TOOLTIP = "MATH_MODULO_TOOLTIP"
  , MATH_CONSTRAIN_HELPURL = "MATH_CONSTRAIN_HELPURL"
  , MATH_CONSTRAIN_TITLE = "MATH_CONSTRAIN_TITLE"
  , MATH_CONSTRAIN_TOOLTIP = "MATH_CONSTRAIN_TOOLTIP"
  , MATH_RANDOM_INT_HELPURL = "MATH_RANDOM_INT_HELPURL"
  , MATH_RANDOM_INT_TITLE = "MATH_RANDOM_INT_TITLE"
  , MATH_RANDOM_INT_TOOLTIP = "MATH_RANDOM_INT_TOOLTIP"
  , MATH_RANDOM_FLOAT_HELPURL = "MATH_RANDOM_FLOAT_HELPURL"
  , MATH_RANDOM_FLOAT_TITLE_RANDOM = "MATH_RANDOM_FLOAT_TITLE_RANDOM"
  , MATH_RANDOM_FLOAT_TOOLTIP = "MATH_RANDOM_FLOAT_TOOLTIP"
  , MATH_ATAN2_HELPURL = "MATH_ATAN2_HELPURL"
  , MATH_ATAN2_TITLE = "MATH_ATAN2_TITLE"
  , MATH_ATAN2_TOOLTIP = "MATH_ATAN2_TOOLTIP"
  , TEXT_TEXT_HELPURL = "TEXT_TEXT_HELPURL"
  , TEXT_TEXT_TOOLTIP = "TEXT_TEXT_TOOLTIP"
  , TEXT_JOIN_HELPURL = "TEXT_JOIN_HELPURL"
  , TEXT_JOIN_TITLE_CREATEWITH = "TEXT_JOIN_TITLE_CREATEWITH"
  , TEXT_JOIN_TOOLTIP = "TEXT_JOIN_TOOLTIP"
  , TEXT_CREATE_JOIN_TITLE_JOIN = "TEXT_CREATE_JOIN_TITLE_JOIN"
  , TEXT_CREATE_JOIN_TOOLTIP = "TEXT_CREATE_JOIN_TOOLTIP"
  , TEXT_CREATE_JOIN_ITEM_TOOLTIP = "TEXT_CREATE_JOIN_ITEM_TOOLTIP"
  , TEXT_APPEND_HELPURL = "TEXT_APPEND_HELPURL"
  , TEXT_APPEND_TITLE = "TEXT_APPEND_TITLE"
  , TEXT_APPEND_TOOLTIP = "TEXT_APPEND_TOOLTIP"
  , TEXT_LENGTH_HELPURL = "TEXT_LENGTH_HELPURL"
  , TEXT_LENGTH_TITLE = "TEXT_LENGTH_TITLE"
  , TEXT_LENGTH_TOOLTIP = "TEXT_LENGTH_TOOLTIP"
  , TEXT_ISEMPTY_HELPURL = "TEXT_ISEMPTY_HELPURL"
  , TEXT_ISEMPTY_TITLE = "TEXT_ISEMPTY_TITLE"
  , TEXT_ISEMPTY_TOOLTIP = "TEXT_ISEMPTY_TOOLTIP"
  , TEXT_INDEXOF_HELPURL = "TEXT_INDEXOF_HELPURL"
  , TEXT_INDEXOF_TOOLTIP = "TEXT_INDEXOF_TOOLTIP"
  , TEXT_INDEXOF_TITLE = "TEXT_INDEXOF_TITLE"
  , TEXT_INDEXOF_OPERATOR_FIRST = "TEXT_INDEXOF_OPERATOR_FIRST"
  , TEXT_INDEXOF_OPERATOR_LAST = "TEXT_INDEXOF_OPERATOR_LAST"
  , TEXT_CHARAT_HELPURL = "TEXT_CHARAT_HELPURL"
  , TEXT_CHARAT_TITLE = "TEXT_CHARAT_TITLE"
  , TEXT_CHARAT_FROM_START = "TEXT_CHARAT_FROM_START"
  , TEXT_CHARAT_FROM_END = "TEXT_CHARAT_FROM_END"
  , TEXT_CHARAT_FIRST = "TEXT_CHARAT_FIRST"
  , TEXT_CHARAT_LAST = "TEXT_CHARAT_LAST"
  , TEXT_CHARAT_RANDOM = "TEXT_CHARAT_RANDOM"
  , TEXT_CHARAT_TAIL = "TEXT_CHARAT_TAIL"
  , TEXT_CHARAT_TOOLTIP = "TEXT_CHARAT_TOOLTIP"
  , TEXT_GET_SUBSTRING_TOOLTIP = "TEXT_GET_SUBSTRING_TOOLTIP"
  , TEXT_GET_SUBSTRING_HELPURL = "TEXT_GET_SUBSTRING_HELPURL"
  , TEXT_GET_SUBSTRING_INPUT_IN_TEXT = "TEXT_GET_SUBSTRING_INPUT_IN_TEXT"
  , TEXT_GET_SUBSTRING_START_FROM_START = "TEXT_GET_SUBSTRING_START_FROM_START"
  , TEXT_GET_SUBSTRING_START_FROM_END = "TEXT_GET_SUBSTRING_START_FROM_END"
  , TEXT_GET_SUBSTRING_START_FIRST = "TEXT_GET_SUBSTRING_START_FIRST"
  , TEXT_GET_SUBSTRING_END_FROM_START = "TEXT_GET_SUBSTRING_END_FROM_START"
  , TEXT_GET_SUBSTRING_END_FROM_END = "TEXT_GET_SUBSTRING_END_FROM_END"
  , TEXT_GET_SUBSTRING_END_LAST = "TEXT_GET_SUBSTRING_END_LAST"
  , TEXT_GET_SUBSTRING_TAIL = "TEXT_GET_SUBSTRING_TAIL"
  , TEXT_CHANGECASE_HELPURL = "TEXT_CHANGECASE_HELPURL"
  , TEXT_CHANGECASE_TOOLTIP = "TEXT_CHANGECASE_TOOLTIP"
  , TEXT_CHANGECASE_OPERATOR_UPPERCASE = "TEXT_CHANGECASE_OPERATOR_UPPERCASE"
  , TEXT_CHANGECASE_OPERATOR_LOWERCASE = "TEXT_CHANGECASE_OPERATOR_LOWERCASE"
  , TEXT_CHANGECASE_OPERATOR_TITLECASE = "TEXT_CHANGECASE_OPERATOR_TITLECASE"
  , TEXT_TRIM_HELPURL = "TEXT_TRIM_HELPURL"
  , TEXT_TRIM_TOOLTIP = "TEXT_TRIM_TOOLTIP"
  , TEXT_TRIM_OPERATOR_BOTH = "TEXT_TRIM_OPERATOR_BOTH"
  , TEXT_TRIM_OPERATOR_LEFT = "TEXT_TRIM_OPERATOR_LEFT"
  , TEXT_TRIM_OPERATOR_RIGHT = "TEXT_TRIM_OPERATOR_RIGHT"
  , TEXT_PRINT_HELPURL = "TEXT_PRINT_HELPURL"
  , TEXT_PRINT_TITLE = "TEXT_PRINT_TITLE"
  , TEXT_PRINT_TOOLTIP = "TEXT_PRINT_TOOLTIP"
  , TEXT_PROMPT_HELPURL = "TEXT_PROMPT_HELPURL"
  , TEXT_PROMPT_TYPE_TEXT = "TEXT_PROMPT_TYPE_TEXT"
  , TEXT_PROMPT_TYPE_NUMBER = "TEXT_PROMPT_TYPE_NUMBER"
  , TEXT_PROMPT_TOOLTIP_NUMBER = "TEXT_PROMPT_TOOLTIP_NUMBER"
  , TEXT_PROMPT_TOOLTIP_TEXT = "TEXT_PROMPT_TOOLTIP_TEXT"
  , TEXT_COUNT_MESSAGE0 = "TEXT_COUNT_MESSAGE0"
  , TEXT_COUNT_HELPURL = "TEXT_COUNT_HELPURL"
  , TEXT_COUNT_TOOLTIP = "TEXT_COUNT_TOOLTIP"
  , TEXT_REPLACE_MESSAGE0 = "TEXT_REPLACE_MESSAGE0"
  , TEXT_REPLACE_HELPURL = "TEXT_REPLACE_HELPURL"
  , TEXT_REPLACE_TOOLTIP = "TEXT_REPLACE_TOOLTIP"
  , TEXT_REVERSE_MESSAGE0 = "TEXT_REVERSE_MESSAGE0"
  , TEXT_REVERSE_HELPURL = "TEXT_REVERSE_HELPURL"
  , TEXT_REVERSE_TOOLTIP = "TEXT_REVERSE_TOOLTIP"
  , LISTS_CREATE_EMPTY_HELPURL = "LISTS_CREATE_EMPTY_HELPURL"
  , LISTS_CREATE_EMPTY_TITLE = "LISTS_CREATE_EMPTY_TITLE"
  , LISTS_CREATE_EMPTY_TOOLTIP = "LISTS_CREATE_EMPTY_TOOLTIP"
  , LISTS_CREATE_WITH_HELPURL = "LISTS_CREATE_WITH_HELPURL"
  , LISTS_CREATE_WITH_TOOLTIP = "LISTS_CREATE_WITH_TOOLTIP"
  , LISTS_CREATE_WITH_INPUT_WITH = "LISTS_CREATE_WITH_INPUT_WITH"
  , LISTS_CREATE_WITH_CONTAINER_TITLE_ADD = "LISTS_CREATE_WITH_CONTAINER_TITLE_ADD"
  , LISTS_CREATE_WITH_CONTAINER_TOOLTIP = "LISTS_CREATE_WITH_CONTAINER_TOOLTIP"
  , LISTS_CREATE_WITH_ITEM_TOOLTIP = "LISTS_CREATE_WITH_ITEM_TOOLTIP"
  , LISTS_REPEAT_HELPURL = "LISTS_REPEAT_HELPURL"
  , LISTS_REPEAT_TOOLTIP = "LISTS_REPEAT_TOOLTIP"
  , LISTS_REPEAT_TITLE = "LISTS_REPEAT_TITLE"
  , LISTS_LENGTH_HELPURL = "LISTS_LENGTH_HELPURL"
  , LISTS_LENGTH_TITLE = "LISTS_LENGTH_TITLE"
  , LISTS_LENGTH_TOOLTIP = "LISTS_LENGTH_TOOLTIP"
  , LISTS_ISEMPTY_HELPURL = "LISTS_ISEMPTY_HELPURL"
  , LISTS_ISEMPTY_TITLE = "LISTS_ISEMPTY_TITLE"
  , LISTS_ISEMPTY_TOOLTIP = "LISTS_ISEMPTY_TOOLTIP"
  , LISTS_INLIST = "LISTS_INLIST"
  , LISTS_INDEX_OF_HELPURL = "LISTS_INDEX_OF_HELPURL"
  , LISTS_INDEX_OF_FIRST = "LISTS_INDEX_OF_FIRST"
  , LISTS_INDEX_OF_LAST = "LISTS_INDEX_OF_LAST"
  , LISTS_INDEX_OF_TOOLTIP = "LISTS_INDEX_OF_TOOLTIP"
  , LISTS_GET_INDEX_GET = "LISTS_GET_INDEX_GET"
  , LISTS_GET_INDEX_GET_REMOVE = "LISTS_GET_INDEX_GET_REMOVE"
  , LISTS_GET_INDEX_REMOVE = "LISTS_GET_INDEX_REMOVE"
  , LISTS_GET_INDEX_FROM_START = "LISTS_GET_INDEX_FROM_START"
  , LISTS_GET_INDEX_FROM_END = "LISTS_GET_INDEX_FROM_END"
  , LISTS_GET_INDEX_FIRST = "LISTS_GET_INDEX_FIRST"
  , LISTS_GET_INDEX_LAST = "LISTS_GET_INDEX_LAST"
  , LISTS_GET_INDEX_RANDOM = "LISTS_GET_INDEX_RANDOM"
  , LISTS_GET_INDEX_TAIL = "LISTS_GET_INDEX_TAIL"
  , LISTS_INDEX_FROM_START_TOOLTIP = "LISTS_INDEX_FROM_START_TOOLTIP"
  , LISTS_INDEX_FROM_END_TOOLTIP = "LISTS_INDEX_FROM_END_TOOLTIP"
  , LISTS_GET_INDEX_TOOLTIP_GET_FROM = "LISTS_GET_INDEX_TOOLTIP_GET_FROM"
  , LISTS_GET_INDEX_TOOLTIP_GET_FIRST = "LISTS_GET_INDEX_TOOLTIP_GET_FIRST"
  , LISTS_GET_INDEX_TOOLTIP_GET_LAST = "LISTS_GET_INDEX_TOOLTIP_GET_LAST"
  , LISTS_GET_INDEX_TOOLTIP_GET_RANDOM = "LISTS_GET_INDEX_TOOLTIP_GET_RANDOM"
  , LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FROM = "LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FROM"
  , LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FIRST = "LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FIRST"
  , LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_LAST = "LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_LAST"
  , LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_RANDOM = "LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_RANDOM"
  , LISTS_GET_INDEX_TOOLTIP_REMOVE_FROM = "LISTS_GET_INDEX_TOOLTIP_REMOVE_FROM"
  , LISTS_GET_INDEX_TOOLTIP_REMOVE_FIRST = "LISTS_GET_INDEX_TOOLTIP_REMOVE_FIRST"
  , LISTS_GET_INDEX_TOOLTIP_REMOVE_LAST = "LISTS_GET_INDEX_TOOLTIP_REMOVE_LAST"
  , LISTS_GET_INDEX_TOOLTIP_REMOVE_RANDOM = "LISTS_GET_INDEX_TOOLTIP_REMOVE_RANDOM"
  , LISTS_SET_INDEX_HELPURL = "LISTS_SET_INDEX_HELPURL"
  , LISTS_SET_INDEX_SET = "LISTS_SET_INDEX_SET"
  , LISTS_SET_INDEX_INSERT = "LISTS_SET_INDEX_INSERT"
  , LISTS_SET_INDEX_INPUT_TO = "LISTS_SET_INDEX_INPUT_TO"
  , LISTS_SET_INDEX_TOOLTIP_SET_FROM = "LISTS_SET_INDEX_TOOLTIP_SET_FROM"
  , LISTS_SET_INDEX_TOOLTIP_SET_FIRST = "LISTS_SET_INDEX_TOOLTIP_SET_FIRST"
  , LISTS_SET_INDEX_TOOLTIP_SET_LAST = "LISTS_SET_INDEX_TOOLTIP_SET_LAST"
  , LISTS_SET_INDEX_TOOLTIP_SET_RANDOM = "LISTS_SET_INDEX_TOOLTIP_SET_RANDOM"
  , LISTS_SET_INDEX_TOOLTIP_INSERT_FROM = "LISTS_SET_INDEX_TOOLTIP_INSERT_FROM"
  , LISTS_SET_INDEX_TOOLTIP_INSERT_FIRST = "LISTS_SET_INDEX_TOOLTIP_INSERT_FIRST"
  , LISTS_SET_INDEX_TOOLTIP_INSERT_LAST = "LISTS_SET_INDEX_TOOLTIP_INSERT_LAST"
  , LISTS_SET_INDEX_TOOLTIP_INSERT_RANDOM = "LISTS_SET_INDEX_TOOLTIP_INSERT_RANDOM"
  , LISTS_GET_SUBLIST_HELPURL = "LISTS_GET_SUBLIST_HELPURL"
  , LISTS_GET_SUBLIST_START_FROM_START = "LISTS_GET_SUBLIST_START_FROM_START"
  , LISTS_GET_SUBLIST_START_FROM_END = "LISTS_GET_SUBLIST_START_FROM_END"
  , LISTS_GET_SUBLIST_START_FIRST = "LISTS_GET_SUBLIST_START_FIRST"
  , LISTS_GET_SUBLIST_END_FROM_START = "LISTS_GET_SUBLIST_END_FROM_START"
  , LISTS_GET_SUBLIST_END_FROM_END = "LISTS_GET_SUBLIST_END_FROM_END"
  , LISTS_GET_SUBLIST_END_LAST = "LISTS_GET_SUBLIST_END_LAST"
  , LISTS_GET_SUBLIST_TAIL = "LISTS_GET_SUBLIST_TAIL"
  , LISTS_GET_SUBLIST_TOOLTIP = "LISTS_GET_SUBLIST_TOOLTIP"
  , LISTS_SORT_HELPURL = "LISTS_SORT_HELPURL"
  , LISTS_SORT_TITLE = "LISTS_SORT_TITLE"
  , LISTS_SORT_TOOLTIP = "LISTS_SORT_TOOLTIP"
  , LISTS_SORT_ORDER_ASCENDING = "LISTS_SORT_ORDER_ASCENDING"
  , LISTS_SORT_ORDER_DESCENDING = "LISTS_SORT_ORDER_DESCENDING"
  , LISTS_SORT_TYPE_NUMERIC = "LISTS_SORT_TYPE_NUMERIC"
  , LISTS_SORT_TYPE_TEXT = "LISTS_SORT_TYPE_TEXT"
  , LISTS_SORT_TYPE_IGNORECASE = "LISTS_SORT_TYPE_IGNORECASE"
  , LISTS_SPLIT_HELPURL = "LISTS_SPLIT_HELPURL"
  , LISTS_SPLIT_LIST_FROM_TEXT = "LISTS_SPLIT_LIST_FROM_TEXT"
  , LISTS_SPLIT_TEXT_FROM_LIST = "LISTS_SPLIT_TEXT_FROM_LIST"
  , LISTS_SPLIT_WITH_DELIMITER = "LISTS_SPLIT_WITH_DELIMITER"
  , LISTS_SPLIT_TOOLTIP_SPLIT = "LISTS_SPLIT_TOOLTIP_SPLIT"
  , LISTS_SPLIT_TOOLTIP_JOIN = "LISTS_SPLIT_TOOLTIP_JOIN"
  , LISTS_REVERSE_HELPURL = "LISTS_REVERSE_HELPURL"
  , LISTS_REVERSE_MESSAGE0 = "LISTS_REVERSE_MESSAGE0"
  , LISTS_REVERSE_TOOLTIP = "LISTS_REVERSE_TOOLTIP"
  , ORDINAL_NUMBER_SUFFIX = "ORDINAL_NUMBER_SUFFIX"
  , VARIABLES_GET_HELPURL = "VARIABLES_GET_HELPURL"
  , VARIABLES_GET_TOOLTIP = "VARIABLES_GET_TOOLTIP"
  , VARIABLES_GET_CREATE_SET = "VARIABLES_GET_CREATE_SET"
  , VARIABLES_SET_HELPURL = "VARIABLES_SET_HELPURL"
  , VARIABLES_SET = "VARIABLES_SET"
  , VARIABLES_SET_TOOLTIP = "VARIABLES_SET_TOOLTIP"
  , VARIABLES_SET_CREATE_GET = "VARIABLES_SET_CREATE_GET"
  , PROCEDURES_DEFNORETURN_HELPURL = "PROCEDURES_DEFNORETURN_HELPURL"
  , PROCEDURES_DEFNORETURN_TITLE = "PROCEDURES_DEFNORETURN_TITLE"
  , PROCEDURES_DEFNORETURN_PROCEDURE = "PROCEDURES_DEFNORETURN_PROCEDURE"
  , PROCEDURES_BEFORE_PARAMS = "PROCEDURES_BEFORE_PARAMS"
  , PROCEDURES_CALL_BEFORE_PARAMS = "PROCEDURES_CALL_BEFORE_PARAMS"
  , PROCEDURES_DEFNORETURN_DO = "PROCEDURES_DEFNORETURN_DO"
  , PROCEDURES_DEFNORETURN_TOOLTIP = "PROCEDURES_DEFNORETURN_TOOLTIP"
  , PROCEDURES_DEFNORETURN_COMMENT = "PROCEDURES_DEFNORETURN_COMMENT"
  , PROCEDURES_DEFRETURN_HELPURL = "PROCEDURES_DEFRETURN_HELPURL"
  , PROCEDURES_DEFRETURN_RETURN = "PROCEDURES_DEFRETURN_RETURN"
  , PROCEDURES_DEFRETURN_TOOLTIP = "PROCEDURES_DEFRETURN_TOOLTIP"
  , PROCEDURES_ALLOW_STATEMENTS = "PROCEDURES_ALLOW_STATEMENTS"
  , PROCEDURES_DEF_DUPLICATE_WARNING = "PROCEDURES_DEF_DUPLICATE_WARNING"
  , PROCEDURES_CALLNORETURN_HELPURL = "PROCEDURES_CALLNORETURN_HELPURL"
  , PROCEDURES_CALLNORETURN_TOOLTIP = "PROCEDURES_CALLNORETURN_TOOLTIP"
  , PROCEDURES_CALLRETURN_HELPURL = "PROCEDURES_CALLRETURN_HELPURL"
  , PROCEDURES_CALLRETURN_TOOLTIP = "PROCEDURES_CALLRETURN_TOOLTIP"
  , PROCEDURES_MUTATORCONTAINER_TITLE = "PROCEDURES_MUTATORCONTAINER_TITLE"
  , PROCEDURES_MUTATORCONTAINER_TOOLTIP = "PROCEDURES_MUTATORCONTAINER_TOOLTIP"
  , PROCEDURES_MUTATORARG_TITLE = "PROCEDURES_MUTATORARG_TITLE"
  , PROCEDURES_MUTATORARG_TOOLTIP = "PROCEDURES_MUTATORARG_TOOLTIP"
  , PROCEDURES_HIGHLIGHT_DEF = "PROCEDURES_HIGHLIGHT_DEF"
  , PROCEDURES_CREATE_DO = "PROCEDURES_CREATE_DO"
  , PROCEDURES_IFRETURN_TOOLTIP = "PROCEDURES_IFRETURN_TOOLTIP"
  , PROCEDURES_IFRETURN_HELPURL = "PROCEDURES_IFRETURN_HELPURL"
  , PROCEDURES_IFRETURN_WARNING = "PROCEDURES_IFRETURN_WARNING"
  , WORKSPACE_COMMENT_DEFAULT_TEXT = "WORKSPACE_COMMENT_DEFAULT_TEXT"
  , WORKSPACE_ARIA_LABEL = "WORKSPACE_ARIA_LABEL"
  , COLLAPSED_WARNINGS_WARNING = "COLLAPSED_WARNINGS_WARNING"
  , BlocklyLocalePlaceholders = {
    VARIABLES_DEFAULT_NAME,
    UNNAMED_KEY,
    TODAY,
    DUPLICATE_BLOCK,
    ADD_COMMENT,
    REMOVE_COMMENT,
    DUPLICATE_COMMENT,
    EXTERNAL_INPUTS,
    INLINE_INPUTS,
    DELETE_BLOCK,
    DELETE_X_BLOCKS,
    DELETE_ALL_BLOCKS,
    CLEAN_UP,
    COLLAPSE_BLOCK,
    COLLAPSE_ALL,
    EXPAND_BLOCK,
    EXPAND_ALL,
    DISABLE_BLOCK,
    ENABLE_BLOCK,
    HELP,
    UNDO,
    REDO,
    CHANGE_VALUE_TITLE,
    RENAME_VARIABLE,
    RENAME_VARIABLE_TITLE,
    NEW_VARIABLE,
    NEW_STRING_VARIABLE,
    NEW_NUMBER_VARIABLE,
    NEW_COLOUR_VARIABLE,
    NEW_VARIABLE_TYPE_TITLE,
    NEW_VARIABLE_TITLE,
    VARIABLE_ALREADY_EXISTS,
    VARIABLE_ALREADY_EXISTS_FOR_ANOTHER_TYPE,
    DELETE_VARIABLE_CONFIRMATION,
    CANNOT_DELETE_VARIABLE_PROCEDURE,
    DELETE_VARIABLE,
    COLOUR_PICKER_HELPURL,
    COLOUR_PICKER_TOOLTIP,
    COLOUR_RANDOM_HELPURL,
    COLOUR_RANDOM_TITLE,
    COLOUR_RANDOM_TOOLTIP,
    COLOUR_RGB_HELPURL,
    COLOUR_RGB_TITLE,
    COLOUR_RGB_RED,
    COLOUR_RGB_GREEN,
    COLOUR_RGB_BLUE,
    COLOUR_RGB_TOOLTIP,
    COLOUR_BLEND_HELPURL,
    COLOUR_BLEND_TITLE,
    COLOUR_BLEND_COLOUR1,
    COLOUR_BLEND_COLOUR2,
    COLOUR_BLEND_RATIO,
    COLOUR_BLEND_TOOLTIP,
    CONTROLS_REPEAT_HELPURL,
    CONTROLS_REPEAT_TITLE,
    CONTROLS_REPEAT_INPUT_DO,
    CONTROLS_REPEAT_TOOLTIP,
    CONTROLS_WHILEUNTIL_HELPURL,
    CONTROLS_WHILEUNTIL_OPERATOR_WHILE,
    CONTROLS_WHILEUNTIL_OPERATOR_UNTIL,
    CONTROLS_WHILEUNTIL_TOOLTIP_WHILE,
    CONTROLS_WHILEUNTIL_TOOLTIP_UNTIL,
    CONTROLS_FOR_HELPURL,
    CONTROLS_FOR_TOOLTIP,
    CONTROLS_FOR_TITLE,
    CONTROLS_FOREACH_HELPURL,
    CONTROLS_FOREACH_TITLE,
    CONTROLS_FOREACH_TOOLTIP,
    CONTROLS_FLOW_STATEMENTS_HELPURL,
    CONTROLS_FLOW_STATEMENTS_OPERATOR_BREAK,
    CONTROLS_FLOW_STATEMENTS_OPERATOR_CONTINUE,
    CONTROLS_FLOW_STATEMENTS_TOOLTIP_BREAK,
    CONTROLS_FLOW_STATEMENTS_TOOLTIP_CONTINUE,
    CONTROLS_FLOW_STATEMENTS_WARNING,
    CONTROLS_IF_HELPURL,
    CONTROLS_IF_TOOLTIP_1,
    CONTROLS_IF_TOOLTIP_2,
    CONTROLS_IF_TOOLTIP_3,
    CONTROLS_IF_TOOLTIP_4,
    CONTROLS_IF_MSG_IF,
    CONTROLS_IF_MSG_ELSEIF,
    CONTROLS_IF_MSG_ELSE,
    CONTROLS_IF_IF_TOOLTIP,
    CONTROLS_IF_ELSEIF_TOOLTIP,
    CONTROLS_IF_ELSE_TOOLTIP,
    IOS_OK,
    IOS_CANCEL,
    IOS_ERROR,
    IOS_PROCEDURES_INPUTS,
    IOS_PROCEDURES_ADD_INPUT,
    IOS_PROCEDURES_ALLOW_STATEMENTS,
    IOS_PROCEDURES_DUPLICATE_INPUTS_ERROR,
    IOS_VARIABLES_ADD_VARIABLE,
    IOS_VARIABLES_ADD_BUTTON,
    IOS_VARIABLES_RENAME_BUTTON,
    IOS_VARIABLES_DELETE_BUTTON,
    IOS_VARIABLES_VARIABLE_NAME,
    IOS_VARIABLES_EMPTY_NAME_ERROR,
    LOGIC_COMPARE_HELPURL,
    LOGIC_COMPARE_TOOLTIP_EQ,
    LOGIC_COMPARE_TOOLTIP_NEQ,
    LOGIC_COMPARE_TOOLTIP_LT,
    LOGIC_COMPARE_TOOLTIP_LTE,
    LOGIC_COMPARE_TOOLTIP_GT,
    LOGIC_COMPARE_TOOLTIP_GTE,
    LOGIC_OPERATION_HELPURL,
    LOGIC_OPERATION_TOOLTIP_AND,
    LOGIC_OPERATION_AND,
    LOGIC_OPERATION_TOOLTIP_OR,
    LOGIC_OPERATION_OR,
    LOGIC_NEGATE_HELPURL,
    LOGIC_NEGATE_TITLE,
    LOGIC_NEGATE_TOOLTIP,
    LOGIC_BOOLEAN_HELPURL,
    LOGIC_BOOLEAN_TRUE,
    LOGIC_BOOLEAN_FALSE,
    LOGIC_BOOLEAN_TOOLTIP,
    LOGIC_NULL_HELPURL,
    LOGIC_NULL,
    LOGIC_NULL_TOOLTIP,
    LOGIC_TERNARY_HELPURL,
    LOGIC_TERNARY_CONDITION,
    LOGIC_TERNARY_IF_TRUE,
    LOGIC_TERNARY_IF_FALSE,
    LOGIC_TERNARY_TOOLTIP,
    MATH_NUMBER_HELPURL,
    MATH_NUMBER_TOOLTIP,
    MATH_ADDITION_SYMBOL,
    MATH_SUBTRACTION_SYMBOL,
    MATH_DIVISION_SYMBOL,
    MATH_MULTIPLICATION_SYMBOL,
    MATH_POWER_SYMBOL,
    MATH_TRIG_SIN,
    MATH_TRIG_COS,
    MATH_TRIG_TAN,
    MATH_TRIG_ASIN,
    MATH_TRIG_ACOS,
    MATH_TRIG_ATAN,
    MATH_ARITHMETIC_HELPURL,
    MATH_ARITHMETIC_TOOLTIP_ADD,
    MATH_ARITHMETIC_TOOLTIP_MINUS,
    MATH_ARITHMETIC_TOOLTIP_MULTIPLY,
    MATH_ARITHMETIC_TOOLTIP_DIVIDE,
    MATH_ARITHMETIC_TOOLTIP_POWER,
    MATH_SINGLE_HELPURL,
    MATH_SINGLE_OP_ROOT,
    MATH_SINGLE_TOOLTIP_ROOT,
    MATH_SINGLE_OP_ABSOLUTE,
    MATH_SINGLE_TOOLTIP_ABS,
    MATH_SINGLE_TOOLTIP_NEG,
    MATH_SINGLE_TOOLTIP_LN,
    MATH_SINGLE_TOOLTIP_LOG10,
    MATH_SINGLE_TOOLTIP_EXP,
    MATH_SINGLE_TOOLTIP_POW10,
    MATH_TRIG_HELPURL,
    MATH_TRIG_TOOLTIP_SIN,
    MATH_TRIG_TOOLTIP_COS,
    MATH_TRIG_TOOLTIP_TAN,
    MATH_TRIG_TOOLTIP_ASIN,
    MATH_TRIG_TOOLTIP_ACOS,
    MATH_TRIG_TOOLTIP_ATAN,
    MATH_CONSTANT_HELPURL,
    MATH_CONSTANT_TOOLTIP,
    MATH_IS_EVEN,
    MATH_IS_ODD,
    MATH_IS_PRIME,
    MATH_IS_WHOLE,
    MATH_IS_POSITIVE,
    MATH_IS_NEGATIVE,
    MATH_IS_DIVISIBLE_BY,
    MATH_IS_TOOLTIP,
    MATH_CHANGE_HELPURL,
    MATH_CHANGE_TITLE,
    MATH_CHANGE_TOOLTIP,
    MATH_ROUND_HELPURL,
    MATH_ROUND_TOOLTIP,
    MATH_ROUND_OPERATOR_ROUND,
    MATH_ROUND_OPERATOR_ROUNDUP,
    MATH_ROUND_OPERATOR_ROUNDDOWN,
    MATH_ONLIST_HELPURL,
    MATH_ONLIST_OPERATOR_SUM,
    MATH_ONLIST_TOOLTIP_SUM,
    MATH_ONLIST_OPERATOR_MIN,
    MATH_ONLIST_TOOLTIP_MIN,
    MATH_ONLIST_OPERATOR_MAX,
    MATH_ONLIST_TOOLTIP_MAX,
    MATH_ONLIST_OPERATOR_AVERAGE,
    MATH_ONLIST_TOOLTIP_AVERAGE,
    MATH_ONLIST_OPERATOR_MEDIAN,
    MATH_ONLIST_TOOLTIP_MEDIAN,
    MATH_ONLIST_OPERATOR_MODE,
    MATH_ONLIST_TOOLTIP_MODE,
    MATH_ONLIST_OPERATOR_STD_DEV,
    MATH_ONLIST_TOOLTIP_STD_DEV,
    MATH_ONLIST_OPERATOR_RANDOM,
    MATH_ONLIST_TOOLTIP_RANDOM,
    MATH_MODULO_HELPURL,
    MATH_MODULO_TITLE,
    MATH_MODULO_TOOLTIP,
    MATH_CONSTRAIN_HELPURL,
    MATH_CONSTRAIN_TITLE,
    MATH_CONSTRAIN_TOOLTIP,
    MATH_RANDOM_INT_HELPURL,
    MATH_RANDOM_INT_TITLE,
    MATH_RANDOM_INT_TOOLTIP,
    MATH_RANDOM_FLOAT_HELPURL,
    MATH_RANDOM_FLOAT_TITLE_RANDOM,
    MATH_RANDOM_FLOAT_TOOLTIP,
    MATH_ATAN2_HELPURL,
    MATH_ATAN2_TITLE,
    MATH_ATAN2_TOOLTIP,
    TEXT_TEXT_HELPURL,
    TEXT_TEXT_TOOLTIP,
    TEXT_JOIN_HELPURL,
    TEXT_JOIN_TITLE_CREATEWITH,
    TEXT_JOIN_TOOLTIP,
    TEXT_CREATE_JOIN_TITLE_JOIN,
    TEXT_CREATE_JOIN_TOOLTIP,
    TEXT_CREATE_JOIN_ITEM_TOOLTIP,
    TEXT_APPEND_HELPURL,
    TEXT_APPEND_TITLE,
    TEXT_APPEND_TOOLTIP,
    TEXT_LENGTH_HELPURL,
    TEXT_LENGTH_TITLE,
    TEXT_LENGTH_TOOLTIP,
    TEXT_ISEMPTY_HELPURL,
    TEXT_ISEMPTY_TITLE,
    TEXT_ISEMPTY_TOOLTIP,
    TEXT_INDEXOF_HELPURL,
    TEXT_INDEXOF_TOOLTIP,
    TEXT_INDEXOF_TITLE,
    TEXT_INDEXOF_OPERATOR_FIRST,
    TEXT_INDEXOF_OPERATOR_LAST,
    TEXT_CHARAT_HELPURL,
    TEXT_CHARAT_TITLE,
    TEXT_CHARAT_FROM_START,
    TEXT_CHARAT_FROM_END,
    TEXT_CHARAT_FIRST,
    TEXT_CHARAT_LAST,
    TEXT_CHARAT_RANDOM,
    TEXT_CHARAT_TAIL,
    TEXT_CHARAT_TOOLTIP,
    TEXT_GET_SUBSTRING_TOOLTIP,
    TEXT_GET_SUBSTRING_HELPURL,
    TEXT_GET_SUBSTRING_INPUT_IN_TEXT,
    TEXT_GET_SUBSTRING_START_FROM_START,
    TEXT_GET_SUBSTRING_START_FROM_END,
    TEXT_GET_SUBSTRING_START_FIRST,
    TEXT_GET_SUBSTRING_END_FROM_START,
    TEXT_GET_SUBSTRING_END_FROM_END,
    TEXT_GET_SUBSTRING_END_LAST,
    TEXT_GET_SUBSTRING_TAIL,
    TEXT_CHANGECASE_HELPURL,
    TEXT_CHANGECASE_TOOLTIP,
    TEXT_CHANGECASE_OPERATOR_UPPERCASE,
    TEXT_CHANGECASE_OPERATOR_LOWERCASE,
    TEXT_CHANGECASE_OPERATOR_TITLECASE,
    TEXT_TRIM_HELPURL,
    TEXT_TRIM_TOOLTIP,
    TEXT_TRIM_OPERATOR_BOTH,
    TEXT_TRIM_OPERATOR_LEFT,
    TEXT_TRIM_OPERATOR_RIGHT,
    TEXT_PRINT_HELPURL,
    TEXT_PRINT_TITLE,
    TEXT_PRINT_TOOLTIP,
    TEXT_PROMPT_HELPURL,
    TEXT_PROMPT_TYPE_TEXT,
    TEXT_PROMPT_TYPE_NUMBER,
    TEXT_PROMPT_TOOLTIP_NUMBER,
    TEXT_PROMPT_TOOLTIP_TEXT,
    TEXT_COUNT_MESSAGE0,
    TEXT_COUNT_HELPURL,
    TEXT_COUNT_TOOLTIP,
    TEXT_REPLACE_MESSAGE0,
    TEXT_REPLACE_HELPURL,
    TEXT_REPLACE_TOOLTIP,
    TEXT_REVERSE_MESSAGE0,
    TEXT_REVERSE_HELPURL,
    TEXT_REVERSE_TOOLTIP,
    LISTS_CREATE_EMPTY_HELPURL,
    LISTS_CREATE_EMPTY_TITLE,
    LISTS_CREATE_EMPTY_TOOLTIP,
    LISTS_CREATE_WITH_HELPURL,
    LISTS_CREATE_WITH_TOOLTIP,
    LISTS_CREATE_WITH_INPUT_WITH,
    LISTS_CREATE_WITH_CONTAINER_TITLE_ADD,
    LISTS_CREATE_WITH_CONTAINER_TOOLTIP,
    LISTS_CREATE_WITH_ITEM_TOOLTIP,
    LISTS_REPEAT_HELPURL,
    LISTS_REPEAT_TOOLTIP,
    LISTS_REPEAT_TITLE,
    LISTS_LENGTH_HELPURL,
    LISTS_LENGTH_TITLE,
    LISTS_LENGTH_TOOLTIP,
    LISTS_ISEMPTY_HELPURL,
    LISTS_ISEMPTY_TITLE,
    LISTS_ISEMPTY_TOOLTIP,
    LISTS_INLIST,
    LISTS_INDEX_OF_HELPURL,
    LISTS_INDEX_OF_FIRST,
    LISTS_INDEX_OF_LAST,
    LISTS_INDEX_OF_TOOLTIP,
    LISTS_GET_INDEX_GET,
    LISTS_GET_INDEX_GET_REMOVE,
    LISTS_GET_INDEX_REMOVE,
    LISTS_GET_INDEX_FROM_START,
    LISTS_GET_INDEX_FROM_END,
    LISTS_GET_INDEX_FIRST,
    LISTS_GET_INDEX_LAST,
    LISTS_GET_INDEX_RANDOM,
    LISTS_GET_INDEX_TAIL,
    LISTS_INDEX_FROM_START_TOOLTIP,
    LISTS_INDEX_FROM_END_TOOLTIP,
    LISTS_GET_INDEX_TOOLTIP_GET_FROM,
    LISTS_GET_INDEX_TOOLTIP_GET_FIRST,
    LISTS_GET_INDEX_TOOLTIP_GET_LAST,
    LISTS_GET_INDEX_TOOLTIP_GET_RANDOM,
    LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FROM,
    LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_FIRST,
    LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_LAST,
    LISTS_GET_INDEX_TOOLTIP_GET_REMOVE_RANDOM,
    LISTS_GET_INDEX_TOOLTIP_REMOVE_FROM,
    LISTS_GET_INDEX_TOOLTIP_REMOVE_FIRST,
    LISTS_GET_INDEX_TOOLTIP_REMOVE_LAST,
    LISTS_GET_INDEX_TOOLTIP_REMOVE_RANDOM,
    LISTS_SET_INDEX_HELPURL,
    LISTS_SET_INDEX_SET,
    LISTS_SET_INDEX_INSERT,
    LISTS_SET_INDEX_INPUT_TO,
    LISTS_SET_INDEX_TOOLTIP_SET_FROM,
    LISTS_SET_INDEX_TOOLTIP_SET_FIRST,
    LISTS_SET_INDEX_TOOLTIP_SET_LAST,
    LISTS_SET_INDEX_TOOLTIP_SET_RANDOM,
    LISTS_SET_INDEX_TOOLTIP_INSERT_FROM,
    LISTS_SET_INDEX_TOOLTIP_INSERT_FIRST,
    LISTS_SET_INDEX_TOOLTIP_INSERT_LAST,
    LISTS_SET_INDEX_TOOLTIP_INSERT_RANDOM,
    LISTS_GET_SUBLIST_HELPURL,
    LISTS_GET_SUBLIST_START_FROM_START,
    LISTS_GET_SUBLIST_START_FROM_END,
    LISTS_GET_SUBLIST_START_FIRST,
    LISTS_GET_SUBLIST_END_FROM_START,
    LISTS_GET_SUBLIST_END_FROM_END,
    LISTS_GET_SUBLIST_END_LAST,
    LISTS_GET_SUBLIST_TAIL,
    LISTS_GET_SUBLIST_TOOLTIP,
    LISTS_SORT_HELPURL,
    LISTS_SORT_TITLE,
    LISTS_SORT_TOOLTIP,
    LISTS_SORT_ORDER_ASCENDING,
    LISTS_SORT_ORDER_DESCENDING,
    LISTS_SORT_TYPE_NUMERIC,
    LISTS_SORT_TYPE_TEXT,
    LISTS_SORT_TYPE_IGNORECASE,
    LISTS_SPLIT_HELPURL,
    LISTS_SPLIT_LIST_FROM_TEXT,
    LISTS_SPLIT_TEXT_FROM_LIST,
    LISTS_SPLIT_WITH_DELIMITER,
    LISTS_SPLIT_TOOLTIP_SPLIT,
    LISTS_SPLIT_TOOLTIP_JOIN,
    LISTS_REVERSE_HELPURL,
    LISTS_REVERSE_MESSAGE0,
    LISTS_REVERSE_TOOLTIP,
    ORDINAL_NUMBER_SUFFIX,
    VARIABLES_GET_HELPURL,
    VARIABLES_GET_TOOLTIP,
    VARIABLES_GET_CREATE_SET,
    VARIABLES_SET_HELPURL,
    VARIABLES_SET,
    VARIABLES_SET_TOOLTIP,
    VARIABLES_SET_CREATE_GET,
    PROCEDURES_DEFNORETURN_HELPURL,
    PROCEDURES_DEFNORETURN_TITLE,
    PROCEDURES_DEFNORETURN_PROCEDURE,
    PROCEDURES_BEFORE_PARAMS,
    PROCEDURES_CALL_BEFORE_PARAMS,
    PROCEDURES_DEFNORETURN_DO,
    PROCEDURES_DEFNORETURN_TOOLTIP,
    PROCEDURES_DEFNORETURN_COMMENT,
    PROCEDURES_DEFRETURN_HELPURL,
    PROCEDURES_DEFRETURN_RETURN,
    PROCEDURES_DEFRETURN_TOOLTIP,
    PROCEDURES_ALLOW_STATEMENTS,
    PROCEDURES_DEF_DUPLICATE_WARNING,
    PROCEDURES_CALLNORETURN_HELPURL,
    PROCEDURES_CALLNORETURN_TOOLTIP,
    PROCEDURES_CALLRETURN_HELPURL,
    PROCEDURES_CALLRETURN_TOOLTIP,
    PROCEDURES_MUTATORCONTAINER_TITLE,
    PROCEDURES_MUTATORCONTAINER_TOOLTIP,
    PROCEDURES_MUTATORARG_TITLE,
    PROCEDURES_MUTATORARG_TOOLTIP,
    PROCEDURES_HIGHLIGHT_DEF,
    PROCEDURES_CREATE_DO,
    PROCEDURES_IFRETURN_TOOLTIP,
    PROCEDURES_IFRETURN_HELPURL,
    PROCEDURES_IFRETURN_WARNING,
    WORKSPACE_COMMENT_DEFAULT_TEXT,
    WORKSPACE_ARIA_LABEL,
    COLLAPSED_WARNINGS_WARNING
}
  , TranslationsContext = reactExports.createContext(new Map)
  , TranslationsProvider = ({sids: V=new Set([]), customQueryKey: X, session: J, children: ne}) => {
    const [ue,ce] = useTranslationsQuery(instance.language, Array.from(V), X, J)
      , {t: me} = useTranslation()
      , ge = REROUTED_LOCALES.has(instance.language) ? REROUTED_LOCALES.get(instance.language) ?? DEFAULT_LOCALE : instance.language
      , Te = (ue == null ? void 0 : ue.reduce( (_e, {sid: Se, localizedText: Ie}) => (_e.set(Se, Ie),
    _e), new Map)) ?? new Map;
    return Te.forEach( (_e, Se) => {
        instance.addResource(ge, I18N_NAMESPACE_KEY, Se, _e)
    }
    ),
    blocklyExports.setLocale({
        ...BlocklyLocalePlaceholders,
        ...instance.getResourceBundle(ge, I18N_NAMESPACE_KEY)
    }),
    jsxRuntimeExports.jsx(TranslationsContext.Provider, {
        value: Te,
        children: ce ? jsxRuntimeExports.jsx(LoadingSpinner, {
            statusText: me("general.loading-translations")
        }) : ne
    })
}
;
var cacheEventTypes = ["added", "removed", "updated"];
function isCacheEventType(V) {
    return cacheEventTypes.includes(V)
}
async function persistQueryClientRestore({queryClient: V, persister: X, maxAge: J=1e3 * 60 * 60 * 24, buster: ne="", hydrateOptions: ue}) {
    try {
        const ce = await X.restoreClient();
        if (ce)
            if (ce.timestamp) {
                const me = Date.now() - ce.timestamp > J
                  , ge = ce.buster !== ne;
                me || ge ? X.removeClient() : hydrate(V, ce.clientState, ue)
            } else
                X.removeClient()
    } catch {
        X.removeClient()
    }
}
async function persistQueryClientSave({queryClient: V, persister: X, buster: J="", dehydrateOptions: ne}) {
    const ue = {
        buster: J,
        timestamp: Date.now(),
        clientState: dehydrate(V, ne)
    };
    await X.persistClient(ue)
}
function persistQueryClientSubscribe(V) {
    const X = V.queryClient.getQueryCache().subscribe(ne => {
        isCacheEventType(ne.type) && persistQueryClientSave(V)
    }
    )
      , J = V.queryClient.getMutationCache().subscribe(ne => {
        isCacheEventType(ne.type) && persistQueryClientSave(V)
    }
    );
    return () => {
        X(),
        J()
    }
}
var PersistQueryClientProvider = ({client: V, children: X, persistOptions: J, onSuccess: ne, ...ue}) => {
    const [ce,me] = reactExports.useState(!0)
      , ge = reactExports.useRef({
        persistOptions: J,
        onSuccess: ne
    })
      , Te = reactExports.useRef(!1);
    return reactExports.useEffect( () => {
        ge.current = {
            persistOptions: J,
            onSuccess: ne
        }
    }
    ),
    reactExports.useEffect( () => {
        const _e = {
            ...ge.current.persistOptions,
            queryClient: V
        };
        return Te.current || (Te.current = !0,
        persistQueryClientRestore(_e).then(async () => {
            var Se, Ie;
            try {
                await ((Ie = (Se = ge.current).onSuccess) == null ? void 0 : Ie.call(Se))
            } finally {
                me(!1)
            }
        }
        )),
        ce ? void 0 : persistQueryClientSubscribe(_e)
    }
    , [V, ce]),
    jsxRuntimeExports.jsx(QueryClientProvider, {
        client: V,
        ...ue,
        children: jsxRuntimeExports.jsx(IsRestoringProvider, {
            value: ce,
            children: X
        })
    })
}
  , client = {
    exports: {}
}
  , reactDomClient_production = {}
  , scheduler = {
    exports: {}
}
  , scheduler_production = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(V) {
    function X(We, nt) {
        var ct = We.length;
        We.push(nt);
        e: for (; 0 < ct; ) {
            var Et = ct - 1 >>> 1
              , Ke = We[Et];
            if (0 < ue(Ke, nt))
                We[Et] = nt,
                We[ct] = Ke,
                ct = Et;
            else
                break e
        }
    }
    function J(We) {
        return We.length === 0 ? null : We[0]
    }
    function ne(We) {
        if (We.length === 0)
            return null;
        var nt = We[0]
          , ct = We.pop();
        if (ct !== nt) {
            We[0] = ct;
            e: for (var Et = 0, Ke = We.length, mt = Ke >>> 1; Et < mt; ) {
                var lt = 2 * (Et + 1) - 1
                  , Qe = We[lt]
                  , gt = lt + 1
                  , Nt = We[gt];
                if (0 > ue(Qe, ct))
                    gt < Ke && 0 > ue(Nt, Qe) ? (We[Et] = Nt,
                    We[gt] = ct,
                    Et = gt) : (We[Et] = Qe,
                    We[lt] = ct,
                    Et = lt);
                else if (gt < Ke && 0 > ue(Nt, ct))
                    We[Et] = Nt,
                    We[gt] = ct,
                    Et = gt;
                else
                    break e
            }
        }
        return nt
    }
    function ue(We, nt) {
        var ct = We.sortIndex - nt.sortIndex;
        return ct !== 0 ? ct : We.id - nt.id
    }
    if (V.unstable_now = void 0,
    typeof performance == "object" && typeof performance.now == "function") {
        var ce = performance;
        V.unstable_now = function() {
            return ce.now()
        }
    } else {
        var me = Date
          , ge = me.now();
        V.unstable_now = function() {
            return me.now() - ge
        }
    }
    var Te = []
      , _e = []
      , Se = 1
      , Ie = null
      , ye = 3
      , $e = !1
      , Ne = !1
      , ve = !1
      , ke = !1
      , xe = typeof setTimeout == "function" ? setTimeout : null
      , we = typeof clearTimeout == "function" ? clearTimeout : null
      , Fe = typeof setImmediate < "u" ? setImmediate : null;
    function je(We) {
        for (var nt = J(_e); nt !== null; ) {
            if (nt.callback === null)
                ne(_e);
            else if (nt.startTime <= We)
                ne(_e),
                nt.sortIndex = nt.expirationTime,
                X(Te, nt);
            else
                break;
            nt = J(_e)
        }
    }
    function Xe(We) {
        if (ve = !1,
        je(We),
        !Ne)
            if (J(Te) !== null)
                Ne = !0,
                ze || (ze = !0,
                rt());
            else {
                var nt = J(_e);
                nt !== null && Ye(Xe, nt.startTime - We)
            }
    }
    var ze = !1
      , qe = -1
      , Ze = 5
      , et = -1;
    function it() {
        return ke ? !0 : !(V.unstable_now() - et < Ze)
    }
    function at() {
        if (ke = !1,
        ze) {
            var We = V.unstable_now();
            et = We;
            var nt = !0;
            try {
                e: {
                    Ne = !1,
                    ve && (ve = !1,
                    we(qe),
                    qe = -1),
                    $e = !0;
                    var ct = ye;
                    try {
                        t: {
                            for (je(We),
                            Ie = J(Te); Ie !== null && !(Ie.expirationTime > We && it()); ) {
                                var Et = Ie.callback;
                                if (typeof Et == "function") {
                                    Ie.callback = null,
                                    ye = Ie.priorityLevel;
                                    var Ke = Et(Ie.expirationTime <= We);
                                    if (We = V.unstable_now(),
                                    typeof Ke == "function") {
                                        Ie.callback = Ke,
                                        je(We),
                                        nt = !0;
                                        break t
                                    }
                                    Ie === J(Te) && ne(Te),
                                    je(We)
                                } else
                                    ne(Te);
                                Ie = J(Te)
                            }
                            if (Ie !== null)
                                nt = !0;
                            else {
                                var mt = J(_e);
                                mt !== null && Ye(Xe, mt.startTime - We),
                                nt = !1
                            }
                        }
                        break e
                    } finally {
                        Ie = null,
                        ye = ct,
                        $e = !1
                    }
                    nt = void 0
                }
            } finally {
                nt ? rt() : ze = !1
            }
        }
    }
    var rt;
    if (typeof Fe == "function")
        rt = function() {
            Fe(at)
        }
        ;
    else if (typeof MessageChannel < "u") {
        var ft = new MessageChannel
          , St = ft.port2;
        ft.port1.onmessage = at,
        rt = function() {
            St.postMessage(null)
        }
    } else
        rt = function() {
            xe(at, 0)
        }
        ;
    function Ye(We, nt) {
        qe = xe(function() {
            We(V.unstable_now())
        }, nt)
    }
    V.unstable_IdlePriority = 5,
    V.unstable_ImmediatePriority = 1,
    V.unstable_LowPriority = 4,
    V.unstable_NormalPriority = 3,
    V.unstable_Profiling = null,
    V.unstable_UserBlockingPriority = 2,
    V.unstable_cancelCallback = function(We) {
        We.callback = null
    }
    ,
    V.unstable_forceFrameRate = function(We) {
        0 > We || 125 < We ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : Ze = 0 < We ? Math.floor(1e3 / We) : 5
    }
    ,
    V.unstable_getCurrentPriorityLevel = function() {
        return ye
    }
    ,
    V.unstable_next = function(We) {
        switch (ye) {
        case 1:
        case 2:
        case 3:
            var nt = 3;
            break;
        default:
            nt = ye
        }
        var ct = ye;
        ye = nt;
        try {
            return We()
        } finally {
            ye = ct
        }
    }
    ,
    V.unstable_requestPaint = function() {
        ke = !0
    }
    ,
    V.unstable_runWithPriority = function(We, nt) {
        switch (We) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            We = 3
        }
        var ct = ye;
        ye = We;
        try {
            return nt()
        } finally {
            ye = ct
        }
    }
    ,
    V.unstable_scheduleCallback = function(We, nt, ct) {
        var Et = V.unstable_now();
        switch (typeof ct == "object" && ct !== null ? (ct = ct.delay,
        ct = typeof ct == "number" && 0 < ct ? Et + ct : Et) : ct = Et,
        We) {
        case 1:
            var Ke = -1;
            break;
        case 2:
            Ke = 250;
            break;
        case 5:
            Ke = 1073741823;
            break;
        case 4:
            Ke = 1e4;
            break;
        default:
            Ke = 5e3
        }
        return Ke = ct + Ke,
        We = {
            id: Se++,
            callback: nt,
            priorityLevel: We,
            startTime: ct,
            expirationTime: Ke,
            sortIndex: -1
        },
        ct > Et ? (We.sortIndex = ct,
        X(_e, We),
        J(Te) === null && We === J(_e) && (ve ? (we(qe),
        qe = -1) : ve = !0,
        Ye(Xe, ct - Et))) : (We.sortIndex = Ke,
        X(Te, We),
        Ne || $e || (Ne = !0,
        ze || (ze = !0,
        rt()))),
        We
    }
    ,
    V.unstable_shouldYield = it,
    V.unstable_wrapCallback = function(We) {
        var nt = ye;
        return function() {
            var ct = ye;
            ye = nt;
            try {
                return We.apply(this, arguments)
            } finally {
                ye = ct
            }
        }
    }
}
)(scheduler_production);
scheduler.exports = scheduler_production;
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Scheduler = schedulerExports
  , React = reactExports
  , ReactDOM = reactDomExports;
function formatProdErrorMessage(V) {
    var X = "https://react.dev/errors/" + V;
    if (1 < arguments.length) {
        X += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var J = 2; J < arguments.length; J++)
            X += "&args[]=" + encodeURIComponent(arguments[J])
    }
    return "Minified React error #" + V + "; visit " + X + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
function isValidContainer(V) {
    return !(!V || V.nodeType !== 1 && V.nodeType !== 9 && V.nodeType !== 11)
}
function getNearestMountedFiber(V) {
    var X = V
      , J = V;
    if (V.alternate)
        for (; X.return; )
            X = X.return;
    else {
        V = X;
        do
            X = V,
            X.flags & 4098 && (J = X.return),
            V = X.return;
        while (V)
    }
    return X.tag === 3 ? J : null
}
function getSuspenseInstanceFromFiber(V) {
    if (V.tag === 13) {
        var X = V.memoizedState;
        if (X === null && (V = V.alternate,
        V !== null && (X = V.memoizedState)),
        X !== null)
            return X.dehydrated
    }
    return null
}
function assertIsMounted(V) {
    if (getNearestMountedFiber(V) !== V)
        throw Error(formatProdErrorMessage(188))
}
function findCurrentFiberUsingSlowPath(V) {
    var X = V.alternate;
    if (!X) {
        if (X = getNearestMountedFiber(V),
        X === null)
            throw Error(formatProdErrorMessage(188));
        return X !== V ? null : V
    }
    for (var J = V, ne = X; ; ) {
        var ue = J.return;
        if (ue === null)
            break;
        var ce = ue.alternate;
        if (ce === null) {
            if (ne = ue.return,
            ne !== null) {
                J = ne;
                continue
            }
            break
        }
        if (ue.child === ce.child) {
            for (ce = ue.child; ce; ) {
                if (ce === J)
                    return assertIsMounted(ue),
                    V;
                if (ce === ne)
                    return assertIsMounted(ue),
                    X;
                ce = ce.sibling
            }
            throw Error(formatProdErrorMessage(188))
        }
        if (J.return !== ne.return)
            J = ue,
            ne = ce;
        else {
            for (var me = !1, ge = ue.child; ge; ) {
                if (ge === J) {
                    me = !0,
                    J = ue,
                    ne = ce;
                    break
                }
                if (ge === ne) {
                    me = !0,
                    ne = ue,
                    J = ce;
                    break
                }
                ge = ge.sibling
            }
            if (!me) {
                for (ge = ce.child; ge; ) {
                    if (ge === J) {
                        me = !0,
                        J = ce,
                        ne = ue;
                        break
                    }
                    if (ge === ne) {
                        me = !0,
                        ne = ce,
                        J = ue;
                        break
                    }
                    ge = ge.sibling
                }
                if (!me)
                    throw Error(formatProdErrorMessage(189))
            }
        }
        if (J.alternate !== ne)
            throw Error(formatProdErrorMessage(190))
    }
    if (J.tag !== 3)
        throw Error(formatProdErrorMessage(188));
    return J.stateNode.current === J ? V : X
}
function findCurrentHostFiberImpl(V) {
    var X = V.tag;
    if (X === 5 || X === 26 || X === 27 || X === 6)
        return V;
    for (V = V.child; V !== null; ) {
        if (X = findCurrentHostFiberImpl(V),
        X !== null)
            return X;
        V = V.sibling
    }
    return null
}
var assign = Object.assign
  , REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element")
  , REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element")
  , REACT_PORTAL_TYPE = Symbol.for("react.portal")
  , REACT_FRAGMENT_TYPE = Symbol.for("react.fragment")
  , REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode")
  , REACT_PROFILER_TYPE = Symbol.for("react.profiler")
  , REACT_PROVIDER_TYPE = Symbol.for("react.provider")
  , REACT_CONSUMER_TYPE = Symbol.for("react.consumer")
  , REACT_CONTEXT_TYPE = Symbol.for("react.context")
  , REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref")
  , REACT_SUSPENSE_TYPE = Symbol.for("react.suspense")
  , REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list")
  , REACT_MEMO_TYPE = Symbol.for("react.memo")
  , REACT_LAZY_TYPE = Symbol.for("react.lazy")
  , REACT_ACTIVITY_TYPE = Symbol.for("react.activity")
  , REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel")
  , MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
function getIteratorFn(V) {
    return V === null || typeof V != "object" ? null : (V = MAYBE_ITERATOR_SYMBOL && V[MAYBE_ITERATOR_SYMBOL] || V["@@iterator"],
    typeof V == "function" ? V : null)
}
var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
function getComponentNameFromType(V) {
    if (V == null)
        return null;
    if (typeof V == "function")
        return V.$$typeof === REACT_CLIENT_REFERENCE ? null : V.displayName || V.name || null;
    if (typeof V == "string")
        return V;
    switch (V) {
    case REACT_FRAGMENT_TYPE:
        return "Fragment";
    case REACT_PROFILER_TYPE:
        return "Profiler";
    case REACT_STRICT_MODE_TYPE:
        return "StrictMode";
    case REACT_SUSPENSE_TYPE:
        return "Suspense";
    case REACT_SUSPENSE_LIST_TYPE:
        return "SuspenseList";
    case REACT_ACTIVITY_TYPE:
        return "Activity"
    }
    if (typeof V == "object")
        switch (V.$$typeof) {
        case REACT_PORTAL_TYPE:
            return "Portal";
        case REACT_CONTEXT_TYPE:
            return (V.displayName || "Context") + ".Provider";
        case REACT_CONSUMER_TYPE:
            return (V._context.displayName || "Context") + ".Consumer";
        case REACT_FORWARD_REF_TYPE:
            var X = V.render;
            return V = V.displayName,
            V || (V = X.displayName || X.name || "",
            V = V !== "" ? "ForwardRef(" + V + ")" : "ForwardRef"),
            V;
        case REACT_MEMO_TYPE:
            return X = V.displayName || null,
            X !== null ? X : getComponentNameFromType(V.type) || "Memo";
        case REACT_LAZY_TYPE:
            X = V._payload,
            V = V._init;
            try {
                return getComponentNameFromType(V(X))
            } catch {}
        }
    return null
}
var isArrayImpl = Array.isArray
  , ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
  , ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
  , sharedNotPendingObject = {
    pending: !1,
    data: null,
    method: null,
    action: null
}
  , valueStack = []
  , index$2 = -1;
function createCursor(V) {
    return {
        current: V
    }
}
function pop(V) {
    0 > index$2 || (V.current = valueStack[index$2],
    valueStack[index$2] = null,
    index$2--)
}
function push$1(V, X) {
    index$2++,
    valueStack[index$2] = V.current,
    V.current = X
}
var contextStackCursor = createCursor(null)
  , contextFiberStackCursor = createCursor(null)
  , rootInstanceStackCursor = createCursor(null)
  , hostTransitionProviderCursor = createCursor(null);
function pushHostContainer(V, X) {
    switch (push$1(rootInstanceStackCursor, X),
    push$1(contextFiberStackCursor, V),
    push$1(contextStackCursor, null),
    X.nodeType) {
    case 9:
    case 11:
        V = (V = X.documentElement) && (V = V.namespaceURI) ? getOwnHostContext(V) : 0;
        break;
    default:
        if (V = X.tagName,
        X = X.namespaceURI)
            X = getOwnHostContext(X),
            V = getChildHostContextProd(X, V);
        else
            switch (V) {
            case "svg":
                V = 1;
                break;
            case "math":
                V = 2;
                break;
            default:
                V = 0
            }
    }
    pop(contextStackCursor),
    push$1(contextStackCursor, V)
}
function popHostContainer() {
    pop(contextStackCursor),
    pop(contextFiberStackCursor),
    pop(rootInstanceStackCursor)
}
function pushHostContext(V) {
    V.memoizedState !== null && push$1(hostTransitionProviderCursor, V);
    var X = contextStackCursor.current
      , J = getChildHostContextProd(X, V.type);
    X !== J && (push$1(contextFiberStackCursor, V),
    push$1(contextStackCursor, J))
}
function popHostContext(V) {
    contextFiberStackCursor.current === V && (pop(contextStackCursor),
    pop(contextFiberStackCursor)),
    hostTransitionProviderCursor.current === V && (pop(hostTransitionProviderCursor),
    HostTransitionContext._currentValue = sharedNotPendingObject)
}
var hasOwnProperty$2 = Object.prototype.hasOwnProperty
  , scheduleCallback$3 = Scheduler.unstable_scheduleCallback
  , cancelCallback$1 = Scheduler.unstable_cancelCallback
  , shouldYield = Scheduler.unstable_shouldYield
  , requestPaint = Scheduler.unstable_requestPaint
  , now = Scheduler.unstable_now
  , getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel
  , ImmediatePriority = Scheduler.unstable_ImmediatePriority
  , UserBlockingPriority = Scheduler.unstable_UserBlockingPriority
  , NormalPriority$1 = Scheduler.unstable_NormalPriority
  , LowPriority = Scheduler.unstable_LowPriority
  , IdlePriority = Scheduler.unstable_IdlePriority
  , log$1 = Scheduler.log
  , unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue
  , rendererID = null
  , injectedHook = null;
function setIsStrictModeForDevtools(V) {
    if (typeof log$1 == "function" && unstable_setDisableYieldValue(V),
    injectedHook && typeof injectedHook.setStrictMode == "function")
        try {
            injectedHook.setStrictMode(rendererID, V)
        } catch {}
}
var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback
  , log = Math.log
  , LN2 = Math.LN2;
function clz32Fallback(V) {
    return V >>>= 0,
    V === 0 ? 32 : 31 - (log(V) / LN2 | 0) | 0
}
var nextTransitionLane = 256
  , nextRetryLane = 4194304;
function getHighestPriorityLanes(V) {
    var X = V & 42;
    if (X !== 0)
        return X;
    switch (V & -V) {
    case 1:
        return 1;
    case 2:
        return 2;
    case 4:
        return 4;
    case 8:
        return 8;
    case 16:
        return 16;
    case 32:
        return 32;
    case 64:
        return 64;
    case 128:
        return 128;
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return V & 4194048;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
        return V & 62914560;
    case 67108864:
        return 67108864;
    case 134217728:
        return 134217728;
    case 268435456:
        return 268435456;
    case 536870912:
        return 536870912;
    case 1073741824:
        return 0;
    default:
        return V
    }
}
function getNextLanes(V, X, J) {
    var ne = V.pendingLanes;
    if (ne === 0)
        return 0;
    var ue = 0
      , ce = V.suspendedLanes
      , me = V.pingedLanes;
    V = V.warmLanes;
    var ge = ne & 134217727;
    return ge !== 0 ? (ne = ge & ~ce,
    ne !== 0 ? ue = getHighestPriorityLanes(ne) : (me &= ge,
    me !== 0 ? ue = getHighestPriorityLanes(me) : J || (J = ge & ~V,
    J !== 0 && (ue = getHighestPriorityLanes(J))))) : (ge = ne & ~ce,
    ge !== 0 ? ue = getHighestPriorityLanes(ge) : me !== 0 ? ue = getHighestPriorityLanes(me) : J || (J = ne & ~V,
    J !== 0 && (ue = getHighestPriorityLanes(J)))),
    ue === 0 ? 0 : X !== 0 && X !== ue && !(X & ce) && (ce = ue & -ue,
    J = X & -X,
    ce >= J || ce === 32 && (J & 4194048) !== 0) ? X : ue
}
function checkIfRootIsPrerendering(V, X) {
    return (V.pendingLanes & ~(V.suspendedLanes & ~V.pingedLanes) & X) === 0
}
function computeExpirationTime(V, X) {
    switch (V) {
    case 1:
    case 2:
    case 4:
    case 8:
    case 64:
        return X + 250;
    case 16:
    case 32:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return X + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
        return -1;
    case 67108864:
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
        return -1;
    default:
        return -1
    }
}
function claimNextTransitionLane() {
    var V = nextTransitionLane;
    return nextTransitionLane <<= 1,
    !(nextTransitionLane & 4194048) && (nextTransitionLane = 256),
    V
}
function claimNextRetryLane() {
    var V = nextRetryLane;
    return nextRetryLane <<= 1,
    !(nextRetryLane & 62914560) && (nextRetryLane = 4194304),
    V
}
function createLaneMap(V) {
    for (var X = [], J = 0; 31 > J; J++)
        X.push(V);
    return X
}
function markRootUpdated$1(V, X) {
    V.pendingLanes |= X,
    X !== 268435456 && (V.suspendedLanes = 0,
    V.pingedLanes = 0,
    V.warmLanes = 0)
}
function markRootFinished(V, X, J, ne, ue, ce) {
    var me = V.pendingLanes;
    V.pendingLanes = J,
    V.suspendedLanes = 0,
    V.pingedLanes = 0,
    V.warmLanes = 0,
    V.expiredLanes &= J,
    V.entangledLanes &= J,
    V.errorRecoveryDisabledLanes &= J,
    V.shellSuspendCounter = 0;
    var ge = V.entanglements
      , Te = V.expirationTimes
      , _e = V.hiddenUpdates;
    for (J = me & ~J; 0 < J; ) {
        var Se = 31 - clz32(J)
          , Ie = 1 << Se;
        ge[Se] = 0,
        Te[Se] = -1;
        var ye = _e[Se];
        if (ye !== null)
            for (_e[Se] = null,
            Se = 0; Se < ye.length; Se++) {
                var $e = ye[Se];
                $e !== null && ($e.lane &= -536870913)
            }
        J &= ~Ie
    }
    ne !== 0 && markSpawnedDeferredLane(V, ne, 0),
    ce !== 0 && ue === 0 && V.tag !== 0 && (V.suspendedLanes |= ce & ~(me & ~X))
}
function markSpawnedDeferredLane(V, X, J) {
    V.pendingLanes |= X,
    V.suspendedLanes &= ~X;
    var ne = 31 - clz32(X);
    V.entangledLanes |= X,
    V.entanglements[ne] = V.entanglements[ne] | 1073741824 | J & 4194090
}
function markRootEntangled(V, X) {
    var J = V.entangledLanes |= X;
    for (V = V.entanglements; J; ) {
        var ne = 31 - clz32(J)
          , ue = 1 << ne;
        ue & X | V[ne] & X && (V[ne] |= X),
        J &= ~ue
    }
}
function getBumpedLaneForHydrationByLane(V) {
    switch (V) {
    case 2:
        V = 1;
        break;
    case 8:
        V = 4;
        break;
    case 32:
        V = 16;
        break;
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
        V = 128;
        break;
    case 268435456:
        V = 134217728;
        break;
    default:
        V = 0
    }
    return V
}
function lanesToEventPriority(V) {
    return V &= -V,
    2 < V ? 8 < V ? V & 134217727 ? 32 : 268435456 : 8 : 2
}
function resolveUpdatePriority() {
    var V = ReactDOMSharedInternals.p;
    return V !== 0 ? V : (V = window.event,
    V === void 0 ? 32 : getEventPriority(V.type))
}
function runWithPriority(V, X) {
    var J = ReactDOMSharedInternals.p;
    try {
        return ReactDOMSharedInternals.p = V,
        X()
    } finally {
        ReactDOMSharedInternals.p = J
    }
}
var randomKey = Math.random().toString(36).slice(2)
  , internalInstanceKey = "__reactFiber$" + randomKey
  , internalPropsKey = "__reactProps$" + randomKey
  , internalContainerInstanceKey = "__reactContainer$" + randomKey
  , internalEventHandlersKey = "__reactEvents$" + randomKey
  , internalEventHandlerListenersKey = "__reactListeners$" + randomKey
  , internalEventHandlesSetKey = "__reactHandles$" + randomKey
  , internalRootNodeResourcesKey = "__reactResources$" + randomKey
  , internalHoistableMarker = "__reactMarker$" + randomKey;
function detachDeletedInstance(V) {
    delete V[internalInstanceKey],
    delete V[internalPropsKey],
    delete V[internalEventHandlersKey],
    delete V[internalEventHandlerListenersKey],
    delete V[internalEventHandlesSetKey]
}
function getClosestInstanceFromNode(V) {
    var X = V[internalInstanceKey];
    if (X)
        return X;
    for (var J = V.parentNode; J; ) {
        if (X = J[internalContainerInstanceKey] || J[internalInstanceKey]) {
            if (J = X.alternate,
            X.child !== null || J !== null && J.child !== null)
                for (V = getParentSuspenseInstance(V); V !== null; ) {
                    if (J = V[internalInstanceKey])
                        return J;
                    V = getParentSuspenseInstance(V)
                }
            return X
        }
        V = J,
        J = V.parentNode
    }
    return null
}
function getInstanceFromNode(V) {
    if (V = V[internalInstanceKey] || V[internalContainerInstanceKey]) {
        var X = V.tag;
        if (X === 5 || X === 6 || X === 13 || X === 26 || X === 27 || X === 3)
            return V
    }
    return null
}
function getNodeFromInstance(V) {
    var X = V.tag;
    if (X === 5 || X === 26 || X === 27 || X === 6)
        return V.stateNode;
    throw Error(formatProdErrorMessage(33))
}
function getResourcesFromRoot(V) {
    var X = V[internalRootNodeResourcesKey];
    return X || (X = V[internalRootNodeResourcesKey] = {
        hoistableStyles: new Map,
        hoistableScripts: new Map
    }),
    X
}
function markNodeAsHoistable(V) {
    V[internalHoistableMarker] = !0
}
var allNativeEvents = new Set
  , registrationNameDependencies = {};
function registerTwoPhaseEvent(V, X) {
    registerDirectEvent(V, X),
    registerDirectEvent(V + "Capture", X)
}
function registerDirectEvent(V, X) {
    for (registrationNameDependencies[V] = X,
    V = 0; V < X.length; V++)
        allNativeEvents.add(X[V])
}
var VALID_ATTRIBUTE_NAME_REGEX = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$")
  , illegalAttributeNameCache = {}
  , validatedAttributeNameCache = {};
function isAttributeNameSafe(V) {
    return hasOwnProperty$2.call(validatedAttributeNameCache, V) ? !0 : hasOwnProperty$2.call(illegalAttributeNameCache, V) ? !1 : VALID_ATTRIBUTE_NAME_REGEX.test(V) ? validatedAttributeNameCache[V] = !0 : (illegalAttributeNameCache[V] = !0,
    !1)
}
function setValueForAttribute(V, X, J) {
    if (isAttributeNameSafe(X))
        if (J === null)
            V.removeAttribute(X);
        else {
            switch (typeof J) {
            case "undefined":
            case "function":
            case "symbol":
                V.removeAttribute(X);
                return;
            case "boolean":
                var ne = X.toLowerCase().slice(0, 5);
                if (ne !== "data-" && ne !== "aria-") {
                    V.removeAttribute(X);
                    return
                }
            }
            V.setAttribute(X, "" + J)
        }
}
function setValueForKnownAttribute(V, X, J) {
    if (J === null)
        V.removeAttribute(X);
    else {
        switch (typeof J) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
            V.removeAttribute(X);
            return
        }
        V.setAttribute(X, "" + J)
    }
}
function setValueForNamespacedAttribute(V, X, J, ne) {
    if (ne === null)
        V.removeAttribute(J);
    else {
        switch (typeof ne) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
            V.removeAttribute(J);
            return
        }
        V.setAttributeNS(X, J, "" + ne)
    }
}
var prefix, suffix;
function describeBuiltInComponentFrame(V) {
    if (prefix === void 0)
        try {
            throw Error()
        } catch (J) {
            var X = J.stack.trim().match(/\n( *(at )?)/);
            prefix = X && X[1] || "",
            suffix = -1 < J.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < J.stack.indexOf("@") ? "@unknown:0:0" : ""
        }
    return `
` + prefix + V + suffix
}
var reentry = !1;
function describeNativeComponentFrame(V, X) {
    if (!V || reentry)
        return "";
    reentry = !0;
    var J = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        var ne = {
            DetermineComponentFrameRoot: function() {
                try {
                    if (X) {
                        var Ie = function() {
                            throw Error()
                        };
                        if (Object.defineProperty(Ie.prototype, "props", {
                            set: function() {
                                throw Error()
                            }
                        }),
                        typeof Reflect == "object" && Reflect.construct) {
                            try {
                                Reflect.construct(Ie, [])
                            } catch ($e) {
                                var ye = $e
                            }
                            Reflect.construct(V, [], Ie)
                        } else {
                            try {
                                Ie.call()
                            } catch ($e) {
                                ye = $e
                            }
                            V.call(Ie.prototype)
                        }
                    } else {
                        try {
                            throw Error()
                        } catch ($e) {
                            ye = $e
                        }
                        (Ie = V()) && typeof Ie.catch == "function" && Ie.catch(function() {})
                    }
                } catch ($e) {
                    if ($e && ye && typeof $e.stack == "string")
                        return [$e.stack, ye.stack]
                }
                return [null, null]
            }
        };
        ne.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var ue = Object.getOwnPropertyDescriptor(ne.DetermineComponentFrameRoot, "name");
        ue && ue.configurable && Object.defineProperty(ne.DetermineComponentFrameRoot, "name", {
            value: "DetermineComponentFrameRoot"
        });
        var ce = ne.DetermineComponentFrameRoot()
          , me = ce[0]
          , ge = ce[1];
        if (me && ge) {
            var Te = me.split(`
`)
              , _e = ge.split(`
`);
            for (ue = ne = 0; ne < Te.length && !Te[ne].includes("DetermineComponentFrameRoot"); )
                ne++;
            for (; ue < _e.length && !_e[ue].includes("DetermineComponentFrameRoot"); )
                ue++;
            if (ne === Te.length || ue === _e.length)
                for (ne = Te.length - 1,
                ue = _e.length - 1; 1 <= ne && 0 <= ue && Te[ne] !== _e[ue]; )
                    ue--;
            for (; 1 <= ne && 0 <= ue; ne--,
            ue--)
                if (Te[ne] !== _e[ue]) {
                    if (ne !== 1 || ue !== 1)
                        do
                            if (ne--,
                            ue--,
                            0 > ue || Te[ne] !== _e[ue]) {
                                var Se = `
` + Te[ne].replace(" at new ", " at ");
                                return V.displayName && Se.includes("<anonymous>") && (Se = Se.replace("<anonymous>", V.displayName)),
                                Se
                            }
                        while (1 <= ne && 0 <= ue);
                    break
                }
        }
    } finally {
        reentry = !1,
        Error.prepareStackTrace = J
    }
    return (J = V ? V.displayName || V.name : "") ? describeBuiltInComponentFrame(J) : ""
}
function describeFiber(V) {
    switch (V.tag) {
    case 26:
    case 27:
    case 5:
        return describeBuiltInComponentFrame(V.type);
    case 16:
        return describeBuiltInComponentFrame("Lazy");
    case 13:
        return describeBuiltInComponentFrame("Suspense");
    case 19:
        return describeBuiltInComponentFrame("SuspenseList");
    case 0:
    case 15:
        return describeNativeComponentFrame(V.type, !1);
    case 11:
        return describeNativeComponentFrame(V.type.render, !1);
    case 1:
        return describeNativeComponentFrame(V.type, !0);
    case 31:
        return describeBuiltInComponentFrame("Activity");
    default:
        return ""
    }
}
function getStackByFiberInDevAndProd(V) {
    try {
        var X = "";
        do
            X += describeFiber(V),
            V = V.return;
        while (V);
        return X
    } catch (J) {
        return `
Error generating stack: ` + J.message + `
` + J.stack
    }
}
function getToStringValue(V) {
    switch (typeof V) {
    case "bigint":
    case "boolean":
    case "number":
    case "string":
    case "undefined":
        return V;
    case "object":
        return V;
    default:
        return ""
    }
}
function isCheckable(V) {
    var X = V.type;
    return (V = V.nodeName) && V.toLowerCase() === "input" && (X === "checkbox" || X === "radio")
}
function trackValueOnNode(V) {
    var X = isCheckable(V) ? "checked" : "value"
      , J = Object.getOwnPropertyDescriptor(V.constructor.prototype, X)
      , ne = "" + V[X];
    if (!V.hasOwnProperty(X) && typeof J < "u" && typeof J.get == "function" && typeof J.set == "function") {
        var ue = J.get
          , ce = J.set;
        return Object.defineProperty(V, X, {
            configurable: !0,
            get: function() {
                return ue.call(this)
            },
            set: function(me) {
                ne = "" + me,
                ce.call(this, me)
            }
        }),
        Object.defineProperty(V, X, {
            enumerable: J.enumerable
        }),
        {
            getValue: function() {
                return ne
            },
            setValue: function(me) {
                ne = "" + me
            },
            stopTracking: function() {
                V._valueTracker = null,
                delete V[X]
            }
        }
    }
}
function track(V) {
    V._valueTracker || (V._valueTracker = trackValueOnNode(V))
}
function updateValueIfChanged(V) {
    if (!V)
        return !1;
    var X = V._valueTracker;
    if (!X)
        return !0;
    var J = X.getValue()
      , ne = "";
    return V && (ne = isCheckable(V) ? V.checked ? "true" : "false" : V.value),
    V = ne,
    V !== J ? (X.setValue(V),
    !0) : !1
}
function getActiveElement(V) {
    if (V = V || (typeof document < "u" ? document : void 0),
    typeof V > "u")
        return null;
    try {
        return V.activeElement || V.body
    } catch {
        return V.body
    }
}
var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
function escapeSelectorAttributeValueInsideDoubleQuotes(V) {
    return V.replace(escapeSelectorAttributeValueInsideDoubleQuotesRegex, function(X) {
        return "\\" + X.charCodeAt(0).toString(16) + " "
    })
}
function updateInput(V, X, J, ne, ue, ce, me, ge) {
    V.name = "",
    me != null && typeof me != "function" && typeof me != "symbol" && typeof me != "boolean" ? V.type = me : V.removeAttribute("type"),
    X != null ? me === "number" ? (X === 0 && V.value === "" || V.value != X) && (V.value = "" + getToStringValue(X)) : V.value !== "" + getToStringValue(X) && (V.value = "" + getToStringValue(X)) : me !== "submit" && me !== "reset" || V.removeAttribute("value"),
    X != null ? setDefaultValue(V, me, getToStringValue(X)) : J != null ? setDefaultValue(V, me, getToStringValue(J)) : ne != null && V.removeAttribute("value"),
    ue == null && ce != null && (V.defaultChecked = !!ce),
    ue != null && (V.checked = ue && typeof ue != "function" && typeof ue != "symbol"),
    ge != null && typeof ge != "function" && typeof ge != "symbol" && typeof ge != "boolean" ? V.name = "" + getToStringValue(ge) : V.removeAttribute("name")
}
function initInput(V, X, J, ne, ue, ce, me, ge) {
    if (ce != null && typeof ce != "function" && typeof ce != "symbol" && typeof ce != "boolean" && (V.type = ce),
    X != null || J != null) {
        if (!(ce !== "submit" && ce !== "reset" || X != null))
            return;
        J = J != null ? "" + getToStringValue(J) : "",
        X = X != null ? "" + getToStringValue(X) : J,
        ge || X === V.value || (V.value = X),
        V.defaultValue = X
    }
    ne = ne ?? ue,
    ne = typeof ne != "function" && typeof ne != "symbol" && !!ne,
    V.checked = ge ? V.checked : !!ne,
    V.defaultChecked = !!ne,
    me != null && typeof me != "function" && typeof me != "symbol" && typeof me != "boolean" && (V.name = me)
}
function setDefaultValue(V, X, J) {
    X === "number" && getActiveElement(V.ownerDocument) === V || V.defaultValue === "" + J || (V.defaultValue = "" + J)
}
function updateOptions(V, X, J, ne) {
    if (V = V.options,
    X) {
        X = {};
        for (var ue = 0; ue < J.length; ue++)
            X["$" + J[ue]] = !0;
        for (J = 0; J < V.length; J++)
            ue = X.hasOwnProperty("$" + V[J].value),
            V[J].selected !== ue && (V[J].selected = ue),
            ue && ne && (V[J].defaultSelected = !0)
    } else {
        for (J = "" + getToStringValue(J),
        X = null,
        ue = 0; ue < V.length; ue++) {
            if (V[ue].value === J) {
                V[ue].selected = !0,
                ne && (V[ue].defaultSelected = !0);
                return
            }
            X !== null || V[ue].disabled || (X = V[ue])
        }
        X !== null && (X.selected = !0)
    }
}
function updateTextarea(V, X, J) {
    if (X != null && (X = "" + getToStringValue(X),
    X !== V.value && (V.value = X),
    J == null)) {
        V.defaultValue !== X && (V.defaultValue = X);
        return
    }
    V.defaultValue = J != null ? "" + getToStringValue(J) : ""
}
function initTextarea(V, X, J, ne) {
    if (X == null) {
        if (ne != null) {
            if (J != null)
                throw Error(formatProdErrorMessage(92));
            if (isArrayImpl(ne)) {
                if (1 < ne.length)
                    throw Error(formatProdErrorMessage(93));
                ne = ne[0]
            }
            J = ne
        }
        J == null && (J = ""),
        X = J
    }
    J = getToStringValue(X),
    V.defaultValue = J,
    ne = V.textContent,
    ne === J && ne !== "" && ne !== null && (V.value = ne)
}
function setTextContent(V, X) {
    if (X) {
        var J = V.firstChild;
        if (J && J === V.lastChild && J.nodeType === 3) {
            J.nodeValue = X;
            return
        }
    }
    V.textContent = X
}
var unitlessNumbers = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
function setValueForStyle(V, X, J) {
    var ne = X.indexOf("--") === 0;
    J == null || typeof J == "boolean" || J === "" ? ne ? V.setProperty(X, "") : X === "float" ? V.cssFloat = "" : V[X] = "" : ne ? V.setProperty(X, J) : typeof J != "number" || J === 0 || unitlessNumbers.has(X) ? X === "float" ? V.cssFloat = J : V[X] = ("" + J).trim() : V[X] = J + "px"
}
function setValueForStyles(V, X, J) {
    if (X != null && typeof X != "object")
        throw Error(formatProdErrorMessage(62));
    if (V = V.style,
    J != null) {
        for (var ne in J)
            !J.hasOwnProperty(ne) || X != null && X.hasOwnProperty(ne) || (ne.indexOf("--") === 0 ? V.setProperty(ne, "") : ne === "float" ? V.cssFloat = "" : V[ne] = "");
        for (var ue in X)
            ne = X[ue],
            X.hasOwnProperty(ue) && J[ue] !== ne && setValueForStyle(V, ue, ne)
    } else
        for (var ce in X)
            X.hasOwnProperty(ce) && setValueForStyle(V, ce, X[ce])
}
function isCustomElement(V) {
    if (V.indexOf("-") === -1)
        return !1;
    switch (V) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
        return !1;
    default:
        return !0
    }
}
var aliases = new Map([["acceptCharset", "accept-charset"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"], ["crossOrigin", "crossorigin"], ["accentHeight", "accent-height"], ["alignmentBaseline", "alignment-baseline"], ["arabicForm", "arabic-form"], ["baselineShift", "baseline-shift"], ["capHeight", "cap-height"], ["clipPath", "clip-path"], ["clipRule", "clip-rule"], ["colorInterpolation", "color-interpolation"], ["colorInterpolationFilters", "color-interpolation-filters"], ["colorProfile", "color-profile"], ["colorRendering", "color-rendering"], ["dominantBaseline", "dominant-baseline"], ["enableBackground", "enable-background"], ["fillOpacity", "fill-opacity"], ["fillRule", "fill-rule"], ["floodColor", "flood-color"], ["floodOpacity", "flood-opacity"], ["fontFamily", "font-family"], ["fontSize", "font-size"], ["fontSizeAdjust", "font-size-adjust"], ["fontStretch", "font-stretch"], ["fontStyle", "font-style"], ["fontVariant", "font-variant"], ["fontWeight", "font-weight"], ["glyphName", "glyph-name"], ["glyphOrientationHorizontal", "glyph-orientation-horizontal"], ["glyphOrientationVertical", "glyph-orientation-vertical"], ["horizAdvX", "horiz-adv-x"], ["horizOriginX", "horiz-origin-x"], ["imageRendering", "image-rendering"], ["letterSpacing", "letter-spacing"], ["lightingColor", "lighting-color"], ["markerEnd", "marker-end"], ["markerMid", "marker-mid"], ["markerStart", "marker-start"], ["overlinePosition", "overline-position"], ["overlineThickness", "overline-thickness"], ["paintOrder", "paint-order"], ["panose-1", "panose-1"], ["pointerEvents", "pointer-events"], ["renderingIntent", "rendering-intent"], ["shapeRendering", "shape-rendering"], ["stopColor", "stop-color"], ["stopOpacity", "stop-opacity"], ["strikethroughPosition", "strikethrough-position"], ["strikethroughThickness", "strikethrough-thickness"], ["strokeDasharray", "stroke-dasharray"], ["strokeDashoffset", "stroke-dashoffset"], ["strokeLinecap", "stroke-linecap"], ["strokeLinejoin", "stroke-linejoin"], ["strokeMiterlimit", "stroke-miterlimit"], ["strokeOpacity", "stroke-opacity"], ["strokeWidth", "stroke-width"], ["textAnchor", "text-anchor"], ["textDecoration", "text-decoration"], ["textRendering", "text-rendering"], ["transformOrigin", "transform-origin"], ["underlinePosition", "underline-position"], ["underlineThickness", "underline-thickness"], ["unicodeBidi", "unicode-bidi"], ["unicodeRange", "unicode-range"], ["unitsPerEm", "units-per-em"], ["vAlphabetic", "v-alphabetic"], ["vHanging", "v-hanging"], ["vIdeographic", "v-ideographic"], ["vMathematical", "v-mathematical"], ["vectorEffect", "vector-effect"], ["vertAdvY", "vert-adv-y"], ["vertOriginX", "vert-origin-x"], ["vertOriginY", "vert-origin-y"], ["wordSpacing", "word-spacing"], ["writingMode", "writing-mode"], ["xmlnsXlink", "xmlns:xlink"], ["xHeight", "x-height"]])
  , isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
function sanitizeURL(V) {
    return isJavaScriptProtocol.test("" + V) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : V
}
var currentReplayingEvent = null;
function getEventTarget(V) {
    return V = V.target || V.srcElement || window,
    V.correspondingUseElement && (V = V.correspondingUseElement),
    V.nodeType === 3 ? V.parentNode : V
}
var restoreTarget = null
  , restoreQueue = null;
function restoreStateOfTarget(V) {
    var X = getInstanceFromNode(V);
    if (X && (V = X.stateNode)) {
        var J = V[internalPropsKey] || null;
        e: switch (V = X.stateNode,
        X.type) {
        case "input":
            if (updateInput(V, J.value, J.defaultValue, J.defaultValue, J.checked, J.defaultChecked, J.type, J.name),
            X = J.name,
            J.type === "radio" && X != null) {
                for (J = V; J.parentNode; )
                    J = J.parentNode;
                for (J = J.querySelectorAll('input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes("" + X) + '"][type="radio"]'),
                X = 0; X < J.length; X++) {
                    var ne = J[X];
                    if (ne !== V && ne.form === V.form) {
                        var ue = ne[internalPropsKey] || null;
                        if (!ue)
                            throw Error(formatProdErrorMessage(90));
                        updateInput(ne, ue.value, ue.defaultValue, ue.defaultValue, ue.checked, ue.defaultChecked, ue.type, ue.name)
                    }
                }
                for (X = 0; X < J.length; X++)
                    ne = J[X],
                    ne.form === V.form && updateValueIfChanged(ne)
            }
            break e;
        case "textarea":
            updateTextarea(V, J.value, J.defaultValue);
            break e;
        case "select":
            X = J.value,
            X != null && updateOptions(V, !!J.multiple, X, !1)
        }
    }
}
var isInsideEventHandler = !1;
function batchedUpdates$1(V, X, J) {
    if (isInsideEventHandler)
        return V(X, J);
    isInsideEventHandler = !0;
    try {
        var ne = V(X);
        return ne
    } finally {
        if (isInsideEventHandler = !1,
        (restoreTarget !== null || restoreQueue !== null) && (flushSyncWork$1(),
        restoreTarget && (X = restoreTarget,
        V = restoreQueue,
        restoreQueue = restoreTarget = null,
        restoreStateOfTarget(X),
        V)))
            for (X = 0; X < V.length; X++)
                restoreStateOfTarget(V[X])
    }
}
function getListener(V, X) {
    var J = V.stateNode;
    if (J === null)
        return null;
    var ne = J[internalPropsKey] || null;
    if (ne === null)
        return null;
    J = ne[X];
    e: switch (X) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
        (ne = !ne.disabled) || (V = V.type,
        ne = !(V === "button" || V === "input" || V === "select" || V === "textarea")),
        V = !ne;
        break e;
    default:
        V = !1
    }
    if (V)
        return null;
    if (J && typeof J != "function")
        throw Error(formatProdErrorMessage(231, X, typeof J));
    return J
}
var canUseDOM = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
  , passiveBrowserEventsSupported = !1;
if (canUseDOM)
    try {
        var options = {};
        Object.defineProperty(options, "passive", {
            get: function() {
                passiveBrowserEventsSupported = !0
            }
        }),
        window.addEventListener("test", options, options),
        window.removeEventListener("test", options, options)
    } catch (V) {
        passiveBrowserEventsSupported = !1
    }
var root$3 = null
  , startText = null
  , fallbackText = null;
function getData() {
    if (fallbackText)
        return fallbackText;
    var V, X = startText, J = X.length, ne, ue = "value"in root$3 ? root$3.value : root$3.textContent, ce = ue.length;
    for (V = 0; V < J && X[V] === ue[V]; V++)
        ;
    var me = J - V;
    for (ne = 1; ne <= me && X[J - ne] === ue[ce - ne]; ne++)
        ;
    return fallbackText = ue.slice(V, 1 < ne ? 1 - ne : void 0)
}
function getEventCharCode(V) {
    var X = V.keyCode;
    return "charCode"in V ? (V = V.charCode,
    V === 0 && X === 13 && (V = 13)) : V = X,
    V === 10 && (V = 13),
    32 <= V || V === 13 ? V : 0
}
function functionThatReturnsTrue() {
    return !0
}
function functionThatReturnsFalse() {
    return !1
}
function createSyntheticEvent(V) {
    function X(J, ne, ue, ce, me) {
        this._reactName = J,
        this._targetInst = ue,
        this.type = ne,
        this.nativeEvent = ce,
        this.target = me,
        this.currentTarget = null;
        for (var ge in V)
            V.hasOwnProperty(ge) && (J = V[ge],
            this[ge] = J ? J(ce) : ce[ge]);
        return this.isDefaultPrevented = (ce.defaultPrevented != null ? ce.defaultPrevented : ce.returnValue === !1) ? functionThatReturnsTrue : functionThatReturnsFalse,
        this.isPropagationStopped = functionThatReturnsFalse,
        this
    }
    return assign(X.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var J = this.nativeEvent;
            J && (J.preventDefault ? J.preventDefault() : typeof J.returnValue != "unknown" && (J.returnValue = !1),
            this.isDefaultPrevented = functionThatReturnsTrue)
        },
        stopPropagation: function() {
            var J = this.nativeEvent;
            J && (J.stopPropagation ? J.stopPropagation() : typeof J.cancelBubble != "unknown" && (J.cancelBubble = !0),
            this.isPropagationStopped = functionThatReturnsTrue)
        },
        persist: function() {},
        isPersistent: functionThatReturnsTrue
    }),
    X
}
var EventInterface = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(V) {
        return V.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0
}, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign({}, EventInterface, {
    view: 0,
    detail: 0
}), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign({}, UIEventInterface, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: getEventModifierState,
    button: 0,
    buttons: 0,
    relatedTarget: function(V) {
        return V.relatedTarget === void 0 ? V.fromElement === V.srcElement ? V.toElement : V.fromElement : V.relatedTarget
    },
    movementX: function(V) {
        return "movementX"in V ? V.movementX : (V !== lastMouseEvent && (lastMouseEvent && V.type === "mousemove" ? (lastMovementX = V.screenX - lastMouseEvent.screenX,
        lastMovementY = V.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0,
        lastMouseEvent = V),
        lastMovementX)
    },
    movementY: function(V) {
        return "movementY"in V ? V.movementY : lastMovementY
    }
}), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign({}, MouseEventInterface, {
    dataTransfer: 0
}), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign({}, UIEventInterface, {
    relatedTarget: 0
}), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign({}, EventInterface, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
}), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign({}, EventInterface, {
    clipboardData: function(V) {
        return "clipboardData"in V ? V.clipboardData : window.clipboardData
    }
}), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign({}, EventInterface, {
    data: 0
}), SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface), normalizeKey = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
}, translateToKey = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
}, modifierKeyToProp = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
};
function modifierStateGetter(V) {
    var X = this.nativeEvent;
    return X.getModifierState ? X.getModifierState(V) : (V = modifierKeyToProp[V]) ? !!X[V] : !1
}
function getEventModifierState() {
    return modifierStateGetter
}
var KeyboardEventInterface = assign({}, UIEventInterface, {
    key: function(V) {
        if (V.key) {
            var X = normalizeKey[V.key] || V.key;
            if (X !== "Unidentified")
                return X
        }
        return V.type === "keypress" ? (V = getEventCharCode(V),
        V === 13 ? "Enter" : String.fromCharCode(V)) : V.type === "keydown" || V.type === "keyup" ? translateToKey[V.keyCode] || "Unidentified" : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: getEventModifierState,
    charCode: function(V) {
        return V.type === "keypress" ? getEventCharCode(V) : 0
    },
    keyCode: function(V) {
        return V.type === "keydown" || V.type === "keyup" ? V.keyCode : 0
    },
    which: function(V) {
        return V.type === "keypress" ? getEventCharCode(V) : V.type === "keydown" || V.type === "keyup" ? V.keyCode : 0
    }
})
  , SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface)
  , PointerEventInterface = assign({}, MouseEventInterface, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
})
  , SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface)
  , TouchEventInterface = assign({}, UIEventInterface, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: getEventModifierState
})
  , SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface)
  , TransitionEventInterface = assign({}, EventInterface, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
})
  , SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface)
  , WheelEventInterface = assign({}, MouseEventInterface, {
    deltaX: function(V) {
        return "deltaX"in V ? V.deltaX : "wheelDeltaX"in V ? -V.wheelDeltaX : 0
    },
    deltaY: function(V) {
        return "deltaY"in V ? V.deltaY : "wheelDeltaY"in V ? -V.wheelDeltaY : "wheelDelta"in V ? -V.wheelDelta : 0
    },
    deltaZ: 0,
    deltaMode: 0
})
  , SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface)
  , ToggleEventInterface = assign({}, EventInterface, {
    newState: 0,
    oldState: 0
})
  , SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface)
  , END_KEYCODES = [9, 13, 27, 32]
  , canUseCompositionEvent = canUseDOM && "CompositionEvent"in window
  , documentMode = null;
canUseDOM && "documentMode"in document && (documentMode = document.documentMode);
var canUseTextInputEvent = canUseDOM && "TextEvent"in window && !documentMode
  , useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode)
  , SPACEBAR_CHAR = " "
  , hasSpaceKeypress = !1;
function isFallbackCompositionEnd(V, X) {
    switch (V) {
    case "keyup":
        return END_KEYCODES.indexOf(X.keyCode) !== -1;
    case "keydown":
        return X.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
        return !0;
    default:
        return !1
    }
}
function getDataFromCustomEvent(V) {
    return V = V.detail,
    typeof V == "object" && "data"in V ? V.data : null
}
var isComposing = !1;
function getNativeBeforeInputChars(V, X) {
    switch (V) {
    case "compositionend":
        return getDataFromCustomEvent(X);
    case "keypress":
        return X.which !== 32 ? null : (hasSpaceKeypress = !0,
        SPACEBAR_CHAR);
    case "textInput":
        return V = X.data,
        V === SPACEBAR_CHAR && hasSpaceKeypress ? null : V;
    default:
        return null
    }
}
function getFallbackBeforeInputChars(V, X) {
    if (isComposing)
        return V === "compositionend" || !canUseCompositionEvent && isFallbackCompositionEnd(V, X) ? (V = getData(),
        fallbackText = startText = root$3 = null,
        isComposing = !1,
        V) : null;
    switch (V) {
    case "paste":
        return null;
    case "keypress":
        if (!(X.ctrlKey || X.altKey || X.metaKey) || X.ctrlKey && X.altKey) {
            if (X.char && 1 < X.char.length)
                return X.char;
            if (X.which)
                return String.fromCharCode(X.which)
        }
        return null;
    case "compositionend":
        return useFallbackCompositionData && X.locale !== "ko" ? null : X.data;
    default:
        return null
    }
}
var supportedInputTypes = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};
function isTextInputElement(V) {
    var X = V && V.nodeName && V.nodeName.toLowerCase();
    return X === "input" ? !!supportedInputTypes[V.type] : X === "textarea"
}
function createAndAccumulateChangeEvent(V, X, J, ne) {
    restoreTarget ? restoreQueue ? restoreQueue.push(ne) : restoreQueue = [ne] : restoreTarget = ne,
    X = accumulateTwoPhaseListeners(X, "onChange"),
    0 < X.length && (J = new SyntheticEvent("onChange","change",null,J,ne),
    V.push({
        event: J,
        listeners: X
    }))
}
var activeElement$1 = null
  , activeElementInst$1 = null;
function runEventInBatch(V) {
    processDispatchQueue(V, 0)
}
function getInstIfValueChanged(V) {
    var X = getNodeFromInstance(V);
    if (updateValueIfChanged(X))
        return V
}
function getTargetInstForChangeEvent(V, X) {
    if (V === "change")
        return X
}
var isInputEventSupported = !1;
if (canUseDOM) {
    var JSCompiler_inline_result$jscomp$282;
    if (canUseDOM) {
        var isSupported$jscomp$inline_417 = "oninput"in document;
        if (!isSupported$jscomp$inline_417) {
            var element$jscomp$inline_418 = document.createElement("div");
            element$jscomp$inline_418.setAttribute("oninput", "return;"),
            isSupported$jscomp$inline_417 = typeof element$jscomp$inline_418.oninput == "function"
        }
        JSCompiler_inline_result$jscomp$282 = isSupported$jscomp$inline_417
    } else
        JSCompiler_inline_result$jscomp$282 = !1;
    isInputEventSupported = JSCompiler_inline_result$jscomp$282 && (!document.documentMode || 9 < document.documentMode)
}
function stopWatchingForValueChange() {
    activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange),
    activeElementInst$1 = activeElement$1 = null)
}
function handlePropertyChange(V) {
    if (V.propertyName === "value" && getInstIfValueChanged(activeElementInst$1)) {
        var X = [];
        createAndAccumulateChangeEvent(X, activeElementInst$1, V, getEventTarget(V)),
        batchedUpdates$1(runEventInBatch, X)
    }
}
function handleEventsForInputEventPolyfill(V, X, J) {
    V === "focusin" ? (stopWatchingForValueChange(),
    activeElement$1 = X,
    activeElementInst$1 = J,
    activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : V === "focusout" && stopWatchingForValueChange()
}
function getTargetInstForInputEventPolyfill(V) {
    if (V === "selectionchange" || V === "keyup" || V === "keydown")
        return getInstIfValueChanged(activeElementInst$1)
}
function getTargetInstForClickEvent(V, X) {
    if (V === "click")
        return getInstIfValueChanged(X)
}
function getTargetInstForInputOrChangeEvent(V, X) {
    if (V === "input" || V === "change")
        return getInstIfValueChanged(X)
}
function is(V, X) {
    return V === X && (V !== 0 || 1 / V === 1 / X) || V !== V && X !== X
}
var objectIs = typeof Object.is == "function" ? Object.is : is;
function shallowEqual(V, X) {
    if (objectIs(V, X))
        return !0;
    if (typeof V != "object" || V === null || typeof X != "object" || X === null)
        return !1;
    var J = Object.keys(V)
      , ne = Object.keys(X);
    if (J.length !== ne.length)
        return !1;
    for (ne = 0; ne < J.length; ne++) {
        var ue = J[ne];
        if (!hasOwnProperty$2.call(X, ue) || !objectIs(V[ue], X[ue]))
            return !1
    }
    return !0
}
function getLeafNode(V) {
    for (; V && V.firstChild; )
        V = V.firstChild;
    return V
}
function getNodeForCharacterOffset(V, X) {
    var J = getLeafNode(V);
    V = 0;
    for (var ne; J; ) {
        if (J.nodeType === 3) {
            if (ne = V + J.textContent.length,
            V <= X && ne >= X)
                return {
                    node: J,
                    offset: X - V
                };
            V = ne
        }
        e: {
            for (; J; ) {
                if (J.nextSibling) {
                    J = J.nextSibling;
                    break e
                }
                J = J.parentNode
            }
            J = void 0
        }
        J = getLeafNode(J)
    }
}
function containsNode(V, X) {
    return V && X ? V === X ? !0 : V && V.nodeType === 3 ? !1 : X && X.nodeType === 3 ? containsNode(V, X.parentNode) : "contains"in V ? V.contains(X) : V.compareDocumentPosition ? !!(V.compareDocumentPosition(X) & 16) : !1 : !1
}
function getActiveElementDeep(V) {
    V = V != null && V.ownerDocument != null && V.ownerDocument.defaultView != null ? V.ownerDocument.defaultView : window;
    for (var X = getActiveElement(V.document); X instanceof V.HTMLIFrameElement; ) {
        try {
            var J = typeof X.contentWindow.location.href == "string"
        } catch {
            J = !1
        }
        if (J)
            V = X.contentWindow;
        else
            break;
        X = getActiveElement(V.document)
    }
    return X
}
function hasSelectionCapabilities(V) {
    var X = V && V.nodeName && V.nodeName.toLowerCase();
    return X && (X === "input" && (V.type === "text" || V.type === "search" || V.type === "tel" || V.type === "url" || V.type === "password") || X === "textarea" || V.contentEditable === "true")
}
var skipSelectionChangeEvent = canUseDOM && "documentMode"in document && 11 >= document.documentMode
  , activeElement = null
  , activeElementInst = null
  , lastSelection = null
  , mouseDown = !1;
function constructSelectEvent(V, X, J) {
    var ne = J.window === J ? J.document : J.nodeType === 9 ? J : J.ownerDocument;
    mouseDown || activeElement == null || activeElement !== getActiveElement(ne) || (ne = activeElement,
    "selectionStart"in ne && hasSelectionCapabilities(ne) ? ne = {
        start: ne.selectionStart,
        end: ne.selectionEnd
    } : (ne = (ne.ownerDocument && ne.ownerDocument.defaultView || window).getSelection(),
    ne = {
        anchorNode: ne.anchorNode,
        anchorOffset: ne.anchorOffset,
        focusNode: ne.focusNode,
        focusOffset: ne.focusOffset
    }),
    lastSelection && shallowEqual(lastSelection, ne) || (lastSelection = ne,
    ne = accumulateTwoPhaseListeners(activeElementInst, "onSelect"),
    0 < ne.length && (X = new SyntheticEvent("onSelect","select",null,X,J),
    V.push({
        event: X,
        listeners: ne
    }),
    X.target = activeElement)))
}
function makePrefixMap(V, X) {
    var J = {};
    return J[V.toLowerCase()] = X.toLowerCase(),
    J["Webkit" + V] = "webkit" + X,
    J["Moz" + V] = "moz" + X,
    J
}
var vendorPrefixes = {
    animationend: makePrefixMap("Animation", "AnimationEnd"),
    animationiteration: makePrefixMap("Animation", "AnimationIteration"),
    animationstart: makePrefixMap("Animation", "AnimationStart"),
    transitionrun: makePrefixMap("Transition", "TransitionRun"),
    transitionstart: makePrefixMap("Transition", "TransitionStart"),
    transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
    transitionend: makePrefixMap("Transition", "TransitionEnd")
}
  , prefixedEventNames = {}
  , style = {};
canUseDOM && (style = document.createElement("div").style,
"AnimationEvent"in window || (delete vendorPrefixes.animationend.animation,
delete vendorPrefixes.animationiteration.animation,
delete vendorPrefixes.animationstart.animation),
"TransitionEvent"in window || delete vendorPrefixes.transitionend.transition);
function getVendorPrefixedEventName(V) {
    if (prefixedEventNames[V])
        return prefixedEventNames[V];
    if (!vendorPrefixes[V])
        return V;
    var X = vendorPrefixes[V], J;
    for (J in X)
        if (X.hasOwnProperty(J) && J in style)
            return prefixedEventNames[V] = X[J];
    return V
}
var ANIMATION_END = getVendorPrefixedEventName("animationend")
  , ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration")
  , ANIMATION_START = getVendorPrefixedEventName("animationstart")
  , TRANSITION_RUN = getVendorPrefixedEventName("transitionrun")
  , TRANSITION_START = getVendorPrefixedEventName("transitionstart")
  , TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel")
  , TRANSITION_END = getVendorPrefixedEventName("transitionend")
  , topLevelEventsToReactNames = new Map
  , simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
simpleEventPluginEvents.push("scrollEnd");
function registerSimpleEvent(V, X) {
    topLevelEventsToReactNames.set(V, X),
    registerTwoPhaseEvent(X, [V])
}
var CapturedStacks = new WeakMap;
function createCapturedValueAtFiber(V, X) {
    if (typeof V == "object" && V !== null) {
        var J = CapturedStacks.get(V);
        return J !== void 0 ? J : (X = {
            value: V,
            source: X,
            stack: getStackByFiberInDevAndProd(X)
        },
        CapturedStacks.set(V, X),
        X)
    }
    return {
        value: V,
        source: X,
        stack: getStackByFiberInDevAndProd(X)
    }
}
var concurrentQueues = []
  , concurrentQueuesIndex = 0
  , concurrentlyUpdatedLanes = 0;
function finishQueueingConcurrentUpdates() {
    for (var V = concurrentQueuesIndex, X = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; X < V; ) {
        var J = concurrentQueues[X];
        concurrentQueues[X++] = null;
        var ne = concurrentQueues[X];
        concurrentQueues[X++] = null;
        var ue = concurrentQueues[X];
        concurrentQueues[X++] = null;
        var ce = concurrentQueues[X];
        if (concurrentQueues[X++] = null,
        ne !== null && ue !== null) {
            var me = ne.pending;
            me === null ? ue.next = ue : (ue.next = me.next,
            me.next = ue),
            ne.pending = ue
        }
        ce !== 0 && markUpdateLaneFromFiberToRoot(J, ue, ce)
    }
}
function enqueueUpdate$1(V, X, J, ne) {
    concurrentQueues[concurrentQueuesIndex++] = V,
    concurrentQueues[concurrentQueuesIndex++] = X,
    concurrentQueues[concurrentQueuesIndex++] = J,
    concurrentQueues[concurrentQueuesIndex++] = ne,
    concurrentlyUpdatedLanes |= ne,
    V.lanes |= ne,
    V = V.alternate,
    V !== null && (V.lanes |= ne)
}
function enqueueConcurrentHookUpdate(V, X, J, ne) {
    return enqueueUpdate$1(V, X, J, ne),
    getRootForUpdatedFiber(V)
}
function enqueueConcurrentRenderForLane(V, X) {
    return enqueueUpdate$1(V, null, null, X),
    getRootForUpdatedFiber(V)
}
function markUpdateLaneFromFiberToRoot(V, X, J) {
    V.lanes |= J;
    var ne = V.alternate;
    ne !== null && (ne.lanes |= J);
    for (var ue = !1, ce = V.return; ce !== null; )
        ce.childLanes |= J,
        ne = ce.alternate,
        ne !== null && (ne.childLanes |= J),
        ce.tag === 22 && (V = ce.stateNode,
        V === null || V._visibility & 1 || (ue = !0)),
        V = ce,
        ce = ce.return;
    return V.tag === 3 ? (ce = V.stateNode,
    ue && X !== null && (ue = 31 - clz32(J),
    V = ce.hiddenUpdates,
    ne = V[ue],
    ne === null ? V[ue] = [X] : ne.push(X),
    X.lane = J | 536870912),
    ce) : null
}
function getRootForUpdatedFiber(V) {
    if (50 < nestedUpdateCount)
        throw nestedUpdateCount = 0,
        rootWithNestedUpdates = null,
        Error(formatProdErrorMessage(185));
    for (var X = V.return; X !== null; )
        V = X,
        X = V.return;
    return V.tag === 3 ? V.stateNode : null
}
var emptyContextObject = {};
function FiberNode(V, X, J, ne) {
    this.tag = V,
    this.key = J,
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
    this.index = 0,
    this.refCleanup = this.ref = null,
    this.pendingProps = X,
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
    this.mode = ne,
    this.subtreeFlags = this.flags = 0,
    this.deletions = null,
    this.childLanes = this.lanes = 0,
    this.alternate = null
}
function createFiberImplClass(V, X, J, ne) {
    return new FiberNode(V,X,J,ne)
}
function shouldConstruct(V) {
    return V = V.prototype,
    !(!V || !V.isReactComponent)
}
function createWorkInProgress(V, X) {
    var J = V.alternate;
    return J === null ? (J = createFiberImplClass(V.tag, X, V.key, V.mode),
    J.elementType = V.elementType,
    J.type = V.type,
    J.stateNode = V.stateNode,
    J.alternate = V,
    V.alternate = J) : (J.pendingProps = X,
    J.type = V.type,
    J.flags = 0,
    J.subtreeFlags = 0,
    J.deletions = null),
    J.flags = V.flags & 65011712,
    J.childLanes = V.childLanes,
    J.lanes = V.lanes,
    J.child = V.child,
    J.memoizedProps = V.memoizedProps,
    J.memoizedState = V.memoizedState,
    J.updateQueue = V.updateQueue,
    X = V.dependencies,
    J.dependencies = X === null ? null : {
        lanes: X.lanes,
        firstContext: X.firstContext
    },
    J.sibling = V.sibling,
    J.index = V.index,
    J.ref = V.ref,
    J.refCleanup = V.refCleanup,
    J
}
function resetWorkInProgress(V, X) {
    V.flags &= 65011714;
    var J = V.alternate;
    return J === null ? (V.childLanes = 0,
    V.lanes = X,
    V.child = null,
    V.subtreeFlags = 0,
    V.memoizedProps = null,
    V.memoizedState = null,
    V.updateQueue = null,
    V.dependencies = null,
    V.stateNode = null) : (V.childLanes = J.childLanes,
    V.lanes = J.lanes,
    V.child = J.child,
    V.subtreeFlags = 0,
    V.deletions = null,
    V.memoizedProps = J.memoizedProps,
    V.memoizedState = J.memoizedState,
    V.updateQueue = J.updateQueue,
    V.type = J.type,
    X = J.dependencies,
    V.dependencies = X === null ? null : {
        lanes: X.lanes,
        firstContext: X.firstContext
    }),
    V
}
function createFiberFromTypeAndProps(V, X, J, ne, ue, ce) {
    var me = 0;
    if (ne = V,
    typeof V == "function")
        shouldConstruct(V) && (me = 1);
    else if (typeof V == "string")
        me = isHostHoistableType(V, J, contextStackCursor.current) ? 26 : V === "html" || V === "head" || V === "body" ? 27 : 5;
    else
        e: switch (V) {
        case REACT_ACTIVITY_TYPE:
            return V = createFiberImplClass(31, J, X, ue),
            V.elementType = REACT_ACTIVITY_TYPE,
            V.lanes = ce,
            V;
        case REACT_FRAGMENT_TYPE:
            return createFiberFromFragment(J.children, ue, ce, X);
        case REACT_STRICT_MODE_TYPE:
            me = 8,
            ue |= 24;
            break;
        case REACT_PROFILER_TYPE:
            return V = createFiberImplClass(12, J, X, ue | 2),
            V.elementType = REACT_PROFILER_TYPE,
            V.lanes = ce,
            V;
        case REACT_SUSPENSE_TYPE:
            return V = createFiberImplClass(13, J, X, ue),
            V.elementType = REACT_SUSPENSE_TYPE,
            V.lanes = ce,
            V;
        case REACT_SUSPENSE_LIST_TYPE:
            return V = createFiberImplClass(19, J, X, ue),
            V.elementType = REACT_SUSPENSE_LIST_TYPE,
            V.lanes = ce,
            V;
        default:
            if (typeof V == "object" && V !== null)
                switch (V.$$typeof) {
                case REACT_PROVIDER_TYPE:
                case REACT_CONTEXT_TYPE:
                    me = 10;
                    break e;
                case REACT_CONSUMER_TYPE:
                    me = 9;
                    break e;
                case REACT_FORWARD_REF_TYPE:
                    me = 11;
                    break e;
                case REACT_MEMO_TYPE:
                    me = 14;
                    break e;
                case REACT_LAZY_TYPE:
                    me = 16,
                    ne = null;
                    break e
                }
            me = 29,
            J = Error(formatProdErrorMessage(130, V === null ? "null" : typeof V, "")),
            ne = null
        }
    return X = createFiberImplClass(me, J, X, ue),
    X.elementType = V,
    X.type = ne,
    X.lanes = ce,
    X
}
function createFiberFromFragment(V, X, J, ne) {
    return V = createFiberImplClass(7, V, ne, X),
    V.lanes = J,
    V
}
function createFiberFromText(V, X, J) {
    return V = createFiberImplClass(6, V, null, X),
    V.lanes = J,
    V
}
function createFiberFromPortal(V, X, J) {
    return X = createFiberImplClass(4, V.children !== null ? V.children : [], V.key, X),
    X.lanes = J,
    X.stateNode = {
        containerInfo: V.containerInfo,
        pendingChildren: null,
        implementation: V.implementation
    },
    X
}
var forkStack = []
  , forkStackIndex = 0
  , treeForkProvider = null
  , treeForkCount = 0
  , idStack = []
  , idStackIndex = 0
  , treeContextProvider = null
  , treeContextId = 1
  , treeContextOverflow = "";
function pushTreeFork(V, X) {
    forkStack[forkStackIndex++] = treeForkCount,
    forkStack[forkStackIndex++] = treeForkProvider,
    treeForkProvider = V,
    treeForkCount = X
}
function pushTreeId(V, X, J) {
    idStack[idStackIndex++] = treeContextId,
    idStack[idStackIndex++] = treeContextOverflow,
    idStack[idStackIndex++] = treeContextProvider,
    treeContextProvider = V;
    var ne = treeContextId;
    V = treeContextOverflow;
    var ue = 32 - clz32(ne) - 1;
    ne &= ~(1 << ue),
    J += 1;
    var ce = 32 - clz32(X) + ue;
    if (30 < ce) {
        var me = ue - ue % 5;
        ce = (ne & (1 << me) - 1).toString(32),
        ne >>= me,
        ue -= me,
        treeContextId = 1 << 32 - clz32(X) + ue | J << ue | ne,
        treeContextOverflow = ce + V
    } else
        treeContextId = 1 << ce | J << ue | ne,
        treeContextOverflow = V
}
function pushMaterializedTreeId(V) {
    V.return !== null && (pushTreeFork(V, 1),
    pushTreeId(V, 1, 0))
}
function popTreeContext(V) {
    for (; V === treeForkProvider; )
        treeForkProvider = forkStack[--forkStackIndex],
        forkStack[forkStackIndex] = null,
        treeForkCount = forkStack[--forkStackIndex],
        forkStack[forkStackIndex] = null;
    for (; V === treeContextProvider; )
        treeContextProvider = idStack[--idStackIndex],
        idStack[idStackIndex] = null,
        treeContextOverflow = idStack[--idStackIndex],
        idStack[idStackIndex] = null,
        treeContextId = idStack[--idStackIndex],
        idStack[idStackIndex] = null
}
var hydrationParentFiber = null
  , nextHydratableInstance = null
  , isHydrating = !1
  , hydrationErrors = null
  , rootOrSingletonContext = !1
  , HydrationMismatchException = Error(formatProdErrorMessage(519));
function throwOnHydrationMismatch(V) {
    var X = Error(formatProdErrorMessage(418, ""));
    throw queueHydrationError(createCapturedValueAtFiber(X, V)),
    HydrationMismatchException
}
function prepareToHydrateHostInstance(V) {
    var X = V.stateNode
      , J = V.type
      , ne = V.memoizedProps;
    switch (X[internalInstanceKey] = V,
    X[internalPropsKey] = ne,
    J) {
    case "dialog":
        listenToNonDelegatedEvent("cancel", X),
        listenToNonDelegatedEvent("close", X);
        break;
    case "iframe":
    case "object":
    case "embed":
        listenToNonDelegatedEvent("load", X);
        break;
    case "video":
    case "audio":
        for (J = 0; J < mediaEventTypes.length; J++)
            listenToNonDelegatedEvent(mediaEventTypes[J], X);
        break;
    case "source":
        listenToNonDelegatedEvent("error", X);
        break;
    case "img":
    case "image":
    case "link":
        listenToNonDelegatedEvent("error", X),
        listenToNonDelegatedEvent("load", X);
        break;
    case "details":
        listenToNonDelegatedEvent("toggle", X);
        break;
    case "input":
        listenToNonDelegatedEvent("invalid", X),
        initInput(X, ne.value, ne.defaultValue, ne.checked, ne.defaultChecked, ne.type, ne.name, !0),
        track(X);
        break;
    case "select":
        listenToNonDelegatedEvent("invalid", X);
        break;
    case "textarea":
        listenToNonDelegatedEvent("invalid", X),
        initTextarea(X, ne.value, ne.defaultValue, ne.children),
        track(X)
    }
    J = ne.children,
    typeof J != "string" && typeof J != "number" && typeof J != "bigint" || X.textContent === "" + J || ne.suppressHydrationWarning === !0 || checkForUnmatchedText(X.textContent, J) ? (ne.popover != null && (listenToNonDelegatedEvent("beforetoggle", X),
    listenToNonDelegatedEvent("toggle", X)),
    ne.onScroll != null && listenToNonDelegatedEvent("scroll", X),
    ne.onScrollEnd != null && listenToNonDelegatedEvent("scrollend", X),
    ne.onClick != null && (X.onclick = noop$1),
    X = !0) : X = !1,
    X || throwOnHydrationMismatch(V)
}
function popToNextHostParent(V) {
    for (hydrationParentFiber = V.return; hydrationParentFiber; )
        switch (hydrationParentFiber.tag) {
        case 5:
        case 13:
            rootOrSingletonContext = !1;
            return;
        case 27:
        case 3:
            rootOrSingletonContext = !0;
            return;
        default:
            hydrationParentFiber = hydrationParentFiber.return
        }
}
function popHydrationState(V) {
    if (V !== hydrationParentFiber)
        return !1;
    if (!isHydrating)
        return popToNextHostParent(V),
        isHydrating = !0,
        !1;
    var X = V.tag, J;
    if ((J = X !== 3 && X !== 27) && ((J = X === 5) && (J = V.type,
    J = !(J !== "form" && J !== "button") || shouldSetTextContent(V.type, V.memoizedProps)),
    J = !J),
    J && nextHydratableInstance && throwOnHydrationMismatch(V),
    popToNextHostParent(V),
    X === 13) {
        if (V = V.memoizedState,
        V = V !== null ? V.dehydrated : null,
        !V)
            throw Error(formatProdErrorMessage(317));
        e: {
            for (V = V.nextSibling,
            X = 0; V; ) {
                if (V.nodeType === 8)
                    if (J = V.data,
                    J === "/$") {
                        if (X === 0) {
                            nextHydratableInstance = getNextHydratable(V.nextSibling);
                            break e
                        }
                        X--
                    } else
                        J !== "$" && J !== "$!" && J !== "$?" || X++;
                V = V.nextSibling
            }
            nextHydratableInstance = null
        }
    } else
        X === 27 ? (X = nextHydratableInstance,
        isSingletonScope(V.type) ? (V = previousHydratableOnEnteringScopedSingleton,
        previousHydratableOnEnteringScopedSingleton = null,
        nextHydratableInstance = V) : nextHydratableInstance = X) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(V.stateNode.nextSibling) : null;
    return !0
}
function resetHydrationState() {
    nextHydratableInstance = hydrationParentFiber = null,
    isHydrating = !1
}
function upgradeHydrationErrorsToRecoverable() {
    var V = hydrationErrors;
    return V !== null && (workInProgressRootRecoverableErrors === null ? workInProgressRootRecoverableErrors = V : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, V),
    hydrationErrors = null),
    V
}
function queueHydrationError(V) {
    hydrationErrors === null ? hydrationErrors = [V] : hydrationErrors.push(V)
}
var valueCursor = createCursor(null)
  , currentlyRenderingFiber$1 = null
  , lastContextDependency = null;
function pushProvider(V, X, J) {
    push$1(valueCursor, X._currentValue),
    X._currentValue = J
}
function popProvider(V) {
    V._currentValue = valueCursor.current,
    pop(valueCursor)
}
function scheduleContextWorkOnParentPath(V, X, J) {
    for (; V !== null; ) {
        var ne = V.alternate;
        if ((V.childLanes & X) !== X ? (V.childLanes |= X,
        ne !== null && (ne.childLanes |= X)) : ne !== null && (ne.childLanes & X) !== X && (ne.childLanes |= X),
        V === J)
            break;
        V = V.return
    }
}
function propagateContextChanges(V, X, J, ne) {
    var ue = V.child;
    for (ue !== null && (ue.return = V); ue !== null; ) {
        var ce = ue.dependencies;
        if (ce !== null) {
            var me = ue.child;
            ce = ce.firstContext;
            e: for (; ce !== null; ) {
                var ge = ce;
                ce = ue;
                for (var Te = 0; Te < X.length; Te++)
                    if (ge.context === X[Te]) {
                        ce.lanes |= J,
                        ge = ce.alternate,
                        ge !== null && (ge.lanes |= J),
                        scheduleContextWorkOnParentPath(ce.return, J, V),
                        ne || (me = null);
                        break e
                    }
                ce = ge.next
            }
        } else if (ue.tag === 18) {
            if (me = ue.return,
            me === null)
                throw Error(formatProdErrorMessage(341));
            me.lanes |= J,
            ce = me.alternate,
            ce !== null && (ce.lanes |= J),
            scheduleContextWorkOnParentPath(me, J, V),
            me = null
        } else
            me = ue.child;
        if (me !== null)
            me.return = ue;
        else
            for (me = ue; me !== null; ) {
                if (me === V) {
                    me = null;
                    break
                }
                if (ue = me.sibling,
                ue !== null) {
                    ue.return = me.return,
                    me = ue;
                    break
                }
                me = me.return
            }
        ue = me
    }
}
function propagateParentContextChanges(V, X, J, ne) {
    V = null;
    for (var ue = X, ce = !1; ue !== null; ) {
        if (!ce) {
            if (ue.flags & 524288)
                ce = !0;
            else if (ue.flags & 262144)
                break
        }
        if (ue.tag === 10) {
            var me = ue.alternate;
            if (me === null)
                throw Error(formatProdErrorMessage(387));
            if (me = me.memoizedProps,
            me !== null) {
                var ge = ue.type;
                objectIs(ue.pendingProps.value, me.value) || (V !== null ? V.push(ge) : V = [ge])
            }
        } else if (ue === hostTransitionProviderCursor.current) {
            if (me = ue.alternate,
            me === null)
                throw Error(formatProdErrorMessage(387));
            me.memoizedState.memoizedState !== ue.memoizedState.memoizedState && (V !== null ? V.push(HostTransitionContext) : V = [HostTransitionContext])
        }
        ue = ue.return
    }
    V !== null && propagateContextChanges(X, V, J, ne),
    X.flags |= 262144
}
function checkIfContextChanged(V) {
    for (V = V.firstContext; V !== null; ) {
        if (!objectIs(V.context._currentValue, V.memoizedValue))
            return !0;
        V = V.next
    }
    return !1
}
function prepareToReadContext(V) {
    currentlyRenderingFiber$1 = V,
    lastContextDependency = null,
    V = V.dependencies,
    V !== null && (V.firstContext = null)
}
function readContext(V) {
    return readContextForConsumer(currentlyRenderingFiber$1, V)
}
function readContextDuringReconciliation(V, X) {
    return currentlyRenderingFiber$1 === null && prepareToReadContext(V),
    readContextForConsumer(V, X)
}
function readContextForConsumer(V, X) {
    var J = X._currentValue;
    if (X = {
        context: X,
        memoizedValue: J,
        next: null
    },
    lastContextDependency === null) {
        if (V === null)
            throw Error(formatProdErrorMessage(308));
        lastContextDependency = X,
        V.dependencies = {
            lanes: 0,
            firstContext: X
        },
        V.flags |= 524288
    } else
        lastContextDependency = lastContextDependency.next = X;
    return J
}
var AbortControllerLocal = typeof AbortController < "u" ? AbortController : function() {
    var V = []
      , X = this.signal = {
        aborted: !1,
        addEventListener: function(J, ne) {
            V.push(ne)
        }
    };
    this.abort = function() {
        X.aborted = !0,
        V.forEach(function(J) {
            return J()
        })
    }
}
  , scheduleCallback$2 = Scheduler.unstable_scheduleCallback
  , NormalPriority = Scheduler.unstable_NormalPriority
  , CacheContext = {
    $$typeof: REACT_CONTEXT_TYPE,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
};
function createCache() {
    return {
        controller: new AbortControllerLocal,
        data: new Map,
        refCount: 0
    }
}
function releaseCache(V) {
    V.refCount--,
    V.refCount === 0 && scheduleCallback$2(NormalPriority, function() {
        V.controller.abort()
    })
}
var currentEntangledListeners = null
  , currentEntangledPendingCount = 0
  , currentEntangledLane = 0
  , currentEntangledActionThenable = null;
function entangleAsyncAction(V, X) {
    if (currentEntangledListeners === null) {
        var J = currentEntangledListeners = [];
        currentEntangledPendingCount = 0,
        currentEntangledLane = requestTransitionLane(),
        currentEntangledActionThenable = {
            status: "pending",
            value: void 0,
            then: function(ne) {
                J.push(ne)
            }
        }
    }
    return currentEntangledPendingCount++,
    X.then(pingEngtangledActionScope, pingEngtangledActionScope),
    X
}
function pingEngtangledActionScope() {
    if (--currentEntangledPendingCount === 0 && currentEntangledListeners !== null) {
        currentEntangledActionThenable !== null && (currentEntangledActionThenable.status = "fulfilled");
        var V = currentEntangledListeners;
        currentEntangledListeners = null,
        currentEntangledLane = 0,
        currentEntangledActionThenable = null;
        for (var X = 0; X < V.length; X++)
            (0,
            V[X])()
    }
}
function chainThenableValue(V, X) {
    var J = []
      , ne = {
        status: "pending",
        value: null,
        reason: null,
        then: function(ue) {
            J.push(ue)
        }
    };
    return V.then(function() {
        ne.status = "fulfilled",
        ne.value = X;
        for (var ue = 0; ue < J.length; ue++)
            (0,
            J[ue])(X)
    }, function(ue) {
        for (ne.status = "rejected",
        ne.reason = ue,
        ue = 0; ue < J.length; ue++)
            (0,
            J[ue])(void 0)
    }),
    ne
}
var prevOnStartTransitionFinish = ReactSharedInternals.S;
ReactSharedInternals.S = function(V, X) {
    typeof X == "object" && X !== null && typeof X.then == "function" && entangleAsyncAction(V, X),
    prevOnStartTransitionFinish !== null && prevOnStartTransitionFinish(V, X)
}
;
var resumedCache = createCursor(null);
function peekCacheFromPool() {
    var V = resumedCache.current;
    return V !== null ? V : workInProgressRoot.pooledCache
}
function pushTransition(V, X) {
    X === null ? push$1(resumedCache, resumedCache.current) : push$1(resumedCache, X.pool)
}
function getSuspendedCache() {
    var V = peekCacheFromPool();
    return V === null ? null : {
        parent: CacheContext._currentValue,
        pool: V
    }
}
var SuspenseException = Error(formatProdErrorMessage(460))
  , SuspenseyCommitException = Error(formatProdErrorMessage(474))
  , SuspenseActionException = Error(formatProdErrorMessage(542))
  , noopSuspenseyCommitThenable = {
    then: function() {}
};
function isThenableResolved(V) {
    return V = V.status,
    V === "fulfilled" || V === "rejected"
}
function noop$3() {}
function trackUsedThenable(V, X, J) {
    switch (J = V[J],
    J === void 0 ? V.push(X) : J !== X && (X.then(noop$3, noop$3),
    X = J),
    X.status) {
    case "fulfilled":
        return X.value;
    case "rejected":
        throw V = X.reason,
        checkIfUseWrappedInAsyncCatch(V),
        V;
    default:
        if (typeof X.status == "string")
            X.then(noop$3, noop$3);
        else {
            if (V = workInProgressRoot,
            V !== null && 100 < V.shellSuspendCounter)
                throw Error(formatProdErrorMessage(482));
            V = X,
            V.status = "pending",
            V.then(function(ne) {
                if (X.status === "pending") {
                    var ue = X;
                    ue.status = "fulfilled",
                    ue.value = ne
                }
            }, function(ne) {
                if (X.status === "pending") {
                    var ue = X;
                    ue.status = "rejected",
                    ue.reason = ne
                }
            })
        }
        switch (X.status) {
        case "fulfilled":
            return X.value;
        case "rejected":
            throw V = X.reason,
            checkIfUseWrappedInAsyncCatch(V),
            V
        }
        throw suspendedThenable = X,
        SuspenseException
    }
}
var suspendedThenable = null;
function getSuspendedThenable() {
    if (suspendedThenable === null)
        throw Error(formatProdErrorMessage(459));
    var V = suspendedThenable;
    return suspendedThenable = null,
    V
}
function checkIfUseWrappedInAsyncCatch(V) {
    if (V === SuspenseException || V === SuspenseActionException)
        throw Error(formatProdErrorMessage(483))
}
var hasForceUpdate = !1;
function initializeUpdateQueue(V) {
    V.updateQueue = {
        baseState: V.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            lanes: 0,
            hiddenCallbacks: null
        },
        callbacks: null
    }
}
function cloneUpdateQueue(V, X) {
    V = V.updateQueue,
    X.updateQueue === V && (X.updateQueue = {
        baseState: V.baseState,
        firstBaseUpdate: V.firstBaseUpdate,
        lastBaseUpdate: V.lastBaseUpdate,
        shared: V.shared,
        callbacks: null
    })
}
function createUpdate(V) {
    return {
        lane: V,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}
function enqueueUpdate(V, X, J) {
    var ne = V.updateQueue;
    if (ne === null)
        return null;
    if (ne = ne.shared,
    executionContext & 2) {
        var ue = ne.pending;
        return ue === null ? X.next = X : (X.next = ue.next,
        ue.next = X),
        ne.pending = X,
        X = getRootForUpdatedFiber(V),
        markUpdateLaneFromFiberToRoot(V, null, J),
        X
    }
    return enqueueUpdate$1(V, ne, X, J),
    getRootForUpdatedFiber(V)
}
function entangleTransitions(V, X, J) {
    if (X = X.updateQueue,
    X !== null && (X = X.shared,
    (J & 4194048) !== 0)) {
        var ne = X.lanes;
        ne &= V.pendingLanes,
        J |= ne,
        X.lanes = J,
        markRootEntangled(V, J)
    }
}
function enqueueCapturedUpdate(V, X) {
    var J = V.updateQueue
      , ne = V.alternate;
    if (ne !== null && (ne = ne.updateQueue,
    J === ne)) {
        var ue = null
          , ce = null;
        if (J = J.firstBaseUpdate,
        J !== null) {
            do {
                var me = {
                    lane: J.lane,
                    tag: J.tag,
                    payload: J.payload,
                    callback: null,
                    next: null
                };
                ce === null ? ue = ce = me : ce = ce.next = me,
                J = J.next
            } while (J !== null);
            ce === null ? ue = ce = X : ce = ce.next = X
        } else
            ue = ce = X;
        J = {
            baseState: ne.baseState,
            firstBaseUpdate: ue,
            lastBaseUpdate: ce,
            shared: ne.shared,
            callbacks: ne.callbacks
        },
        V.updateQueue = J;
        return
    }
    V = J.lastBaseUpdate,
    V === null ? J.firstBaseUpdate = X : V.next = X,
    J.lastBaseUpdate = X
}
var didReadFromEntangledAsyncAction = !1;
function suspendIfUpdateReadFromEntangledAsyncAction() {
    if (didReadFromEntangledAsyncAction) {
        var V = currentEntangledActionThenable;
        if (V !== null)
            throw V
    }
}
function processUpdateQueue(V, X, J, ne) {
    didReadFromEntangledAsyncAction = !1;
    var ue = V.updateQueue;
    hasForceUpdate = !1;
    var ce = ue.firstBaseUpdate
      , me = ue.lastBaseUpdate
      , ge = ue.shared.pending;
    if (ge !== null) {
        ue.shared.pending = null;
        var Te = ge
          , _e = Te.next;
        Te.next = null,
        me === null ? ce = _e : me.next = _e,
        me = Te;
        var Se = V.alternate;
        Se !== null && (Se = Se.updateQueue,
        ge = Se.lastBaseUpdate,
        ge !== me && (ge === null ? Se.firstBaseUpdate = _e : ge.next = _e,
        Se.lastBaseUpdate = Te))
    }
    if (ce !== null) {
        var Ie = ue.baseState;
        me = 0,
        Se = _e = Te = null,
        ge = ce;
        do {
            var ye = ge.lane & -536870913
              , $e = ye !== ge.lane;
            if ($e ? (workInProgressRootRenderLanes & ye) === ye : (ne & ye) === ye) {
                ye !== 0 && ye === currentEntangledLane && (didReadFromEntangledAsyncAction = !0),
                Se !== null && (Se = Se.next = {
                    lane: 0,
                    tag: ge.tag,
                    payload: ge.payload,
                    callback: null,
                    next: null
                });
                e: {
                    var Ne = V
                      , ve = ge;
                    ye = X;
                    var ke = J;
                    switch (ve.tag) {
                    case 1:
                        if (Ne = ve.payload,
                        typeof Ne == "function") {
                            Ie = Ne.call(ke, Ie, ye);
                            break e
                        }
                        Ie = Ne;
                        break e;
                    case 3:
                        Ne.flags = Ne.flags & -65537 | 128;
                    case 0:
                        if (Ne = ve.payload,
                        ye = typeof Ne == "function" ? Ne.call(ke, Ie, ye) : Ne,
                        ye == null)
                            break e;
                        Ie = assign({}, Ie, ye);
                        break e;
                    case 2:
                        hasForceUpdate = !0
                    }
                }
                ye = ge.callback,
                ye !== null && (V.flags |= 64,
                $e && (V.flags |= 8192),
                $e = ue.callbacks,
                $e === null ? ue.callbacks = [ye] : $e.push(ye))
            } else
                $e = {
                    lane: ye,
                    tag: ge.tag,
                    payload: ge.payload,
                    callback: ge.callback,
                    next: null
                },
                Se === null ? (_e = Se = $e,
                Te = Ie) : Se = Se.next = $e,
                me |= ye;
            if (ge = ge.next,
            ge === null) {
                if (ge = ue.shared.pending,
                ge === null)
                    break;
                $e = ge,
                ge = $e.next,
                $e.next = null,
                ue.lastBaseUpdate = $e,
                ue.shared.pending = null
            }
        } while (!0);
        Se === null && (Te = Ie),
        ue.baseState = Te,
        ue.firstBaseUpdate = _e,
        ue.lastBaseUpdate = Se,
        ce === null && (ue.shared.lanes = 0),
        workInProgressRootSkippedLanes |= me,
        V.lanes = me,
        V.memoizedState = Ie
    }
}
function callCallback(V, X) {
    if (typeof V != "function")
        throw Error(formatProdErrorMessage(191, V));
    V.call(X)
}
function commitCallbacks(V, X) {
    var J = V.callbacks;
    if (J !== null)
        for (V.callbacks = null,
        V = 0; V < J.length; V++)
            callCallback(J[V], X)
}
var currentTreeHiddenStackCursor = createCursor(null)
  , prevEntangledRenderLanesCursor = createCursor(0);
function pushHiddenContext(V, X) {
    V = entangledRenderLanes,
    push$1(prevEntangledRenderLanesCursor, V),
    push$1(currentTreeHiddenStackCursor, X),
    entangledRenderLanes = V | X.baseLanes
}
function reuseHiddenContextOnStack() {
    push$1(prevEntangledRenderLanesCursor, entangledRenderLanes),
    push$1(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current)
}
function popHiddenContext() {
    entangledRenderLanes = prevEntangledRenderLanesCursor.current,
    pop(currentTreeHiddenStackCursor),
    pop(prevEntangledRenderLanesCursor)
}
var renderLanes = 0
  , currentlyRenderingFiber = null
  , currentHook = null
  , workInProgressHook = null
  , didScheduleRenderPhaseUpdate = !1
  , didScheduleRenderPhaseUpdateDuringThisPass = !1
  , shouldDoubleInvokeUserFnsInHooksDEV = !1
  , localIdCounter = 0
  , thenableIndexCounter$1 = 0
  , thenableState$1 = null
  , globalClientIdCounter = 0;
function throwInvalidHookError() {
    throw Error(formatProdErrorMessage(321))
}
function areHookInputsEqual(V, X) {
    if (X === null)
        return !1;
    for (var J = 0; J < X.length && J < V.length; J++)
        if (!objectIs(V[J], X[J]))
            return !1;
    return !0
}
function renderWithHooks(V, X, J, ne, ue, ce) {
    return renderLanes = ce,
    currentlyRenderingFiber = X,
    X.memoizedState = null,
    X.updateQueue = null,
    X.lanes = 0,
    ReactSharedInternals.H = V === null || V.memoizedState === null ? HooksDispatcherOnMount : HooksDispatcherOnUpdate,
    shouldDoubleInvokeUserFnsInHooksDEV = !1,
    ce = J(ne, ue),
    shouldDoubleInvokeUserFnsInHooksDEV = !1,
    didScheduleRenderPhaseUpdateDuringThisPass && (ce = renderWithHooksAgain(X, J, ne, ue)),
    finishRenderingHooks(V),
    ce
}
function finishRenderingHooks(V) {
    ReactSharedInternals.H = ContextOnlyDispatcher;
    var X = currentHook !== null && currentHook.next !== null;
    if (renderLanes = 0,
    workInProgressHook = currentHook = currentlyRenderingFiber = null,
    didScheduleRenderPhaseUpdate = !1,
    thenableIndexCounter$1 = 0,
    thenableState$1 = null,
    X)
        throw Error(formatProdErrorMessage(300));
    V === null || didReceiveUpdate || (V = V.dependencies,
    V !== null && checkIfContextChanged(V) && (didReceiveUpdate = !0))
}
function renderWithHooksAgain(V, X, J, ne) {
    currentlyRenderingFiber = V;
    var ue = 0;
    do {
        if (didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null),
        thenableIndexCounter$1 = 0,
        didScheduleRenderPhaseUpdateDuringThisPass = !1,
        25 <= ue)
            throw Error(formatProdErrorMessage(301));
        if (ue += 1,
        workInProgressHook = currentHook = null,
        V.updateQueue != null) {
            var ce = V.updateQueue;
            ce.lastEffect = null,
            ce.events = null,
            ce.stores = null,
            ce.memoCache != null && (ce.memoCache.index = 0)
        }
        ReactSharedInternals.H = HooksDispatcherOnRerender,
        ce = X(J, ne)
    } while (didScheduleRenderPhaseUpdateDuringThisPass);
    return ce
}
function TransitionAwareHostComponent() {
    var V = ReactSharedInternals.H
      , X = V.useState()[0];
    return X = typeof X.then == "function" ? useThenable(X) : X,
    V = V.useState()[0],
    (currentHook !== null ? currentHook.memoizedState : null) !== V && (currentlyRenderingFiber.flags |= 1024),
    X
}
function checkDidRenderIdHook() {
    var V = localIdCounter !== 0;
    return localIdCounter = 0,
    V
}
function bailoutHooks(V, X, J) {
    X.updateQueue = V.updateQueue,
    X.flags &= -2053,
    V.lanes &= ~J
}
function resetHooksOnUnwind(V) {
    if (didScheduleRenderPhaseUpdate) {
        for (V = V.memoizedState; V !== null; ) {
            var X = V.queue;
            X !== null && (X.pending = null),
            V = V.next
        }
        didScheduleRenderPhaseUpdate = !1
    }
    renderLanes = 0,
    workInProgressHook = currentHook = currentlyRenderingFiber = null,
    didScheduleRenderPhaseUpdateDuringThisPass = !1,
    thenableIndexCounter$1 = localIdCounter = 0,
    thenableState$1 = null
}
function mountWorkInProgressHook() {
    var V = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return workInProgressHook === null ? currentlyRenderingFiber.memoizedState = workInProgressHook = V : workInProgressHook = workInProgressHook.next = V,
    workInProgressHook
}
function updateWorkInProgressHook() {
    if (currentHook === null) {
        var V = currentlyRenderingFiber.alternate;
        V = V !== null ? V.memoizedState : null
    } else
        V = currentHook.next;
    var X = workInProgressHook === null ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
    if (X !== null)
        workInProgressHook = X,
        currentHook = V;
    else {
        if (V === null)
            throw currentlyRenderingFiber.alternate === null ? Error(formatProdErrorMessage(467)) : Error(formatProdErrorMessage(310));
        currentHook = V,
        V = {
            memoizedState: currentHook.memoizedState,
            baseState: currentHook.baseState,
            baseQueue: currentHook.baseQueue,
            queue: currentHook.queue,
            next: null
        },
        workInProgressHook === null ? currentlyRenderingFiber.memoizedState = workInProgressHook = V : workInProgressHook = workInProgressHook.next = V
    }
    return workInProgressHook
}
function createFunctionComponentUpdateQueue() {
    return {
        lastEffect: null,
        events: null,
        stores: null,
        memoCache: null
    }
}
function useThenable(V) {
    var X = thenableIndexCounter$1;
    return thenableIndexCounter$1 += 1,
    thenableState$1 === null && (thenableState$1 = []),
    V = trackUsedThenable(thenableState$1, V, X),
    X = currentlyRenderingFiber,
    (workInProgressHook === null ? X.memoizedState : workInProgressHook.next) === null && (X = X.alternate,
    ReactSharedInternals.H = X === null || X.memoizedState === null ? HooksDispatcherOnMount : HooksDispatcherOnUpdate),
    V
}
function use$1(V) {
    if (V !== null && typeof V == "object") {
        if (typeof V.then == "function")
            return useThenable(V);
        if (V.$$typeof === REACT_CONTEXT_TYPE)
            return readContext(V)
    }
    throw Error(formatProdErrorMessage(438, String(V)))
}
function useMemoCache(V) {
    var X = null
      , J = currentlyRenderingFiber.updateQueue;
    if (J !== null && (X = J.memoCache),
    X == null) {
        var ne = currentlyRenderingFiber.alternate;
        ne !== null && (ne = ne.updateQueue,
        ne !== null && (ne = ne.memoCache,
        ne != null && (X = {
            data: ne.data.map(function(ue) {
                return ue.slice()
            }),
            index: 0
        })))
    }
    if (X == null && (X = {
        data: [],
        index: 0
    }),
    J === null && (J = createFunctionComponentUpdateQueue(),
    currentlyRenderingFiber.updateQueue = J),
    J.memoCache = X,
    J = X.data[X.index],
    J === void 0)
        for (J = X.data[X.index] = Array(V),
        ne = 0; ne < V; ne++)
            J[ne] = REACT_MEMO_CACHE_SENTINEL;
    return X.index++,
    J
}
function basicStateReducer(V, X) {
    return typeof X == "function" ? X(V) : X
}
function updateReducer(V) {
    var X = updateWorkInProgressHook();
    return updateReducerImpl(X, currentHook, V)
}
function updateReducerImpl(V, X, J) {
    var ne = V.queue;
    if (ne === null)
        throw Error(formatProdErrorMessage(311));
    ne.lastRenderedReducer = J;
    var ue = V.baseQueue
      , ce = ne.pending;
    if (ce !== null) {
        if (ue !== null) {
            var me = ue.next;
            ue.next = ce.next,
            ce.next = me
        }
        X.baseQueue = ue = ce,
        ne.pending = null
    }
    if (ce = V.baseState,
    ue === null)
        V.memoizedState = ce;
    else {
        X = ue.next;
        var ge = me = null
          , Te = null
          , _e = X
          , Se = !1;
        do {
            var Ie = _e.lane & -536870913;
            if (Ie !== _e.lane ? (workInProgressRootRenderLanes & Ie) === Ie : (renderLanes & Ie) === Ie) {
                var ye = _e.revertLane;
                if (ye === 0)
                    Te !== null && (Te = Te.next = {
                        lane: 0,
                        revertLane: 0,
                        action: _e.action,
                        hasEagerState: _e.hasEagerState,
                        eagerState: _e.eagerState,
                        next: null
                    }),
                    Ie === currentEntangledLane && (Se = !0);
                else if ((renderLanes & ye) === ye) {
                    _e = _e.next,
                    ye === currentEntangledLane && (Se = !0);
                    continue
                } else
                    Ie = {
                        lane: 0,
                        revertLane: _e.revertLane,
                        action: _e.action,
                        hasEagerState: _e.hasEagerState,
                        eagerState: _e.eagerState,
                        next: null
                    },
                    Te === null ? (ge = Te = Ie,
                    me = ce) : Te = Te.next = Ie,
                    currentlyRenderingFiber.lanes |= ye,
                    workInProgressRootSkippedLanes |= ye;
                Ie = _e.action,
                shouldDoubleInvokeUserFnsInHooksDEV && J(ce, Ie),
                ce = _e.hasEagerState ? _e.eagerState : J(ce, Ie)
            } else
                ye = {
                    lane: Ie,
                    revertLane: _e.revertLane,
                    action: _e.action,
                    hasEagerState: _e.hasEagerState,
                    eagerState: _e.eagerState,
                    next: null
                },
                Te === null ? (ge = Te = ye,
                me = ce) : Te = Te.next = ye,
                currentlyRenderingFiber.lanes |= Ie,
                workInProgressRootSkippedLanes |= Ie;
            _e = _e.next
        } while (_e !== null && _e !== X);
        if (Te === null ? me = ce : Te.next = ge,
        !objectIs(ce, V.memoizedState) && (didReceiveUpdate = !0,
        Se && (J = currentEntangledActionThenable,
        J !== null)))
            throw J;
        V.memoizedState = ce,
        V.baseState = me,
        V.baseQueue = Te,
        ne.lastRenderedState = ce
    }
    return ue === null && (ne.lanes = 0),
    [V.memoizedState, ne.dispatch]
}
function rerenderReducer(V) {
    var X = updateWorkInProgressHook()
      , J = X.queue;
    if (J === null)
        throw Error(formatProdErrorMessage(311));
    J.lastRenderedReducer = V;
    var ne = J.dispatch
      , ue = J.pending
      , ce = X.memoizedState;
    if (ue !== null) {
        J.pending = null;
        var me = ue = ue.next;
        do
            ce = V(ce, me.action),
            me = me.next;
        while (me !== ue);
        objectIs(ce, X.memoizedState) || (didReceiveUpdate = !0),
        X.memoizedState = ce,
        X.baseQueue === null && (X.baseState = ce),
        J.lastRenderedState = ce
    }
    return [ce, ne]
}
function updateSyncExternalStore(V, X, J) {
    var ne = currentlyRenderingFiber
      , ue = updateWorkInProgressHook()
      , ce = isHydrating;
    if (ce) {
        if (J === void 0)
            throw Error(formatProdErrorMessage(407));
        J = J()
    } else
        J = X();
    var me = !objectIs((currentHook || ue).memoizedState, J);
    me && (ue.memoizedState = J,
    didReceiveUpdate = !0),
    ue = ue.queue;
    var ge = subscribeToStore.bind(null, ne, ue, V);
    if (updateEffectImpl(2048, 8, ge, [V]),
    ue.getSnapshot !== X || me || workInProgressHook !== null && workInProgressHook.memoizedState.tag & 1) {
        if (ne.flags |= 2048,
        pushSimpleEffect(9, createEffectInstance(), updateStoreInstance.bind(null, ne, ue, J, X), null),
        workInProgressRoot === null)
            throw Error(formatProdErrorMessage(349));
        ce || renderLanes & 124 || pushStoreConsistencyCheck(ne, X, J)
    }
    return J
}
function pushStoreConsistencyCheck(V, X, J) {
    V.flags |= 16384,
    V = {
        getSnapshot: X,
        value: J
    },
    X = currentlyRenderingFiber.updateQueue,
    X === null ? (X = createFunctionComponentUpdateQueue(),
    currentlyRenderingFiber.updateQueue = X,
    X.stores = [V]) : (J = X.stores,
    J === null ? X.stores = [V] : J.push(V))
}
function updateStoreInstance(V, X, J, ne) {
    X.value = J,
    X.getSnapshot = ne,
    checkIfSnapshotChanged(X) && forceStoreRerender(V)
}
function subscribeToStore(V, X, J) {
    return J(function() {
        checkIfSnapshotChanged(X) && forceStoreRerender(V)
    })
}
function checkIfSnapshotChanged(V) {
    var X = V.getSnapshot;
    V = V.value;
    try {
        var J = X();
        return !objectIs(V, J)
    } catch {
        return !0
    }
}
function forceStoreRerender(V) {
    var X = enqueueConcurrentRenderForLane(V, 2);
    X !== null && scheduleUpdateOnFiber(X, V, 2)
}
function mountStateImpl(V) {
    var X = mountWorkInProgressHook();
    if (typeof V == "function") {
        var J = V;
        if (V = J(),
        shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(!0);
            try {
                J()
            } finally {
                setIsStrictModeForDevtools(!1)
            }
        }
    }
    return X.memoizedState = X.baseState = V,
    X.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: basicStateReducer,
        lastRenderedState: V
    },
    X
}
function updateOptimisticImpl(V, X, J, ne) {
    return V.baseState = J,
    updateReducerImpl(V, currentHook, typeof ne == "function" ? ne : basicStateReducer)
}
function dispatchActionState(V, X, J, ne, ue) {
    if (isRenderPhaseUpdate(V))
        throw Error(formatProdErrorMessage(485));
    if (V = X.action,
    V !== null) {
        var ce = {
            payload: ue,
            action: V,
            next: null,
            isTransition: !0,
            status: "pending",
            value: null,
            reason: null,
            listeners: [],
            then: function(me) {
                ce.listeners.push(me)
            }
        };
        ReactSharedInternals.T !== null ? J(!0) : ce.isTransition = !1,
        ne(ce),
        J = X.pending,
        J === null ? (ce.next = X.pending = ce,
        runActionStateAction(X, ce)) : (ce.next = J.next,
        X.pending = J.next = ce)
    }
}
function runActionStateAction(V, X) {
    var J = X.action
      , ne = X.payload
      , ue = V.state;
    if (X.isTransition) {
        var ce = ReactSharedInternals.T
          , me = {};
        ReactSharedInternals.T = me;
        try {
            var ge = J(ue, ne)
              , Te = ReactSharedInternals.S;
            Te !== null && Te(me, ge),
            handleActionReturnValue(V, X, ge)
        } catch (_e) {
            onActionError(V, X, _e)
        } finally {
            ReactSharedInternals.T = ce
        }
    } else
        try {
            ce = J(ue, ne),
            handleActionReturnValue(V, X, ce)
        } catch (_e) {
            onActionError(V, X, _e)
        }
}
function handleActionReturnValue(V, X, J) {
    J !== null && typeof J == "object" && typeof J.then == "function" ? J.then(function(ne) {
        onActionSuccess(V, X, ne)
    }, function(ne) {
        return onActionError(V, X, ne)
    }) : onActionSuccess(V, X, J)
}
function onActionSuccess(V, X, J) {
    X.status = "fulfilled",
    X.value = J,
    notifyActionListeners(X),
    V.state = J,
    X = V.pending,
    X !== null && (J = X.next,
    J === X ? V.pending = null : (J = J.next,
    X.next = J,
    runActionStateAction(V, J)))
}
function onActionError(V, X, J) {
    var ne = V.pending;
    if (V.pending = null,
    ne !== null) {
        ne = ne.next;
        do
            X.status = "rejected",
            X.reason = J,
            notifyActionListeners(X),
            X = X.next;
        while (X !== ne)
    }
    V.action = null
}
function notifyActionListeners(V) {
    V = V.listeners;
    for (var X = 0; X < V.length; X++)
        (0,
        V[X])()
}
function actionStateReducer(V, X) {
    return X
}
function mountActionState(V, X) {
    if (isHydrating) {
        var J = workInProgressRoot.formState;
        if (J !== null) {
            e: {
                var ne = currentlyRenderingFiber;
                if (isHydrating) {
                    if (nextHydratableInstance) {
                        t: {
                            for (var ue = nextHydratableInstance, ce = rootOrSingletonContext; ue.nodeType !== 8; ) {
                                if (!ce) {
                                    ue = null;
                                    break t
                                }
                                if (ue = getNextHydratable(ue.nextSibling),
                                ue === null) {
                                    ue = null;
                                    break t
                                }
                            }
                            ce = ue.data,
                            ue = ce === "F!" || ce === "F" ? ue : null
                        }
                        if (ue) {
                            nextHydratableInstance = getNextHydratable(ue.nextSibling),
                            ne = ue.data === "F!";
                            break e
                        }
                    }
                    throwOnHydrationMismatch(ne)
                }
                ne = !1
            }
            ne && (X = J[0])
        }
    }
    return J = mountWorkInProgressHook(),
    J.memoizedState = J.baseState = X,
    ne = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: actionStateReducer,
        lastRenderedState: X
    },
    J.queue = ne,
    J = dispatchSetState.bind(null, currentlyRenderingFiber, ne),
    ne.dispatch = J,
    ne = mountStateImpl(!1),
    ce = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber, !1, ne.queue),
    ne = mountWorkInProgressHook(),
    ue = {
        state: X,
        dispatch: null,
        action: V,
        pending: null
    },
    ne.queue = ue,
    J = dispatchActionState.bind(null, currentlyRenderingFiber, ue, ce, J),
    ue.dispatch = J,
    ne.memoizedState = V,
    [X, J, !1]
}
function updateActionState(V) {
    var X = updateWorkInProgressHook();
    return updateActionStateImpl(X, currentHook, V)
}
function updateActionStateImpl(V, X, J) {
    if (X = updateReducerImpl(V, X, actionStateReducer)[0],
    V = updateReducer(basicStateReducer)[0],
    typeof X == "object" && X !== null && typeof X.then == "function")
        try {
            var ne = useThenable(X)
        } catch (me) {
            throw me === SuspenseException ? SuspenseActionException : me
        }
    else
        ne = X;
    X = updateWorkInProgressHook();
    var ue = X.queue
      , ce = ue.dispatch;
    return J !== X.memoizedState && (currentlyRenderingFiber.flags |= 2048,
    pushSimpleEffect(9, createEffectInstance(), actionStateActionEffect.bind(null, ue, J), null)),
    [ne, ce, V]
}
function actionStateActionEffect(V, X) {
    V.action = X
}
function rerenderActionState(V) {
    var X = updateWorkInProgressHook()
      , J = currentHook;
    if (J !== null)
        return updateActionStateImpl(X, J, V);
    updateWorkInProgressHook(),
    X = X.memoizedState,
    J = updateWorkInProgressHook();
    var ne = J.queue.dispatch;
    return J.memoizedState = V,
    [X, ne, !1]
}
function pushSimpleEffect(V, X, J, ne) {
    return V = {
        tag: V,
        create: J,
        deps: ne,
        inst: X,
        next: null
    },
    X = currentlyRenderingFiber.updateQueue,
    X === null && (X = createFunctionComponentUpdateQueue(),
    currentlyRenderingFiber.updateQueue = X),
    J = X.lastEffect,
    J === null ? X.lastEffect = V.next = V : (ne = J.next,
    J.next = V,
    V.next = ne,
    X.lastEffect = V),
    V
}
function createEffectInstance() {
    return {
        destroy: void 0,
        resource: void 0
    }
}
function updateRef() {
    return updateWorkInProgressHook().memoizedState
}
function mountEffectImpl(V, X, J, ne) {
    var ue = mountWorkInProgressHook();
    ne = ne === void 0 ? null : ne,
    currentlyRenderingFiber.flags |= V,
    ue.memoizedState = pushSimpleEffect(1 | X, createEffectInstance(), J, ne)
}
function updateEffectImpl(V, X, J, ne) {
    var ue = updateWorkInProgressHook();
    ne = ne === void 0 ? null : ne;
    var ce = ue.memoizedState.inst;
    currentHook !== null && ne !== null && areHookInputsEqual(ne, currentHook.memoizedState.deps) ? ue.memoizedState = pushSimpleEffect(X, ce, J, ne) : (currentlyRenderingFiber.flags |= V,
    ue.memoizedState = pushSimpleEffect(1 | X, ce, J, ne))
}
function mountEffect(V, X) {
    mountEffectImpl(8390656, 8, V, X)
}
function updateEffect(V, X) {
    updateEffectImpl(2048, 8, V, X)
}
function updateInsertionEffect(V, X) {
    return updateEffectImpl(4, 2, V, X)
}
function updateLayoutEffect(V, X) {
    return updateEffectImpl(4, 4, V, X)
}
function imperativeHandleEffect(V, X) {
    if (typeof X == "function") {
        V = V();
        var J = X(V);
        return function() {
            typeof J == "function" ? J() : X(null)
        }
    }
    if (X != null)
        return V = V(),
        X.current = V,
        function() {
            X.current = null
        }
}
function updateImperativeHandle(V, X, J) {
    J = J != null ? J.concat([V]) : null,
    updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, X, V), J)
}
function mountDebugValue() {}
function updateCallback(V, X) {
    var J = updateWorkInProgressHook();
    X = X === void 0 ? null : X;
    var ne = J.memoizedState;
    return X !== null && areHookInputsEqual(X, ne[1]) ? ne[0] : (J.memoizedState = [V, X],
    V)
}
function updateMemo(V, X) {
    var J = updateWorkInProgressHook();
    X = X === void 0 ? null : X;
    var ne = J.memoizedState;
    if (X !== null && areHookInputsEqual(X, ne[1]))
        return ne[0];
    if (ne = V(),
    shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(!0);
        try {
            V()
        } finally {
            setIsStrictModeForDevtools(!1)
        }
    }
    return J.memoizedState = [ne, X],
    ne
}
function mountDeferredValueImpl(V, X, J) {
    return J === void 0 || renderLanes & 1073741824 ? V.memoizedState = X : (V.memoizedState = J,
    V = requestDeferredLane(),
    currentlyRenderingFiber.lanes |= V,
    workInProgressRootSkippedLanes |= V,
    J)
}
function updateDeferredValueImpl(V, X, J, ne) {
    return objectIs(J, X) ? J : currentTreeHiddenStackCursor.current !== null ? (V = mountDeferredValueImpl(V, J, ne),
    objectIs(V, X) || (didReceiveUpdate = !0),
    V) : renderLanes & 42 ? (V = requestDeferredLane(),
    currentlyRenderingFiber.lanes |= V,
    workInProgressRootSkippedLanes |= V,
    X) : (didReceiveUpdate = !0,
    V.memoizedState = J)
}
function startTransition(V, X, J, ne, ue) {
    var ce = ReactDOMSharedInternals.p;
    ReactDOMSharedInternals.p = ce !== 0 && 8 > ce ? ce : 8;
    var me = ReactSharedInternals.T
      , ge = {};
    ReactSharedInternals.T = ge,
    dispatchOptimisticSetState(V, !1, X, J);
    try {
        var Te = ue()
          , _e = ReactSharedInternals.S;
        if (_e !== null && _e(ge, Te),
        Te !== null && typeof Te == "object" && typeof Te.then == "function") {
            var Se = chainThenableValue(Te, ne);
            dispatchSetStateInternal(V, X, Se, requestUpdateLane(V))
        } else
            dispatchSetStateInternal(V, X, ne, requestUpdateLane(V))
    } catch (Ie) {
        dispatchSetStateInternal(V, X, {
            then: function() {},
            status: "rejected",
            reason: Ie
        }, requestUpdateLane())
    } finally {
        ReactDOMSharedInternals.p = ce,
        ReactSharedInternals.T = me
    }
}
function noop$2() {}
function startHostTransition(V, X, J, ne) {
    if (V.tag !== 5)
        throw Error(formatProdErrorMessage(476));
    var ue = ensureFormComponentIsStateful(V).queue;
    startTransition(V, ue, X, sharedNotPendingObject, J === null ? noop$2 : function() {
        return requestFormReset$1(V),
        J(ne)
    }
    )
}
function ensureFormComponentIsStateful(V) {
    var X = V.memoizedState;
    if (X !== null)
        return X;
    X = {
        memoizedState: sharedNotPendingObject,
        baseState: sharedNotPendingObject,
        baseQueue: null,
        queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: sharedNotPendingObject
        },
        next: null
    };
    var J = {};
    return X.next = {
        memoizedState: J,
        baseState: J,
        baseQueue: null,
        queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: J
        },
        next: null
    },
    V.memoizedState = X,
    V = V.alternate,
    V !== null && (V.memoizedState = X),
    X
}
function requestFormReset$1(V) {
    var X = ensureFormComponentIsStateful(V).next.queue;
    dispatchSetStateInternal(V, X, {}, requestUpdateLane())
}
function useHostTransitionStatus() {
    return readContext(HostTransitionContext)
}
function updateId() {
    return updateWorkInProgressHook().memoizedState
}
function updateRefresh() {
    return updateWorkInProgressHook().memoizedState
}
function refreshCache(V) {
    for (var X = V.return; X !== null; ) {
        switch (X.tag) {
        case 24:
        case 3:
            var J = requestUpdateLane();
            V = createUpdate(J);
            var ne = enqueueUpdate(X, V, J);
            ne !== null && (scheduleUpdateOnFiber(ne, X, J),
            entangleTransitions(ne, X, J)),
            X = {
                cache: createCache()
            },
            V.payload = X;
            return
        }
        X = X.return
    }
}
function dispatchReducerAction(V, X, J) {
    var ne = requestUpdateLane();
    J = {
        lane: ne,
        revertLane: 0,
        action: J,
        hasEagerState: !1,
        eagerState: null,
        next: null
    },
    isRenderPhaseUpdate(V) ? enqueueRenderPhaseUpdate(X, J) : (J = enqueueConcurrentHookUpdate(V, X, J, ne),
    J !== null && (scheduleUpdateOnFiber(J, V, ne),
    entangleTransitionUpdate(J, X, ne)))
}
function dispatchSetState(V, X, J) {
    var ne = requestUpdateLane();
    dispatchSetStateInternal(V, X, J, ne)
}
function dispatchSetStateInternal(V, X, J, ne) {
    var ue = {
        lane: ne,
        revertLane: 0,
        action: J,
        hasEagerState: !1,
        eagerState: null,
        next: null
    };
    if (isRenderPhaseUpdate(V))
        enqueueRenderPhaseUpdate(X, ue);
    else {
        var ce = V.alternate;
        if (V.lanes === 0 && (ce === null || ce.lanes === 0) && (ce = X.lastRenderedReducer,
        ce !== null))
            try {
                var me = X.lastRenderedState
                  , ge = ce(me, J);
                if (ue.hasEagerState = !0,
                ue.eagerState = ge,
                objectIs(ge, me))
                    return enqueueUpdate$1(V, X, ue, 0),
                    workInProgressRoot === null && finishQueueingConcurrentUpdates(),
                    !1
            } catch {} finally {}
        if (J = enqueueConcurrentHookUpdate(V, X, ue, ne),
        J !== null)
            return scheduleUpdateOnFiber(J, V, ne),
            entangleTransitionUpdate(J, X, ne),
            !0
    }
    return !1
}
function dispatchOptimisticSetState(V, X, J, ne) {
    if (ne = {
        lane: 2,
        revertLane: requestTransitionLane(),
        action: ne,
        hasEagerState: !1,
        eagerState: null,
        next: null
    },
    isRenderPhaseUpdate(V)) {
        if (X)
            throw Error(formatProdErrorMessage(479))
    } else
        X = enqueueConcurrentHookUpdate(V, J, ne, 2),
        X !== null && scheduleUpdateOnFiber(X, V, 2)
}
function isRenderPhaseUpdate(V) {
    var X = V.alternate;
    return V === currentlyRenderingFiber || X !== null && X === currentlyRenderingFiber
}
function enqueueRenderPhaseUpdate(V, X) {
    didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = !0;
    var J = V.pending;
    J === null ? X.next = X : (X.next = J.next,
    J.next = X),
    V.pending = X
}
function entangleTransitionUpdate(V, X, J) {
    if (J & 4194048) {
        var ne = X.lanes;
        ne &= V.pendingLanes,
        J |= ne,
        X.lanes = J,
        markRootEntangled(V, J)
    }
}
var ContextOnlyDispatcher = {
    readContext,
    use: use$1,
    useCallback: throwInvalidHookError,
    useContext: throwInvalidHookError,
    useEffect: throwInvalidHookError,
    useImperativeHandle: throwInvalidHookError,
    useLayoutEffect: throwInvalidHookError,
    useInsertionEffect: throwInvalidHookError,
    useMemo: throwInvalidHookError,
    useReducer: throwInvalidHookError,
    useRef: throwInvalidHookError,
    useState: throwInvalidHookError,
    useDebugValue: throwInvalidHookError,
    useDeferredValue: throwInvalidHookError,
    useTransition: throwInvalidHookError,
    useSyncExternalStore: throwInvalidHookError,
    useId: throwInvalidHookError,
    useHostTransitionStatus: throwInvalidHookError,
    useFormState: throwInvalidHookError,
    useActionState: throwInvalidHookError,
    useOptimistic: throwInvalidHookError,
    useMemoCache: throwInvalidHookError,
    useCacheRefresh: throwInvalidHookError
}
  , HooksDispatcherOnMount = {
    readContext,
    use: use$1,
    useCallback: function(V, X) {
        return mountWorkInProgressHook().memoizedState = [V, X === void 0 ? null : X],
        V
    },
    useContext: readContext,
    useEffect: mountEffect,
    useImperativeHandle: function(V, X, J) {
        J = J != null ? J.concat([V]) : null,
        mountEffectImpl(4194308, 4, imperativeHandleEffect.bind(null, X, V), J)
    },
    useLayoutEffect: function(V, X) {
        return mountEffectImpl(4194308, 4, V, X)
    },
    useInsertionEffect: function(V, X) {
        mountEffectImpl(4, 2, V, X)
    },
    useMemo: function(V, X) {
        var J = mountWorkInProgressHook();
        X = X === void 0 ? null : X;
        var ne = V();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(!0);
            try {
                V()
            } finally {
                setIsStrictModeForDevtools(!1)
            }
        }
        return J.memoizedState = [ne, X],
        ne
    },
    useReducer: function(V, X, J) {
        var ne = mountWorkInProgressHook();
        if (J !== void 0) {
            var ue = J(X);
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
                setIsStrictModeForDevtools(!0);
                try {
                    J(X)
                } finally {
                    setIsStrictModeForDevtools(!1)
                }
            }
        } else
            ue = X;
        return ne.memoizedState = ne.baseState = ue,
        V = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: V,
            lastRenderedState: ue
        },
        ne.queue = V,
        V = V.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber, V),
        [ne.memoizedState, V]
    },
    useRef: function(V) {
        var X = mountWorkInProgressHook();
        return V = {
            current: V
        },
        X.memoizedState = V
    },
    useState: function(V) {
        V = mountStateImpl(V);
        var X = V.queue
          , J = dispatchSetState.bind(null, currentlyRenderingFiber, X);
        return X.dispatch = J,
        [V.memoizedState, J]
    },
    useDebugValue: mountDebugValue,
    useDeferredValue: function(V, X) {
        var J = mountWorkInProgressHook();
        return mountDeferredValueImpl(J, V, X)
    },
    useTransition: function() {
        var V = mountStateImpl(!1);
        return V = startTransition.bind(null, currentlyRenderingFiber, V.queue, !0, !1),
        mountWorkInProgressHook().memoizedState = V,
        [!1, V]
    },
    useSyncExternalStore: function(V, X, J) {
        var ne = currentlyRenderingFiber
          , ue = mountWorkInProgressHook();
        if (isHydrating) {
            if (J === void 0)
                throw Error(formatProdErrorMessage(407));
            J = J()
        } else {
            if (J = X(),
            workInProgressRoot === null)
                throw Error(formatProdErrorMessage(349));
            workInProgressRootRenderLanes & 124 || pushStoreConsistencyCheck(ne, X, J)
        }
        ue.memoizedState = J;
        var ce = {
            value: J,
            getSnapshot: X
        };
        return ue.queue = ce,
        mountEffect(subscribeToStore.bind(null, ne, ce, V), [V]),
        ne.flags |= 2048,
        pushSimpleEffect(9, createEffectInstance(), updateStoreInstance.bind(null, ne, ce, J, X), null),
        J
    },
    useId: function() {
        var V = mountWorkInProgressHook()
          , X = workInProgressRoot.identifierPrefix;
        if (isHydrating) {
            var J = treeContextOverflow
              , ne = treeContextId;
            J = (ne & ~(1 << 32 - clz32(ne) - 1)).toString(32) + J,
            X = "«" + X + "R" + J,
            J = localIdCounter++,
            0 < J && (X += "H" + J.toString(32)),
            X += "»"
        } else
            J = globalClientIdCounter++,
            X = "«" + X + "r" + J.toString(32) + "»";
        return V.memoizedState = X
    },
    useHostTransitionStatus,
    useFormState: mountActionState,
    useActionState: mountActionState,
    useOptimistic: function(V) {
        var X = mountWorkInProgressHook();
        X.memoizedState = X.baseState = V;
        var J = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: null,
            lastRenderedState: null
        };
        return X.queue = J,
        X = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber, !0, J),
        J.dispatch = X,
        [V, X]
    },
    useMemoCache,
    useCacheRefresh: function() {
        return mountWorkInProgressHook().memoizedState = refreshCache.bind(null, currentlyRenderingFiber)
    }
}
  , HooksDispatcherOnUpdate = {
    readContext,
    use: use$1,
    useCallback: updateCallback,
    useContext: readContext,
    useEffect: updateEffect,
    useImperativeHandle: updateImperativeHandle,
    useInsertionEffect: updateInsertionEffect,
    useLayoutEffect: updateLayoutEffect,
    useMemo: updateMemo,
    useReducer: updateReducer,
    useRef: updateRef,
    useState: function() {
        return updateReducer(basicStateReducer)
    },
    useDebugValue: mountDebugValue,
    useDeferredValue: function(V, X) {
        var J = updateWorkInProgressHook();
        return updateDeferredValueImpl(J, currentHook.memoizedState, V, X)
    },
    useTransition: function() {
        var V = updateReducer(basicStateReducer)[0]
          , X = updateWorkInProgressHook().memoizedState;
        return [typeof V == "boolean" ? V : useThenable(V), X]
    },
    useSyncExternalStore: updateSyncExternalStore,
    useId: updateId,
    useHostTransitionStatus,
    useFormState: updateActionState,
    useActionState: updateActionState,
    useOptimistic: function(V, X) {
        var J = updateWorkInProgressHook();
        return updateOptimisticImpl(J, currentHook, V, X)
    },
    useMemoCache,
    useCacheRefresh: updateRefresh
}
  , HooksDispatcherOnRerender = {
    readContext,
    use: use$1,
    useCallback: updateCallback,
    useContext: readContext,
    useEffect: updateEffect,
    useImperativeHandle: updateImperativeHandle,
    useInsertionEffect: updateInsertionEffect,
    useLayoutEffect: updateLayoutEffect,
    useMemo: updateMemo,
    useReducer: rerenderReducer,
    useRef: updateRef,
    useState: function() {
        return rerenderReducer(basicStateReducer)
    },
    useDebugValue: mountDebugValue,
    useDeferredValue: function(V, X) {
        var J = updateWorkInProgressHook();
        return currentHook === null ? mountDeferredValueImpl(J, V, X) : updateDeferredValueImpl(J, currentHook.memoizedState, V, X)
    },
    useTransition: function() {
        var V = rerenderReducer(basicStateReducer)[0]
          , X = updateWorkInProgressHook().memoizedState;
        return [typeof V == "boolean" ? V : useThenable(V), X]
    },
    useSyncExternalStore: updateSyncExternalStore,
    useId: updateId,
    useHostTransitionStatus,
    useFormState: rerenderActionState,
    useActionState: rerenderActionState,
    useOptimistic: function(V, X) {
        var J = updateWorkInProgressHook();
        return currentHook !== null ? updateOptimisticImpl(J, currentHook, V, X) : (J.baseState = V,
        [V, J.queue.dispatch])
    },
    useMemoCache,
    useCacheRefresh: updateRefresh
}
  , thenableState = null
  , thenableIndexCounter = 0;
function unwrapThenable(V) {
    var X = thenableIndexCounter;
    return thenableIndexCounter += 1,
    thenableState === null && (thenableState = []),
    trackUsedThenable(thenableState, V, X)
}
function coerceRef(V, X) {
    X = X.props.ref,
    V.ref = X !== void 0 ? X : null
}
function throwOnInvalidObjectType(V, X) {
    throw X.$$typeof === REACT_LEGACY_ELEMENT_TYPE ? Error(formatProdErrorMessage(525)) : (V = Object.prototype.toString.call(X),
    Error(formatProdErrorMessage(31, V === "[object Object]" ? "object with keys {" + Object.keys(X).join(", ") + "}" : V)))
}
function resolveLazy(V) {
    var X = V._init;
    return X(V._payload)
}
function createChildReconciler(V) {
    function X(xe, we) {
        if (V) {
            var Fe = xe.deletions;
            Fe === null ? (xe.deletions = [we],
            xe.flags |= 16) : Fe.push(we)
        }
    }
    function J(xe, we) {
        if (!V)
            return null;
        for (; we !== null; )
            X(xe, we),
            we = we.sibling;
        return null
    }
    function ne(xe) {
        for (var we = new Map; xe !== null; )
            xe.key !== null ? we.set(xe.key, xe) : we.set(xe.index, xe),
            xe = xe.sibling;
        return we
    }
    function ue(xe, we) {
        return xe = createWorkInProgress(xe, we),
        xe.index = 0,
        xe.sibling = null,
        xe
    }
    function ce(xe, we, Fe) {
        return xe.index = Fe,
        V ? (Fe = xe.alternate,
        Fe !== null ? (Fe = Fe.index,
        Fe < we ? (xe.flags |= 67108866,
        we) : Fe) : (xe.flags |= 67108866,
        we)) : (xe.flags |= 1048576,
        we)
    }
    function me(xe) {
        return V && xe.alternate === null && (xe.flags |= 67108866),
        xe
    }
    function ge(xe, we, Fe, je) {
        return we === null || we.tag !== 6 ? (we = createFiberFromText(Fe, xe.mode, je),
        we.return = xe,
        we) : (we = ue(we, Fe),
        we.return = xe,
        we)
    }
    function Te(xe, we, Fe, je) {
        var Xe = Fe.type;
        return Xe === REACT_FRAGMENT_TYPE ? Se(xe, we, Fe.props.children, je, Fe.key) : we !== null && (we.elementType === Xe || typeof Xe == "object" && Xe !== null && Xe.$$typeof === REACT_LAZY_TYPE && resolveLazy(Xe) === we.type) ? (we = ue(we, Fe.props),
        coerceRef(we, Fe),
        we.return = xe,
        we) : (we = createFiberFromTypeAndProps(Fe.type, Fe.key, Fe.props, null, xe.mode, je),
        coerceRef(we, Fe),
        we.return = xe,
        we)
    }
    function _e(xe, we, Fe, je) {
        return we === null || we.tag !== 4 || we.stateNode.containerInfo !== Fe.containerInfo || we.stateNode.implementation !== Fe.implementation ? (we = createFiberFromPortal(Fe, xe.mode, je),
        we.return = xe,
        we) : (we = ue(we, Fe.children || []),
        we.return = xe,
        we)
    }
    function Se(xe, we, Fe, je, Xe) {
        return we === null || we.tag !== 7 ? (we = createFiberFromFragment(Fe, xe.mode, je, Xe),
        we.return = xe,
        we) : (we = ue(we, Fe),
        we.return = xe,
        we)
    }
    function Ie(xe, we, Fe) {
        if (typeof we == "string" && we !== "" || typeof we == "number" || typeof we == "bigint")
            return we = createFiberFromText("" + we, xe.mode, Fe),
            we.return = xe,
            we;
        if (typeof we == "object" && we !== null) {
            switch (we.$$typeof) {
            case REACT_ELEMENT_TYPE:
                return Fe = createFiberFromTypeAndProps(we.type, we.key, we.props, null, xe.mode, Fe),
                coerceRef(Fe, we),
                Fe.return = xe,
                Fe;
            case REACT_PORTAL_TYPE:
                return we = createFiberFromPortal(we, xe.mode, Fe),
                we.return = xe,
                we;
            case REACT_LAZY_TYPE:
                var je = we._init;
                return we = je(we._payload),
                Ie(xe, we, Fe)
            }
            if (isArrayImpl(we) || getIteratorFn(we))
                return we = createFiberFromFragment(we, xe.mode, Fe, null),
                we.return = xe,
                we;
            if (typeof we.then == "function")
                return Ie(xe, unwrapThenable(we), Fe);
            if (we.$$typeof === REACT_CONTEXT_TYPE)
                return Ie(xe, readContextDuringReconciliation(xe, we), Fe);
            throwOnInvalidObjectType(xe, we)
        }
        return null
    }
    function ye(xe, we, Fe, je) {
        var Xe = we !== null ? we.key : null;
        if (typeof Fe == "string" && Fe !== "" || typeof Fe == "number" || typeof Fe == "bigint")
            return Xe !== null ? null : ge(xe, we, "" + Fe, je);
        if (typeof Fe == "object" && Fe !== null) {
            switch (Fe.$$typeof) {
            case REACT_ELEMENT_TYPE:
                return Fe.key === Xe ? Te(xe, we, Fe, je) : null;
            case REACT_PORTAL_TYPE:
                return Fe.key === Xe ? _e(xe, we, Fe, je) : null;
            case REACT_LAZY_TYPE:
                return Xe = Fe._init,
                Fe = Xe(Fe._payload),
                ye(xe, we, Fe, je)
            }
            if (isArrayImpl(Fe) || getIteratorFn(Fe))
                return Xe !== null ? null : Se(xe, we, Fe, je, null);
            if (typeof Fe.then == "function")
                return ye(xe, we, unwrapThenable(Fe), je);
            if (Fe.$$typeof === REACT_CONTEXT_TYPE)
                return ye(xe, we, readContextDuringReconciliation(xe, Fe), je);
            throwOnInvalidObjectType(xe, Fe)
        }
        return null
    }
    function $e(xe, we, Fe, je, Xe) {
        if (typeof je == "string" && je !== "" || typeof je == "number" || typeof je == "bigint")
            return xe = xe.get(Fe) || null,
            ge(we, xe, "" + je, Xe);
        if (typeof je == "object" && je !== null) {
            switch (je.$$typeof) {
            case REACT_ELEMENT_TYPE:
                return xe = xe.get(je.key === null ? Fe : je.key) || null,
                Te(we, xe, je, Xe);
            case REACT_PORTAL_TYPE:
                return xe = xe.get(je.key === null ? Fe : je.key) || null,
                _e(we, xe, je, Xe);
            case REACT_LAZY_TYPE:
                var ze = je._init;
                return je = ze(je._payload),
                $e(xe, we, Fe, je, Xe)
            }
            if (isArrayImpl(je) || getIteratorFn(je))
                return xe = xe.get(Fe) || null,
                Se(we, xe, je, Xe, null);
            if (typeof je.then == "function")
                return $e(xe, we, Fe, unwrapThenable(je), Xe);
            if (je.$$typeof === REACT_CONTEXT_TYPE)
                return $e(xe, we, Fe, readContextDuringReconciliation(we, je), Xe);
            throwOnInvalidObjectType(we, je)
        }
        return null
    }
    function Ne(xe, we, Fe, je) {
        for (var Xe = null, ze = null, qe = we, Ze = we = 0, et = null; qe !== null && Ze < Fe.length; Ze++) {
            qe.index > Ze ? (et = qe,
            qe = null) : et = qe.sibling;
            var it = ye(xe, qe, Fe[Ze], je);
            if (it === null) {
                qe === null && (qe = et);
                break
            }
            V && qe && it.alternate === null && X(xe, qe),
            we = ce(it, we, Ze),
            ze === null ? Xe = it : ze.sibling = it,
            ze = it,
            qe = et
        }
        if (Ze === Fe.length)
            return J(xe, qe),
            isHydrating && pushTreeFork(xe, Ze),
            Xe;
        if (qe === null) {
            for (; Ze < Fe.length; Ze++)
                qe = Ie(xe, Fe[Ze], je),
                qe !== null && (we = ce(qe, we, Ze),
                ze === null ? Xe = qe : ze.sibling = qe,
                ze = qe);
            return isHydrating && pushTreeFork(xe, Ze),
            Xe
        }
        for (qe = ne(qe); Ze < Fe.length; Ze++)
            et = $e(qe, xe, Ze, Fe[Ze], je),
            et !== null && (V && et.alternate !== null && qe.delete(et.key === null ? Ze : et.key),
            we = ce(et, we, Ze),
            ze === null ? Xe = et : ze.sibling = et,
            ze = et);
        return V && qe.forEach(function(at) {
            return X(xe, at)
        }),
        isHydrating && pushTreeFork(xe, Ze),
        Xe
    }
    function ve(xe, we, Fe, je) {
        if (Fe == null)
            throw Error(formatProdErrorMessage(151));
        for (var Xe = null, ze = null, qe = we, Ze = we = 0, et = null, it = Fe.next(); qe !== null && !it.done; Ze++,
        it = Fe.next()) {
            qe.index > Ze ? (et = qe,
            qe = null) : et = qe.sibling;
            var at = ye(xe, qe, it.value, je);
            if (at === null) {
                qe === null && (qe = et);
                break
            }
            V && qe && at.alternate === null && X(xe, qe),
            we = ce(at, we, Ze),
            ze === null ? Xe = at : ze.sibling = at,
            ze = at,
            qe = et
        }
        if (it.done)
            return J(xe, qe),
            isHydrating && pushTreeFork(xe, Ze),
            Xe;
        if (qe === null) {
            for (; !it.done; Ze++,
            it = Fe.next())
                it = Ie(xe, it.value, je),
                it !== null && (we = ce(it, we, Ze),
                ze === null ? Xe = it : ze.sibling = it,
                ze = it);
            return isHydrating && pushTreeFork(xe, Ze),
            Xe
        }
        for (qe = ne(qe); !it.done; Ze++,
        it = Fe.next())
            it = $e(qe, xe, Ze, it.value, je),
            it !== null && (V && it.alternate !== null && qe.delete(it.key === null ? Ze : it.key),
            we = ce(it, we, Ze),
            ze === null ? Xe = it : ze.sibling = it,
            ze = it);
        return V && qe.forEach(function(rt) {
            return X(xe, rt)
        }),
        isHydrating && pushTreeFork(xe, Ze),
        Xe
    }
    function ke(xe, we, Fe, je) {
        if (typeof Fe == "object" && Fe !== null && Fe.type === REACT_FRAGMENT_TYPE && Fe.key === null && (Fe = Fe.props.children),
        typeof Fe == "object" && Fe !== null) {
            switch (Fe.$$typeof) {
            case REACT_ELEMENT_TYPE:
                e: {
                    for (var Xe = Fe.key; we !== null; ) {
                        if (we.key === Xe) {
                            if (Xe = Fe.type,
                            Xe === REACT_FRAGMENT_TYPE) {
                                if (we.tag === 7) {
                                    J(xe, we.sibling),
                                    je = ue(we, Fe.props.children),
                                    je.return = xe,
                                    xe = je;
                                    break e
                                }
                            } else if (we.elementType === Xe || typeof Xe == "object" && Xe !== null && Xe.$$typeof === REACT_LAZY_TYPE && resolveLazy(Xe) === we.type) {
                                J(xe, we.sibling),
                                je = ue(we, Fe.props),
                                coerceRef(je, Fe),
                                je.return = xe,
                                xe = je;
                                break e
                            }
                            J(xe, we);
                            break
                        } else
                            X(xe, we);
                        we = we.sibling
                    }
                    Fe.type === REACT_FRAGMENT_TYPE ? (je = createFiberFromFragment(Fe.props.children, xe.mode, je, Fe.key),
                    je.return = xe,
                    xe = je) : (je = createFiberFromTypeAndProps(Fe.type, Fe.key, Fe.props, null, xe.mode, je),
                    coerceRef(je, Fe),
                    je.return = xe,
                    xe = je)
                }
                return me(xe);
            case REACT_PORTAL_TYPE:
                e: {
                    for (Xe = Fe.key; we !== null; ) {
                        if (we.key === Xe)
                            if (we.tag === 4 && we.stateNode.containerInfo === Fe.containerInfo && we.stateNode.implementation === Fe.implementation) {
                                J(xe, we.sibling),
                                je = ue(we, Fe.children || []),
                                je.return = xe,
                                xe = je;
                                break e
                            } else {
                                J(xe, we);
                                break
                            }
                        else
                            X(xe, we);
                        we = we.sibling
                    }
                    je = createFiberFromPortal(Fe, xe.mode, je),
                    je.return = xe,
                    xe = je
                }
                return me(xe);
            case REACT_LAZY_TYPE:
                return Xe = Fe._init,
                Fe = Xe(Fe._payload),
                ke(xe, we, Fe, je)
            }
            if (isArrayImpl(Fe))
                return Ne(xe, we, Fe, je);
            if (getIteratorFn(Fe)) {
                if (Xe = getIteratorFn(Fe),
                typeof Xe != "function")
                    throw Error(formatProdErrorMessage(150));
                return Fe = Xe.call(Fe),
                ve(xe, we, Fe, je)
            }
            if (typeof Fe.then == "function")
                return ke(xe, we, unwrapThenable(Fe), je);
            if (Fe.$$typeof === REACT_CONTEXT_TYPE)
                return ke(xe, we, readContextDuringReconciliation(xe, Fe), je);
            throwOnInvalidObjectType(xe, Fe)
        }
        return typeof Fe == "string" && Fe !== "" || typeof Fe == "number" || typeof Fe == "bigint" ? (Fe = "" + Fe,
        we !== null && we.tag === 6 ? (J(xe, we.sibling),
        je = ue(we, Fe),
        je.return = xe,
        xe = je) : (J(xe, we),
        je = createFiberFromText(Fe, xe.mode, je),
        je.return = xe,
        xe = je),
        me(xe)) : J(xe, we)
    }
    return function(xe, we, Fe, je) {
        try {
            thenableIndexCounter = 0;
            var Xe = ke(xe, we, Fe, je);
            return thenableState = null,
            Xe
        } catch (qe) {
            if (qe === SuspenseException || qe === SuspenseActionException)
                throw qe;
            var ze = createFiberImplClass(29, qe, null, xe.mode);
            return ze.lanes = je,
            ze.return = xe,
            ze
        } finally {}
    }
}
var reconcileChildFibers = createChildReconciler(!0)
  , mountChildFibers = createChildReconciler(!1)
  , suspenseHandlerStackCursor = createCursor(null)
  , shellBoundary = null;
function pushPrimaryTreeSuspenseHandler(V) {
    var X = V.alternate;
    push$1(suspenseStackCursor, suspenseStackCursor.current & 1),
    push$1(suspenseHandlerStackCursor, V),
    shellBoundary === null && (X === null || currentTreeHiddenStackCursor.current !== null || X.memoizedState !== null) && (shellBoundary = V)
}
function pushOffscreenSuspenseHandler(V) {
    if (V.tag === 22) {
        if (push$1(suspenseStackCursor, suspenseStackCursor.current),
        push$1(suspenseHandlerStackCursor, V),
        shellBoundary === null) {
            var X = V.alternate;
            X !== null && X.memoizedState !== null && (shellBoundary = V)
        }
    } else
        reuseSuspenseHandlerOnStack()
}
function reuseSuspenseHandlerOnStack() {
    push$1(suspenseStackCursor, suspenseStackCursor.current),
    push$1(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current)
}
function popSuspenseHandler(V) {
    pop(suspenseHandlerStackCursor),
    shellBoundary === V && (shellBoundary = null),
    pop(suspenseStackCursor)
}
var suspenseStackCursor = createCursor(0);
function findFirstSuspended(V) {
    for (var X = V; X !== null; ) {
        if (X.tag === 13) {
            var J = X.memoizedState;
            if (J !== null && (J = J.dehydrated,
            J === null || J.data === "$?" || isSuspenseInstanceFallback(J)))
                return X
        } else if (X.tag === 19 && X.memoizedProps.revealOrder !== void 0) {
            if (X.flags & 128)
                return X
        } else if (X.child !== null) {
            X.child.return = X,
            X = X.child;
            continue
        }
        if (X === V)
            break;
        for (; X.sibling === null; ) {
            if (X.return === null || X.return === V)
                return null;
            X = X.return
        }
        X.sibling.return = X.return,
        X = X.sibling
    }
    return null
}
function applyDerivedStateFromProps(V, X, J, ne) {
    X = V.memoizedState,
    J = J(ne, X),
    J = J == null ? X : assign({}, X, J),
    V.memoizedState = J,
    V.lanes === 0 && (V.updateQueue.baseState = J)
}
var classComponentUpdater = {
    enqueueSetState: function(V, X, J) {
        V = V._reactInternals;
        var ne = requestUpdateLane()
          , ue = createUpdate(ne);
        ue.payload = X,
        J != null && (ue.callback = J),
        X = enqueueUpdate(V, ue, ne),
        X !== null && (scheduleUpdateOnFiber(X, V, ne),
        entangleTransitions(X, V, ne))
    },
    enqueueReplaceState: function(V, X, J) {
        V = V._reactInternals;
        var ne = requestUpdateLane()
          , ue = createUpdate(ne);
        ue.tag = 1,
        ue.payload = X,
        J != null && (ue.callback = J),
        X = enqueueUpdate(V, ue, ne),
        X !== null && (scheduleUpdateOnFiber(X, V, ne),
        entangleTransitions(X, V, ne))
    },
    enqueueForceUpdate: function(V, X) {
        V = V._reactInternals;
        var J = requestUpdateLane()
          , ne = createUpdate(J);
        ne.tag = 2,
        X != null && (ne.callback = X),
        X = enqueueUpdate(V, ne, J),
        X !== null && (scheduleUpdateOnFiber(X, V, J),
        entangleTransitions(X, V, J))
    }
};
function checkShouldComponentUpdate(V, X, J, ne, ue, ce, me) {
    return V = V.stateNode,
    typeof V.shouldComponentUpdate == "function" ? V.shouldComponentUpdate(ne, ce, me) : X.prototype && X.prototype.isPureReactComponent ? !shallowEqual(J, ne) || !shallowEqual(ue, ce) : !0
}
function callComponentWillReceiveProps(V, X, J, ne) {
    V = X.state,
    typeof X.componentWillReceiveProps == "function" && X.componentWillReceiveProps(J, ne),
    typeof X.UNSAFE_componentWillReceiveProps == "function" && X.UNSAFE_componentWillReceiveProps(J, ne),
    X.state !== V && classComponentUpdater.enqueueReplaceState(X, X.state, null)
}
function resolveClassComponentProps(V, X) {
    var J = X;
    if ("ref"in X) {
        J = {};
        for (var ne in X)
            ne !== "ref" && (J[ne] = X[ne])
    }
    if (V = V.defaultProps) {
        J === X && (J = assign({}, J));
        for (var ue in V)
            J[ue] === void 0 && (J[ue] = V[ue])
    }
    return J
}
var reportGlobalError = typeof reportError == "function" ? reportError : function(V) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
        var X = new window.ErrorEvent("error",{
            bubbles: !0,
            cancelable: !0,
            message: typeof V == "object" && V !== null && typeof V.message == "string" ? String(V.message) : String(V),
            error: V
        });
        if (!window.dispatchEvent(X))
            return
    } else if (typeof process == "object" && typeof process.emit == "function") {
        process.emit("uncaughtException", V);
        return
    }
    console.error(V)
}
;
function defaultOnUncaughtError(V) {
    reportGlobalError(V)
}
function defaultOnCaughtError(V) {
    console.error(V)
}
function defaultOnRecoverableError(V) {
    reportGlobalError(V)
}
function logUncaughtError(V, X) {
    try {
        var J = V.onUncaughtError;
        J(X.value, {
            componentStack: X.stack
        })
    } catch (ne) {
        setTimeout(function() {
            throw ne
        })
    }
}
function logCaughtError(V, X, J) {
    try {
        var ne = V.onCaughtError;
        ne(J.value, {
            componentStack: J.stack,
            errorBoundary: X.tag === 1 ? X.stateNode : null
        })
    } catch (ue) {
        setTimeout(function() {
            throw ue
        })
    }
}
function createRootErrorUpdate(V, X, J) {
    return J = createUpdate(J),
    J.tag = 3,
    J.payload = {
        element: null
    },
    J.callback = function() {
        logUncaughtError(V, X)
    }
    ,
    J
}
function createClassErrorUpdate(V) {
    return V = createUpdate(V),
    V.tag = 3,
    V
}
function initializeClassErrorUpdate(V, X, J, ne) {
    var ue = J.type.getDerivedStateFromError;
    if (typeof ue == "function") {
        var ce = ne.value;
        V.payload = function() {
            return ue(ce)
        }
        ,
        V.callback = function() {
            logCaughtError(X, J, ne)
        }
    }
    var me = J.stateNode;
    me !== null && typeof me.componentDidCatch == "function" && (V.callback = function() {
        logCaughtError(X, J, ne),
        typeof ue != "function" && (legacyErrorBoundariesThatAlreadyFailed === null ? legacyErrorBoundariesThatAlreadyFailed = new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
        var ge = ne.stack;
        this.componentDidCatch(ne.value, {
            componentStack: ge !== null ? ge : ""
        })
    }
    )
}
function throwException(V, X, J, ne, ue) {
    if (J.flags |= 32768,
    ne !== null && typeof ne == "object" && typeof ne.then == "function") {
        if (X = J.alternate,
        X !== null && propagateParentContextChanges(X, J, ue, !0),
        J = suspenseHandlerStackCursor.current,
        J !== null) {
            switch (J.tag) {
            case 13:
                return shellBoundary === null ? renderDidSuspendDelayIfPossible() : J.alternate === null && workInProgressRootExitStatus === 0 && (workInProgressRootExitStatus = 3),
                J.flags &= -257,
                J.flags |= 65536,
                J.lanes = ue,
                ne === noopSuspenseyCommitThenable ? J.flags |= 16384 : (X = J.updateQueue,
                X === null ? J.updateQueue = new Set([ne]) : X.add(ne),
                attachPingListener(V, ne, ue)),
                !1;
            case 22:
                return J.flags |= 65536,
                ne === noopSuspenseyCommitThenable ? J.flags |= 16384 : (X = J.updateQueue,
                X === null ? (X = {
                    transitions: null,
                    markerInstances: null,
                    retryQueue: new Set([ne])
                },
                J.updateQueue = X) : (J = X.retryQueue,
                J === null ? X.retryQueue = new Set([ne]) : J.add(ne)),
                attachPingListener(V, ne, ue)),
                !1
            }
            throw Error(formatProdErrorMessage(435, J.tag))
        }
        return attachPingListener(V, ne, ue),
        renderDidSuspendDelayIfPossible(),
        !1
    }
    if (isHydrating)
        return X = suspenseHandlerStackCursor.current,
        X !== null ? (!(X.flags & 65536) && (X.flags |= 256),
        X.flags |= 65536,
        X.lanes = ue,
        ne !== HydrationMismatchException && (V = Error(formatProdErrorMessage(422), {
            cause: ne
        }),
        queueHydrationError(createCapturedValueAtFiber(V, J)))) : (ne !== HydrationMismatchException && (X = Error(formatProdErrorMessage(423), {
            cause: ne
        }),
        queueHydrationError(createCapturedValueAtFiber(X, J))),
        V = V.current.alternate,
        V.flags |= 65536,
        ue &= -ue,
        V.lanes |= ue,
        ne = createCapturedValueAtFiber(ne, J),
        ue = createRootErrorUpdate(V.stateNode, ne, ue),
        enqueueCapturedUpdate(V, ue),
        workInProgressRootExitStatus !== 4 && (workInProgressRootExitStatus = 2)),
        !1;
    var ce = Error(formatProdErrorMessage(520), {
        cause: ne
    });
    if (ce = createCapturedValueAtFiber(ce, J),
    workInProgressRootConcurrentErrors === null ? workInProgressRootConcurrentErrors = [ce] : workInProgressRootConcurrentErrors.push(ce),
    workInProgressRootExitStatus !== 4 && (workInProgressRootExitStatus = 2),
    X === null)
        return !0;
    ne = createCapturedValueAtFiber(ne, J),
    J = X;
    do {
        switch (J.tag) {
        case 3:
            return J.flags |= 65536,
            V = ue & -ue,
            J.lanes |= V,
            V = createRootErrorUpdate(J.stateNode, ne, V),
            enqueueCapturedUpdate(J, V),
            !1;
        case 1:
            if (X = J.type,
            ce = J.stateNode,
            (J.flags & 128) === 0 && (typeof X.getDerivedStateFromError == "function" || ce !== null && typeof ce.componentDidCatch == "function" && (legacyErrorBoundariesThatAlreadyFailed === null || !legacyErrorBoundariesThatAlreadyFailed.has(ce))))
                return J.flags |= 65536,
                ue &= -ue,
                J.lanes |= ue,
                ue = createClassErrorUpdate(ue),
                initializeClassErrorUpdate(ue, V, J, ne),
                enqueueCapturedUpdate(J, ue),
                !1
        }
        J = J.return
    } while (J !== null);
    return !1
}
var SelectiveHydrationException = Error(formatProdErrorMessage(461))
  , didReceiveUpdate = !1;
function reconcileChildren(V, X, J, ne) {
    X.child = V === null ? mountChildFibers(X, null, J, ne) : reconcileChildFibers(X, V.child, J, ne)
}
function updateForwardRef(V, X, J, ne, ue) {
    J = J.render;
    var ce = X.ref;
    if ("ref"in ne) {
        var me = {};
        for (var ge in ne)
            ge !== "ref" && (me[ge] = ne[ge])
    } else
        me = ne;
    return prepareToReadContext(X),
    ne = renderWithHooks(V, X, J, me, ce, ue),
    ge = checkDidRenderIdHook(),
    V !== null && !didReceiveUpdate ? (bailoutHooks(V, X, ue),
    bailoutOnAlreadyFinishedWork(V, X, ue)) : (isHydrating && ge && pushMaterializedTreeId(X),
    X.flags |= 1,
    reconcileChildren(V, X, ne, ue),
    X.child)
}
function updateMemoComponent(V, X, J, ne, ue) {
    if (V === null) {
        var ce = J.type;
        return typeof ce == "function" && !shouldConstruct(ce) && ce.defaultProps === void 0 && J.compare === null ? (X.tag = 15,
        X.type = ce,
        updateSimpleMemoComponent(V, X, ce, ne, ue)) : (V = createFiberFromTypeAndProps(J.type, null, ne, X, X.mode, ue),
        V.ref = X.ref,
        V.return = X,
        X.child = V)
    }
    if (ce = V.child,
    !checkScheduledUpdateOrContext(V, ue)) {
        var me = ce.memoizedProps;
        if (J = J.compare,
        J = J !== null ? J : shallowEqual,
        J(me, ne) && V.ref === X.ref)
            return bailoutOnAlreadyFinishedWork(V, X, ue)
    }
    return X.flags |= 1,
    V = createWorkInProgress(ce, ne),
    V.ref = X.ref,
    V.return = X,
    X.child = V
}
function updateSimpleMemoComponent(V, X, J, ne, ue) {
    if (V !== null) {
        var ce = V.memoizedProps;
        if (shallowEqual(ce, ne) && V.ref === X.ref)
            if (didReceiveUpdate = !1,
            X.pendingProps = ne = ce,
            checkScheduledUpdateOrContext(V, ue))
                V.flags & 131072 && (didReceiveUpdate = !0);
            else
                return X.lanes = V.lanes,
                bailoutOnAlreadyFinishedWork(V, X, ue)
    }
    return updateFunctionComponent(V, X, J, ne, ue)
}
function updateOffscreenComponent(V, X, J) {
    var ne = X.pendingProps
      , ue = ne.children
      , ce = V !== null ? V.memoizedState : null;
    if (ne.mode === "hidden") {
        if (X.flags & 128) {
            if (ne = ce !== null ? ce.baseLanes | J : J,
            V !== null) {
                for (ue = X.child = V.child,
                ce = 0; ue !== null; )
                    ce = ce | ue.lanes | ue.childLanes,
                    ue = ue.sibling;
                X.childLanes = ce & ~ne
            } else
                X.childLanes = 0,
                X.child = null;
            return deferHiddenOffscreenComponent(V, X, ne, J)
        }
        if (J & 536870912)
            X.memoizedState = {
                baseLanes: 0,
                cachePool: null
            },
            V !== null && pushTransition(X, ce !== null ? ce.cachePool : null),
            ce !== null ? pushHiddenContext(X, ce) : reuseHiddenContextOnStack(),
            pushOffscreenSuspenseHandler(X);
        else
            return X.lanes = X.childLanes = 536870912,
            deferHiddenOffscreenComponent(V, X, ce !== null ? ce.baseLanes | J : J, J)
    } else
        ce !== null ? (pushTransition(X, ce.cachePool),
        pushHiddenContext(X, ce),
        reuseSuspenseHandlerOnStack(),
        X.memoizedState = null) : (V !== null && pushTransition(X, null),
        reuseHiddenContextOnStack(),
        reuseSuspenseHandlerOnStack());
    return reconcileChildren(V, X, ue, J),
    X.child
}
function deferHiddenOffscreenComponent(V, X, J, ne) {
    var ue = peekCacheFromPool();
    return ue = ue === null ? null : {
        parent: CacheContext._currentValue,
        pool: ue
    },
    X.memoizedState = {
        baseLanes: J,
        cachePool: ue
    },
    V !== null && pushTransition(X, null),
    reuseHiddenContextOnStack(),
    pushOffscreenSuspenseHandler(X),
    V !== null && propagateParentContextChanges(V, X, ne, !0),
    null
}
function markRef(V, X) {
    var J = X.ref;
    if (J === null)
        V !== null && V.ref !== null && (X.flags |= 4194816);
    else {
        if (typeof J != "function" && typeof J != "object")
            throw Error(formatProdErrorMessage(284));
        (V === null || V.ref !== J) && (X.flags |= 4194816)
    }
}
function updateFunctionComponent(V, X, J, ne, ue) {
    return prepareToReadContext(X),
    J = renderWithHooks(V, X, J, ne, void 0, ue),
    ne = checkDidRenderIdHook(),
    V !== null && !didReceiveUpdate ? (bailoutHooks(V, X, ue),
    bailoutOnAlreadyFinishedWork(V, X, ue)) : (isHydrating && ne && pushMaterializedTreeId(X),
    X.flags |= 1,
    reconcileChildren(V, X, J, ue),
    X.child)
}
function replayFunctionComponent(V, X, J, ne, ue, ce) {
    return prepareToReadContext(X),
    X.updateQueue = null,
    J = renderWithHooksAgain(X, ne, J, ue),
    finishRenderingHooks(V),
    ne = checkDidRenderIdHook(),
    V !== null && !didReceiveUpdate ? (bailoutHooks(V, X, ce),
    bailoutOnAlreadyFinishedWork(V, X, ce)) : (isHydrating && ne && pushMaterializedTreeId(X),
    X.flags |= 1,
    reconcileChildren(V, X, J, ce),
    X.child)
}
function updateClassComponent(V, X, J, ne, ue) {
    if (prepareToReadContext(X),
    X.stateNode === null) {
        var ce = emptyContextObject
          , me = J.contextType;
        typeof me == "object" && me !== null && (ce = readContext(me)),
        ce = new J(ne,ce),
        X.memoizedState = ce.state !== null && ce.state !== void 0 ? ce.state : null,
        ce.updater = classComponentUpdater,
        X.stateNode = ce,
        ce._reactInternals = X,
        ce = X.stateNode,
        ce.props = ne,
        ce.state = X.memoizedState,
        ce.refs = {},
        initializeUpdateQueue(X),
        me = J.contextType,
        ce.context = typeof me == "object" && me !== null ? readContext(me) : emptyContextObject,
        ce.state = X.memoizedState,
        me = J.getDerivedStateFromProps,
        typeof me == "function" && (applyDerivedStateFromProps(X, J, me, ne),
        ce.state = X.memoizedState),
        typeof J.getDerivedStateFromProps == "function" || typeof ce.getSnapshotBeforeUpdate == "function" || typeof ce.UNSAFE_componentWillMount != "function" && typeof ce.componentWillMount != "function" || (me = ce.state,
        typeof ce.componentWillMount == "function" && ce.componentWillMount(),
        typeof ce.UNSAFE_componentWillMount == "function" && ce.UNSAFE_componentWillMount(),
        me !== ce.state && classComponentUpdater.enqueueReplaceState(ce, ce.state, null),
        processUpdateQueue(X, ne, ce, ue),
        suspendIfUpdateReadFromEntangledAsyncAction(),
        ce.state = X.memoizedState),
        typeof ce.componentDidMount == "function" && (X.flags |= 4194308),
        ne = !0
    } else if (V === null) {
        ce = X.stateNode;
        var ge = X.memoizedProps
          , Te = resolveClassComponentProps(J, ge);
        ce.props = Te;
        var _e = ce.context
          , Se = J.contextType;
        me = emptyContextObject,
        typeof Se == "object" && Se !== null && (me = readContext(Se));
        var Ie = J.getDerivedStateFromProps;
        Se = typeof Ie == "function" || typeof ce.getSnapshotBeforeUpdate == "function",
        ge = X.pendingProps !== ge,
        Se || typeof ce.UNSAFE_componentWillReceiveProps != "function" && typeof ce.componentWillReceiveProps != "function" || (ge || _e !== me) && callComponentWillReceiveProps(X, ce, ne, me),
        hasForceUpdate = !1;
        var ye = X.memoizedState;
        ce.state = ye,
        processUpdateQueue(X, ne, ce, ue),
        suspendIfUpdateReadFromEntangledAsyncAction(),
        _e = X.memoizedState,
        ge || ye !== _e || hasForceUpdate ? (typeof Ie == "function" && (applyDerivedStateFromProps(X, J, Ie, ne),
        _e = X.memoizedState),
        (Te = hasForceUpdate || checkShouldComponentUpdate(X, J, Te, ne, ye, _e, me)) ? (Se || typeof ce.UNSAFE_componentWillMount != "function" && typeof ce.componentWillMount != "function" || (typeof ce.componentWillMount == "function" && ce.componentWillMount(),
        typeof ce.UNSAFE_componentWillMount == "function" && ce.UNSAFE_componentWillMount()),
        typeof ce.componentDidMount == "function" && (X.flags |= 4194308)) : (typeof ce.componentDidMount == "function" && (X.flags |= 4194308),
        X.memoizedProps = ne,
        X.memoizedState = _e),
        ce.props = ne,
        ce.state = _e,
        ce.context = me,
        ne = Te) : (typeof ce.componentDidMount == "function" && (X.flags |= 4194308),
        ne = !1)
    } else {
        ce = X.stateNode,
        cloneUpdateQueue(V, X),
        me = X.memoizedProps,
        Se = resolveClassComponentProps(J, me),
        ce.props = Se,
        Ie = X.pendingProps,
        ye = ce.context,
        _e = J.contextType,
        Te = emptyContextObject,
        typeof _e == "object" && _e !== null && (Te = readContext(_e)),
        ge = J.getDerivedStateFromProps,
        (_e = typeof ge == "function" || typeof ce.getSnapshotBeforeUpdate == "function") || typeof ce.UNSAFE_componentWillReceiveProps != "function" && typeof ce.componentWillReceiveProps != "function" || (me !== Ie || ye !== Te) && callComponentWillReceiveProps(X, ce, ne, Te),
        hasForceUpdate = !1,
        ye = X.memoizedState,
        ce.state = ye,
        processUpdateQueue(X, ne, ce, ue),
        suspendIfUpdateReadFromEntangledAsyncAction();
        var $e = X.memoizedState;
        me !== Ie || ye !== $e || hasForceUpdate || V !== null && V.dependencies !== null && checkIfContextChanged(V.dependencies) ? (typeof ge == "function" && (applyDerivedStateFromProps(X, J, ge, ne),
        $e = X.memoizedState),
        (Se = hasForceUpdate || checkShouldComponentUpdate(X, J, Se, ne, ye, $e, Te) || V !== null && V.dependencies !== null && checkIfContextChanged(V.dependencies)) ? (_e || typeof ce.UNSAFE_componentWillUpdate != "function" && typeof ce.componentWillUpdate != "function" || (typeof ce.componentWillUpdate == "function" && ce.componentWillUpdate(ne, $e, Te),
        typeof ce.UNSAFE_componentWillUpdate == "function" && ce.UNSAFE_componentWillUpdate(ne, $e, Te)),
        typeof ce.componentDidUpdate == "function" && (X.flags |= 4),
        typeof ce.getSnapshotBeforeUpdate == "function" && (X.flags |= 1024)) : (typeof ce.componentDidUpdate != "function" || me === V.memoizedProps && ye === V.memoizedState || (X.flags |= 4),
        typeof ce.getSnapshotBeforeUpdate != "function" || me === V.memoizedProps && ye === V.memoizedState || (X.flags |= 1024),
        X.memoizedProps = ne,
        X.memoizedState = $e),
        ce.props = ne,
        ce.state = $e,
        ce.context = Te,
        ne = Se) : (typeof ce.componentDidUpdate != "function" || me === V.memoizedProps && ye === V.memoizedState || (X.flags |= 4),
        typeof ce.getSnapshotBeforeUpdate != "function" || me === V.memoizedProps && ye === V.memoizedState || (X.flags |= 1024),
        ne = !1)
    }
    return ce = ne,
    markRef(V, X),
    ne = (X.flags & 128) !== 0,
    ce || ne ? (ce = X.stateNode,
    J = ne && typeof J.getDerivedStateFromError != "function" ? null : ce.render(),
    X.flags |= 1,
    V !== null && ne ? (X.child = reconcileChildFibers(X, V.child, null, ue),
    X.child = reconcileChildFibers(X, null, J, ue)) : reconcileChildren(V, X, J, ue),
    X.memoizedState = ce.state,
    V = X.child) : V = bailoutOnAlreadyFinishedWork(V, X, ue),
    V
}
function mountHostRootWithoutHydrating(V, X, J, ne) {
    return resetHydrationState(),
    X.flags |= 256,
    reconcileChildren(V, X, J, ne),
    X.child
}
var SUSPENDED_MARKER = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null
};
function mountSuspenseOffscreenState(V) {
    return {
        baseLanes: V,
        cachePool: getSuspendedCache()
    }
}
function getRemainingWorkInPrimaryTree(V, X, J) {
    return V = V !== null ? V.childLanes & ~J : 0,
    X && (V |= workInProgressDeferredLane),
    V
}
function updateSuspenseComponent(V, X, J) {
    var ne = X.pendingProps, ue = !1, ce = (X.flags & 128) !== 0, me;
    if ((me = ce) || (me = V !== null && V.memoizedState === null ? !1 : (suspenseStackCursor.current & 2) !== 0),
    me && (ue = !0,
    X.flags &= -129),
    me = (X.flags & 32) !== 0,
    X.flags &= -33,
    V === null) {
        if (isHydrating) {
            if (ue ? pushPrimaryTreeSuspenseHandler(X) : reuseSuspenseHandlerOnStack(),
            isHydrating) {
                var ge = nextHydratableInstance, Te;
                if (Te = ge) {
                    e: {
                        for (Te = ge,
                        ge = rootOrSingletonContext; Te.nodeType !== 8; ) {
                            if (!ge) {
                                ge = null;
                                break e
                            }
                            if (Te = getNextHydratable(Te.nextSibling),
                            Te === null) {
                                ge = null;
                                break e
                            }
                        }
                        ge = Te
                    }
                    ge !== null ? (X.memoizedState = {
                        dehydrated: ge,
                        treeContext: treeContextProvider !== null ? {
                            id: treeContextId,
                            overflow: treeContextOverflow
                        } : null,
                        retryLane: 536870912,
                        hydrationErrors: null
                    },
                    Te = createFiberImplClass(18, null, null, 0),
                    Te.stateNode = ge,
                    Te.return = X,
                    X.child = Te,
                    hydrationParentFiber = X,
                    nextHydratableInstance = null,
                    Te = !0) : Te = !1
                }
                Te || throwOnHydrationMismatch(X)
            }
            if (ge = X.memoizedState,
            ge !== null && (ge = ge.dehydrated,
            ge !== null))
                return isSuspenseInstanceFallback(ge) ? X.lanes = 32 : X.lanes = 536870912,
                null;
            popSuspenseHandler(X)
        }
        return ge = ne.children,
        ne = ne.fallback,
        ue ? (reuseSuspenseHandlerOnStack(),
        ue = X.mode,
        ge = mountWorkInProgressOffscreenFiber({
            mode: "hidden",
            children: ge
        }, ue),
        ne = createFiberFromFragment(ne, ue, J, null),
        ge.return = X,
        ne.return = X,
        ge.sibling = ne,
        X.child = ge,
        ue = X.child,
        ue.memoizedState = mountSuspenseOffscreenState(J),
        ue.childLanes = getRemainingWorkInPrimaryTree(V, me, J),
        X.memoizedState = SUSPENDED_MARKER,
        ne) : (pushPrimaryTreeSuspenseHandler(X),
        mountSuspensePrimaryChildren(X, ge))
    }
    if (Te = V.memoizedState,
    Te !== null && (ge = Te.dehydrated,
    ge !== null)) {
        if (ce)
            X.flags & 256 ? (pushPrimaryTreeSuspenseHandler(X),
            X.flags &= -257,
            X = retrySuspenseComponentWithoutHydrating(V, X, J)) : X.memoizedState !== null ? (reuseSuspenseHandlerOnStack(),
            X.child = V.child,
            X.flags |= 128,
            X = null) : (reuseSuspenseHandlerOnStack(),
            ue = ne.fallback,
            ge = X.mode,
            ne = mountWorkInProgressOffscreenFiber({
                mode: "visible",
                children: ne.children
            }, ge),
            ue = createFiberFromFragment(ue, ge, J, null),
            ue.flags |= 2,
            ne.return = X,
            ue.return = X,
            ne.sibling = ue,
            X.child = ne,
            reconcileChildFibers(X, V.child, null, J),
            ne = X.child,
            ne.memoizedState = mountSuspenseOffscreenState(J),
            ne.childLanes = getRemainingWorkInPrimaryTree(V, me, J),
            X.memoizedState = SUSPENDED_MARKER,
            X = ue);
        else if (pushPrimaryTreeSuspenseHandler(X),
        isSuspenseInstanceFallback(ge)) {
            if (me = ge.nextSibling && ge.nextSibling.dataset,
            me)
                var _e = me.dgst;
            me = _e,
            ne = Error(formatProdErrorMessage(419)),
            ne.stack = "",
            ne.digest = me,
            queueHydrationError({
                value: ne,
                source: null,
                stack: null
            }),
            X = retrySuspenseComponentWithoutHydrating(V, X, J)
        } else if (didReceiveUpdate || propagateParentContextChanges(V, X, J, !1),
        me = (J & V.childLanes) !== 0,
        didReceiveUpdate || me) {
            if (me = workInProgressRoot,
            me !== null && (ne = J & -J,
            ne = ne & 42 ? 1 : getBumpedLaneForHydrationByLane(ne),
            ne = ne & (me.suspendedLanes | J) ? 0 : ne,
            ne !== 0 && ne !== Te.retryLane))
                throw Te.retryLane = ne,
                enqueueConcurrentRenderForLane(V, ne),
                scheduleUpdateOnFiber(me, V, ne),
                SelectiveHydrationException;
            ge.data === "$?" || renderDidSuspendDelayIfPossible(),
            X = retrySuspenseComponentWithoutHydrating(V, X, J)
        } else
            ge.data === "$?" ? (X.flags |= 192,
            X.child = V.child,
            X = null) : (V = Te.treeContext,
            nextHydratableInstance = getNextHydratable(ge.nextSibling),
            hydrationParentFiber = X,
            isHydrating = !0,
            hydrationErrors = null,
            rootOrSingletonContext = !1,
            V !== null && (idStack[idStackIndex++] = treeContextId,
            idStack[idStackIndex++] = treeContextOverflow,
            idStack[idStackIndex++] = treeContextProvider,
            treeContextId = V.id,
            treeContextOverflow = V.overflow,
            treeContextProvider = X),
            X = mountSuspensePrimaryChildren(X, ne.children),
            X.flags |= 4096);
        return X
    }
    return ue ? (reuseSuspenseHandlerOnStack(),
    ue = ne.fallback,
    ge = X.mode,
    Te = V.child,
    _e = Te.sibling,
    ne = createWorkInProgress(Te, {
        mode: "hidden",
        children: ne.children
    }),
    ne.subtreeFlags = Te.subtreeFlags & 65011712,
    _e !== null ? ue = createWorkInProgress(_e, ue) : (ue = createFiberFromFragment(ue, ge, J, null),
    ue.flags |= 2),
    ue.return = X,
    ne.return = X,
    ne.sibling = ue,
    X.child = ne,
    ne = ue,
    ue = X.child,
    ge = V.child.memoizedState,
    ge === null ? ge = mountSuspenseOffscreenState(J) : (Te = ge.cachePool,
    Te !== null ? (_e = CacheContext._currentValue,
    Te = Te.parent !== _e ? {
        parent: _e,
        pool: _e
    } : Te) : Te = getSuspendedCache(),
    ge = {
        baseLanes: ge.baseLanes | J,
        cachePool: Te
    }),
    ue.memoizedState = ge,
    ue.childLanes = getRemainingWorkInPrimaryTree(V, me, J),
    X.memoizedState = SUSPENDED_MARKER,
    ne) : (pushPrimaryTreeSuspenseHandler(X),
    J = V.child,
    V = J.sibling,
    J = createWorkInProgress(J, {
        mode: "visible",
        children: ne.children
    }),
    J.return = X,
    J.sibling = null,
    V !== null && (me = X.deletions,
    me === null ? (X.deletions = [V],
    X.flags |= 16) : me.push(V)),
    X.child = J,
    X.memoizedState = null,
    J)
}
function mountSuspensePrimaryChildren(V, X) {
    return X = mountWorkInProgressOffscreenFiber({
        mode: "visible",
        children: X
    }, V.mode),
    X.return = V,
    V.child = X
}
function mountWorkInProgressOffscreenFiber(V, X) {
    return V = createFiberImplClass(22, V, null, X),
    V.lanes = 0,
    V.stateNode = {
        _visibility: 1,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
    },
    V
}
function retrySuspenseComponentWithoutHydrating(V, X, J) {
    return reconcileChildFibers(X, V.child, null, J),
    V = mountSuspensePrimaryChildren(X, X.pendingProps.children),
    V.flags |= 2,
    X.memoizedState = null,
    V
}
function scheduleSuspenseWorkOnFiber(V, X, J) {
    V.lanes |= X;
    var ne = V.alternate;
    ne !== null && (ne.lanes |= X),
    scheduleContextWorkOnParentPath(V.return, X, J)
}
function initSuspenseListRenderState(V, X, J, ne, ue) {
    var ce = V.memoizedState;
    ce === null ? V.memoizedState = {
        isBackwards: X,
        rendering: null,
        renderingStartTime: 0,
        last: ne,
        tail: J,
        tailMode: ue
    } : (ce.isBackwards = X,
    ce.rendering = null,
    ce.renderingStartTime = 0,
    ce.last = ne,
    ce.tail = J,
    ce.tailMode = ue)
}
function updateSuspenseListComponent(V, X, J) {
    var ne = X.pendingProps
      , ue = ne.revealOrder
      , ce = ne.tail;
    if (reconcileChildren(V, X, ne.children, J),
    ne = suspenseStackCursor.current,
    ne & 2)
        ne = ne & 1 | 2,
        X.flags |= 128;
    else {
        if (V !== null && V.flags & 128)
            e: for (V = X.child; V !== null; ) {
                if (V.tag === 13)
                    V.memoizedState !== null && scheduleSuspenseWorkOnFiber(V, J, X);
                else if (V.tag === 19)
                    scheduleSuspenseWorkOnFiber(V, J, X);
                else if (V.child !== null) {
                    V.child.return = V,
                    V = V.child;
                    continue
                }
                if (V === X)
                    break e;
                for (; V.sibling === null; ) {
                    if (V.return === null || V.return === X)
                        break e;
                    V = V.return
                }
                V.sibling.return = V.return,
                V = V.sibling
            }
        ne &= 1
    }
    switch (push$1(suspenseStackCursor, ne),
    ue) {
    case "forwards":
        for (J = X.child,
        ue = null; J !== null; )
            V = J.alternate,
            V !== null && findFirstSuspended(V) === null && (ue = J),
            J = J.sibling;
        J = ue,
        J === null ? (ue = X.child,
        X.child = null) : (ue = J.sibling,
        J.sibling = null),
        initSuspenseListRenderState(X, !1, ue, J, ce);
        break;
    case "backwards":
        for (J = null,
        ue = X.child,
        X.child = null; ue !== null; ) {
            if (V = ue.alternate,
            V !== null && findFirstSuspended(V) === null) {
                X.child = ue;
                break
            }
            V = ue.sibling,
            ue.sibling = J,
            J = ue,
            ue = V
        }
        initSuspenseListRenderState(X, !0, J, null, ce);
        break;
    case "together":
        initSuspenseListRenderState(X, !1, null, null, void 0);
        break;
    default:
        X.memoizedState = null
    }
    return X.child
}
function bailoutOnAlreadyFinishedWork(V, X, J) {
    if (V !== null && (X.dependencies = V.dependencies),
    workInProgressRootSkippedLanes |= X.lanes,
    !(J & X.childLanes))
        if (V !== null) {
            if (propagateParentContextChanges(V, X, J, !1),
            (J & X.childLanes) === 0)
                return null
        } else
            return null;
    if (V !== null && X.child !== V.child)
        throw Error(formatProdErrorMessage(153));
    if (X.child !== null) {
        for (V = X.child,
        J = createWorkInProgress(V, V.pendingProps),
        X.child = J,
        J.return = X; V.sibling !== null; )
            V = V.sibling,
            J = J.sibling = createWorkInProgress(V, V.pendingProps),
            J.return = X;
        J.sibling = null
    }
    return X.child
}
function checkScheduledUpdateOrContext(V, X) {
    return V.lanes & X ? !0 : (V = V.dependencies,
    !!(V !== null && checkIfContextChanged(V)))
}
function attemptEarlyBailoutIfNoScheduledUpdate(V, X, J) {
    switch (X.tag) {
    case 3:
        pushHostContainer(X, X.stateNode.containerInfo),
        pushProvider(X, CacheContext, V.memoizedState.cache),
        resetHydrationState();
        break;
    case 27:
    case 5:
        pushHostContext(X);
        break;
    case 4:
        pushHostContainer(X, X.stateNode.containerInfo);
        break;
    case 10:
        pushProvider(X, X.type, X.memoizedProps.value);
        break;
    case 13:
        var ne = X.memoizedState;
        if (ne !== null)
            return ne.dehydrated !== null ? (pushPrimaryTreeSuspenseHandler(X),
            X.flags |= 128,
            null) : J & X.child.childLanes ? updateSuspenseComponent(V, X, J) : (pushPrimaryTreeSuspenseHandler(X),
            V = bailoutOnAlreadyFinishedWork(V, X, J),
            V !== null ? V.sibling : null);
        pushPrimaryTreeSuspenseHandler(X);
        break;
    case 19:
        var ue = (V.flags & 128) !== 0;
        if (ne = (J & X.childLanes) !== 0,
        ne || (propagateParentContextChanges(V, X, J, !1),
        ne = (J & X.childLanes) !== 0),
        ue) {
            if (ne)
                return updateSuspenseListComponent(V, X, J);
            X.flags |= 128
        }
        if (ue = X.memoizedState,
        ue !== null && (ue.rendering = null,
        ue.tail = null,
        ue.lastEffect = null),
        push$1(suspenseStackCursor, suspenseStackCursor.current),
        ne)
            break;
        return null;
    case 22:
    case 23:
        return X.lanes = 0,
        updateOffscreenComponent(V, X, J);
    case 24:
        pushProvider(X, CacheContext, V.memoizedState.cache)
    }
    return bailoutOnAlreadyFinishedWork(V, X, J)
}
function beginWork(V, X, J) {
    if (V !== null)
        if (V.memoizedProps !== X.pendingProps)
            didReceiveUpdate = !0;
        else {
            if (!checkScheduledUpdateOrContext(V, J) && !(X.flags & 128))
                return didReceiveUpdate = !1,
                attemptEarlyBailoutIfNoScheduledUpdate(V, X, J);
            didReceiveUpdate = !!(V.flags & 131072)
        }
    else
        didReceiveUpdate = !1,
        isHydrating && X.flags & 1048576 && pushTreeId(X, treeForkCount, X.index);
    switch (X.lanes = 0,
    X.tag) {
    case 16:
        e: {
            V = X.pendingProps;
            var ne = X.elementType
              , ue = ne._init;
            if (ne = ue(ne._payload),
            X.type = ne,
            typeof ne == "function")
                shouldConstruct(ne) ? (V = resolveClassComponentProps(ne, V),
                X.tag = 1,
                X = updateClassComponent(null, X, ne, V, J)) : (X.tag = 0,
                X = updateFunctionComponent(null, X, ne, V, J));
            else {
                if (ne != null) {
                    if (ue = ne.$$typeof,
                    ue === REACT_FORWARD_REF_TYPE) {
                        X.tag = 11,
                        X = updateForwardRef(null, X, ne, V, J);
                        break e
                    } else if (ue === REACT_MEMO_TYPE) {
                        X.tag = 14,
                        X = updateMemoComponent(null, X, ne, V, J);
                        break e
                    }
                }
                throw X = getComponentNameFromType(ne) || ne,
                Error(formatProdErrorMessage(306, X, ""))
            }
        }
        return X;
    case 0:
        return updateFunctionComponent(V, X, X.type, X.pendingProps, J);
    case 1:
        return ne = X.type,
        ue = resolveClassComponentProps(ne, X.pendingProps),
        updateClassComponent(V, X, ne, ue, J);
    case 3:
        e: {
            if (pushHostContainer(X, X.stateNode.containerInfo),
            V === null)
                throw Error(formatProdErrorMessage(387));
            ne = X.pendingProps;
            var ce = X.memoizedState;
            ue = ce.element,
            cloneUpdateQueue(V, X),
            processUpdateQueue(X, ne, null, J);
            var me = X.memoizedState;
            if (ne = me.cache,
            pushProvider(X, CacheContext, ne),
            ne !== ce.cache && propagateContextChanges(X, [CacheContext], J, !0),
            suspendIfUpdateReadFromEntangledAsyncAction(),
            ne = me.element,
            ce.isDehydrated)
                if (ce = {
                    element: ne,
                    isDehydrated: !1,
                    cache: me.cache
                },
                X.updateQueue.baseState = ce,
                X.memoizedState = ce,
                X.flags & 256) {
                    X = mountHostRootWithoutHydrating(V, X, ne, J);
                    break e
                } else if (ne !== ue) {
                    ue = createCapturedValueAtFiber(Error(formatProdErrorMessage(424)), X),
                    queueHydrationError(ue),
                    X = mountHostRootWithoutHydrating(V, X, ne, J);
                    break e
                } else {
                    switch (V = X.stateNode.containerInfo,
                    V.nodeType) {
                    case 9:
                        V = V.body;
                        break;
                    default:
                        V = V.nodeName === "HTML" ? V.ownerDocument.body : V
                    }
                    for (nextHydratableInstance = getNextHydratable(V.firstChild),
                    hydrationParentFiber = X,
                    isHydrating = !0,
                    hydrationErrors = null,
                    rootOrSingletonContext = !0,
                    J = mountChildFibers(X, null, ne, J),
                    X.child = J; J; )
                        J.flags = J.flags & -3 | 4096,
                        J = J.sibling
                }
            else {
                if (resetHydrationState(),
                ne === ue) {
                    X = bailoutOnAlreadyFinishedWork(V, X, J);
                    break e
                }
                reconcileChildren(V, X, ne, J)
            }
            X = X.child
        }
        return X;
    case 26:
        return markRef(V, X),
        V === null ? (J = getResource(X.type, null, X.pendingProps, null)) ? X.memoizedState = J : isHydrating || (J = X.type,
        V = X.pendingProps,
        ne = getOwnerDocumentFromRootContainer(rootInstanceStackCursor.current).createElement(J),
        ne[internalInstanceKey] = X,
        ne[internalPropsKey] = V,
        setInitialProperties(ne, J, V),
        markNodeAsHoistable(ne),
        X.stateNode = ne) : X.memoizedState = getResource(X.type, V.memoizedProps, X.pendingProps, V.memoizedState),
        null;
    case 27:
        return pushHostContext(X),
        V === null && isHydrating && (ne = X.stateNode = resolveSingletonInstance(X.type, X.pendingProps, rootInstanceStackCursor.current),
        hydrationParentFiber = X,
        rootOrSingletonContext = !0,
        ue = nextHydratableInstance,
        isSingletonScope(X.type) ? (previousHydratableOnEnteringScopedSingleton = ue,
        nextHydratableInstance = getNextHydratable(ne.firstChild)) : nextHydratableInstance = ue),
        reconcileChildren(V, X, X.pendingProps.children, J),
        markRef(V, X),
        V === null && (X.flags |= 4194304),
        X.child;
    case 5:
        return V === null && isHydrating && ((ue = ne = nextHydratableInstance) && (ne = canHydrateInstance(ne, X.type, X.pendingProps, rootOrSingletonContext),
        ne !== null ? (X.stateNode = ne,
        hydrationParentFiber = X,
        nextHydratableInstance = getNextHydratable(ne.firstChild),
        rootOrSingletonContext = !1,
        ue = !0) : ue = !1),
        ue || throwOnHydrationMismatch(X)),
        pushHostContext(X),
        ue = X.type,
        ce = X.pendingProps,
        me = V !== null ? V.memoizedProps : null,
        ne = ce.children,
        shouldSetTextContent(ue, ce) ? ne = null : me !== null && shouldSetTextContent(ue, me) && (X.flags |= 32),
        X.memoizedState !== null && (ue = renderWithHooks(V, X, TransitionAwareHostComponent, null, null, J),
        HostTransitionContext._currentValue = ue),
        markRef(V, X),
        reconcileChildren(V, X, ne, J),
        X.child;
    case 6:
        return V === null && isHydrating && ((V = J = nextHydratableInstance) && (J = canHydrateTextInstance(J, X.pendingProps, rootOrSingletonContext),
        J !== null ? (X.stateNode = J,
        hydrationParentFiber = X,
        nextHydratableInstance = null,
        V = !0) : V = !1),
        V || throwOnHydrationMismatch(X)),
        null;
    case 13:
        return updateSuspenseComponent(V, X, J);
    case 4:
        return pushHostContainer(X, X.stateNode.containerInfo),
        ne = X.pendingProps,
        V === null ? X.child = reconcileChildFibers(X, null, ne, J) : reconcileChildren(V, X, ne, J),
        X.child;
    case 11:
        return updateForwardRef(V, X, X.type, X.pendingProps, J);
    case 7:
        return reconcileChildren(V, X, X.pendingProps, J),
        X.child;
    case 8:
        return reconcileChildren(V, X, X.pendingProps.children, J),
        X.child;
    case 12:
        return reconcileChildren(V, X, X.pendingProps.children, J),
        X.child;
    case 10:
        return ne = X.pendingProps,
        pushProvider(X, X.type, ne.value),
        reconcileChildren(V, X, ne.children, J),
        X.child;
    case 9:
        return ue = X.type._context,
        ne = X.pendingProps.children,
        prepareToReadContext(X),
        ue = readContext(ue),
        ne = ne(ue),
        X.flags |= 1,
        reconcileChildren(V, X, ne, J),
        X.child;
    case 14:
        return updateMemoComponent(V, X, X.type, X.pendingProps, J);
    case 15:
        return updateSimpleMemoComponent(V, X, X.type, X.pendingProps, J);
    case 19:
        return updateSuspenseListComponent(V, X, J);
    case 31:
        return ne = X.pendingProps,
        J = X.mode,
        ne = {
            mode: ne.mode,
            children: ne.children
        },
        V === null ? (J = mountWorkInProgressOffscreenFiber(ne, J),
        J.ref = X.ref,
        X.child = J,
        J.return = X,
        X = J) : (J = createWorkInProgress(V.child, ne),
        J.ref = X.ref,
        X.child = J,
        J.return = X,
        X = J),
        X;
    case 22:
        return updateOffscreenComponent(V, X, J);
    case 24:
        return prepareToReadContext(X),
        ne = readContext(CacheContext),
        V === null ? (ue = peekCacheFromPool(),
        ue === null && (ue = workInProgressRoot,
        ce = createCache(),
        ue.pooledCache = ce,
        ce.refCount++,
        ce !== null && (ue.pooledCacheLanes |= J),
        ue = ce),
        X.memoizedState = {
            parent: ne,
            cache: ue
        },
        initializeUpdateQueue(X),
        pushProvider(X, CacheContext, ue)) : (V.lanes & J && (cloneUpdateQueue(V, X),
        processUpdateQueue(X, null, null, J),
        suspendIfUpdateReadFromEntangledAsyncAction()),
        ue = V.memoizedState,
        ce = X.memoizedState,
        ue.parent !== ne ? (ue = {
            parent: ne,
            cache: ne
        },
        X.memoizedState = ue,
        X.lanes === 0 && (X.memoizedState = X.updateQueue.baseState = ue),
        pushProvider(X, CacheContext, ne)) : (ne = ce.cache,
        pushProvider(X, CacheContext, ne),
        ne !== ue.cache && propagateContextChanges(X, [CacheContext], J, !0))),
        reconcileChildren(V, X, X.pendingProps.children, J),
        X.child;
    case 29:
        throw X.pendingProps
    }
    throw Error(formatProdErrorMessage(156, X.tag))
}
function markUpdate(V) {
    V.flags |= 4
}
function preloadResourceAndSuspendIfNeeded(V, X) {
    if (X.type !== "stylesheet" || X.state.loading & 4)
        V.flags &= -16777217;
    else if (V.flags |= 16777216,
    !preloadResource(X)) {
        if (X = suspenseHandlerStackCursor.current,
        X !== null && ((workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? shellBoundary !== null : (workInProgressRootRenderLanes & 62914560) !== workInProgressRootRenderLanes && !(workInProgressRootRenderLanes & 536870912) || X !== shellBoundary))
            throw suspendedThenable = noopSuspenseyCommitThenable,
            SuspenseyCommitException;
        V.flags |= 8192
    }
}
function scheduleRetryEffect(V, X) {
    X !== null && (V.flags |= 4),
    V.flags & 16384 && (X = V.tag !== 22 ? claimNextRetryLane() : 536870912,
    V.lanes |= X,
    workInProgressSuspendedRetryLanes |= X)
}
function cutOffTailIfNeeded(V, X) {
    if (!isHydrating)
        switch (V.tailMode) {
        case "hidden":
            X = V.tail;
            for (var J = null; X !== null; )
                X.alternate !== null && (J = X),
                X = X.sibling;
            J === null ? V.tail = null : J.sibling = null;
            break;
        case "collapsed":
            J = V.tail;
            for (var ne = null; J !== null; )
                J.alternate !== null && (ne = J),
                J = J.sibling;
            ne === null ? X || V.tail === null ? V.tail = null : V.tail.sibling = null : ne.sibling = null
        }
}
function bubbleProperties(V) {
    var X = V.alternate !== null && V.alternate.child === V.child
      , J = 0
      , ne = 0;
    if (X)
        for (var ue = V.child; ue !== null; )
            J |= ue.lanes | ue.childLanes,
            ne |= ue.subtreeFlags & 65011712,
            ne |= ue.flags & 65011712,
            ue.return = V,
            ue = ue.sibling;
    else
        for (ue = V.child; ue !== null; )
            J |= ue.lanes | ue.childLanes,
            ne |= ue.subtreeFlags,
            ne |= ue.flags,
            ue.return = V,
            ue = ue.sibling;
    return V.subtreeFlags |= ne,
    V.childLanes = J,
    X
}
function completeWork(V, X, J) {
    var ne = X.pendingProps;
    switch (popTreeContext(X),
    X.tag) {
    case 31:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
        return bubbleProperties(X),
        null;
    case 1:
        return bubbleProperties(X),
        null;
    case 3:
        return J = X.stateNode,
        ne = null,
        V !== null && (ne = V.memoizedState.cache),
        X.memoizedState.cache !== ne && (X.flags |= 2048),
        popProvider(CacheContext),
        popHostContainer(),
        J.pendingContext && (J.context = J.pendingContext,
        J.pendingContext = null),
        (V === null || V.child === null) && (popHydrationState(X) ? markUpdate(X) : V === null || V.memoizedState.isDehydrated && !(X.flags & 256) || (X.flags |= 1024,
        upgradeHydrationErrorsToRecoverable())),
        bubbleProperties(X),
        null;
    case 26:
        return J = X.memoizedState,
        V === null ? (markUpdate(X),
        J !== null ? (bubbleProperties(X),
        preloadResourceAndSuspendIfNeeded(X, J)) : (bubbleProperties(X),
        X.flags &= -16777217)) : J ? J !== V.memoizedState ? (markUpdate(X),
        bubbleProperties(X),
        preloadResourceAndSuspendIfNeeded(X, J)) : (bubbleProperties(X),
        X.flags &= -16777217) : (V.memoizedProps !== ne && markUpdate(X),
        bubbleProperties(X),
        X.flags &= -16777217),
        null;
    case 27:
        popHostContext(X),
        J = rootInstanceStackCursor.current;
        var ue = X.type;
        if (V !== null && X.stateNode != null)
            V.memoizedProps !== ne && markUpdate(X);
        else {
            if (!ne) {
                if (X.stateNode === null)
                    throw Error(formatProdErrorMessage(166));
                return bubbleProperties(X),
                null
            }
            V = contextStackCursor.current,
            popHydrationState(X) ? prepareToHydrateHostInstance(X) : (V = resolveSingletonInstance(ue, ne, J),
            X.stateNode = V,
            markUpdate(X))
        }
        return bubbleProperties(X),
        null;
    case 5:
        if (popHostContext(X),
        J = X.type,
        V !== null && X.stateNode != null)
            V.memoizedProps !== ne && markUpdate(X);
        else {
            if (!ne) {
                if (X.stateNode === null)
                    throw Error(formatProdErrorMessage(166));
                return bubbleProperties(X),
                null
            }
            if (V = contextStackCursor.current,
            popHydrationState(X))
                prepareToHydrateHostInstance(X);
            else {
                switch (ue = getOwnerDocumentFromRootContainer(rootInstanceStackCursor.current),
                V) {
                case 1:
                    V = ue.createElementNS("http://www.w3.org/2000/svg", J);
                    break;
                case 2:
                    V = ue.createElementNS("http://www.w3.org/1998/Math/MathML", J);
                    break;
                default:
                    switch (J) {
                    case "svg":
                        V = ue.createElementNS("http://www.w3.org/2000/svg", J);
                        break;
                    case "math":
                        V = ue.createElementNS("http://www.w3.org/1998/Math/MathML", J);
                        break;
                    case "script":
                        V = ue.createElement("div"),
                        V.innerHTML = "<script><\/script>",
                        V = V.removeChild(V.firstChild);
                        break;
                    case "select":
                        V = typeof ne.is == "string" ? ue.createElement("select", {
                            is: ne.is
                        }) : ue.createElement("select"),
                        ne.multiple ? V.multiple = !0 : ne.size && (V.size = ne.size);
                        break;
                    default:
                        V = typeof ne.is == "string" ? ue.createElement(J, {
                            is: ne.is
                        }) : ue.createElement(J)
                    }
                }
                V[internalInstanceKey] = X,
                V[internalPropsKey] = ne;
                e: for (ue = X.child; ue !== null; ) {
                    if (ue.tag === 5 || ue.tag === 6)
                        V.appendChild(ue.stateNode);
                    else if (ue.tag !== 4 && ue.tag !== 27 && ue.child !== null) {
                        ue.child.return = ue,
                        ue = ue.child;
                        continue
                    }
                    if (ue === X)
                        break e;
                    for (; ue.sibling === null; ) {
                        if (ue.return === null || ue.return === X)
                            break e;
                        ue = ue.return
                    }
                    ue.sibling.return = ue.return,
                    ue = ue.sibling
                }
                X.stateNode = V;
                e: switch (setInitialProperties(V, J, ne),
                J) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                    V = !!ne.autoFocus;
                    break e;
                case "img":
                    V = !0;
                    break e;
                default:
                    V = !1
                }
                V && markUpdate(X)
            }
        }
        return bubbleProperties(X),
        X.flags &= -16777217,
        null;
    case 6:
        if (V && X.stateNode != null)
            V.memoizedProps !== ne && markUpdate(X);
        else {
            if (typeof ne != "string" && X.stateNode === null)
                throw Error(formatProdErrorMessage(166));
            if (V = rootInstanceStackCursor.current,
            popHydrationState(X)) {
                if (V = X.stateNode,
                J = X.memoizedProps,
                ne = null,
                ue = hydrationParentFiber,
                ue !== null)
                    switch (ue.tag) {
                    case 27:
                    case 5:
                        ne = ue.memoizedProps
                    }
                V[internalInstanceKey] = X,
                V = !!(V.nodeValue === J || ne !== null && ne.suppressHydrationWarning === !0 || checkForUnmatchedText(V.nodeValue, J)),
                V || throwOnHydrationMismatch(X)
            } else
                V = getOwnerDocumentFromRootContainer(V).createTextNode(ne),
                V[internalInstanceKey] = X,
                X.stateNode = V
        }
        return bubbleProperties(X),
        null;
    case 13:
        if (ne = X.memoizedState,
        V === null || V.memoizedState !== null && V.memoizedState.dehydrated !== null) {
            if (ue = popHydrationState(X),
            ne !== null && ne.dehydrated !== null) {
                if (V === null) {
                    if (!ue)
                        throw Error(formatProdErrorMessage(318));
                    if (ue = X.memoizedState,
                    ue = ue !== null ? ue.dehydrated : null,
                    !ue)
                        throw Error(formatProdErrorMessage(317));
                    ue[internalInstanceKey] = X
                } else
                    resetHydrationState(),
                    !(X.flags & 128) && (X.memoizedState = null),
                    X.flags |= 4;
                bubbleProperties(X),
                ue = !1
            } else
                ue = upgradeHydrationErrorsToRecoverable(),
                V !== null && V.memoizedState !== null && (V.memoizedState.hydrationErrors = ue),
                ue = !0;
            if (!ue)
                return X.flags & 256 ? (popSuspenseHandler(X),
                X) : (popSuspenseHandler(X),
                null)
        }
        if (popSuspenseHandler(X),
        X.flags & 128)
            return X.lanes = J,
            X;
        if (J = ne !== null,
        V = V !== null && V.memoizedState !== null,
        J) {
            ne = X.child,
            ue = null,
            ne.alternate !== null && ne.alternate.memoizedState !== null && ne.alternate.memoizedState.cachePool !== null && (ue = ne.alternate.memoizedState.cachePool.pool);
            var ce = null;
            ne.memoizedState !== null && ne.memoizedState.cachePool !== null && (ce = ne.memoizedState.cachePool.pool),
            ce !== ue && (ne.flags |= 2048)
        }
        return J !== V && J && (X.child.flags |= 8192),
        scheduleRetryEffect(X, X.updateQueue),
        bubbleProperties(X),
        null;
    case 4:
        return popHostContainer(),
        V === null && listenToAllSupportedEvents(X.stateNode.containerInfo),
        bubbleProperties(X),
        null;
    case 10:
        return popProvider(X.type),
        bubbleProperties(X),
        null;
    case 19:
        if (pop(suspenseStackCursor),
        ue = X.memoizedState,
        ue === null)
            return bubbleProperties(X),
            null;
        if (ne = (X.flags & 128) !== 0,
        ce = ue.rendering,
        ce === null)
            if (ne)
                cutOffTailIfNeeded(ue, !1);
            else {
                if (workInProgressRootExitStatus !== 0 || V !== null && V.flags & 128)
                    for (V = X.child; V !== null; ) {
                        if (ce = findFirstSuspended(V),
                        ce !== null) {
                            for (X.flags |= 128,
                            cutOffTailIfNeeded(ue, !1),
                            V = ce.updateQueue,
                            X.updateQueue = V,
                            scheduleRetryEffect(X, V),
                            X.subtreeFlags = 0,
                            V = J,
                            J = X.child; J !== null; )
                                resetWorkInProgress(J, V),
                                J = J.sibling;
                            return push$1(suspenseStackCursor, suspenseStackCursor.current & 1 | 2),
                            X.child
                        }
                        V = V.sibling
                    }
                ue.tail !== null && now() > workInProgressRootRenderTargetTime && (X.flags |= 128,
                ne = !0,
                cutOffTailIfNeeded(ue, !1),
                X.lanes = 4194304)
            }
        else {
            if (!ne)
                if (V = findFirstSuspended(ce),
                V !== null) {
                    if (X.flags |= 128,
                    ne = !0,
                    V = V.updateQueue,
                    X.updateQueue = V,
                    scheduleRetryEffect(X, V),
                    cutOffTailIfNeeded(ue, !0),
                    ue.tail === null && ue.tailMode === "hidden" && !ce.alternate && !isHydrating)
                        return bubbleProperties(X),
                        null
                } else
                    2 * now() - ue.renderingStartTime > workInProgressRootRenderTargetTime && J !== 536870912 && (X.flags |= 128,
                    ne = !0,
                    cutOffTailIfNeeded(ue, !1),
                    X.lanes = 4194304);
            ue.isBackwards ? (ce.sibling = X.child,
            X.child = ce) : (V = ue.last,
            V !== null ? V.sibling = ce : X.child = ce,
            ue.last = ce)
        }
        return ue.tail !== null ? (X = ue.tail,
        ue.rendering = X,
        ue.tail = X.sibling,
        ue.renderingStartTime = now(),
        X.sibling = null,
        V = suspenseStackCursor.current,
        push$1(suspenseStackCursor, ne ? V & 1 | 2 : V & 1),
        X) : (bubbleProperties(X),
        null);
    case 22:
    case 23:
        return popSuspenseHandler(X),
        popHiddenContext(),
        ne = X.memoizedState !== null,
        V !== null ? V.memoizedState !== null !== ne && (X.flags |= 8192) : ne && (X.flags |= 8192),
        ne ? J & 536870912 && !(X.flags & 128) && (bubbleProperties(X),
        X.subtreeFlags & 6 && (X.flags |= 8192)) : bubbleProperties(X),
        J = X.updateQueue,
        J !== null && scheduleRetryEffect(X, J.retryQueue),
        J = null,
        V !== null && V.memoizedState !== null && V.memoizedState.cachePool !== null && (J = V.memoizedState.cachePool.pool),
        ne = null,
        X.memoizedState !== null && X.memoizedState.cachePool !== null && (ne = X.memoizedState.cachePool.pool),
        ne !== J && (X.flags |= 2048),
        V !== null && pop(resumedCache),
        null;
    case 24:
        return J = null,
        V !== null && (J = V.memoizedState.cache),
        X.memoizedState.cache !== J && (X.flags |= 2048),
        popProvider(CacheContext),
        bubbleProperties(X),
        null;
    case 25:
        return null;
    case 30:
        return null
    }
    throw Error(formatProdErrorMessage(156, X.tag))
}
function unwindWork(V, X) {
    switch (popTreeContext(X),
    X.tag) {
    case 1:
        return V = X.flags,
        V & 65536 ? (X.flags = V & -65537 | 128,
        X) : null;
    case 3:
        return popProvider(CacheContext),
        popHostContainer(),
        V = X.flags,
        V & 65536 && !(V & 128) ? (X.flags = V & -65537 | 128,
        X) : null;
    case 26:
    case 27:
    case 5:
        return popHostContext(X),
        null;
    case 13:
        if (popSuspenseHandler(X),
        V = X.memoizedState,
        V !== null && V.dehydrated !== null) {
            if (X.alternate === null)
                throw Error(formatProdErrorMessage(340));
            resetHydrationState()
        }
        return V = X.flags,
        V & 65536 ? (X.flags = V & -65537 | 128,
        X) : null;
    case 19:
        return pop(suspenseStackCursor),
        null;
    case 4:
        return popHostContainer(),
        null;
    case 10:
        return popProvider(X.type),
        null;
    case 22:
    case 23:
        return popSuspenseHandler(X),
        popHiddenContext(),
        V !== null && pop(resumedCache),
        V = X.flags,
        V & 65536 ? (X.flags = V & -65537 | 128,
        X) : null;
    case 24:
        return popProvider(CacheContext),
        null;
    case 25:
        return null;
    default:
        return null
    }
}
function unwindInterruptedWork(V, X) {
    switch (popTreeContext(X),
    X.tag) {
    case 3:
        popProvider(CacheContext),
        popHostContainer();
        break;
    case 26:
    case 27:
    case 5:
        popHostContext(X);
        break;
    case 4:
        popHostContainer();
        break;
    case 13:
        popSuspenseHandler(X);
        break;
    case 19:
        pop(suspenseStackCursor);
        break;
    case 10:
        popProvider(X.type);
        break;
    case 22:
    case 23:
        popSuspenseHandler(X),
        popHiddenContext(),
        V !== null && pop(resumedCache);
        break;
    case 24:
        popProvider(CacheContext)
    }
}
function commitHookEffectListMount(V, X) {
    try {
        var J = X.updateQueue
          , ne = J !== null ? J.lastEffect : null;
        if (ne !== null) {
            var ue = ne.next;
            J = ue;
            do {
                if ((J.tag & V) === V) {
                    ne = void 0;
                    var ce = J.create
                      , me = J.inst;
                    ne = ce(),
                    me.destroy = ne
                }
                J = J.next
            } while (J !== ue)
        }
    } catch (ge) {
        captureCommitPhaseError(X, X.return, ge)
    }
}
function commitHookEffectListUnmount(V, X, J) {
    try {
        var ne = X.updateQueue
          , ue = ne !== null ? ne.lastEffect : null;
        if (ue !== null) {
            var ce = ue.next;
            ne = ce;
            do {
                if ((ne.tag & V) === V) {
                    var me = ne.inst
                      , ge = me.destroy;
                    if (ge !== void 0) {
                        me.destroy = void 0,
                        ue = X;
                        var Te = J
                          , _e = ge;
                        try {
                            _e()
                        } catch (Se) {
                            captureCommitPhaseError(ue, Te, Se)
                        }
                    }
                }
                ne = ne.next
            } while (ne !== ce)
        }
    } catch (Se) {
        captureCommitPhaseError(X, X.return, Se)
    }
}
function commitClassCallbacks(V) {
    var X = V.updateQueue;
    if (X !== null) {
        var J = V.stateNode;
        try {
            commitCallbacks(X, J)
        } catch (ne) {
            captureCommitPhaseError(V, V.return, ne)
        }
    }
}
function safelyCallComponentWillUnmount(V, X, J) {
    J.props = resolveClassComponentProps(V.type, V.memoizedProps),
    J.state = V.memoizedState;
    try {
        J.componentWillUnmount()
    } catch (ne) {
        captureCommitPhaseError(V, X, ne)
    }
}
function safelyAttachRef(V, X) {
    try {
        var J = V.ref;
        if (J !== null) {
            switch (V.tag) {
            case 26:
            case 27:
            case 5:
                var ne = V.stateNode;
                break;
            case 30:
                ne = V.stateNode;
                break;
            default:
                ne = V.stateNode
            }
            typeof J == "function" ? V.refCleanup = J(ne) : J.current = ne
        }
    } catch (ue) {
        captureCommitPhaseError(V, X, ue)
    }
}
function safelyDetachRef(V, X) {
    var J = V.ref
      , ne = V.refCleanup;
    if (J !== null)
        if (typeof ne == "function")
            try {
                ne()
            } catch (ue) {
                captureCommitPhaseError(V, X, ue)
            } finally {
                V.refCleanup = null,
                V = V.alternate,
                V != null && (V.refCleanup = null)
            }
        else if (typeof J == "function")
            try {
                J(null)
            } catch (ue) {
                captureCommitPhaseError(V, X, ue)
            }
        else
            J.current = null
}
function commitHostMount(V) {
    var X = V.type
      , J = V.memoizedProps
      , ne = V.stateNode;
    try {
        e: switch (X) {
        case "button":
        case "input":
        case "select":
        case "textarea":
            J.autoFocus && ne.focus();
            break e;
        case "img":
            J.src ? ne.src = J.src : J.srcSet && (ne.srcset = J.srcSet)
        }
    } catch (ue) {
        captureCommitPhaseError(V, V.return, ue)
    }
}
function commitHostUpdate(V, X, J) {
    try {
        var ne = V.stateNode;
        updateProperties(ne, V.type, J, X),
        ne[internalPropsKey] = X
    } catch (ue) {
        captureCommitPhaseError(V, V.return, ue)
    }
}
function isHostParent(V) {
    return V.tag === 5 || V.tag === 3 || V.tag === 26 || V.tag === 27 && isSingletonScope(V.type) || V.tag === 4
}
function getHostSibling(V) {
    e: for (; ; ) {
        for (; V.sibling === null; ) {
            if (V.return === null || isHostParent(V.return))
                return null;
            V = V.return
        }
        for (V.sibling.return = V.return,
        V = V.sibling; V.tag !== 5 && V.tag !== 6 && V.tag !== 18; ) {
            if (V.tag === 27 && isSingletonScope(V.type) || V.flags & 2 || V.child === null || V.tag === 4)
                continue e;
            V.child.return = V,
            V = V.child
        }
        if (!(V.flags & 2))
            return V.stateNode
    }
}
function insertOrAppendPlacementNodeIntoContainer(V, X, J) {
    var ne = V.tag;
    if (ne === 5 || ne === 6)
        V = V.stateNode,
        X ? (J.nodeType === 9 ? J.body : J.nodeName === "HTML" ? J.ownerDocument.body : J).insertBefore(V, X) : (X = J.nodeType === 9 ? J.body : J.nodeName === "HTML" ? J.ownerDocument.body : J,
        X.appendChild(V),
        J = J._reactRootContainer,
        J != null || X.onclick !== null || (X.onclick = noop$1));
    else if (ne !== 4 && (ne === 27 && isSingletonScope(V.type) && (J = V.stateNode,
    X = null),
    V = V.child,
    V !== null))
        for (insertOrAppendPlacementNodeIntoContainer(V, X, J),
        V = V.sibling; V !== null; )
            insertOrAppendPlacementNodeIntoContainer(V, X, J),
            V = V.sibling
}
function insertOrAppendPlacementNode(V, X, J) {
    var ne = V.tag;
    if (ne === 5 || ne === 6)
        V = V.stateNode,
        X ? J.insertBefore(V, X) : J.appendChild(V);
    else if (ne !== 4 && (ne === 27 && isSingletonScope(V.type) && (J = V.stateNode),
    V = V.child,
    V !== null))
        for (insertOrAppendPlacementNode(V, X, J),
        V = V.sibling; V !== null; )
            insertOrAppendPlacementNode(V, X, J),
            V = V.sibling
}
function commitHostSingletonAcquisition(V) {
    var X = V.stateNode
      , J = V.memoizedProps;
    try {
        for (var ne = V.type, ue = X.attributes; ue.length; )
            X.removeAttributeNode(ue[0]);
        setInitialProperties(X, ne, J),
        X[internalInstanceKey] = V,
        X[internalPropsKey] = J
    } catch (ce) {
        captureCommitPhaseError(V, V.return, ce)
    }
}
var offscreenSubtreeIsHidden = !1
  , offscreenSubtreeWasHidden = !1
  , needsFormReset = !1
  , PossiblyWeakSet = typeof WeakSet == "function" ? WeakSet : Set
  , nextEffect = null;
function commitBeforeMutationEffects(V, X) {
    if (V = V.containerInfo,
    eventsEnabled = _enabled,
    V = getActiveElementDeep(V),
    hasSelectionCapabilities(V)) {
        if ("selectionStart"in V)
            var J = {
                start: V.selectionStart,
                end: V.selectionEnd
            };
        else
            e: {
                J = (J = V.ownerDocument) && J.defaultView || window;
                var ne = J.getSelection && J.getSelection();
                if (ne && ne.rangeCount !== 0) {
                    J = ne.anchorNode;
                    var ue = ne.anchorOffset
                      , ce = ne.focusNode;
                    ne = ne.focusOffset;
                    try {
                        J.nodeType,
                        ce.nodeType
                    } catch {
                        J = null;
                        break e
                    }
                    var me = 0
                      , ge = -1
                      , Te = -1
                      , _e = 0
                      , Se = 0
                      , Ie = V
                      , ye = null;
                    t: for (; ; ) {
                        for (var $e; Ie !== J || ue !== 0 && Ie.nodeType !== 3 || (ge = me + ue),
                        Ie !== ce || ne !== 0 && Ie.nodeType !== 3 || (Te = me + ne),
                        Ie.nodeType === 3 && (me += Ie.nodeValue.length),
                        ($e = Ie.firstChild) !== null; )
                            ye = Ie,
                            Ie = $e;
                        for (; ; ) {
                            if (Ie === V)
                                break t;
                            if (ye === J && ++_e === ue && (ge = me),
                            ye === ce && ++Se === ne && (Te = me),
                            ($e = Ie.nextSibling) !== null)
                                break;
                            Ie = ye,
                            ye = Ie.parentNode
                        }
                        Ie = $e
                    }
                    J = ge === -1 || Te === -1 ? null : {
                        start: ge,
                        end: Te
                    }
                } else
                    J = null
            }
        J = J || {
            start: 0,
            end: 0
        }
    } else
        J = null;
    for (selectionInformation = {
        focusedElem: V,
        selectionRange: J
    },
    _enabled = !1,
    nextEffect = X; nextEffect !== null; )
        if (X = nextEffect,
        V = X.child,
        (X.subtreeFlags & 1024) !== 0 && V !== null)
            V.return = X,
            nextEffect = V;
        else
            for (; nextEffect !== null; ) {
                switch (X = nextEffect,
                ce = X.alternate,
                V = X.flags,
                X.tag) {
                case 0:
                    break;
                case 11:
                case 15:
                    break;
                case 1:
                    if (V & 1024 && ce !== null) {
                        V = void 0,
                        J = X,
                        ue = ce.memoizedProps,
                        ce = ce.memoizedState,
                        ne = J.stateNode;
                        try {
                            var Ne = resolveClassComponentProps(J.type, ue, J.elementType === J.type);
                            V = ne.getSnapshotBeforeUpdate(Ne, ce),
                            ne.__reactInternalSnapshotBeforeUpdate = V
                        } catch (ve) {
                            captureCommitPhaseError(J, J.return, ve)
                        }
                    }
                    break;
                case 3:
                    if (V & 1024) {
                        if (V = X.stateNode.containerInfo,
                        J = V.nodeType,
                        J === 9)
                            clearContainerSparingly(V);
                        else if (J === 1)
                            switch (V.nodeName) {
                            case "HEAD":
                            case "HTML":
                            case "BODY":
                                clearContainerSparingly(V);
                                break;
                            default:
                                V.textContent = ""
                            }
                    }
                    break;
                case 5:
                case 26:
                case 27:
                case 6:
                case 4:
                case 17:
                    break;
                default:
                    if (V & 1024)
                        throw Error(formatProdErrorMessage(163))
                }
                if (V = X.sibling,
                V !== null) {
                    V.return = X.return,
                    nextEffect = V;
                    break
                }
                nextEffect = X.return
            }
}
function commitLayoutEffectOnFiber(V, X, J) {
    var ne = J.flags;
    switch (J.tag) {
    case 0:
    case 11:
    case 15:
        recursivelyTraverseLayoutEffects(V, J),
        ne & 4 && commitHookEffectListMount(5, J);
        break;
    case 1:
        if (recursivelyTraverseLayoutEffects(V, J),
        ne & 4)
            if (V = J.stateNode,
            X === null)
                try {
                    V.componentDidMount()
                } catch (me) {
                    captureCommitPhaseError(J, J.return, me)
                }
            else {
                var ue = resolveClassComponentProps(J.type, X.memoizedProps);
                X = X.memoizedState;
                try {
                    V.componentDidUpdate(ue, X, V.__reactInternalSnapshotBeforeUpdate)
                } catch (me) {
                    captureCommitPhaseError(J, J.return, me)
                }
            }
        ne & 64 && commitClassCallbacks(J),
        ne & 512 && safelyAttachRef(J, J.return);
        break;
    case 3:
        if (recursivelyTraverseLayoutEffects(V, J),
        ne & 64 && (V = J.updateQueue,
        V !== null)) {
            if (X = null,
            J.child !== null)
                switch (J.child.tag) {
                case 27:
                case 5:
                    X = J.child.stateNode;
                    break;
                case 1:
                    X = J.child.stateNode
                }
            try {
                commitCallbacks(V, X)
            } catch (me) {
                captureCommitPhaseError(J, J.return, me)
            }
        }
        break;
    case 27:
        X === null && ne & 4 && commitHostSingletonAcquisition(J);
    case 26:
    case 5:
        recursivelyTraverseLayoutEffects(V, J),
        X === null && ne & 4 && commitHostMount(J),
        ne & 512 && safelyAttachRef(J, J.return);
        break;
    case 12:
        recursivelyTraverseLayoutEffects(V, J);
        break;
    case 13:
        recursivelyTraverseLayoutEffects(V, J),
        ne & 4 && commitSuspenseHydrationCallbacks(V, J),
        ne & 64 && (V = J.memoizedState,
        V !== null && (V = V.dehydrated,
        V !== null && (J = retryDehydratedSuspenseBoundary.bind(null, J),
        registerSuspenseInstanceRetry(V, J))));
        break;
    case 22:
        if (ne = J.memoizedState !== null || offscreenSubtreeIsHidden,
        !ne) {
            X = X !== null && X.memoizedState !== null || offscreenSubtreeWasHidden,
            ue = offscreenSubtreeIsHidden;
            var ce = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = ne,
            (offscreenSubtreeWasHidden = X) && !ce ? recursivelyTraverseReappearLayoutEffects(V, J, (J.subtreeFlags & 8772) !== 0) : recursivelyTraverseLayoutEffects(V, J),
            offscreenSubtreeIsHidden = ue,
            offscreenSubtreeWasHidden = ce
        }
        break;
    case 30:
        break;
    default:
        recursivelyTraverseLayoutEffects(V, J)
    }
}
function detachFiberAfterEffects(V) {
    var X = V.alternate;
    X !== null && (V.alternate = null,
    detachFiberAfterEffects(X)),
    V.child = null,
    V.deletions = null,
    V.sibling = null,
    V.tag === 5 && (X = V.stateNode,
    X !== null && detachDeletedInstance(X)),
    V.stateNode = null,
    V.return = null,
    V.dependencies = null,
    V.memoizedProps = null,
    V.memoizedState = null,
    V.pendingProps = null,
    V.stateNode = null,
    V.updateQueue = null
}
var hostParent = null
  , hostParentIsContainer = !1;
function recursivelyTraverseDeletionEffects(V, X, J) {
    for (J = J.child; J !== null; )
        commitDeletionEffectsOnFiber(V, X, J),
        J = J.sibling
}
function commitDeletionEffectsOnFiber(V, X, J) {
    if (injectedHook && typeof injectedHook.onCommitFiberUnmount == "function")
        try {
            injectedHook.onCommitFiberUnmount(rendererID, J)
        } catch {}
    switch (J.tag) {
    case 26:
        offscreenSubtreeWasHidden || safelyDetachRef(J, X),
        recursivelyTraverseDeletionEffects(V, X, J),
        J.memoizedState ? J.memoizedState.count-- : J.stateNode && (J = J.stateNode,
        J.parentNode.removeChild(J));
        break;
    case 27:
        offscreenSubtreeWasHidden || safelyDetachRef(J, X);
        var ne = hostParent
          , ue = hostParentIsContainer;
        isSingletonScope(J.type) && (hostParent = J.stateNode,
        hostParentIsContainer = !1),
        recursivelyTraverseDeletionEffects(V, X, J),
        releaseSingletonInstance(J.stateNode),
        hostParent = ne,
        hostParentIsContainer = ue;
        break;
    case 5:
        offscreenSubtreeWasHidden || safelyDetachRef(J, X);
    case 6:
        if (ne = hostParent,
        ue = hostParentIsContainer,
        hostParent = null,
        recursivelyTraverseDeletionEffects(V, X, J),
        hostParent = ne,
        hostParentIsContainer = ue,
        hostParent !== null)
            if (hostParentIsContainer)
                try {
                    (hostParent.nodeType === 9 ? hostParent.body : hostParent.nodeName === "HTML" ? hostParent.ownerDocument.body : hostParent).removeChild(J.stateNode)
                } catch (ce) {
                    captureCommitPhaseError(J, X, ce)
                }
            else
                try {
                    hostParent.removeChild(J.stateNode)
                } catch (ce) {
                    captureCommitPhaseError(J, X, ce)
                }
        break;
    case 18:
        hostParent !== null && (hostParentIsContainer ? (V = hostParent,
        clearSuspenseBoundary(V.nodeType === 9 ? V.body : V.nodeName === "HTML" ? V.ownerDocument.body : V, J.stateNode),
        retryIfBlockedOn(V)) : clearSuspenseBoundary(hostParent, J.stateNode));
        break;
    case 4:
        ne = hostParent,
        ue = hostParentIsContainer,
        hostParent = J.stateNode.containerInfo,
        hostParentIsContainer = !0,
        recursivelyTraverseDeletionEffects(V, X, J),
        hostParent = ne,
        hostParentIsContainer = ue;
        break;
    case 0:
    case 11:
    case 14:
    case 15:
        offscreenSubtreeWasHidden || commitHookEffectListUnmount(2, J, X),
        offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, J, X),
        recursivelyTraverseDeletionEffects(V, X, J);
        break;
    case 1:
        offscreenSubtreeWasHidden || (safelyDetachRef(J, X),
        ne = J.stateNode,
        typeof ne.componentWillUnmount == "function" && safelyCallComponentWillUnmount(J, X, ne)),
        recursivelyTraverseDeletionEffects(V, X, J);
        break;
    case 21:
        recursivelyTraverseDeletionEffects(V, X, J);
        break;
    case 22:
        offscreenSubtreeWasHidden = (ne = offscreenSubtreeWasHidden) || J.memoizedState !== null,
        recursivelyTraverseDeletionEffects(V, X, J),
        offscreenSubtreeWasHidden = ne;
        break;
    default:
        recursivelyTraverseDeletionEffects(V, X, J)
    }
}
function commitSuspenseHydrationCallbacks(V, X) {
    if (X.memoizedState === null && (V = X.alternate,
    V !== null && (V = V.memoizedState,
    V !== null && (V = V.dehydrated,
    V !== null))))
        try {
            retryIfBlockedOn(V)
        } catch (J) {
            captureCommitPhaseError(X, X.return, J)
        }
}
function getRetryCache(V) {
    switch (V.tag) {
    case 13:
    case 19:
        var X = V.stateNode;
        return X === null && (X = V.stateNode = new PossiblyWeakSet),
        X;
    case 22:
        return V = V.stateNode,
        X = V._retryCache,
        X === null && (X = V._retryCache = new PossiblyWeakSet),
        X;
    default:
        throw Error(formatProdErrorMessage(435, V.tag))
    }
}
function attachSuspenseRetryListeners(V, X) {
    var J = getRetryCache(V);
    X.forEach(function(ne) {
        var ue = resolveRetryWakeable.bind(null, V, ne);
        J.has(ne) || (J.add(ne),
        ne.then(ue, ue))
    })
}
function recursivelyTraverseMutationEffects(V, X) {
    var J = X.deletions;
    if (J !== null)
        for (var ne = 0; ne < J.length; ne++) {
            var ue = J[ne]
              , ce = V
              , me = X
              , ge = me;
            e: for (; ge !== null; ) {
                switch (ge.tag) {
                case 27:
                    if (isSingletonScope(ge.type)) {
                        hostParent = ge.stateNode,
                        hostParentIsContainer = !1;
                        break e
                    }
                    break;
                case 5:
                    hostParent = ge.stateNode,
                    hostParentIsContainer = !1;
                    break e;
                case 3:
                case 4:
                    hostParent = ge.stateNode.containerInfo,
                    hostParentIsContainer = !0;
                    break e
                }
                ge = ge.return
            }
            if (hostParent === null)
                throw Error(formatProdErrorMessage(160));
            commitDeletionEffectsOnFiber(ce, me, ue),
            hostParent = null,
            hostParentIsContainer = !1,
            ce = ue.alternate,
            ce !== null && (ce.return = null),
            ue.return = null
        }
    if (X.subtreeFlags & 13878)
        for (X = X.child; X !== null; )
            commitMutationEffectsOnFiber(X, V),
            X = X.sibling
}
var currentHoistableRoot = null;
function commitMutationEffectsOnFiber(V, X) {
    var J = V.alternate
      , ne = V.flags;
    switch (V.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
        recursivelyTraverseMutationEffects(X, V),
        commitReconciliationEffects(V),
        ne & 4 && (commitHookEffectListUnmount(3, V, V.return),
        commitHookEffectListMount(3, V),
        commitHookEffectListUnmount(5, V, V.return));
        break;
    case 1:
        recursivelyTraverseMutationEffects(X, V),
        commitReconciliationEffects(V),
        ne & 512 && (offscreenSubtreeWasHidden || J === null || safelyDetachRef(J, J.return)),
        ne & 64 && offscreenSubtreeIsHidden && (V = V.updateQueue,
        V !== null && (ne = V.callbacks,
        ne !== null && (J = V.shared.hiddenCallbacks,
        V.shared.hiddenCallbacks = J === null ? ne : J.concat(ne))));
        break;
    case 26:
        var ue = currentHoistableRoot;
        if (recursivelyTraverseMutationEffects(X, V),
        commitReconciliationEffects(V),
        ne & 512 && (offscreenSubtreeWasHidden || J === null || safelyDetachRef(J, J.return)),
        ne & 4) {
            var ce = J !== null ? J.memoizedState : null;
            if (ne = V.memoizedState,
            J === null)
                if (ne === null)
                    if (V.stateNode === null) {
                        e: {
                            ne = V.type,
                            J = V.memoizedProps,
                            ue = ue.ownerDocument || ue;
                            t: switch (ne) {
                            case "title":
                                ce = ue.getElementsByTagName("title")[0],
                                (!ce || ce[internalHoistableMarker] || ce[internalInstanceKey] || ce.namespaceURI === "http://www.w3.org/2000/svg" || ce.hasAttribute("itemprop")) && (ce = ue.createElement(ne),
                                ue.head.insertBefore(ce, ue.querySelector("head > title"))),
                                setInitialProperties(ce, ne, J),
                                ce[internalInstanceKey] = V,
                                markNodeAsHoistable(ce),
                                ne = ce;
                                break e;
                            case "link":
                                var me = getHydratableHoistableCache("link", "href", ue).get(ne + (J.href || ""));
                                if (me) {
                                    for (var ge = 0; ge < me.length; ge++)
                                        if (ce = me[ge],
                                        ce.getAttribute("href") === (J.href == null || J.href === "" ? null : J.href) && ce.getAttribute("rel") === (J.rel == null ? null : J.rel) && ce.getAttribute("title") === (J.title == null ? null : J.title) && ce.getAttribute("crossorigin") === (J.crossOrigin == null ? null : J.crossOrigin)) {
                                            me.splice(ge, 1);
                                            break t
                                        }
                                }
                                ce = ue.createElement(ne),
                                setInitialProperties(ce, ne, J),
                                ue.head.appendChild(ce);
                                break;
                            case "meta":
                                if (me = getHydratableHoistableCache("meta", "content", ue).get(ne + (J.content || ""))) {
                                    for (ge = 0; ge < me.length; ge++)
                                        if (ce = me[ge],
                                        ce.getAttribute("content") === (J.content == null ? null : "" + J.content) && ce.getAttribute("name") === (J.name == null ? null : J.name) && ce.getAttribute("property") === (J.property == null ? null : J.property) && ce.getAttribute("http-equiv") === (J.httpEquiv == null ? null : J.httpEquiv) && ce.getAttribute("charset") === (J.charSet == null ? null : J.charSet)) {
                                            me.splice(ge, 1);
                                            break t
                                        }
                                }
                                ce = ue.createElement(ne),
                                setInitialProperties(ce, ne, J),
                                ue.head.appendChild(ce);
                                break;
                            default:
                                throw Error(formatProdErrorMessage(468, ne))
                            }
                            ce[internalInstanceKey] = V,
                            markNodeAsHoistable(ce),
                            ne = ce
                        }
                        V.stateNode = ne
                    } else
                        mountHoistable(ue, V.type, V.stateNode);
                else
                    V.stateNode = acquireResource(ue, ne, V.memoizedProps);
            else
                ce !== ne ? (ce === null ? J.stateNode !== null && (J = J.stateNode,
                J.parentNode.removeChild(J)) : ce.count--,
                ne === null ? mountHoistable(ue, V.type, V.stateNode) : acquireResource(ue, ne, V.memoizedProps)) : ne === null && V.stateNode !== null && commitHostUpdate(V, V.memoizedProps, J.memoizedProps)
        }
        break;
    case 27:
        recursivelyTraverseMutationEffects(X, V),
        commitReconciliationEffects(V),
        ne & 512 && (offscreenSubtreeWasHidden || J === null || safelyDetachRef(J, J.return)),
        J !== null && ne & 4 && commitHostUpdate(V, V.memoizedProps, J.memoizedProps);
        break;
    case 5:
        if (recursivelyTraverseMutationEffects(X, V),
        commitReconciliationEffects(V),
        ne & 512 && (offscreenSubtreeWasHidden || J === null || safelyDetachRef(J, J.return)),
        V.flags & 32) {
            ue = V.stateNode;
            try {
                setTextContent(ue, "")
            } catch ($e) {
                captureCommitPhaseError(V, V.return, $e)
            }
        }
        ne & 4 && V.stateNode != null && (ue = V.memoizedProps,
        commitHostUpdate(V, ue, J !== null ? J.memoizedProps : ue)),
        ne & 1024 && (needsFormReset = !0);
        break;
    case 6:
        if (recursivelyTraverseMutationEffects(X, V),
        commitReconciliationEffects(V),
        ne & 4) {
            if (V.stateNode === null)
                throw Error(formatProdErrorMessage(162));
            ne = V.memoizedProps,
            J = V.stateNode;
            try {
                J.nodeValue = ne
            } catch ($e) {
                captureCommitPhaseError(V, V.return, $e)
            }
        }
        break;
    case 3:
        if (tagCaches = null,
        ue = currentHoistableRoot,
        currentHoistableRoot = getHoistableRoot(X.containerInfo),
        recursivelyTraverseMutationEffects(X, V),
        currentHoistableRoot = ue,
        commitReconciliationEffects(V),
        ne & 4 && J !== null && J.memoizedState.isDehydrated)
            try {
                retryIfBlockedOn(X.containerInfo)
            } catch ($e) {
                captureCommitPhaseError(V, V.return, $e)
            }
        needsFormReset && (needsFormReset = !1,
        recursivelyResetForms(V));
        break;
    case 4:
        ne = currentHoistableRoot,
        currentHoistableRoot = getHoistableRoot(V.stateNode.containerInfo),
        recursivelyTraverseMutationEffects(X, V),
        commitReconciliationEffects(V),
        currentHoistableRoot = ne;
        break;
    case 12:
        recursivelyTraverseMutationEffects(X, V),
        commitReconciliationEffects(V);
        break;
    case 13:
        recursivelyTraverseMutationEffects(X, V),
        commitReconciliationEffects(V),
        V.child.flags & 8192 && V.memoizedState !== null != (J !== null && J.memoizedState !== null) && (globalMostRecentFallbackTime = now()),
        ne & 4 && (ne = V.updateQueue,
        ne !== null && (V.updateQueue = null,
        attachSuspenseRetryListeners(V, ne)));
        break;
    case 22:
        ue = V.memoizedState !== null;
        var Te = J !== null && J.memoizedState !== null
          , _e = offscreenSubtreeIsHidden
          , Se = offscreenSubtreeWasHidden;
        if (offscreenSubtreeIsHidden = _e || ue,
        offscreenSubtreeWasHidden = Se || Te,
        recursivelyTraverseMutationEffects(X, V),
        offscreenSubtreeWasHidden = Se,
        offscreenSubtreeIsHidden = _e,
        commitReconciliationEffects(V),
        ne & 8192)
            e: for (X = V.stateNode,
            X._visibility = ue ? X._visibility & -2 : X._visibility | 1,
            ue && (J === null || Te || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(V)),
            J = null,
            X = V; ; ) {
                if (X.tag === 5 || X.tag === 26) {
                    if (J === null) {
                        Te = J = X;
                        try {
                            if (ce = Te.stateNode,
                            ue)
                                me = ce.style,
                                typeof me.setProperty == "function" ? me.setProperty("display", "none", "important") : me.display = "none";
                            else {
                                ge = Te.stateNode;
                                var Ie = Te.memoizedProps.style
                                  , ye = Ie != null && Ie.hasOwnProperty("display") ? Ie.display : null;
                                ge.style.display = ye == null || typeof ye == "boolean" ? "" : ("" + ye).trim()
                            }
                        } catch ($e) {
                            captureCommitPhaseError(Te, Te.return, $e)
                        }
                    }
                } else if (X.tag === 6) {
                    if (J === null) {
                        Te = X;
                        try {
                            Te.stateNode.nodeValue = ue ? "" : Te.memoizedProps
                        } catch ($e) {
                            captureCommitPhaseError(Te, Te.return, $e)
                        }
                    }
                } else if ((X.tag !== 22 && X.tag !== 23 || X.memoizedState === null || X === V) && X.child !== null) {
                    X.child.return = X,
                    X = X.child;
                    continue
                }
                if (X === V)
                    break e;
                for (; X.sibling === null; ) {
                    if (X.return === null || X.return === V)
                        break e;
                    J === X && (J = null),
                    X = X.return
                }
                J === X && (J = null),
                X.sibling.return = X.return,
                X = X.sibling
            }
        ne & 4 && (ne = V.updateQueue,
        ne !== null && (J = ne.retryQueue,
        J !== null && (ne.retryQueue = null,
        attachSuspenseRetryListeners(V, J))));
        break;
    case 19:
        recursivelyTraverseMutationEffects(X, V),
        commitReconciliationEffects(V),
        ne & 4 && (ne = V.updateQueue,
        ne !== null && (V.updateQueue = null,
        attachSuspenseRetryListeners(V, ne)));
        break;
    case 30:
        break;
    case 21:
        break;
    default:
        recursivelyTraverseMutationEffects(X, V),
        commitReconciliationEffects(V)
    }
}
function commitReconciliationEffects(V) {
    var X = V.flags;
    if (X & 2) {
        try {
            for (var J, ne = V.return; ne !== null; ) {
                if (isHostParent(ne)) {
                    J = ne;
                    break
                }
                ne = ne.return
            }
            if (J == null)
                throw Error(formatProdErrorMessage(160));
            switch (J.tag) {
            case 27:
                var ue = J.stateNode
                  , ce = getHostSibling(V);
                insertOrAppendPlacementNode(V, ce, ue);
                break;
            case 5:
                var me = J.stateNode;
                J.flags & 32 && (setTextContent(me, ""),
                J.flags &= -33);
                var ge = getHostSibling(V);
                insertOrAppendPlacementNode(V, ge, me);
                break;
            case 3:
            case 4:
                var Te = J.stateNode.containerInfo
                  , _e = getHostSibling(V);
                insertOrAppendPlacementNodeIntoContainer(V, _e, Te);
                break;
            default:
                throw Error(formatProdErrorMessage(161))
            }
        } catch (Se) {
            captureCommitPhaseError(V, V.return, Se)
        }
        V.flags &= -3
    }
    X & 4096 && (V.flags &= -4097)
}
function recursivelyResetForms(V) {
    if (V.subtreeFlags & 1024)
        for (V = V.child; V !== null; ) {
            var X = V;
            recursivelyResetForms(X),
            X.tag === 5 && X.flags & 1024 && X.stateNode.reset(),
            V = V.sibling
        }
}
function recursivelyTraverseLayoutEffects(V, X) {
    if (X.subtreeFlags & 8772)
        for (X = X.child; X !== null; )
            commitLayoutEffectOnFiber(V, X.alternate, X),
            X = X.sibling
}
function recursivelyTraverseDisappearLayoutEffects(V) {
    for (V = V.child; V !== null; ) {
        var X = V;
        switch (X.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            commitHookEffectListUnmount(4, X, X.return),
            recursivelyTraverseDisappearLayoutEffects(X);
            break;
        case 1:
            safelyDetachRef(X, X.return);
            var J = X.stateNode;
            typeof J.componentWillUnmount == "function" && safelyCallComponentWillUnmount(X, X.return, J),
            recursivelyTraverseDisappearLayoutEffects(X);
            break;
        case 27:
            releaseSingletonInstance(X.stateNode);
        case 26:
        case 5:
            safelyDetachRef(X, X.return),
            recursivelyTraverseDisappearLayoutEffects(X);
            break;
        case 22:
            X.memoizedState === null && recursivelyTraverseDisappearLayoutEffects(X);
            break;
        case 30:
            recursivelyTraverseDisappearLayoutEffects(X);
            break;
        default:
            recursivelyTraverseDisappearLayoutEffects(X)
        }
        V = V.sibling
    }
}
function recursivelyTraverseReappearLayoutEffects(V, X, J) {
    for (J = J && (X.subtreeFlags & 8772) !== 0,
    X = X.child; X !== null; ) {
        var ne = X.alternate
          , ue = V
          , ce = X
          , me = ce.flags;
        switch (ce.tag) {
        case 0:
        case 11:
        case 15:
            recursivelyTraverseReappearLayoutEffects(ue, ce, J),
            commitHookEffectListMount(4, ce);
            break;
        case 1:
            if (recursivelyTraverseReappearLayoutEffects(ue, ce, J),
            ne = ce,
            ue = ne.stateNode,
            typeof ue.componentDidMount == "function")
                try {
                    ue.componentDidMount()
                } catch (_e) {
                    captureCommitPhaseError(ne, ne.return, _e)
                }
            if (ne = ce,
            ue = ne.updateQueue,
            ue !== null) {
                var ge = ne.stateNode;
                try {
                    var Te = ue.shared.hiddenCallbacks;
                    if (Te !== null)
                        for (ue.shared.hiddenCallbacks = null,
                        ue = 0; ue < Te.length; ue++)
                            callCallback(Te[ue], ge)
                } catch (_e) {
                    captureCommitPhaseError(ne, ne.return, _e)
                }
            }
            J && me & 64 && commitClassCallbacks(ce),
            safelyAttachRef(ce, ce.return);
            break;
        case 27:
            commitHostSingletonAcquisition(ce);
        case 26:
        case 5:
            recursivelyTraverseReappearLayoutEffects(ue, ce, J),
            J && ne === null && me & 4 && commitHostMount(ce),
            safelyAttachRef(ce, ce.return);
            break;
        case 12:
            recursivelyTraverseReappearLayoutEffects(ue, ce, J);
            break;
        case 13:
            recursivelyTraverseReappearLayoutEffects(ue, ce, J),
            J && me & 4 && commitSuspenseHydrationCallbacks(ue, ce);
            break;
        case 22:
            ce.memoizedState === null && recursivelyTraverseReappearLayoutEffects(ue, ce, J),
            safelyAttachRef(ce, ce.return);
            break;
        case 30:
            break;
        default:
            recursivelyTraverseReappearLayoutEffects(ue, ce, J)
        }
        X = X.sibling
    }
}
function commitOffscreenPassiveMountEffects(V, X) {
    var J = null;
    V !== null && V.memoizedState !== null && V.memoizedState.cachePool !== null && (J = V.memoizedState.cachePool.pool),
    V = null,
    X.memoizedState !== null && X.memoizedState.cachePool !== null && (V = X.memoizedState.cachePool.pool),
    V !== J && (V != null && V.refCount++,
    J != null && releaseCache(J))
}
function commitCachePassiveMountEffect(V, X) {
    V = null,
    X.alternate !== null && (V = X.alternate.memoizedState.cache),
    X = X.memoizedState.cache,
    X !== V && (X.refCount++,
    V != null && releaseCache(V))
}
function recursivelyTraversePassiveMountEffects(V, X, J, ne) {
    if (X.subtreeFlags & 10256)
        for (X = X.child; X !== null; )
            commitPassiveMountOnFiber(V, X, J, ne),
            X = X.sibling
}
function commitPassiveMountOnFiber(V, X, J, ne) {
    var ue = X.flags;
    switch (X.tag) {
    case 0:
    case 11:
    case 15:
        recursivelyTraversePassiveMountEffects(V, X, J, ne),
        ue & 2048 && commitHookEffectListMount(9, X);
        break;
    case 1:
        recursivelyTraversePassiveMountEffects(V, X, J, ne);
        break;
    case 3:
        recursivelyTraversePassiveMountEffects(V, X, J, ne),
        ue & 2048 && (V = null,
        X.alternate !== null && (V = X.alternate.memoizedState.cache),
        X = X.memoizedState.cache,
        X !== V && (X.refCount++,
        V != null && releaseCache(V)));
        break;
    case 12:
        if (ue & 2048) {
            recursivelyTraversePassiveMountEffects(V, X, J, ne),
            V = X.stateNode;
            try {
                var ce = X.memoizedProps
                  , me = ce.id
                  , ge = ce.onPostCommit;
                typeof ge == "function" && ge(me, X.alternate === null ? "mount" : "update", V.passiveEffectDuration, -0)
            } catch (Te) {
                captureCommitPhaseError(X, X.return, Te)
            }
        } else
            recursivelyTraversePassiveMountEffects(V, X, J, ne);
        break;
    case 13:
        recursivelyTraversePassiveMountEffects(V, X, J, ne);
        break;
    case 23:
        break;
    case 22:
        ce = X.stateNode,
        me = X.alternate,
        X.memoizedState !== null ? ce._visibility & 2 ? recursivelyTraversePassiveMountEffects(V, X, J, ne) : recursivelyTraverseAtomicPassiveEffects(V, X) : ce._visibility & 2 ? recursivelyTraversePassiveMountEffects(V, X, J, ne) : (ce._visibility |= 2,
        recursivelyTraverseReconnectPassiveEffects(V, X, J, ne, (X.subtreeFlags & 10256) !== 0)),
        ue & 2048 && commitOffscreenPassiveMountEffects(me, X);
        break;
    case 24:
        recursivelyTraversePassiveMountEffects(V, X, J, ne),
        ue & 2048 && commitCachePassiveMountEffect(X.alternate, X);
        break;
    default:
        recursivelyTraversePassiveMountEffects(V, X, J, ne)
    }
}
function recursivelyTraverseReconnectPassiveEffects(V, X, J, ne, ue) {
    for (ue = ue && (X.subtreeFlags & 10256) !== 0,
    X = X.child; X !== null; ) {
        var ce = V
          , me = X
          , ge = J
          , Te = ne
          , _e = me.flags;
        switch (me.tag) {
        case 0:
        case 11:
        case 15:
            recursivelyTraverseReconnectPassiveEffects(ce, me, ge, Te, ue),
            commitHookEffectListMount(8, me);
            break;
        case 23:
            break;
        case 22:
            var Se = me.stateNode;
            me.memoizedState !== null ? Se._visibility & 2 ? recursivelyTraverseReconnectPassiveEffects(ce, me, ge, Te, ue) : recursivelyTraverseAtomicPassiveEffects(ce, me) : (Se._visibility |= 2,
            recursivelyTraverseReconnectPassiveEffects(ce, me, ge, Te, ue)),
            ue && _e & 2048 && commitOffscreenPassiveMountEffects(me.alternate, me);
            break;
        case 24:
            recursivelyTraverseReconnectPassiveEffects(ce, me, ge, Te, ue),
            ue && _e & 2048 && commitCachePassiveMountEffect(me.alternate, me);
            break;
        default:
            recursivelyTraverseReconnectPassiveEffects(ce, me, ge, Te, ue)
        }
        X = X.sibling
    }
}
function recursivelyTraverseAtomicPassiveEffects(V, X) {
    if (X.subtreeFlags & 10256)
        for (X = X.child; X !== null; ) {
            var J = V
              , ne = X
              , ue = ne.flags;
            switch (ne.tag) {
            case 22:
                recursivelyTraverseAtomicPassiveEffects(J, ne),
                ue & 2048 && commitOffscreenPassiveMountEffects(ne.alternate, ne);
                break;
            case 24:
                recursivelyTraverseAtomicPassiveEffects(J, ne),
                ue & 2048 && commitCachePassiveMountEffect(ne.alternate, ne);
                break;
            default:
                recursivelyTraverseAtomicPassiveEffects(J, ne)
            }
            X = X.sibling
        }
}
var suspenseyCommitFlag = 8192;
function recursivelyAccumulateSuspenseyCommit(V) {
    if (V.subtreeFlags & suspenseyCommitFlag)
        for (V = V.child; V !== null; )
            accumulateSuspenseyCommitOnFiber(V),
            V = V.sibling
}
function accumulateSuspenseyCommitOnFiber(V) {
    switch (V.tag) {
    case 26:
        recursivelyAccumulateSuspenseyCommit(V),
        V.flags & suspenseyCommitFlag && V.memoizedState !== null && suspendResource(currentHoistableRoot, V.memoizedState, V.memoizedProps);
        break;
    case 5:
        recursivelyAccumulateSuspenseyCommit(V);
        break;
    case 3:
    case 4:
        var X = currentHoistableRoot;
        currentHoistableRoot = getHoistableRoot(V.stateNode.containerInfo),
        recursivelyAccumulateSuspenseyCommit(V),
        currentHoistableRoot = X;
        break;
    case 22:
        V.memoizedState === null && (X = V.alternate,
        X !== null && X.memoizedState !== null ? (X = suspenseyCommitFlag,
        suspenseyCommitFlag = 16777216,
        recursivelyAccumulateSuspenseyCommit(V),
        suspenseyCommitFlag = X) : recursivelyAccumulateSuspenseyCommit(V));
        break;
    default:
        recursivelyAccumulateSuspenseyCommit(V)
    }
}
function detachAlternateSiblings(V) {
    var X = V.alternate;
    if (X !== null && (V = X.child,
    V !== null)) {
        X.child = null;
        do
            X = V.sibling,
            V.sibling = null,
            V = X;
        while (V !== null)
    }
}
function recursivelyTraversePassiveUnmountEffects(V) {
    var X = V.deletions;
    if (V.flags & 16) {
        if (X !== null)
            for (var J = 0; J < X.length; J++) {
                var ne = X[J];
                nextEffect = ne,
                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(ne, V)
            }
        detachAlternateSiblings(V)
    }
    if (V.subtreeFlags & 10256)
        for (V = V.child; V !== null; )
            commitPassiveUnmountOnFiber(V),
            V = V.sibling
}
function commitPassiveUnmountOnFiber(V) {
    switch (V.tag) {
    case 0:
    case 11:
    case 15:
        recursivelyTraversePassiveUnmountEffects(V),
        V.flags & 2048 && commitHookEffectListUnmount(9, V, V.return);
        break;
    case 3:
        recursivelyTraversePassiveUnmountEffects(V);
        break;
    case 12:
        recursivelyTraversePassiveUnmountEffects(V);
        break;
    case 22:
        var X = V.stateNode;
        V.memoizedState !== null && X._visibility & 2 && (V.return === null || V.return.tag !== 13) ? (X._visibility &= -3,
        recursivelyTraverseDisconnectPassiveEffects(V)) : recursivelyTraversePassiveUnmountEffects(V);
        break;
    default:
        recursivelyTraversePassiveUnmountEffects(V)
    }
}
function recursivelyTraverseDisconnectPassiveEffects(V) {
    var X = V.deletions;
    if (V.flags & 16) {
        if (X !== null)
            for (var J = 0; J < X.length; J++) {
                var ne = X[J];
                nextEffect = ne,
                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(ne, V)
            }
        detachAlternateSiblings(V)
    }
    for (V = V.child; V !== null; ) {
        switch (X = V,
        X.tag) {
        case 0:
        case 11:
        case 15:
            commitHookEffectListUnmount(8, X, X.return),
            recursivelyTraverseDisconnectPassiveEffects(X);
            break;
        case 22:
            J = X.stateNode,
            J._visibility & 2 && (J._visibility &= -3,
            recursivelyTraverseDisconnectPassiveEffects(X));
            break;
        default:
            recursivelyTraverseDisconnectPassiveEffects(X)
        }
        V = V.sibling
    }
}
function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(V, X) {
    for (; nextEffect !== null; ) {
        var J = nextEffect;
        switch (J.tag) {
        case 0:
        case 11:
        case 15:
            commitHookEffectListUnmount(8, J, X);
            break;
        case 23:
        case 22:
            if (J.memoizedState !== null && J.memoizedState.cachePool !== null) {
                var ne = J.memoizedState.cachePool.pool;
                ne != null && ne.refCount++
            }
            break;
        case 24:
            releaseCache(J.memoizedState.cache)
        }
        if (ne = J.child,
        ne !== null)
            ne.return = J,
            nextEffect = ne;
        else
            e: for (J = V; nextEffect !== null; ) {
                ne = nextEffect;
                var ue = ne.sibling
                  , ce = ne.return;
                if (detachFiberAfterEffects(ne),
                ne === J) {
                    nextEffect = null;
                    break e
                }
                if (ue !== null) {
                    ue.return = ce,
                    nextEffect = ue;
                    break e
                }
                nextEffect = ce
            }
    }
}
var DefaultAsyncDispatcher = {
    getCacheForType: function(V) {
        var X = readContext(CacheContext)
          , J = X.data.get(V);
        return J === void 0 && (J = V(),
        X.data.set(V, J)),
        J
    }
}
  , PossiblyWeakMap = typeof WeakMap == "function" ? WeakMap : Map
  , executionContext = 0
  , workInProgressRoot = null
  , workInProgress = null
  , workInProgressRootRenderLanes = 0
  , workInProgressSuspendedReason = 0
  , workInProgressThrownValue = null
  , workInProgressRootDidSkipSuspendedSiblings = !1
  , workInProgressRootIsPrerendering = !1
  , workInProgressRootDidAttachPingListener = !1
  , entangledRenderLanes = 0
  , workInProgressRootExitStatus = 0
  , workInProgressRootSkippedLanes = 0
  , workInProgressRootInterleavedUpdatedLanes = 0
  , workInProgressRootPingedLanes = 0
  , workInProgressDeferredLane = 0
  , workInProgressSuspendedRetryLanes = 0
  , workInProgressRootConcurrentErrors = null
  , workInProgressRootRecoverableErrors = null
  , workInProgressRootDidIncludeRecursiveRenderUpdate = !1
  , globalMostRecentFallbackTime = 0
  , workInProgressRootRenderTargetTime = 1 / 0
  , workInProgressTransitions = null
  , legacyErrorBoundariesThatAlreadyFailed = null
  , pendingEffectsStatus = 0
  , pendingEffectsRoot = null
  , pendingFinishedWork = null
  , pendingEffectsLanes = 0
  , pendingEffectsRemainingLanes = 0
  , pendingPassiveTransitions = null
  , pendingRecoverableErrors = null
  , nestedUpdateCount = 0
  , rootWithNestedUpdates = null;
function requestUpdateLane() {
    if (executionContext & 2 && workInProgressRootRenderLanes !== 0)
        return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
    if (ReactSharedInternals.T !== null) {
        var V = currentEntangledLane;
        return V !== 0 ? V : requestTransitionLane()
    }
    return resolveUpdatePriority()
}
function requestDeferredLane() {
    workInProgressDeferredLane === 0 && (workInProgressDeferredLane = !(workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);
    var V = suspenseHandlerStackCursor.current;
    return V !== null && (V.flags |= 32),
    workInProgressDeferredLane
}
function scheduleUpdateOnFiber(V, X, J) {
    (V === workInProgressRoot && (workInProgressSuspendedReason === 2 || workInProgressSuspendedReason === 9) || V.cancelPendingCommit !== null) && (prepareFreshStack(V, 0),
    markRootSuspended(V, workInProgressRootRenderLanes, workInProgressDeferredLane, !1)),
    markRootUpdated$1(V, J),
    (!(executionContext & 2) || V !== workInProgressRoot) && (V === workInProgressRoot && (!(executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= J),
    workInProgressRootExitStatus === 4 && markRootSuspended(V, workInProgressRootRenderLanes, workInProgressDeferredLane, !1)),
    ensureRootIsScheduled(V))
}
function performWorkOnRoot(V, X, J) {
    if (executionContext & 6)
        throw Error(formatProdErrorMessage(327));
    var ne = !J && (X & 124) === 0 && (X & V.expiredLanes) === 0 || checkIfRootIsPrerendering(V, X)
      , ue = ne ? renderRootConcurrent(V, X) : renderRootSync(V, X, !0)
      , ce = ne;
    do {
        if (ue === 0) {
            workInProgressRootIsPrerendering && !ne && markRootSuspended(V, X, 0, !1);
            break
        } else {
            if (J = V.current.alternate,
            ce && !isRenderConsistentWithExternalStores(J)) {
                ue = renderRootSync(V, X, !1),
                ce = !1;
                continue
            }
            if (ue === 2) {
                if (ce = X,
                V.errorRecoveryDisabledLanes & ce)
                    var me = 0;
                else
                    me = V.pendingLanes & -536870913,
                    me = me !== 0 ? me : me & 536870912 ? 536870912 : 0;
                if (me !== 0) {
                    X = me;
                    e: {
                        var ge = V;
                        ue = workInProgressRootConcurrentErrors;
                        var Te = ge.current.memoizedState.isDehydrated;
                        if (Te && (prepareFreshStack(ge, me).flags |= 256),
                        me = renderRootSync(ge, me, !1),
                        me !== 2) {
                            if (workInProgressRootDidAttachPingListener && !Te) {
                                ge.errorRecoveryDisabledLanes |= ce,
                                workInProgressRootInterleavedUpdatedLanes |= ce,
                                ue = 4;
                                break e
                            }
                            ce = workInProgressRootRecoverableErrors,
                            workInProgressRootRecoverableErrors = ue,
                            ce !== null && (workInProgressRootRecoverableErrors === null ? workInProgressRootRecoverableErrors = ce : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, ce))
                        }
                        ue = me
                    }
                    if (ce = !1,
                    ue !== 2)
                        continue
                }
            }
            if (ue === 1) {
                prepareFreshStack(V, 0),
                markRootSuspended(V, X, 0, !0);
                break
            }
            e: {
                switch (ne = V,
                ce = ue,
                ce) {
                case 0:
                case 1:
                    throw Error(formatProdErrorMessage(345));
                case 4:
                    if ((X & 4194048) !== X)
                        break;
                case 6:
                    markRootSuspended(ne, X, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);
                    break e;
                case 2:
                    workInProgressRootRecoverableErrors = null;
                    break;
                case 3:
                case 5:
                    break;
                default:
                    throw Error(formatProdErrorMessage(329))
                }
                if ((X & 62914560) === X && (ue = globalMostRecentFallbackTime + 300 - now(),
                10 < ue)) {
                    if (markRootSuspended(ne, X, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings),
                    getNextLanes(ne, 0, !0) !== 0)
                        break e;
                    ne.timeoutHandle = scheduleTimeout(commitRootWhenReady.bind(null, ne, J, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, X, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, ce, 2, -0, 0), ue);
                    break e
                }
                commitRootWhenReady(ne, J, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, X, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, ce, 0, -0, 0)
            }
        }
        break
    } while (!0);
    ensureRootIsScheduled(V)
}
function commitRootWhenReady(V, X, J, ne, ue, ce, me, ge, Te, _e, Se, Ie, ye, $e) {
    if (V.timeoutHandle = -1,
    Ie = X.subtreeFlags,
    (Ie & 8192 || (Ie & 16785408) === 16785408) && (suspendedState = {
        stylesheets: null,
        count: 0,
        unsuspend: noop
    },
    accumulateSuspenseyCommitOnFiber(X),
    Ie = waitForCommitToBeReady(),
    Ie !== null)) {
        V.cancelPendingCommit = Ie(commitRoot.bind(null, V, X, ce, J, ne, ue, me, ge, Te, Se, 1, ye, $e)),
        markRootSuspended(V, ce, me, !_e);
        return
    }
    commitRoot(V, X, ce, J, ne, ue, me, ge, Te)
}
function isRenderConsistentWithExternalStores(V) {
    for (var X = V; ; ) {
        var J = X.tag;
        if ((J === 0 || J === 11 || J === 15) && X.flags & 16384 && (J = X.updateQueue,
        J !== null && (J = J.stores,
        J !== null)))
            for (var ne = 0; ne < J.length; ne++) {
                var ue = J[ne]
                  , ce = ue.getSnapshot;
                ue = ue.value;
                try {
                    if (!objectIs(ce(), ue))
                        return !1
                } catch {
                    return !1
                }
            }
        if (J = X.child,
        X.subtreeFlags & 16384 && J !== null)
            J.return = X,
            X = J;
        else {
            if (X === V)
                break;
            for (; X.sibling === null; ) {
                if (X.return === null || X.return === V)
                    return !0;
                X = X.return
            }
            X.sibling.return = X.return,
            X = X.sibling
        }
    }
    return !0
}
function markRootSuspended(V, X, J, ne) {
    X &= ~workInProgressRootPingedLanes,
    X &= ~workInProgressRootInterleavedUpdatedLanes,
    V.suspendedLanes |= X,
    V.pingedLanes &= ~X,
    ne && (V.warmLanes |= X),
    ne = V.expirationTimes;
    for (var ue = X; 0 < ue; ) {
        var ce = 31 - clz32(ue)
          , me = 1 << ce;
        ne[ce] = -1,
        ue &= ~me
    }
    J !== 0 && markSpawnedDeferredLane(V, J, X)
}
function flushSyncWork$1() {
    return executionContext & 6 ? !0 : (flushSyncWorkAcrossRoots_impl(0),
    !1)
}
function resetWorkInProgressStack() {
    if (workInProgress !== null) {
        if (workInProgressSuspendedReason === 0)
            var V = workInProgress.return;
        else
            V = workInProgress,
            lastContextDependency = currentlyRenderingFiber$1 = null,
            resetHooksOnUnwind(V),
            thenableState = null,
            thenableIndexCounter = 0,
            V = workInProgress;
        for (; V !== null; )
            unwindInterruptedWork(V.alternate, V),
            V = V.return;
        workInProgress = null
    }
}
function prepareFreshStack(V, X) {
    var J = V.timeoutHandle;
    J !== -1 && (V.timeoutHandle = -1,
    cancelTimeout(J)),
    J = V.cancelPendingCommit,
    J !== null && (V.cancelPendingCommit = null,
    J()),
    resetWorkInProgressStack(),
    workInProgressRoot = V,
    workInProgress = J = createWorkInProgress(V.current, null),
    workInProgressRootRenderLanes = X,
    workInProgressSuspendedReason = 0,
    workInProgressThrownValue = null,
    workInProgressRootDidSkipSuspendedSiblings = !1,
    workInProgressRootIsPrerendering = checkIfRootIsPrerendering(V, X),
    workInProgressRootDidAttachPingListener = !1,
    workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0,
    workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null,
    workInProgressRootDidIncludeRecursiveRenderUpdate = !1,
    X & 8 && (X |= X & 32);
    var ne = V.entangledLanes;
    if (ne !== 0)
        for (V = V.entanglements,
        ne &= X; 0 < ne; ) {
            var ue = 31 - clz32(ne)
              , ce = 1 << ue;
            X |= V[ue],
            ne &= ~ce
        }
    return entangledRenderLanes = X,
    finishQueueingConcurrentUpdates(),
    J
}
function handleThrow(V, X) {
    currentlyRenderingFiber = null,
    ReactSharedInternals.H = ContextOnlyDispatcher,
    X === SuspenseException || X === SuspenseActionException ? (X = getSuspendedThenable(),
    workInProgressSuspendedReason = 3) : X === SuspenseyCommitException ? (X = getSuspendedThenable(),
    workInProgressSuspendedReason = 4) : workInProgressSuspendedReason = X === SelectiveHydrationException ? 8 : X !== null && typeof X == "object" && typeof X.then == "function" ? 6 : 1,
    workInProgressThrownValue = X,
    workInProgress === null && (workInProgressRootExitStatus = 1,
    logUncaughtError(V, createCapturedValueAtFiber(X, V.current)))
}
function pushDispatcher() {
    var V = ReactSharedInternals.H;
    return ReactSharedInternals.H = ContextOnlyDispatcher,
    V === null ? ContextOnlyDispatcher : V
}
function pushAsyncDispatcher() {
    var V = ReactSharedInternals.A;
    return ReactSharedInternals.A = DefaultAsyncDispatcher,
    V
}
function renderDidSuspendDelayIfPossible() {
    workInProgressRootExitStatus = 4,
    workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && suspenseHandlerStackCursor.current !== null || (workInProgressRootIsPrerendering = !0),
    !(workInProgressRootSkippedLanes & 134217727) && !(workInProgressRootInterleavedUpdatedLanes & 134217727) || workInProgressRoot === null || markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes, workInProgressDeferredLane, !1)
}
function renderRootSync(V, X, J) {
    var ne = executionContext;
    executionContext |= 2;
    var ue = pushDispatcher()
      , ce = pushAsyncDispatcher();
    (workInProgressRoot !== V || workInProgressRootRenderLanes !== X) && (workInProgressTransitions = null,
    prepareFreshStack(V, X)),
    X = !1;
    var me = workInProgressRootExitStatus;
    e: do
        try {
            if (workInProgressSuspendedReason !== 0 && workInProgress !== null) {
                var ge = workInProgress
                  , Te = workInProgressThrownValue;
                switch (workInProgressSuspendedReason) {
                case 8:
                    resetWorkInProgressStack(),
                    me = 6;
                    break e;
                case 3:
                case 2:
                case 9:
                case 6:
                    suspenseHandlerStackCursor.current === null && (X = !0);
                    var _e = workInProgressSuspendedReason;
                    if (workInProgressSuspendedReason = 0,
                    workInProgressThrownValue = null,
                    throwAndUnwindWorkLoop(V, ge, Te, _e),
                    J && workInProgressRootIsPrerendering) {
                        me = 0;
                        break e
                    }
                    break;
                default:
                    _e = workInProgressSuspendedReason,
                    workInProgressSuspendedReason = 0,
                    workInProgressThrownValue = null,
                    throwAndUnwindWorkLoop(V, ge, Te, _e)
                }
            }
            workLoopSync(),
            me = workInProgressRootExitStatus;
            break
        } catch (Se) {
            handleThrow(V, Se)
        }
    while (!0);
    return X && V.shellSuspendCounter++,
    lastContextDependency = currentlyRenderingFiber$1 = null,
    executionContext = ne,
    ReactSharedInternals.H = ue,
    ReactSharedInternals.A = ce,
    workInProgress === null && (workInProgressRoot = null,
    workInProgressRootRenderLanes = 0,
    finishQueueingConcurrentUpdates()),
    me
}
function workLoopSync() {
    for (; workInProgress !== null; )
        performUnitOfWork(workInProgress)
}
function renderRootConcurrent(V, X) {
    var J = executionContext;
    executionContext |= 2;
    var ne = pushDispatcher()
      , ue = pushAsyncDispatcher();
    workInProgressRoot !== V || workInProgressRootRenderLanes !== X ? (workInProgressTransitions = null,
    workInProgressRootRenderTargetTime = now() + 500,
    prepareFreshStack(V, X)) : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(V, X);
    e: do
        try {
            if (workInProgressSuspendedReason !== 0 && workInProgress !== null) {
                X = workInProgress;
                var ce = workInProgressThrownValue;
                t: switch (workInProgressSuspendedReason) {
                case 1:
                    workInProgressSuspendedReason = 0,
                    workInProgressThrownValue = null,
                    throwAndUnwindWorkLoop(V, X, ce, 1);
                    break;
                case 2:
                case 9:
                    if (isThenableResolved(ce)) {
                        workInProgressSuspendedReason = 0,
                        workInProgressThrownValue = null,
                        replaySuspendedUnitOfWork(X);
                        break
                    }
                    X = function() {
                        workInProgressSuspendedReason !== 2 && workInProgressSuspendedReason !== 9 || workInProgressRoot !== V || (workInProgressSuspendedReason = 7),
                        ensureRootIsScheduled(V)
                    }
                    ,
                    ce.then(X, X);
                    break e;
                case 3:
                    workInProgressSuspendedReason = 7;
                    break e;
                case 4:
                    workInProgressSuspendedReason = 5;
                    break e;
                case 7:
                    isThenableResolved(ce) ? (workInProgressSuspendedReason = 0,
                    workInProgressThrownValue = null,
                    replaySuspendedUnitOfWork(X)) : (workInProgressSuspendedReason = 0,
                    workInProgressThrownValue = null,
                    throwAndUnwindWorkLoop(V, X, ce, 7));
                    break;
                case 5:
                    var me = null;
                    switch (workInProgress.tag) {
                    case 26:
                        me = workInProgress.memoizedState;
                    case 5:
                    case 27:
                        var ge = workInProgress;
                        if (!me || preloadResource(me)) {
                            workInProgressSuspendedReason = 0,
                            workInProgressThrownValue = null;
                            var Te = ge.sibling;
                            if (Te !== null)
                                workInProgress = Te;
                            else {
                                var _e = ge.return;
                                _e !== null ? (workInProgress = _e,
                                completeUnitOfWork(_e)) : workInProgress = null
                            }
                            break t
                        }
                    }
                    workInProgressSuspendedReason = 0,
                    workInProgressThrownValue = null,
                    throwAndUnwindWorkLoop(V, X, ce, 5);
                    break;
                case 6:
                    workInProgressSuspendedReason = 0,
                    workInProgressThrownValue = null,
                    throwAndUnwindWorkLoop(V, X, ce, 6);
                    break;
                case 8:
                    resetWorkInProgressStack(),
                    workInProgressRootExitStatus = 6;
                    break e;
                default:
                    throw Error(formatProdErrorMessage(462))
                }
            }
            workLoopConcurrentByScheduler();
            break
        } catch (Se) {
            handleThrow(V, Se)
        }
    while (!0);
    return lastContextDependency = currentlyRenderingFiber$1 = null,
    ReactSharedInternals.H = ne,
    ReactSharedInternals.A = ue,
    executionContext = J,
    workInProgress !== null ? 0 : (workInProgressRoot = null,
    workInProgressRootRenderLanes = 0,
    finishQueueingConcurrentUpdates(),
    workInProgressRootExitStatus)
}
function workLoopConcurrentByScheduler() {
    for (; workInProgress !== null && !shouldYield(); )
        performUnitOfWork(workInProgress)
}
function performUnitOfWork(V) {
    var X = beginWork(V.alternate, V, entangledRenderLanes);
    V.memoizedProps = V.pendingProps,
    X === null ? completeUnitOfWork(V) : workInProgress = X
}
function replaySuspendedUnitOfWork(V) {
    var X = V
      , J = X.alternate;
    switch (X.tag) {
    case 15:
    case 0:
        X = replayFunctionComponent(J, X, X.pendingProps, X.type, void 0, workInProgressRootRenderLanes);
        break;
    case 11:
        X = replayFunctionComponent(J, X, X.pendingProps, X.type.render, X.ref, workInProgressRootRenderLanes);
        break;
    case 5:
        resetHooksOnUnwind(X);
    default:
        unwindInterruptedWork(J, X),
        X = workInProgress = resetWorkInProgress(X, entangledRenderLanes),
        X = beginWork(J, X, entangledRenderLanes)
    }
    V.memoizedProps = V.pendingProps,
    X === null ? completeUnitOfWork(V) : workInProgress = X
}
function throwAndUnwindWorkLoop(V, X, J, ne) {
    lastContextDependency = currentlyRenderingFiber$1 = null,
    resetHooksOnUnwind(X),
    thenableState = null,
    thenableIndexCounter = 0;
    var ue = X.return;
    try {
        if (throwException(V, ue, X, J, workInProgressRootRenderLanes)) {
            workInProgressRootExitStatus = 1,
            logUncaughtError(V, createCapturedValueAtFiber(J, V.current)),
            workInProgress = null;
            return
        }
    } catch (ce) {
        if (ue !== null)
            throw workInProgress = ue,
            ce;
        workInProgressRootExitStatus = 1,
        logUncaughtError(V, createCapturedValueAtFiber(J, V.current)),
        workInProgress = null;
        return
    }
    X.flags & 32768 ? (isHydrating || ne === 1 ? V = !0 : workInProgressRootIsPrerendering || workInProgressRootRenderLanes & 536870912 ? V = !1 : (workInProgressRootDidSkipSuspendedSiblings = V = !0,
    (ne === 2 || ne === 9 || ne === 3 || ne === 6) && (ne = suspenseHandlerStackCursor.current,
    ne !== null && ne.tag === 13 && (ne.flags |= 16384))),
    unwindUnitOfWork(X, V)) : completeUnitOfWork(X)
}
function completeUnitOfWork(V) {
    var X = V;
    do {
        if (X.flags & 32768) {
            unwindUnitOfWork(X, workInProgressRootDidSkipSuspendedSiblings);
            return
        }
        V = X.return;
        var J = completeWork(X.alternate, X, entangledRenderLanes);
        if (J !== null) {
            workInProgress = J;
            return
        }
        if (X = X.sibling,
        X !== null) {
            workInProgress = X;
            return
        }
        workInProgress = X = V
    } while (X !== null);
    workInProgressRootExitStatus === 0 && (workInProgressRootExitStatus = 5)
}
function unwindUnitOfWork(V, X) {
    do {
        var J = unwindWork(V.alternate, V);
        if (J !== null) {
            J.flags &= 32767,
            workInProgress = J;
            return
        }
        if (J = V.return,
        J !== null && (J.flags |= 32768,
        J.subtreeFlags = 0,
        J.deletions = null),
        !X && (V = V.sibling,
        V !== null)) {
            workInProgress = V;
            return
        }
        workInProgress = V = J
    } while (V !== null);
    workInProgressRootExitStatus = 6,
    workInProgress = null
}
function commitRoot(V, X, J, ne, ue, ce, me, ge, Te) {
    V.cancelPendingCommit = null;
    do
        flushPendingEffects();
    while (pendingEffectsStatus !== 0);
    if (executionContext & 6)
        throw Error(formatProdErrorMessage(327));
    if (X !== null) {
        if (X === V.current)
            throw Error(formatProdErrorMessage(177));
        if (ce = X.lanes | X.childLanes,
        ce |= concurrentlyUpdatedLanes,
        markRootFinished(V, J, ce, me, ge, Te),
        V === workInProgressRoot && (workInProgress = workInProgressRoot = null,
        workInProgressRootRenderLanes = 0),
        pendingFinishedWork = X,
        pendingEffectsRoot = V,
        pendingEffectsLanes = J,
        pendingEffectsRemainingLanes = ce,
        pendingPassiveTransitions = ue,
        pendingRecoverableErrors = ne,
        X.subtreeFlags & 10256 || X.flags & 10256 ? (V.callbackNode = null,
        V.callbackPriority = 0,
        scheduleCallback$1(NormalPriority$1, function() {
            return flushPassiveEffects(),
            null
        })) : (V.callbackNode = null,
        V.callbackPriority = 0),
        ne = (X.flags & 13878) !== 0,
        X.subtreeFlags & 13878 || ne) {
            ne = ReactSharedInternals.T,
            ReactSharedInternals.T = null,
            ue = ReactDOMSharedInternals.p,
            ReactDOMSharedInternals.p = 2,
            me = executionContext,
            executionContext |= 4;
            try {
                commitBeforeMutationEffects(V, X, J)
            } finally {
                executionContext = me,
                ReactDOMSharedInternals.p = ue,
                ReactSharedInternals.T = ne
            }
        }
        pendingEffectsStatus = 1,
        flushMutationEffects(),
        flushLayoutEffects(),
        flushSpawnedWork()
    }
}
function flushMutationEffects() {
    if (pendingEffectsStatus === 1) {
        pendingEffectsStatus = 0;
        var V = pendingEffectsRoot
          , X = pendingFinishedWork
          , J = (X.flags & 13878) !== 0;
        if (X.subtreeFlags & 13878 || J) {
            J = ReactSharedInternals.T,
            ReactSharedInternals.T = null;
            var ne = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            var ue = executionContext;
            executionContext |= 4;
            try {
                commitMutationEffectsOnFiber(X, V);
                var ce = selectionInformation
                  , me = getActiveElementDeep(V.containerInfo)
                  , ge = ce.focusedElem
                  , Te = ce.selectionRange;
                if (me !== ge && ge && ge.ownerDocument && containsNode(ge.ownerDocument.documentElement, ge)) {
                    if (Te !== null && hasSelectionCapabilities(ge)) {
                        var _e = Te.start
                          , Se = Te.end;
                        if (Se === void 0 && (Se = _e),
                        "selectionStart"in ge)
                            ge.selectionStart = _e,
                            ge.selectionEnd = Math.min(Se, ge.value.length);
                        else {
                            var Ie = ge.ownerDocument || document
                              , ye = Ie && Ie.defaultView || window;
                            if (ye.getSelection) {
                                var $e = ye.getSelection()
                                  , Ne = ge.textContent.length
                                  , ve = Math.min(Te.start, Ne)
                                  , ke = Te.end === void 0 ? ve : Math.min(Te.end, Ne);
                                !$e.extend && ve > ke && (me = ke,
                                ke = ve,
                                ve = me);
                                var xe = getNodeForCharacterOffset(ge, ve)
                                  , we = getNodeForCharacterOffset(ge, ke);
                                if (xe && we && ($e.rangeCount !== 1 || $e.anchorNode !== xe.node || $e.anchorOffset !== xe.offset || $e.focusNode !== we.node || $e.focusOffset !== we.offset)) {
                                    var Fe = Ie.createRange();
                                    Fe.setStart(xe.node, xe.offset),
                                    $e.removeAllRanges(),
                                    ve > ke ? ($e.addRange(Fe),
                                    $e.extend(we.node, we.offset)) : (Fe.setEnd(we.node, we.offset),
                                    $e.addRange(Fe))
                                }
                            }
                        }
                    }
                    for (Ie = [],
                    $e = ge; $e = $e.parentNode; )
                        $e.nodeType === 1 && Ie.push({
                            element: $e,
                            left: $e.scrollLeft,
                            top: $e.scrollTop
                        });
                    for (typeof ge.focus == "function" && ge.focus(),
                    ge = 0; ge < Ie.length; ge++) {
                        var je = Ie[ge];
                        je.element.scrollLeft = je.left,
                        je.element.scrollTop = je.top
                    }
                }
                _enabled = !!eventsEnabled,
                selectionInformation = eventsEnabled = null
            } finally {
                executionContext = ue,
                ReactDOMSharedInternals.p = ne,
                ReactSharedInternals.T = J
            }
        }
        V.current = X,
        pendingEffectsStatus = 2
    }
}
function flushLayoutEffects() {
    if (pendingEffectsStatus === 2) {
        pendingEffectsStatus = 0;
        var V = pendingEffectsRoot
          , X = pendingFinishedWork
          , J = (X.flags & 8772) !== 0;
        if (X.subtreeFlags & 8772 || J) {
            J = ReactSharedInternals.T,
            ReactSharedInternals.T = null;
            var ne = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            var ue = executionContext;
            executionContext |= 4;
            try {
                commitLayoutEffectOnFiber(V, X.alternate, X)
            } finally {
                executionContext = ue,
                ReactDOMSharedInternals.p = ne,
                ReactSharedInternals.T = J
            }
        }
        pendingEffectsStatus = 3
    }
}
function flushSpawnedWork() {
    if (pendingEffectsStatus === 4 || pendingEffectsStatus === 3) {
        pendingEffectsStatus = 0,
        requestPaint();
        var V = pendingEffectsRoot
          , X = pendingFinishedWork
          , J = pendingEffectsLanes
          , ne = pendingRecoverableErrors;
        X.subtreeFlags & 10256 || X.flags & 10256 ? pendingEffectsStatus = 5 : (pendingEffectsStatus = 0,
        pendingFinishedWork = pendingEffectsRoot = null,
        releaseRootPooledCache(V, V.pendingLanes));
        var ue = V.pendingLanes;
        if (ue === 0 && (legacyErrorBoundariesThatAlreadyFailed = null),
        lanesToEventPriority(J),
        X = X.stateNode,
        injectedHook && typeof injectedHook.onCommitFiberRoot == "function")
            try {
                injectedHook.onCommitFiberRoot(rendererID, X, void 0, (X.current.flags & 128) === 128)
            } catch {}
        if (ne !== null) {
            X = ReactSharedInternals.T,
            ue = ReactDOMSharedInternals.p,
            ReactDOMSharedInternals.p = 2,
            ReactSharedInternals.T = null;
            try {
                for (var ce = V.onRecoverableError, me = 0; me < ne.length; me++) {
                    var ge = ne[me];
                    ce(ge.value, {
                        componentStack: ge.stack
                    })
                }
            } finally {
                ReactSharedInternals.T = X,
                ReactDOMSharedInternals.p = ue
            }
        }
        pendingEffectsLanes & 3 && flushPendingEffects(),
        ensureRootIsScheduled(V),
        ue = V.pendingLanes,
        J & 4194090 && ue & 42 ? V === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0,
        rootWithNestedUpdates = V) : nestedUpdateCount = 0,
        flushSyncWorkAcrossRoots_impl(0)
    }
}
function releaseRootPooledCache(V, X) {
    (V.pooledCacheLanes &= X) === 0 && (X = V.pooledCache,
    X != null && (V.pooledCache = null,
    releaseCache(X)))
}
function flushPendingEffects(V) {
    return flushMutationEffects(),
    flushLayoutEffects(),
    flushSpawnedWork(),
    flushPassiveEffects()
}
function flushPassiveEffects() {
    if (pendingEffectsStatus !== 5)
        return !1;
    var V = pendingEffectsRoot
      , X = pendingEffectsRemainingLanes;
    pendingEffectsRemainingLanes = 0;
    var J = lanesToEventPriority(pendingEffectsLanes)
      , ne = ReactSharedInternals.T
      , ue = ReactDOMSharedInternals.p;
    try {
        ReactDOMSharedInternals.p = 32 > J ? 32 : J,
        ReactSharedInternals.T = null,
        J = pendingPassiveTransitions,
        pendingPassiveTransitions = null;
        var ce = pendingEffectsRoot
          , me = pendingEffectsLanes;
        if (pendingEffectsStatus = 0,
        pendingFinishedWork = pendingEffectsRoot = null,
        pendingEffectsLanes = 0,
        executionContext & 6)
            throw Error(formatProdErrorMessage(331));
        var ge = executionContext;
        if (executionContext |= 4,
        commitPassiveUnmountOnFiber(ce.current),
        commitPassiveMountOnFiber(ce, ce.current, me, J),
        executionContext = ge,
        flushSyncWorkAcrossRoots_impl(0, !1),
        injectedHook && typeof injectedHook.onPostCommitFiberRoot == "function")
            try {
                injectedHook.onPostCommitFiberRoot(rendererID, ce)
            } catch {}
        return !0
    } finally {
        ReactDOMSharedInternals.p = ue,
        ReactSharedInternals.T = ne,
        releaseRootPooledCache(V, X)
    }
}
function captureCommitPhaseErrorOnRoot(V, X, J) {
    X = createCapturedValueAtFiber(J, X),
    X = createRootErrorUpdate(V.stateNode, X, 2),
    V = enqueueUpdate(V, X, 2),
    V !== null && (markRootUpdated$1(V, 2),
    ensureRootIsScheduled(V))
}
function captureCommitPhaseError(V, X, J) {
    if (V.tag === 3)
        captureCommitPhaseErrorOnRoot(V, V, J);
    else
        for (; X !== null; ) {
            if (X.tag === 3) {
                captureCommitPhaseErrorOnRoot(X, V, J);
                break
            } else if (X.tag === 1) {
                var ne = X.stateNode;
                if (typeof X.type.getDerivedStateFromError == "function" || typeof ne.componentDidCatch == "function" && (legacyErrorBoundariesThatAlreadyFailed === null || !legacyErrorBoundariesThatAlreadyFailed.has(ne))) {
                    V = createCapturedValueAtFiber(J, V),
                    J = createClassErrorUpdate(2),
                    ne = enqueueUpdate(X, J, 2),
                    ne !== null && (initializeClassErrorUpdate(J, ne, X, V),
                    markRootUpdated$1(ne, 2),
                    ensureRootIsScheduled(ne));
                    break
                }
            }
            X = X.return
        }
}
function attachPingListener(V, X, J) {
    var ne = V.pingCache;
    if (ne === null) {
        ne = V.pingCache = new PossiblyWeakMap;
        var ue = new Set;
        ne.set(X, ue)
    } else
        ue = ne.get(X),
        ue === void 0 && (ue = new Set,
        ne.set(X, ue));
    ue.has(J) || (workInProgressRootDidAttachPingListener = !0,
    ue.add(J),
    V = pingSuspendedRoot.bind(null, V, X, J),
    X.then(V, V))
}
function pingSuspendedRoot(V, X, J) {
    var ne = V.pingCache;
    ne !== null && ne.delete(X),
    V.pingedLanes |= V.suspendedLanes & J,
    V.warmLanes &= ~J,
    workInProgressRoot === V && (workInProgressRootRenderLanes & J) === J && (workInProgressRootExitStatus === 4 || workInProgressRootExitStatus === 3 && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now() - globalMostRecentFallbackTime ? !(executionContext & 2) && prepareFreshStack(V, 0) : workInProgressRootPingedLanes |= J,
    workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0)),
    ensureRootIsScheduled(V)
}
function retryTimedOutBoundary(V, X) {
    X === 0 && (X = claimNextRetryLane()),
    V = enqueueConcurrentRenderForLane(V, X),
    V !== null && (markRootUpdated$1(V, X),
    ensureRootIsScheduled(V))
}
function retryDehydratedSuspenseBoundary(V) {
    var X = V.memoizedState
      , J = 0;
    X !== null && (J = X.retryLane),
    retryTimedOutBoundary(V, J)
}
function resolveRetryWakeable(V, X) {
    var J = 0;
    switch (V.tag) {
    case 13:
        var ne = V.stateNode
          , ue = V.memoizedState;
        ue !== null && (J = ue.retryLane);
        break;
    case 19:
        ne = V.stateNode;
        break;
    case 22:
        ne = V.stateNode._retryCache;
        break;
    default:
        throw Error(formatProdErrorMessage(314))
    }
    ne !== null && ne.delete(X),
    retryTimedOutBoundary(V, J)
}
function scheduleCallback$1(V, X) {
    return scheduleCallback$3(V, X)
}
var firstScheduledRoot = null
  , lastScheduledRoot = null
  , didScheduleMicrotask = !1
  , mightHavePendingSyncWork = !1
  , isFlushingWork = !1
  , currentEventTransitionLane = 0;
function ensureRootIsScheduled(V) {
    V !== lastScheduledRoot && V.next === null && (lastScheduledRoot === null ? firstScheduledRoot = lastScheduledRoot = V : lastScheduledRoot = lastScheduledRoot.next = V),
    mightHavePendingSyncWork = !0,
    didScheduleMicrotask || (didScheduleMicrotask = !0,
    scheduleImmediateRootScheduleTask())
}
function flushSyncWorkAcrossRoots_impl(V, X) {
    if (!isFlushingWork && mightHavePendingSyncWork) {
        isFlushingWork = !0;
        do
            for (var J = !1, ne = firstScheduledRoot; ne !== null; ) {
                if (V !== 0) {
                    var ue = ne.pendingLanes;
                    if (ue === 0)
                        var ce = 0;
                    else {
                        var me = ne.suspendedLanes
                          , ge = ne.pingedLanes;
                        ce = (1 << 31 - clz32(42 | V) + 1) - 1,
                        ce &= ue & ~(me & ~ge),
                        ce = ce & 201326741 ? ce & 201326741 | 1 : ce ? ce | 2 : 0
                    }
                    ce !== 0 && (J = !0,
                    performSyncWorkOnRoot(ne, ce))
                } else
                    ce = workInProgressRootRenderLanes,
                    ce = getNextLanes(ne, ne === workInProgressRoot ? ce : 0, ne.cancelPendingCommit !== null || ne.timeoutHandle !== -1),
                    !(ce & 3) || checkIfRootIsPrerendering(ne, ce) || (J = !0,
                    performSyncWorkOnRoot(ne, ce));
                ne = ne.next
            }
        while (J);
        isFlushingWork = !1
    }
}
function processRootScheduleInImmediateTask() {
    processRootScheduleInMicrotask()
}
function processRootScheduleInMicrotask() {
    mightHavePendingSyncWork = didScheduleMicrotask = !1;
    var V = 0;
    currentEventTransitionLane !== 0 && (shouldAttemptEagerTransition() && (V = currentEventTransitionLane),
    currentEventTransitionLane = 0);
    for (var X = now(), J = null, ne = firstScheduledRoot; ne !== null; ) {
        var ue = ne.next
          , ce = scheduleTaskForRootDuringMicrotask(ne, X);
        ce === 0 ? (ne.next = null,
        J === null ? firstScheduledRoot = ue : J.next = ue,
        ue === null && (lastScheduledRoot = J)) : (J = ne,
        (V !== 0 || ce & 3) && (mightHavePendingSyncWork = !0)),
        ne = ue
    }
    flushSyncWorkAcrossRoots_impl(V)
}
function scheduleTaskForRootDuringMicrotask(V, X) {
    for (var J = V.suspendedLanes, ne = V.pingedLanes, ue = V.expirationTimes, ce = V.pendingLanes & -62914561; 0 < ce; ) {
        var me = 31 - clz32(ce)
          , ge = 1 << me
          , Te = ue[me];
        Te === -1 ? (!(ge & J) || ge & ne) && (ue[me] = computeExpirationTime(ge, X)) : Te <= X && (V.expiredLanes |= ge),
        ce &= ~ge
    }
    if (X = workInProgressRoot,
    J = workInProgressRootRenderLanes,
    J = getNextLanes(V, V === X ? J : 0, V.cancelPendingCommit !== null || V.timeoutHandle !== -1),
    ne = V.callbackNode,
    J === 0 || V === X && (workInProgressSuspendedReason === 2 || workInProgressSuspendedReason === 9) || V.cancelPendingCommit !== null)
        return ne !== null && ne !== null && cancelCallback$1(ne),
        V.callbackNode = null,
        V.callbackPriority = 0;
    if (!(J & 3) || checkIfRootIsPrerendering(V, J)) {
        if (X = J & -J,
        X === V.callbackPriority)
            return X;
        switch (ne !== null && cancelCallback$1(ne),
        lanesToEventPriority(J)) {
        case 2:
        case 8:
            J = UserBlockingPriority;
            break;
        case 32:
            J = NormalPriority$1;
            break;
        case 268435456:
            J = IdlePriority;
            break;
        default:
            J = NormalPriority$1
        }
        return ne = performWorkOnRootViaSchedulerTask.bind(null, V),
        J = scheduleCallback$3(J, ne),
        V.callbackPriority = X,
        V.callbackNode = J,
        X
    }
    return ne !== null && ne !== null && cancelCallback$1(ne),
    V.callbackPriority = 2,
    V.callbackNode = null,
    2
}
function performWorkOnRootViaSchedulerTask(V, X) {
    if (pendingEffectsStatus !== 0 && pendingEffectsStatus !== 5)
        return V.callbackNode = null,
        V.callbackPriority = 0,
        null;
    var J = V.callbackNode;
    if (flushPendingEffects() && V.callbackNode !== J)
        return null;
    var ne = workInProgressRootRenderLanes;
    return ne = getNextLanes(V, V === workInProgressRoot ? ne : 0, V.cancelPendingCommit !== null || V.timeoutHandle !== -1),
    ne === 0 ? null : (performWorkOnRoot(V, ne, X),
    scheduleTaskForRootDuringMicrotask(V, now()),
    V.callbackNode != null && V.callbackNode === J ? performWorkOnRootViaSchedulerTask.bind(null, V) : null)
}
function performSyncWorkOnRoot(V, X) {
    if (flushPendingEffects())
        return null;
    performWorkOnRoot(V, X, !0)
}
function scheduleImmediateRootScheduleTask() {
    scheduleMicrotask(function() {
        executionContext & 6 ? scheduleCallback$3(ImmediatePriority, processRootScheduleInImmediateTask) : processRootScheduleInMicrotask()
    })
}
function requestTransitionLane() {
    return currentEventTransitionLane === 0 && (currentEventTransitionLane = claimNextTransitionLane()),
    currentEventTransitionLane
}
function coerceFormActionProp(V) {
    return V == null || typeof V == "symbol" || typeof V == "boolean" ? null : typeof V == "function" ? V : sanitizeURL("" + V)
}
function createFormDataWithSubmitter(V, X) {
    var J = X.ownerDocument.createElement("input");
    return J.name = X.name,
    J.value = X.value,
    V.id && J.setAttribute("form", V.id),
    X.parentNode.insertBefore(J, X),
    V = new FormData(V),
    J.parentNode.removeChild(J),
    V
}
function extractEvents$1(V, X, J, ne, ue) {
    if (X === "submit" && J && J.stateNode === ue) {
        var ce = coerceFormActionProp((ue[internalPropsKey] || null).action)
          , me = ne.submitter;
        me && (X = (X = me[internalPropsKey] || null) ? coerceFormActionProp(X.formAction) : me.getAttribute("formAction"),
        X !== null && (ce = X,
        me = null));
        var ge = new SyntheticEvent("action","action",null,ne,ue);
        V.push({
            event: ge,
            listeners: [{
                instance: null,
                listener: function() {
                    if (ne.defaultPrevented) {
                        if (currentEventTransitionLane !== 0) {
                            var Te = me ? createFormDataWithSubmitter(ue, me) : new FormData(ue);
                            startHostTransition(J, {
                                pending: !0,
                                data: Te,
                                method: ue.method,
                                action: ce
                            }, null, Te)
                        }
                    } else
                        typeof ce == "function" && (ge.preventDefault(),
                        Te = me ? createFormDataWithSubmitter(ue, me) : new FormData(ue),
                        startHostTransition(J, {
                            pending: !0,
                            data: Te,
                            method: ue.method,
                            action: ce
                        }, ce, Te))
                },
                currentTarget: ue
            }]
        })
    }
}
for (var i$jscomp$inline_1528 = 0; i$jscomp$inline_1528 < simpleEventPluginEvents.length; i$jscomp$inline_1528++) {
    var eventName$jscomp$inline_1529 = simpleEventPluginEvents[i$jscomp$inline_1528]
      , domEventName$jscomp$inline_1530 = eventName$jscomp$inline_1529.toLowerCase()
      , capitalizedEvent$jscomp$inline_1531 = eventName$jscomp$inline_1529[0].toUpperCase() + eventName$jscomp$inline_1529.slice(1);
    registerSimpleEvent(domEventName$jscomp$inline_1530, "on" + capitalizedEvent$jscomp$inline_1531)
}
registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
registerSimpleEvent(ANIMATION_START, "onAnimationStart");
registerSimpleEvent("dblclick", "onDoubleClick");
registerSimpleEvent("focusin", "onFocus");
registerSimpleEvent("focusout", "onBlur");
registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
registerSimpleEvent(TRANSITION_START, "onTransitionStart");
registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
registerTwoPhaseEvent("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
registerTwoPhaseEvent("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
registerTwoPhaseEvent("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
registerTwoPhaseEvent("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
registerTwoPhaseEvent("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
registerTwoPhaseEvent("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
  , nonDelegatedEvents = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes));
function processDispatchQueue(V, X) {
    X = (X & 4) !== 0;
    for (var J = 0; J < V.length; J++) {
        var ne = V[J]
          , ue = ne.event;
        ne = ne.listeners;
        e: {
            var ce = void 0;
            if (X)
                for (var me = ne.length - 1; 0 <= me; me--) {
                    var ge = ne[me]
                      , Te = ge.instance
                      , _e = ge.currentTarget;
                    if (ge = ge.listener,
                    Te !== ce && ue.isPropagationStopped())
                        break e;
                    ce = ge,
                    ue.currentTarget = _e;
                    try {
                        ce(ue)
                    } catch (Se) {
                        reportGlobalError(Se)
                    }
                    ue.currentTarget = null,
                    ce = Te
                }
            else
                for (me = 0; me < ne.length; me++) {
                    if (ge = ne[me],
                    Te = ge.instance,
                    _e = ge.currentTarget,
                    ge = ge.listener,
                    Te !== ce && ue.isPropagationStopped())
                        break e;
                    ce = ge,
                    ue.currentTarget = _e;
                    try {
                        ce(ue)
                    } catch (Se) {
                        reportGlobalError(Se)
                    }
                    ue.currentTarget = null,
                    ce = Te
                }
        }
    }
}
function listenToNonDelegatedEvent(V, X) {
    var J = X[internalEventHandlersKey];
    J === void 0 && (J = X[internalEventHandlersKey] = new Set);
    var ne = V + "__bubble";
    J.has(ne) || (addTrappedEventListener(X, V, 2, !1),
    J.add(ne))
}
function listenToNativeEvent(V, X, J) {
    var ne = 0;
    X && (ne |= 4),
    addTrappedEventListener(J, V, ne, X)
}
var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
function listenToAllSupportedEvents(V) {
    if (!V[listeningMarker]) {
        V[listeningMarker] = !0,
        allNativeEvents.forEach(function(J) {
            J !== "selectionchange" && (nonDelegatedEvents.has(J) || listenToNativeEvent(J, !1, V),
            listenToNativeEvent(J, !0, V))
        });
        var X = V.nodeType === 9 ? V : V.ownerDocument;
        X === null || X[listeningMarker] || (X[listeningMarker] = !0,
        listenToNativeEvent("selectionchange", !1, X))
    }
}
function addTrappedEventListener(V, X, J, ne) {
    switch (getEventPriority(X)) {
    case 2:
        var ue = dispatchDiscreteEvent;
        break;
    case 8:
        ue = dispatchContinuousEvent;
        break;
    default:
        ue = dispatchEvent
    }
    J = ue.bind(null, X, J, V),
    ue = void 0,
    !passiveBrowserEventsSupported || X !== "touchstart" && X !== "touchmove" && X !== "wheel" || (ue = !0),
    ne ? ue !== void 0 ? V.addEventListener(X, J, {
        capture: !0,
        passive: ue
    }) : V.addEventListener(X, J, !0) : ue !== void 0 ? V.addEventListener(X, J, {
        passive: ue
    }) : V.addEventListener(X, J, !1)
}
function dispatchEventForPluginEventSystem(V, X, J, ne, ue) {
    var ce = ne;
    if (!(X & 1) && !(X & 2) && ne !== null)
        e: for (; ; ) {
            if (ne === null)
                return;
            var me = ne.tag;
            if (me === 3 || me === 4) {
                var ge = ne.stateNode.containerInfo;
                if (ge === ue)
                    break;
                if (me === 4)
                    for (me = ne.return; me !== null; ) {
                        var Te = me.tag;
                        if ((Te === 3 || Te === 4) && me.stateNode.containerInfo === ue)
                            return;
                        me = me.return
                    }
                for (; ge !== null; ) {
                    if (me = getClosestInstanceFromNode(ge),
                    me === null)
                        return;
                    if (Te = me.tag,
                    Te === 5 || Te === 6 || Te === 26 || Te === 27) {
                        ne = ce = me;
                        continue e
                    }
                    ge = ge.parentNode
                }
            }
            ne = ne.return
        }
    batchedUpdates$1(function() {
        var _e = ce
          , Se = getEventTarget(J)
          , Ie = [];
        e: {
            var ye = topLevelEventsToReactNames.get(V);
            if (ye !== void 0) {
                var $e = SyntheticEvent
                  , Ne = V;
                switch (V) {
                case "keypress":
                    if (getEventCharCode(J) === 0)
                        break e;
                case "keydown":
                case "keyup":
                    $e = SyntheticKeyboardEvent;
                    break;
                case "focusin":
                    Ne = "focus",
                    $e = SyntheticFocusEvent;
                    break;
                case "focusout":
                    Ne = "blur",
                    $e = SyntheticFocusEvent;
                    break;
                case "beforeblur":
                case "afterblur":
                    $e = SyntheticFocusEvent;
                    break;
                case "click":
                    if (J.button === 2)
                        break e;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                    $e = SyntheticMouseEvent;
                    break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                    $e = SyntheticDragEvent;
                    break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                    $e = SyntheticTouchEvent;
                    break;
                case ANIMATION_END:
                case ANIMATION_ITERATION:
                case ANIMATION_START:
                    $e = SyntheticAnimationEvent;
                    break;
                case TRANSITION_END:
                    $e = SyntheticTransitionEvent;
                    break;
                case "scroll":
                case "scrollend":
                    $e = SyntheticUIEvent;
                    break;
                case "wheel":
                    $e = SyntheticWheelEvent;
                    break;
                case "copy":
                case "cut":
                case "paste":
                    $e = SyntheticClipboardEvent;
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                    $e = SyntheticPointerEvent;
                    break;
                case "toggle":
                case "beforetoggle":
                    $e = SyntheticToggleEvent
                }
                var ve = (X & 4) !== 0
                  , ke = !ve && (V === "scroll" || V === "scrollend")
                  , xe = ve ? ye !== null ? ye + "Capture" : null : ye;
                ve = [];
                for (var we = _e, Fe; we !== null; ) {
                    var je = we;
                    if (Fe = je.stateNode,
                    je = je.tag,
                    je !== 5 && je !== 26 && je !== 27 || Fe === null || xe === null || (je = getListener(we, xe),
                    je != null && ve.push(createDispatchListener(we, je, Fe))),
                    ke)
                        break;
                    we = we.return
                }
                0 < ve.length && (ye = new $e(ye,Ne,null,J,Se),
                Ie.push({
                    event: ye,
                    listeners: ve
                }))
            }
        }
        if (!(X & 7)) {
            e: {
                if (ye = V === "mouseover" || V === "pointerover",
                $e = V === "mouseout" || V === "pointerout",
                ye && J !== currentReplayingEvent && (Ne = J.relatedTarget || J.fromElement) && (getClosestInstanceFromNode(Ne) || Ne[internalContainerInstanceKey]))
                    break e;
                if (($e || ye) && (ye = Se.window === Se ? Se : (ye = Se.ownerDocument) ? ye.defaultView || ye.parentWindow : window,
                $e ? (Ne = J.relatedTarget || J.toElement,
                $e = _e,
                Ne = Ne ? getClosestInstanceFromNode(Ne) : null,
                Ne !== null && (ke = getNearestMountedFiber(Ne),
                ve = Ne.tag,
                Ne !== ke || ve !== 5 && ve !== 27 && ve !== 6) && (Ne = null)) : ($e = null,
                Ne = _e),
                $e !== Ne)) {
                    if (ve = SyntheticMouseEvent,
                    je = "onMouseLeave",
                    xe = "onMouseEnter",
                    we = "mouse",
                    (V === "pointerout" || V === "pointerover") && (ve = SyntheticPointerEvent,
                    je = "onPointerLeave",
                    xe = "onPointerEnter",
                    we = "pointer"),
                    ke = $e == null ? ye : getNodeFromInstance($e),
                    Fe = Ne == null ? ye : getNodeFromInstance(Ne),
                    ye = new ve(je,we + "leave",$e,J,Se),
                    ye.target = ke,
                    ye.relatedTarget = Fe,
                    je = null,
                    getClosestInstanceFromNode(Se) === _e && (ve = new ve(xe,we + "enter",Ne,J,Se),
                    ve.target = Fe,
                    ve.relatedTarget = ke,
                    je = ve),
                    ke = je,
                    $e && Ne)
                        t: {
                            for (ve = $e,
                            xe = Ne,
                            we = 0,
                            Fe = ve; Fe; Fe = getParent(Fe))
                                we++;
                            for (Fe = 0,
                            je = xe; je; je = getParent(je))
                                Fe++;
                            for (; 0 < we - Fe; )
                                ve = getParent(ve),
                                we--;
                            for (; 0 < Fe - we; )
                                xe = getParent(xe),
                                Fe--;
                            for (; we--; ) {
                                if (ve === xe || xe !== null && ve === xe.alternate)
                                    break t;
                                ve = getParent(ve),
                                xe = getParent(xe)
                            }
                            ve = null
                        }
                    else
                        ve = null;
                    $e !== null && accumulateEnterLeaveListenersForEvent(Ie, ye, $e, ve, !1),
                    Ne !== null && ke !== null && accumulateEnterLeaveListenersForEvent(Ie, ke, Ne, ve, !0)
                }
            }
            e: {
                if (ye = _e ? getNodeFromInstance(_e) : window,
                $e = ye.nodeName && ye.nodeName.toLowerCase(),
                $e === "select" || $e === "input" && ye.type === "file")
                    var Xe = getTargetInstForChangeEvent;
                else if (isTextInputElement(ye))
                    if (isInputEventSupported)
                        Xe = getTargetInstForInputOrChangeEvent;
                    else {
                        Xe = getTargetInstForInputEventPolyfill;
                        var ze = handleEventsForInputEventPolyfill
                    }
                else
                    $e = ye.nodeName,
                    !$e || $e.toLowerCase() !== "input" || ye.type !== "checkbox" && ye.type !== "radio" ? _e && isCustomElement(_e.elementType) && (Xe = getTargetInstForChangeEvent) : Xe = getTargetInstForClickEvent;
                if (Xe && (Xe = Xe(V, _e))) {
                    createAndAccumulateChangeEvent(Ie, Xe, J, Se);
                    break e
                }
                ze && ze(V, ye, _e),
                V === "focusout" && _e && ye.type === "number" && _e.memoizedProps.value != null && setDefaultValue(ye, "number", ye.value)
            }
            switch (ze = _e ? getNodeFromInstance(_e) : window,
            V) {
            case "focusin":
                (isTextInputElement(ze) || ze.contentEditable === "true") && (activeElement = ze,
                activeElementInst = _e,
                lastSelection = null);
                break;
            case "focusout":
                lastSelection = activeElementInst = activeElement = null;
                break;
            case "mousedown":
                mouseDown = !0;
                break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
                mouseDown = !1,
                constructSelectEvent(Ie, J, Se);
                break;
            case "selectionchange":
                if (skipSelectionChangeEvent)
                    break;
            case "keydown":
            case "keyup":
                constructSelectEvent(Ie, J, Se)
            }
            var qe;
            if (canUseCompositionEvent)
                e: {
                    switch (V) {
                    case "compositionstart":
                        var Ze = "onCompositionStart";
                        break e;
                    case "compositionend":
                        Ze = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        Ze = "onCompositionUpdate";
                        break e
                    }
                    Ze = void 0
                }
            else
                isComposing ? isFallbackCompositionEnd(V, J) && (Ze = "onCompositionEnd") : V === "keydown" && J.keyCode === 229 && (Ze = "onCompositionStart");
            Ze && (useFallbackCompositionData && J.locale !== "ko" && (isComposing || Ze !== "onCompositionStart" ? Ze === "onCompositionEnd" && isComposing && (qe = getData()) : (root$3 = Se,
            startText = "value"in root$3 ? root$3.value : root$3.textContent,
            isComposing = !0)),
            ze = accumulateTwoPhaseListeners(_e, Ze),
            0 < ze.length && (Ze = new SyntheticCompositionEvent(Ze,V,null,J,Se),
            Ie.push({
                event: Ze,
                listeners: ze
            }),
            qe ? Ze.data = qe : (qe = getDataFromCustomEvent(J),
            qe !== null && (Ze.data = qe)))),
            (qe = canUseTextInputEvent ? getNativeBeforeInputChars(V, J) : getFallbackBeforeInputChars(V, J)) && (Ze = accumulateTwoPhaseListeners(_e, "onBeforeInput"),
            0 < Ze.length && (ze = new SyntheticCompositionEvent("onBeforeInput","beforeinput",null,J,Se),
            Ie.push({
                event: ze,
                listeners: Ze
            }),
            ze.data = qe)),
            extractEvents$1(Ie, V, _e, J, Se)
        }
        processDispatchQueue(Ie, X)
    })
}
function createDispatchListener(V, X, J) {
    return {
        instance: V,
        listener: X,
        currentTarget: J
    }
}
function accumulateTwoPhaseListeners(V, X) {
    for (var J = X + "Capture", ne = []; V !== null; ) {
        var ue = V
          , ce = ue.stateNode;
        if (ue = ue.tag,
        ue !== 5 && ue !== 26 && ue !== 27 || ce === null || (ue = getListener(V, J),
        ue != null && ne.unshift(createDispatchListener(V, ue, ce)),
        ue = getListener(V, X),
        ue != null && ne.push(createDispatchListener(V, ue, ce))),
        V.tag === 3)
            return ne;
        V = V.return
    }
    return []
}
function getParent(V) {
    if (V === null)
        return null;
    do
        V = V.return;
    while (V && V.tag !== 5 && V.tag !== 27);
    return V || null
}
function accumulateEnterLeaveListenersForEvent(V, X, J, ne, ue) {
    for (var ce = X._reactName, me = []; J !== null && J !== ne; ) {
        var ge = J
          , Te = ge.alternate
          , _e = ge.stateNode;
        if (ge = ge.tag,
        Te !== null && Te === ne)
            break;
        ge !== 5 && ge !== 26 && ge !== 27 || _e === null || (Te = _e,
        ue ? (_e = getListener(J, ce),
        _e != null && me.unshift(createDispatchListener(J, _e, Te))) : ue || (_e = getListener(J, ce),
        _e != null && me.push(createDispatchListener(J, _e, Te)))),
        J = J.return
    }
    me.length !== 0 && V.push({
        event: X,
        listeners: me
    })
}
var NORMALIZE_NEWLINES_REGEX = /\r\n?/g
  , NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
function normalizeMarkupForTextOrAttribute(V) {
    return (typeof V == "string" ? V : "" + V).replace(NORMALIZE_NEWLINES_REGEX, `
`).replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "")
}
function checkForUnmatchedText(V, X) {
    return X = normalizeMarkupForTextOrAttribute(X),
    normalizeMarkupForTextOrAttribute(V) === X
}
function noop$1() {}
function setProp(V, X, J, ne, ue, ce) {
    switch (J) {
    case "children":
        typeof ne == "string" ? X === "body" || X === "textarea" && ne === "" || setTextContent(V, ne) : (typeof ne == "number" || typeof ne == "bigint") && X !== "body" && setTextContent(V, "" + ne);
        break;
    case "className":
        setValueForKnownAttribute(V, "class", ne);
        break;
    case "tabIndex":
        setValueForKnownAttribute(V, "tabindex", ne);
        break;
    case "dir":
    case "role":
    case "viewBox":
    case "width":
    case "height":
        setValueForKnownAttribute(V, J, ne);
        break;
    case "style":
        setValueForStyles(V, ne, ce);
        break;
    case "data":
        if (X !== "object") {
            setValueForKnownAttribute(V, "data", ne);
            break
        }
    case "src":
    case "href":
        if (ne === "" && (X !== "a" || J !== "href")) {
            V.removeAttribute(J);
            break
        }
        if (ne == null || typeof ne == "function" || typeof ne == "symbol" || typeof ne == "boolean") {
            V.removeAttribute(J);
            break
        }
        ne = sanitizeURL("" + ne),
        V.setAttribute(J, ne);
        break;
    case "action":
    case "formAction":
        if (typeof ne == "function") {
            V.setAttribute(J, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
            break
        } else
            typeof ce == "function" && (J === "formAction" ? (X !== "input" && setProp(V, X, "name", ue.name, ue, null),
            setProp(V, X, "formEncType", ue.formEncType, ue, null),
            setProp(V, X, "formMethod", ue.formMethod, ue, null),
            setProp(V, X, "formTarget", ue.formTarget, ue, null)) : (setProp(V, X, "encType", ue.encType, ue, null),
            setProp(V, X, "method", ue.method, ue, null),
            setProp(V, X, "target", ue.target, ue, null)));
        if (ne == null || typeof ne == "symbol" || typeof ne == "boolean") {
            V.removeAttribute(J);
            break
        }
        ne = sanitizeURL("" + ne),
        V.setAttribute(J, ne);
        break;
    case "onClick":
        ne != null && (V.onclick = noop$1);
        break;
    case "onScroll":
        ne != null && listenToNonDelegatedEvent("scroll", V);
        break;
    case "onScrollEnd":
        ne != null && listenToNonDelegatedEvent("scrollend", V);
        break;
    case "dangerouslySetInnerHTML":
        if (ne != null) {
            if (typeof ne != "object" || !("__html"in ne))
                throw Error(formatProdErrorMessage(61));
            if (J = ne.__html,
            J != null) {
                if (ue.children != null)
                    throw Error(formatProdErrorMessage(60));
                V.innerHTML = J
            }
        }
        break;
    case "multiple":
        V.multiple = ne && typeof ne != "function" && typeof ne != "symbol";
        break;
    case "muted":
        V.muted = ne && typeof ne != "function" && typeof ne != "symbol";
        break;
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
    case "defaultValue":
    case "defaultChecked":
    case "innerHTML":
    case "ref":
        break;
    case "autoFocus":
        break;
    case "xlinkHref":
        if (ne == null || typeof ne == "function" || typeof ne == "boolean" || typeof ne == "symbol") {
            V.removeAttribute("xlink:href");
            break
        }
        J = sanitizeURL("" + ne),
        V.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", J);
        break;
    case "contentEditable":
    case "spellCheck":
    case "draggable":
    case "value":
    case "autoReverse":
    case "externalResourcesRequired":
    case "focusable":
    case "preserveAlpha":
        ne != null && typeof ne != "function" && typeof ne != "symbol" ? V.setAttribute(J, "" + ne) : V.removeAttribute(J);
        break;
    case "inert":
    case "allowFullScreen":
    case "async":
    case "autoPlay":
    case "controls":
    case "default":
    case "defer":
    case "disabled":
    case "disablePictureInPicture":
    case "disableRemotePlayback":
    case "formNoValidate":
    case "hidden":
    case "loop":
    case "noModule":
    case "noValidate":
    case "open":
    case "playsInline":
    case "readOnly":
    case "required":
    case "reversed":
    case "scoped":
    case "seamless":
    case "itemScope":
        ne && typeof ne != "function" && typeof ne != "symbol" ? V.setAttribute(J, "") : V.removeAttribute(J);
        break;
    case "capture":
    case "download":
        ne === !0 ? V.setAttribute(J, "") : ne !== !1 && ne != null && typeof ne != "function" && typeof ne != "symbol" ? V.setAttribute(J, ne) : V.removeAttribute(J);
        break;
    case "cols":
    case "rows":
    case "size":
    case "span":
        ne != null && typeof ne != "function" && typeof ne != "symbol" && !isNaN(ne) && 1 <= ne ? V.setAttribute(J, ne) : V.removeAttribute(J);
        break;
    case "rowSpan":
    case "start":
        ne == null || typeof ne == "function" || typeof ne == "symbol" || isNaN(ne) ? V.removeAttribute(J) : V.setAttribute(J, ne);
        break;
    case "popover":
        listenToNonDelegatedEvent("beforetoggle", V),
        listenToNonDelegatedEvent("toggle", V),
        setValueForAttribute(V, "popover", ne);
        break;
    case "xlinkActuate":
        setValueForNamespacedAttribute(V, "http://www.w3.org/1999/xlink", "xlink:actuate", ne);
        break;
    case "xlinkArcrole":
        setValueForNamespacedAttribute(V, "http://www.w3.org/1999/xlink", "xlink:arcrole", ne);
        break;
    case "xlinkRole":
        setValueForNamespacedAttribute(V, "http://www.w3.org/1999/xlink", "xlink:role", ne);
        break;
    case "xlinkShow":
        setValueForNamespacedAttribute(V, "http://www.w3.org/1999/xlink", "xlink:show", ne);
        break;
    case "xlinkTitle":
        setValueForNamespacedAttribute(V, "http://www.w3.org/1999/xlink", "xlink:title", ne);
        break;
    case "xlinkType":
        setValueForNamespacedAttribute(V, "http://www.w3.org/1999/xlink", "xlink:type", ne);
        break;
    case "xmlBase":
        setValueForNamespacedAttribute(V, "http://www.w3.org/XML/1998/namespace", "xml:base", ne);
        break;
    case "xmlLang":
        setValueForNamespacedAttribute(V, "http://www.w3.org/XML/1998/namespace", "xml:lang", ne);
        break;
    case "xmlSpace":
        setValueForNamespacedAttribute(V, "http://www.w3.org/XML/1998/namespace", "xml:space", ne);
        break;
    case "is":
        setValueForAttribute(V, "is", ne);
        break;
    case "innerText":
    case "textContent":
        break;
    default:
        (!(2 < J.length) || J[0] !== "o" && J[0] !== "O" || J[1] !== "n" && J[1] !== "N") && (J = aliases.get(J) || J,
        setValueForAttribute(V, J, ne))
    }
}
function setPropOnCustomElement(V, X, J, ne, ue, ce) {
    switch (J) {
    case "style":
        setValueForStyles(V, ne, ce);
        break;
    case "dangerouslySetInnerHTML":
        if (ne != null) {
            if (typeof ne != "object" || !("__html"in ne))
                throw Error(formatProdErrorMessage(61));
            if (J = ne.__html,
            J != null) {
                if (ue.children != null)
                    throw Error(formatProdErrorMessage(60));
                V.innerHTML = J
            }
        }
        break;
    case "children":
        typeof ne == "string" ? setTextContent(V, ne) : (typeof ne == "number" || typeof ne == "bigint") && setTextContent(V, "" + ne);
        break;
    case "onScroll":
        ne != null && listenToNonDelegatedEvent("scroll", V);
        break;
    case "onScrollEnd":
        ne != null && listenToNonDelegatedEvent("scrollend", V);
        break;
    case "onClick":
        ne != null && (V.onclick = noop$1);
        break;
    case "suppressContentEditableWarning":
    case "suppressHydrationWarning":
    case "innerHTML":
    case "ref":
        break;
    case "innerText":
    case "textContent":
        break;
    default:
        if (!registrationNameDependencies.hasOwnProperty(J))
            e: {
                if (J[0] === "o" && J[1] === "n" && (ue = J.endsWith("Capture"),
                X = J.slice(2, ue ? J.length - 7 : void 0),
                ce = V[internalPropsKey] || null,
                ce = ce != null ? ce[J] : null,
                typeof ce == "function" && V.removeEventListener(X, ce, ue),
                typeof ne == "function")) {
                    typeof ce != "function" && ce !== null && (J in V ? V[J] = null : V.hasAttribute(J) && V.removeAttribute(J)),
                    V.addEventListener(X, ne, ue);
                    break e
                }
                J in V ? V[J] = ne : ne === !0 ? V.setAttribute(J, "") : setValueForAttribute(V, J, ne)
            }
    }
}
function setInitialProperties(V, X, J) {
    switch (X) {
    case "div":
    case "span":
    case "svg":
    case "path":
    case "a":
    case "g":
    case "p":
    case "li":
        break;
    case "img":
        listenToNonDelegatedEvent("error", V),
        listenToNonDelegatedEvent("load", V);
        var ne = !1, ue = !1, ce;
        for (ce in J)
            if (J.hasOwnProperty(ce)) {
                var me = J[ce];
                if (me != null)
                    switch (ce) {
                    case "src":
                        ne = !0;
                        break;
                    case "srcSet":
                        ue = !0;
                        break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                        throw Error(formatProdErrorMessage(137, X));
                    default:
                        setProp(V, X, ce, me, J, null)
                    }
            }
        ue && setProp(V, X, "srcSet", J.srcSet, J, null),
        ne && setProp(V, X, "src", J.src, J, null);
        return;
    case "input":
        listenToNonDelegatedEvent("invalid", V);
        var ge = ce = me = ue = null
          , Te = null
          , _e = null;
        for (ne in J)
            if (J.hasOwnProperty(ne)) {
                var Se = J[ne];
                if (Se != null)
                    switch (ne) {
                    case "name":
                        ue = Se;
                        break;
                    case "type":
                        me = Se;
                        break;
                    case "checked":
                        Te = Se;
                        break;
                    case "defaultChecked":
                        _e = Se;
                        break;
                    case "value":
                        ce = Se;
                        break;
                    case "defaultValue":
                        ge = Se;
                        break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                        if (Se != null)
                            throw Error(formatProdErrorMessage(137, X));
                        break;
                    default:
                        setProp(V, X, ne, Se, J, null)
                    }
            }
        initInput(V, ce, ge, Te, _e, me, ue, !1),
        track(V);
        return;
    case "select":
        listenToNonDelegatedEvent("invalid", V),
        ne = me = ce = null;
        for (ue in J)
            if (J.hasOwnProperty(ue) && (ge = J[ue],
            ge != null))
                switch (ue) {
                case "value":
                    ce = ge;
                    break;
                case "defaultValue":
                    me = ge;
                    break;
                case "multiple":
                    ne = ge;
                default:
                    setProp(V, X, ue, ge, J, null)
                }
        X = ce,
        J = me,
        V.multiple = !!ne,
        X != null ? updateOptions(V, !!ne, X, !1) : J != null && updateOptions(V, !!ne, J, !0);
        return;
    case "textarea":
        listenToNonDelegatedEvent("invalid", V),
        ce = ue = ne = null;
        for (me in J)
            if (J.hasOwnProperty(me) && (ge = J[me],
            ge != null))
                switch (me) {
                case "value":
                    ne = ge;
                    break;
                case "defaultValue":
                    ue = ge;
                    break;
                case "children":
                    ce = ge;
                    break;
                case "dangerouslySetInnerHTML":
                    if (ge != null)
                        throw Error(formatProdErrorMessage(91));
                    break;
                default:
                    setProp(V, X, me, ge, J, null)
                }
        initTextarea(V, ne, ue, ce),
        track(V);
        return;
    case "option":
        for (Te in J)
            if (J.hasOwnProperty(Te) && (ne = J[Te],
            ne != null))
                switch (Te) {
                case "selected":
                    V.selected = ne && typeof ne != "function" && typeof ne != "symbol";
                    break;
                default:
                    setProp(V, X, Te, ne, J, null)
                }
        return;
    case "dialog":
        listenToNonDelegatedEvent("beforetoggle", V),
        listenToNonDelegatedEvent("toggle", V),
        listenToNonDelegatedEvent("cancel", V),
        listenToNonDelegatedEvent("close", V);
        break;
    case "iframe":
    case "object":
        listenToNonDelegatedEvent("load", V);
        break;
    case "video":
    case "audio":
        for (ne = 0; ne < mediaEventTypes.length; ne++)
            listenToNonDelegatedEvent(mediaEventTypes[ne], V);
        break;
    case "image":
        listenToNonDelegatedEvent("error", V),
        listenToNonDelegatedEvent("load", V);
        break;
    case "details":
        listenToNonDelegatedEvent("toggle", V);
        break;
    case "embed":
    case "source":
    case "link":
        listenToNonDelegatedEvent("error", V),
        listenToNonDelegatedEvent("load", V);
    case "area":
    case "base":
    case "br":
    case "col":
    case "hr":
    case "keygen":
    case "meta":
    case "param":
    case "track":
    case "wbr":
    case "menuitem":
        for (_e in J)
            if (J.hasOwnProperty(_e) && (ne = J[_e],
            ne != null))
                switch (_e) {
                case "children":
                case "dangerouslySetInnerHTML":
                    throw Error(formatProdErrorMessage(137, X));
                default:
                    setProp(V, X, _e, ne, J, null)
                }
        return;
    default:
        if (isCustomElement(X)) {
            for (Se in J)
                J.hasOwnProperty(Se) && (ne = J[Se],
                ne !== void 0 && setPropOnCustomElement(V, X, Se, ne, J, void 0));
            return
        }
    }
    for (ge in J)
        J.hasOwnProperty(ge) && (ne = J[ge],
        ne != null && setProp(V, X, ge, ne, J, null))
}
function updateProperties(V, X, J, ne) {
    switch (X) {
    case "div":
    case "span":
    case "svg":
    case "path":
    case "a":
    case "g":
    case "p":
    case "li":
        break;
    case "input":
        var ue = null
          , ce = null
          , me = null
          , ge = null
          , Te = null
          , _e = null
          , Se = null;
        for ($e in J) {
            var Ie = J[$e];
            if (J.hasOwnProperty($e) && Ie != null)
                switch ($e) {
                case "checked":
                    break;
                case "value":
                    break;
                case "defaultValue":
                    Te = Ie;
                default:
                    ne.hasOwnProperty($e) || setProp(V, X, $e, null, ne, Ie)
                }
        }
        for (var ye in ne) {
            var $e = ne[ye];
            if (Ie = J[ye],
            ne.hasOwnProperty(ye) && ($e != null || Ie != null))
                switch (ye) {
                case "type":
                    ce = $e;
                    break;
                case "name":
                    ue = $e;
                    break;
                case "checked":
                    _e = $e;
                    break;
                case "defaultChecked":
                    Se = $e;
                    break;
                case "value":
                    me = $e;
                    break;
                case "defaultValue":
                    ge = $e;
                    break;
                case "children":
                case "dangerouslySetInnerHTML":
                    if ($e != null)
                        throw Error(formatProdErrorMessage(137, X));
                    break;
                default:
                    $e !== Ie && setProp(V, X, ye, $e, ne, Ie)
                }
        }
        updateInput(V, me, ge, Te, _e, Se, ce, ue);
        return;
    case "select":
        $e = me = ge = ye = null;
        for (ce in J)
            if (Te = J[ce],
            J.hasOwnProperty(ce) && Te != null)
                switch (ce) {
                case "value":
                    break;
                case "multiple":
                    $e = Te;
                default:
                    ne.hasOwnProperty(ce) || setProp(V, X, ce, null, ne, Te)
                }
        for (ue in ne)
            if (ce = ne[ue],
            Te = J[ue],
            ne.hasOwnProperty(ue) && (ce != null || Te != null))
                switch (ue) {
                case "value":
                    ye = ce;
                    break;
                case "defaultValue":
                    ge = ce;
                    break;
                case "multiple":
                    me = ce;
                default:
                    ce !== Te && setProp(V, X, ue, ce, ne, Te)
                }
        X = ge,
        J = me,
        ne = $e,
        ye != null ? updateOptions(V, !!J, ye, !1) : !!ne != !!J && (X != null ? updateOptions(V, !!J, X, !0) : updateOptions(V, !!J, J ? [] : "", !1));
        return;
    case "textarea":
        $e = ye = null;
        for (ge in J)
            if (ue = J[ge],
            J.hasOwnProperty(ge) && ue != null && !ne.hasOwnProperty(ge))
                switch (ge) {
                case "value":
                    break;
                case "children":
                    break;
                default:
                    setProp(V, X, ge, null, ne, ue)
                }
        for (me in ne)
            if (ue = ne[me],
            ce = J[me],
            ne.hasOwnProperty(me) && (ue != null || ce != null))
                switch (me) {
                case "value":
                    ye = ue;
                    break;
                case "defaultValue":
                    $e = ue;
                    break;
                case "children":
                    break;
                case "dangerouslySetInnerHTML":
                    if (ue != null)
                        throw Error(formatProdErrorMessage(91));
                    break;
                default:
                    ue !== ce && setProp(V, X, me, ue, ne, ce)
                }
        updateTextarea(V, ye, $e);
        return;
    case "option":
        for (var Ne in J)
            if (ye = J[Ne],
            J.hasOwnProperty(Ne) && ye != null && !ne.hasOwnProperty(Ne))
                switch (Ne) {
                case "selected":
                    V.selected = !1;
                    break;
                default:
                    setProp(V, X, Ne, null, ne, ye)
                }
        for (Te in ne)
            if (ye = ne[Te],
            $e = J[Te],
            ne.hasOwnProperty(Te) && ye !== $e && (ye != null || $e != null))
                switch (Te) {
                case "selected":
                    V.selected = ye && typeof ye != "function" && typeof ye != "symbol";
                    break;
                default:
                    setProp(V, X, Te, ye, ne, $e)
                }
        return;
    case "img":
    case "link":
    case "area":
    case "base":
    case "br":
    case "col":
    case "embed":
    case "hr":
    case "keygen":
    case "meta":
    case "param":
    case "source":
    case "track":
    case "wbr":
    case "menuitem":
        for (var ve in J)
            ye = J[ve],
            J.hasOwnProperty(ve) && ye != null && !ne.hasOwnProperty(ve) && setProp(V, X, ve, null, ne, ye);
        for (_e in ne)
            if (ye = ne[_e],
            $e = J[_e],
            ne.hasOwnProperty(_e) && ye !== $e && (ye != null || $e != null))
                switch (_e) {
                case "children":
                case "dangerouslySetInnerHTML":
                    if (ye != null)
                        throw Error(formatProdErrorMessage(137, X));
                    break;
                default:
                    setProp(V, X, _e, ye, ne, $e)
                }
        return;
    default:
        if (isCustomElement(X)) {
            for (var ke in J)
                ye = J[ke],
                J.hasOwnProperty(ke) && ye !== void 0 && !ne.hasOwnProperty(ke) && setPropOnCustomElement(V, X, ke, void 0, ne, ye);
            for (Se in ne)
                ye = ne[Se],
                $e = J[Se],
                !ne.hasOwnProperty(Se) || ye === $e || ye === void 0 && $e === void 0 || setPropOnCustomElement(V, X, Se, ye, ne, $e);
            return
        }
    }
    for (var xe in J)
        ye = J[xe],
        J.hasOwnProperty(xe) && ye != null && !ne.hasOwnProperty(xe) && setProp(V, X, xe, null, ne, ye);
    for (Ie in ne)
        ye = ne[Ie],
        $e = J[Ie],
        !ne.hasOwnProperty(Ie) || ye === $e || ye == null && $e == null || setProp(V, X, Ie, ye, ne, $e)
}
var eventsEnabled = null
  , selectionInformation = null;
function getOwnerDocumentFromRootContainer(V) {
    return V.nodeType === 9 ? V : V.ownerDocument
}
function getOwnHostContext(V) {
    switch (V) {
    case "http://www.w3.org/2000/svg":
        return 1;
    case "http://www.w3.org/1998/Math/MathML":
        return 2;
    default:
        return 0
    }
}
function getChildHostContextProd(V, X) {
    if (V === 0)
        switch (X) {
        case "svg":
            return 1;
        case "math":
            return 2;
        default:
            return 0
        }
    return V === 1 && X === "foreignObject" ? 0 : V
}
function shouldSetTextContent(V, X) {
    return V === "textarea" || V === "noscript" || typeof X.children == "string" || typeof X.children == "number" || typeof X.children == "bigint" || typeof X.dangerouslySetInnerHTML == "object" && X.dangerouslySetInnerHTML !== null && X.dangerouslySetInnerHTML.__html != null
}
var currentPopstateTransitionEvent = null;
function shouldAttemptEagerTransition() {
    var V = window.event;
    return V && V.type === "popstate" ? V === currentPopstateTransitionEvent ? !1 : (currentPopstateTransitionEvent = V,
    !0) : (currentPopstateTransitionEvent = null,
    !1)
}
var scheduleTimeout = typeof setTimeout == "function" ? setTimeout : void 0
  , cancelTimeout = typeof clearTimeout == "function" ? clearTimeout : void 0
  , localPromise = typeof Promise == "function" ? Promise : void 0
  , scheduleMicrotask = typeof queueMicrotask == "function" ? queueMicrotask : typeof localPromise < "u" ? function(V) {
    return localPromise.resolve(null).then(V).catch(handleErrorInNextTick)
}
: scheduleTimeout;
function handleErrorInNextTick(V) {
    setTimeout(function() {
        throw V
    })
}
function isSingletonScope(V) {
    return V === "head"
}
function clearSuspenseBoundary(V, X) {
    var J = X
      , ne = 0
      , ue = 0;
    do {
        var ce = J.nextSibling;
        if (V.removeChild(J),
        ce && ce.nodeType === 8)
            if (J = ce.data,
            J === "/$") {
                if (0 < ne && 8 > ne) {
                    J = ne;
                    var me = V.ownerDocument;
                    if (J & 1 && releaseSingletonInstance(me.documentElement),
                    J & 2 && releaseSingletonInstance(me.body),
                    J & 4)
                        for (J = me.head,
                        releaseSingletonInstance(J),
                        me = J.firstChild; me; ) {
                            var ge = me.nextSibling
                              , Te = me.nodeName;
                            me[internalHoistableMarker] || Te === "SCRIPT" || Te === "STYLE" || Te === "LINK" && me.rel.toLowerCase() === "stylesheet" || J.removeChild(me),
                            me = ge
                        }
                }
                if (ue === 0) {
                    V.removeChild(ce),
                    retryIfBlockedOn(X);
                    return
                }
                ue--
            } else
                J === "$" || J === "$?" || J === "$!" ? ue++ : ne = J.charCodeAt(0) - 48;
        else
            ne = 0;
        J = ce
    } while (J);
    retryIfBlockedOn(X)
}
function clearContainerSparingly(V) {
    var X = V.firstChild;
    for (X && X.nodeType === 10 && (X = X.nextSibling); X; ) {
        var J = X;
        switch (X = X.nextSibling,
        J.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
            clearContainerSparingly(J),
            detachDeletedInstance(J);
            continue;
        case "SCRIPT":
        case "STYLE":
            continue;
        case "LINK":
            if (J.rel.toLowerCase() === "stylesheet")
                continue
        }
        V.removeChild(J)
    }
}
function canHydrateInstance(V, X, J, ne) {
    for (; V.nodeType === 1; ) {
        var ue = J;
        if (V.nodeName.toLowerCase() !== X.toLowerCase()) {
            if (!ne && (V.nodeName !== "INPUT" || V.type !== "hidden"))
                break
        } else if (ne) {
            if (!V[internalHoistableMarker])
                switch (X) {
                case "meta":
                    if (!V.hasAttribute("itemprop"))
                        break;
                    return V;
                case "link":
                    if (ce = V.getAttribute("rel"),
                    ce === "stylesheet" && V.hasAttribute("data-precedence"))
                        break;
                    if (ce !== ue.rel || V.getAttribute("href") !== (ue.href == null || ue.href === "" ? null : ue.href) || V.getAttribute("crossorigin") !== (ue.crossOrigin == null ? null : ue.crossOrigin) || V.getAttribute("title") !== (ue.title == null ? null : ue.title))
                        break;
                    return V;
                case "style":
                    if (V.hasAttribute("data-precedence"))
                        break;
                    return V;
                case "script":
                    if (ce = V.getAttribute("src"),
                    (ce !== (ue.src == null ? null : ue.src) || V.getAttribute("type") !== (ue.type == null ? null : ue.type) || V.getAttribute("crossorigin") !== (ue.crossOrigin == null ? null : ue.crossOrigin)) && ce && V.hasAttribute("async") && !V.hasAttribute("itemprop"))
                        break;
                    return V;
                default:
                    return V
                }
        } else if (X === "input" && V.type === "hidden") {
            var ce = ue.name == null ? null : "" + ue.name;
            if (ue.type === "hidden" && V.getAttribute("name") === ce)
                return V
        } else
            return V;
        if (V = getNextHydratable(V.nextSibling),
        V === null)
            break
    }
    return null
}
function canHydrateTextInstance(V, X, J) {
    if (X === "")
        return null;
    for (; V.nodeType !== 3; )
        if ((V.nodeType !== 1 || V.nodeName !== "INPUT" || V.type !== "hidden") && !J || (V = getNextHydratable(V.nextSibling),
        V === null))
            return null;
    return V
}
function isSuspenseInstanceFallback(V) {
    return V.data === "$!" || V.data === "$?" && V.ownerDocument.readyState === "complete"
}
function registerSuspenseInstanceRetry(V, X) {
    var J = V.ownerDocument;
    if (V.data !== "$?" || J.readyState === "complete")
        X();
    else {
        var ne = function() {
            X(),
            J.removeEventListener("DOMContentLoaded", ne)
        };
        J.addEventListener("DOMContentLoaded", ne),
        V._reactRetry = ne
    }
}
function getNextHydratable(V) {
    for (; V != null; V = V.nextSibling) {
        var X = V.nodeType;
        if (X === 1 || X === 3)
            break;
        if (X === 8) {
            if (X = V.data,
            X === "$" || X === "$!" || X === "$?" || X === "F!" || X === "F")
                break;
            if (X === "/$")
                return null
        }
    }
    return V
}
var previousHydratableOnEnteringScopedSingleton = null;
function getParentSuspenseInstance(V) {
    V = V.previousSibling;
    for (var X = 0; V; ) {
        if (V.nodeType === 8) {
            var J = V.data;
            if (J === "$" || J === "$!" || J === "$?") {
                if (X === 0)
                    return V;
                X--
            } else
                J === "/$" && X++
        }
        V = V.previousSibling
    }
    return null
}
function resolveSingletonInstance(V, X, J) {
    switch (X = getOwnerDocumentFromRootContainer(J),
    V) {
    case "html":
        if (V = X.documentElement,
        !V)
            throw Error(formatProdErrorMessage(452));
        return V;
    case "head":
        if (V = X.head,
        !V)
            throw Error(formatProdErrorMessage(453));
        return V;
    case "body":
        if (V = X.body,
        !V)
            throw Error(formatProdErrorMessage(454));
        return V;
    default:
        throw Error(formatProdErrorMessage(451))
    }
}
function releaseSingletonInstance(V) {
    for (var X = V.attributes; X.length; )
        V.removeAttributeNode(X[0]);
    detachDeletedInstance(V)
}
var preloadPropsMap = new Map
  , preconnectsSet = new Set;
function getHoistableRoot(V) {
    return typeof V.getRootNode == "function" ? V.getRootNode() : V.nodeType === 9 ? V : V.ownerDocument
}
var previousDispatcher = ReactDOMSharedInternals.d;
ReactDOMSharedInternals.d = {
    f: flushSyncWork,
    r: requestFormReset,
    D: prefetchDNS,
    C: preconnect,
    L: preload,
    m: preloadModule,
    X: preinitScript,
    S: preinitStyle,
    M: preinitModuleScript
};
function flushSyncWork() {
    var V = previousDispatcher.f()
      , X = flushSyncWork$1();
    return V || X
}
function requestFormReset(V) {
    var X = getInstanceFromNode(V);
    X !== null && X.tag === 5 && X.type === "form" ? requestFormReset$1(X) : previousDispatcher.r(V)
}
var globalDocument = typeof document > "u" ? null : document;
function preconnectAs(V, X, J) {
    var ne = globalDocument;
    if (ne && typeof X == "string" && X) {
        var ue = escapeSelectorAttributeValueInsideDoubleQuotes(X);
        ue = 'link[rel="' + V + '"][href="' + ue + '"]',
        typeof J == "string" && (ue += '[crossorigin="' + J + '"]'),
        preconnectsSet.has(ue) || (preconnectsSet.add(ue),
        V = {
            rel: V,
            crossOrigin: J,
            href: X
        },
        ne.querySelector(ue) === null && (X = ne.createElement("link"),
        setInitialProperties(X, "link", V),
        markNodeAsHoistable(X),
        ne.head.appendChild(X)))
    }
}
function prefetchDNS(V) {
    previousDispatcher.D(V),
    preconnectAs("dns-prefetch", V, null)
}
function preconnect(V, X) {
    previousDispatcher.C(V, X),
    preconnectAs("preconnect", V, X)
}
function preload(V, X, J) {
    previousDispatcher.L(V, X, J);
    var ne = globalDocument;
    if (ne && V && X) {
        var ue = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(X) + '"]';
        X === "image" && J && J.imageSrcSet ? (ue += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(J.imageSrcSet) + '"]',
        typeof J.imageSizes == "string" && (ue += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(J.imageSizes) + '"]')) : ue += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(V) + '"]';
        var ce = ue;
        switch (X) {
        case "style":
            ce = getStyleKey(V);
            break;
        case "script":
            ce = getScriptKey(V)
        }
        preloadPropsMap.has(ce) || (V = assign({
            rel: "preload",
            href: X === "image" && J && J.imageSrcSet ? void 0 : V,
            as: X
        }, J),
        preloadPropsMap.set(ce, V),
        ne.querySelector(ue) !== null || X === "style" && ne.querySelector(getStylesheetSelectorFromKey(ce)) || X === "script" && ne.querySelector(getScriptSelectorFromKey(ce)) || (X = ne.createElement("link"),
        setInitialProperties(X, "link", V),
        markNodeAsHoistable(X),
        ne.head.appendChild(X)))
    }
}
function preloadModule(V, X) {
    previousDispatcher.m(V, X);
    var J = globalDocument;
    if (J && V) {
        var ne = X && typeof X.as == "string" ? X.as : "script"
          , ue = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(ne) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(V) + '"]'
          , ce = ue;
        switch (ne) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
            ce = getScriptKey(V)
        }
        if (!preloadPropsMap.has(ce) && (V = assign({
            rel: "modulepreload",
            href: V
        }, X),
        preloadPropsMap.set(ce, V),
        J.querySelector(ue) === null)) {
            switch (ne) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
                if (J.querySelector(getScriptSelectorFromKey(ce)))
                    return
            }
            ne = J.createElement("link"),
            setInitialProperties(ne, "link", V),
            markNodeAsHoistable(ne),
            J.head.appendChild(ne)
        }
    }
}
function preinitStyle(V, X, J) {
    previousDispatcher.S(V, X, J);
    var ne = globalDocument;
    if (ne && V) {
        var ue = getResourcesFromRoot(ne).hoistableStyles
          , ce = getStyleKey(V);
        X = X || "default";
        var me = ue.get(ce);
        if (!me) {
            var ge = {
                loading: 0,
                preload: null
            };
            if (me = ne.querySelector(getStylesheetSelectorFromKey(ce)))
                ge.loading = 5;
            else {
                V = assign({
                    rel: "stylesheet",
                    href: V,
                    "data-precedence": X
                }, J),
                (J = preloadPropsMap.get(ce)) && adoptPreloadPropsForStylesheet(V, J);
                var Te = me = ne.createElement("link");
                markNodeAsHoistable(Te),
                setInitialProperties(Te, "link", V),
                Te._p = new Promise(function(_e, Se) {
                    Te.onload = _e,
                    Te.onerror = Se
                }
                ),
                Te.addEventListener("load", function() {
                    ge.loading |= 1
                }),
                Te.addEventListener("error", function() {
                    ge.loading |= 2
                }),
                ge.loading |= 4,
                insertStylesheet(me, X, ne)
            }
            me = {
                type: "stylesheet",
                instance: me,
                count: 1,
                state: ge
            },
            ue.set(ce, me)
        }
    }
}
function preinitScript(V, X) {
    previousDispatcher.X(V, X);
    var J = globalDocument;
    if (J && V) {
        var ne = getResourcesFromRoot(J).hoistableScripts
          , ue = getScriptKey(V)
          , ce = ne.get(ue);
        ce || (ce = J.querySelector(getScriptSelectorFromKey(ue)),
        ce || (V = assign({
            src: V,
            async: !0
        }, X),
        (X = preloadPropsMap.get(ue)) && adoptPreloadPropsForScript(V, X),
        ce = J.createElement("script"),
        markNodeAsHoistable(ce),
        setInitialProperties(ce, "link", V),
        J.head.appendChild(ce)),
        ce = {
            type: "script",
            instance: ce,
            count: 1,
            state: null
        },
        ne.set(ue, ce))
    }
}
function preinitModuleScript(V, X) {
    previousDispatcher.M(V, X);
    var J = globalDocument;
    if (J && V) {
        var ne = getResourcesFromRoot(J).hoistableScripts
          , ue = getScriptKey(V)
          , ce = ne.get(ue);
        ce || (ce = J.querySelector(getScriptSelectorFromKey(ue)),
        ce || (V = assign({
            src: V,
            async: !0,
            type: "module"
        }, X),
        (X = preloadPropsMap.get(ue)) && adoptPreloadPropsForScript(V, X),
        ce = J.createElement("script"),
        markNodeAsHoistable(ce),
        setInitialProperties(ce, "link", V),
        J.head.appendChild(ce)),
        ce = {
            type: "script",
            instance: ce,
            count: 1,
            state: null
        },
        ne.set(ue, ce))
    }
}
function getResource(V, X, J, ne) {
    var ue = (ue = rootInstanceStackCursor.current) ? getHoistableRoot(ue) : null;
    if (!ue)
        throw Error(formatProdErrorMessage(446));
    switch (V) {
    case "meta":
    case "title":
        return null;
    case "style":
        return typeof J.precedence == "string" && typeof J.href == "string" ? (X = getStyleKey(J.href),
        J = getResourcesFromRoot(ue).hoistableStyles,
        ne = J.get(X),
        ne || (ne = {
            type: "style",
            instance: null,
            count: 0,
            state: null
        },
        J.set(X, ne)),
        ne) : {
            type: "void",
            instance: null,
            count: 0,
            state: null
        };
    case "link":
        if (J.rel === "stylesheet" && typeof J.href == "string" && typeof J.precedence == "string") {
            V = getStyleKey(J.href);
            var ce = getResourcesFromRoot(ue).hoistableStyles
              , me = ce.get(V);
            if (me || (ue = ue.ownerDocument || ue,
            me = {
                type: "stylesheet",
                instance: null,
                count: 0,
                state: {
                    loading: 0,
                    preload: null
                }
            },
            ce.set(V, me),
            (ce = ue.querySelector(getStylesheetSelectorFromKey(V))) && !ce._p && (me.instance = ce,
            me.state.loading = 5),
            preloadPropsMap.has(V) || (J = {
                rel: "preload",
                as: "style",
                href: J.href,
                crossOrigin: J.crossOrigin,
                integrity: J.integrity,
                media: J.media,
                hrefLang: J.hrefLang,
                referrerPolicy: J.referrerPolicy
            },
            preloadPropsMap.set(V, J),
            ce || preloadStylesheet(ue, V, J, me.state))),
            X && ne === null)
                throw Error(formatProdErrorMessage(528, ""));
            return me
        }
        if (X && ne !== null)
            throw Error(formatProdErrorMessage(529, ""));
        return null;
    case "script":
        return X = J.async,
        J = J.src,
        typeof J == "string" && X && typeof X != "function" && typeof X != "symbol" ? (X = getScriptKey(J),
        J = getResourcesFromRoot(ue).hoistableScripts,
        ne = J.get(X),
        ne || (ne = {
            type: "script",
            instance: null,
            count: 0,
            state: null
        },
        J.set(X, ne)),
        ne) : {
            type: "void",
            instance: null,
            count: 0,
            state: null
        };
    default:
        throw Error(formatProdErrorMessage(444, V))
    }
}
function getStyleKey(V) {
    return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(V) + '"'
}
function getStylesheetSelectorFromKey(V) {
    return 'link[rel="stylesheet"][' + V + "]"
}
function stylesheetPropsFromRawProps(V) {
    return assign({}, V, {
        "data-precedence": V.precedence,
        precedence: null
    })
}
function preloadStylesheet(V, X, J, ne) {
    V.querySelector('link[rel="preload"][as="style"][' + X + "]") ? ne.loading = 1 : (X = V.createElement("link"),
    ne.preload = X,
    X.addEventListener("load", function() {
        return ne.loading |= 1
    }),
    X.addEventListener("error", function() {
        return ne.loading |= 2
    }),
    setInitialProperties(X, "link", J),
    markNodeAsHoistable(X),
    V.head.appendChild(X))
}
function getScriptKey(V) {
    return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(V) + '"]'
}
function getScriptSelectorFromKey(V) {
    return "script[async]" + V
}
function acquireResource(V, X, J) {
    if (X.count++,
    X.instance === null)
        switch (X.type) {
        case "style":
            var ne = V.querySelector('style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(J.href) + '"]');
            if (ne)
                return X.instance = ne,
                markNodeAsHoistable(ne),
                ne;
            var ue = assign({}, J, {
                "data-href": J.href,
                "data-precedence": J.precedence,
                href: null,
                precedence: null
            });
            return ne = (V.ownerDocument || V).createElement("style"),
            markNodeAsHoistable(ne),
            setInitialProperties(ne, "style", ue),
            insertStylesheet(ne, J.precedence, V),
            X.instance = ne;
        case "stylesheet":
            ue = getStyleKey(J.href);
            var ce = V.querySelector(getStylesheetSelectorFromKey(ue));
            if (ce)
                return X.state.loading |= 4,
                X.instance = ce,
                markNodeAsHoistable(ce),
                ce;
            ne = stylesheetPropsFromRawProps(J),
            (ue = preloadPropsMap.get(ue)) && adoptPreloadPropsForStylesheet(ne, ue),
            ce = (V.ownerDocument || V).createElement("link"),
            markNodeAsHoistable(ce);
            var me = ce;
            return me._p = new Promise(function(ge, Te) {
                me.onload = ge,
                me.onerror = Te
            }
            ),
            setInitialProperties(ce, "link", ne),
            X.state.loading |= 4,
            insertStylesheet(ce, J.precedence, V),
            X.instance = ce;
        case "script":
            return ce = getScriptKey(J.src),
            (ue = V.querySelector(getScriptSelectorFromKey(ce))) ? (X.instance = ue,
            markNodeAsHoistable(ue),
            ue) : (ne = J,
            (ue = preloadPropsMap.get(ce)) && (ne = assign({}, J),
            adoptPreloadPropsForScript(ne, ue)),
            V = V.ownerDocument || V,
            ue = V.createElement("script"),
            markNodeAsHoistable(ue),
            setInitialProperties(ue, "link", ne),
            V.head.appendChild(ue),
            X.instance = ue);
        case "void":
            return null;
        default:
            throw Error(formatProdErrorMessage(443, X.type))
        }
    else
        X.type === "stylesheet" && !(X.state.loading & 4) && (ne = X.instance,
        X.state.loading |= 4,
        insertStylesheet(ne, J.precedence, V));
    return X.instance
}
function insertStylesheet(V, X, J) {
    for (var ne = J.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), ue = ne.length ? ne[ne.length - 1] : null, ce = ue, me = 0; me < ne.length; me++) {
        var ge = ne[me];
        if (ge.dataset.precedence === X)
            ce = ge;
        else if (ce !== ue)
            break
    }
    ce ? ce.parentNode.insertBefore(V, ce.nextSibling) : (X = J.nodeType === 9 ? J.head : J,
    X.insertBefore(V, X.firstChild))
}
function adoptPreloadPropsForStylesheet(V, X) {
    V.crossOrigin == null && (V.crossOrigin = X.crossOrigin),
    V.referrerPolicy == null && (V.referrerPolicy = X.referrerPolicy),
    V.title == null && (V.title = X.title)
}
function adoptPreloadPropsForScript(V, X) {
    V.crossOrigin == null && (V.crossOrigin = X.crossOrigin),
    V.referrerPolicy == null && (V.referrerPolicy = X.referrerPolicy),
    V.integrity == null && (V.integrity = X.integrity)
}
var tagCaches = null;
function getHydratableHoistableCache(V, X, J) {
    if (tagCaches === null) {
        var ne = new Map
          , ue = tagCaches = new Map;
        ue.set(J, ne)
    } else
        ue = tagCaches,
        ne = ue.get(J),
        ne || (ne = new Map,
        ue.set(J, ne));
    if (ne.has(V))
        return ne;
    for (ne.set(V, null),
    J = J.getElementsByTagName(V),
    ue = 0; ue < J.length; ue++) {
        var ce = J[ue];
        if (!(ce[internalHoistableMarker] || ce[internalInstanceKey] || V === "link" && ce.getAttribute("rel") === "stylesheet") && ce.namespaceURI !== "http://www.w3.org/2000/svg") {
            var me = ce.getAttribute(X) || "";
            me = V + me;
            var ge = ne.get(me);
            ge ? ge.push(ce) : ne.set(me, [ce])
        }
    }
    return ne
}
function mountHoistable(V, X, J) {
    V = V.ownerDocument || V,
    V.head.insertBefore(J, X === "title" ? V.querySelector("head > title") : null)
}
function isHostHoistableType(V, X, J) {
    if (J === 1 || X.itemProp != null)
        return !1;
    switch (V) {
    case "meta":
    case "title":
        return !0;
    case "style":
        if (typeof X.precedence != "string" || typeof X.href != "string" || X.href === "")
            break;
        return !0;
    case "link":
        if (typeof X.rel != "string" || typeof X.href != "string" || X.href === "" || X.onLoad || X.onError)
            break;
        switch (X.rel) {
        case "stylesheet":
            return V = X.disabled,
            typeof X.precedence == "string" && V == null;
        default:
            return !0
        }
    case "script":
        if (X.async && typeof X.async != "function" && typeof X.async != "symbol" && !X.onLoad && !X.onError && X.src && typeof X.src == "string")
            return !0
    }
    return !1
}
function preloadResource(V) {
    return !(V.type === "stylesheet" && !(V.state.loading & 3))
}
var suspendedState = null;
function noop() {}
function suspendResource(V, X, J) {
    if (suspendedState === null)
        throw Error(formatProdErrorMessage(475));
    var ne = suspendedState;
    if (X.type === "stylesheet" && (typeof J.media != "string" || matchMedia(J.media).matches !== !1) && !(X.state.loading & 4)) {
        if (X.instance === null) {
            var ue = getStyleKey(J.href)
              , ce = V.querySelector(getStylesheetSelectorFromKey(ue));
            if (ce) {
                V = ce._p,
                V !== null && typeof V == "object" && typeof V.then == "function" && (ne.count++,
                ne = onUnsuspend.bind(ne),
                V.then(ne, ne)),
                X.state.loading |= 4,
                X.instance = ce,
                markNodeAsHoistable(ce);
                return
            }
            ce = V.ownerDocument || V,
            J = stylesheetPropsFromRawProps(J),
            (ue = preloadPropsMap.get(ue)) && adoptPreloadPropsForStylesheet(J, ue),
            ce = ce.createElement("link"),
            markNodeAsHoistable(ce);
            var me = ce;
            me._p = new Promise(function(ge, Te) {
                me.onload = ge,
                me.onerror = Te
            }
            ),
            setInitialProperties(ce, "link", J),
            X.instance = ce
        }
        ne.stylesheets === null && (ne.stylesheets = new Map),
        ne.stylesheets.set(X, V),
        (V = X.state.preload) && !(X.state.loading & 3) && (ne.count++,
        X = onUnsuspend.bind(ne),
        V.addEventListener("load", X),
        V.addEventListener("error", X))
    }
}
function waitForCommitToBeReady() {
    if (suspendedState === null)
        throw Error(formatProdErrorMessage(475));
    var V = suspendedState;
    return V.stylesheets && V.count === 0 && insertSuspendedStylesheets(V, V.stylesheets),
    0 < V.count ? function(X) {
        var J = setTimeout(function() {
            if (V.stylesheets && insertSuspendedStylesheets(V, V.stylesheets),
            V.unsuspend) {
                var ne = V.unsuspend;
                V.unsuspend = null,
                ne()
            }
        }, 6e4);
        return V.unsuspend = X,
        function() {
            V.unsuspend = null,
            clearTimeout(J)
        }
    }
    : null
}
function onUnsuspend() {
    if (this.count--,
    this.count === 0) {
        if (this.stylesheets)
            insertSuspendedStylesheets(this, this.stylesheets);
        else if (this.unsuspend) {
            var V = this.unsuspend;
            this.unsuspend = null,
            V()
        }
    }
}
var precedencesByRoot = null;
function insertSuspendedStylesheets(V, X) {
    V.stylesheets = null,
    V.unsuspend !== null && (V.count++,
    precedencesByRoot = new Map,
    X.forEach(insertStylesheetIntoRoot, V),
    precedencesByRoot = null,
    onUnsuspend.call(V))
}
function insertStylesheetIntoRoot(V, X) {
    if (!(X.state.loading & 4)) {
        var J = precedencesByRoot.get(V);
        if (J)
            var ne = J.get(null);
        else {
            J = new Map,
            precedencesByRoot.set(V, J);
            for (var ue = V.querySelectorAll("link[data-precedence],style[data-precedence]"), ce = 0; ce < ue.length; ce++) {
                var me = ue[ce];
                (me.nodeName === "LINK" || me.getAttribute("media") !== "not all") && (J.set(me.dataset.precedence, me),
                ne = me)
            }
            ne && J.set(null, ne)
        }
        ue = X.instance,
        me = ue.getAttribute("data-precedence"),
        ce = J.get(me) || ne,
        ce === ne && J.set(null, ue),
        J.set(me, ue),
        this.count++,
        ne = onUnsuspend.bind(this),
        ue.addEventListener("load", ne),
        ue.addEventListener("error", ne),
        ce ? ce.parentNode.insertBefore(ue, ce.nextSibling) : (V = V.nodeType === 9 ? V.head : V,
        V.insertBefore(ue, V.firstChild)),
        X.state.loading |= 4
    }
}
var HostTransitionContext = {
    $$typeof: REACT_CONTEXT_TYPE,
    Provider: null,
    Consumer: null,
    _currentValue: sharedNotPendingObject,
    _currentValue2: sharedNotPendingObject,
    _threadCount: 0
};
function FiberRootNode(V, X, J, ne, ue, ce, me, ge) {
    this.tag = 1,
    this.containerInfo = V,
    this.pingCache = this.current = this.pendingChildren = null,
    this.timeoutHandle = -1,
    this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null,
    this.callbackPriority = 0,
    this.expirationTimes = createLaneMap(-1),
    this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
    this.entanglements = createLaneMap(0),
    this.hiddenUpdates = createLaneMap(null),
    this.identifierPrefix = ne,
    this.onUncaughtError = ue,
    this.onCaughtError = ce,
    this.onRecoverableError = me,
    this.pooledCache = null,
    this.pooledCacheLanes = 0,
    this.formState = ge,
    this.incompleteTransitions = new Map
}
function createFiberRoot(V, X, J, ne, ue, ce, me, ge, Te, _e, Se, Ie) {
    return V = new FiberRootNode(V,X,J,me,ge,Te,_e,Ie),
    X = 1,
    ce === !0 && (X |= 24),
    ce = createFiberImplClass(3, null, null, X),
    V.current = ce,
    ce.stateNode = V,
    X = createCache(),
    X.refCount++,
    V.pooledCache = X,
    X.refCount++,
    ce.memoizedState = {
        element: ne,
        isDehydrated: J,
        cache: X
    },
    initializeUpdateQueue(ce),
    V
}
function getContextForSubtree(V) {
    return V ? (V = emptyContextObject,
    V) : emptyContextObject
}
function updateContainerImpl(V, X, J, ne, ue, ce) {
    ue = getContextForSubtree(ue),
    ne.context === null ? ne.context = ue : ne.pendingContext = ue,
    ne = createUpdate(X),
    ne.payload = {
        element: J
    },
    ce = ce === void 0 ? null : ce,
    ce !== null && (ne.callback = ce),
    J = enqueueUpdate(V, ne, X),
    J !== null && (scheduleUpdateOnFiber(J, V, X),
    entangleTransitions(J, V, X))
}
function markRetryLaneImpl(V, X) {
    if (V = V.memoizedState,
    V !== null && V.dehydrated !== null) {
        var J = V.retryLane;
        V.retryLane = J !== 0 && J < X ? J : X
    }
}
function markRetryLaneIfNotHydrated(V, X) {
    markRetryLaneImpl(V, X),
    (V = V.alternate) && markRetryLaneImpl(V, X)
}
function attemptContinuousHydration(V) {
    if (V.tag === 13) {
        var X = enqueueConcurrentRenderForLane(V, 67108864);
        X !== null && scheduleUpdateOnFiber(X, V, 67108864),
        markRetryLaneIfNotHydrated(V, 67108864)
    }
}
var _enabled = !0;
function dispatchDiscreteEvent(V, X, J, ne) {
    var ue = ReactSharedInternals.T;
    ReactSharedInternals.T = null;
    var ce = ReactDOMSharedInternals.p;
    try {
        ReactDOMSharedInternals.p = 2,
        dispatchEvent(V, X, J, ne)
    } finally {
        ReactDOMSharedInternals.p = ce,
        ReactSharedInternals.T = ue
    }
}
function dispatchContinuousEvent(V, X, J, ne) {
    var ue = ReactSharedInternals.T;
    ReactSharedInternals.T = null;
    var ce = ReactDOMSharedInternals.p;
    try {
        ReactDOMSharedInternals.p = 8,
        dispatchEvent(V, X, J, ne)
    } finally {
        ReactDOMSharedInternals.p = ce,
        ReactSharedInternals.T = ue
    }
}
function dispatchEvent(V, X, J, ne) {
    if (_enabled) {
        var ue = findInstanceBlockingEvent(ne);
        if (ue === null)
            dispatchEventForPluginEventSystem(V, X, ne, return_targetInst, J),
            clearIfContinuousEvent(V, ne);
        else if (queueIfContinuousEvent(ue, V, X, J, ne))
            ne.stopPropagation();
        else if (clearIfContinuousEvent(V, ne),
        X & 4 && -1 < discreteReplayableEvents.indexOf(V)) {
            for (; ue !== null; ) {
                var ce = getInstanceFromNode(ue);
                if (ce !== null)
                    switch (ce.tag) {
                    case 3:
                        if (ce = ce.stateNode,
                        ce.current.memoizedState.isDehydrated) {
                            var me = getHighestPriorityLanes(ce.pendingLanes);
                            if (me !== 0) {
                                var ge = ce;
                                for (ge.pendingLanes |= 2,
                                ge.entangledLanes |= 2; me; ) {
                                    var Te = 1 << 31 - clz32(me);
                                    ge.entanglements[1] |= Te,
                                    me &= ~Te
                                }
                                ensureRootIsScheduled(ce),
                                !(executionContext & 6) && (workInProgressRootRenderTargetTime = now() + 500,
                                flushSyncWorkAcrossRoots_impl(0))
                            }
                        }
                        break;
                    case 13:
                        ge = enqueueConcurrentRenderForLane(ce, 2),
                        ge !== null && scheduleUpdateOnFiber(ge, ce, 2),
                        flushSyncWork$1(),
                        markRetryLaneIfNotHydrated(ce, 2)
                    }
                if (ce = findInstanceBlockingEvent(ne),
                ce === null && dispatchEventForPluginEventSystem(V, X, ne, return_targetInst, J),
                ce === ue)
                    break;
                ue = ce
            }
            ue !== null && ne.stopPropagation()
        } else
            dispatchEventForPluginEventSystem(V, X, ne, null, J)
    }
}
function findInstanceBlockingEvent(V) {
    return V = getEventTarget(V),
    findInstanceBlockingTarget(V)
}
var return_targetInst = null;
function findInstanceBlockingTarget(V) {
    if (return_targetInst = null,
    V = getClosestInstanceFromNode(V),
    V !== null) {
        var X = getNearestMountedFiber(V);
        if (X === null)
            V = null;
        else {
            var J = X.tag;
            if (J === 13) {
                if (V = getSuspenseInstanceFromFiber(X),
                V !== null)
                    return V;
                V = null
            } else if (J === 3) {
                if (X.stateNode.current.memoizedState.isDehydrated)
                    return X.tag === 3 ? X.stateNode.containerInfo : null;
                V = null
            } else
                X !== V && (V = null)
        }
    }
    return return_targetInst = V,
    null
}
function getEventPriority(V) {
    switch (V) {
    case "beforetoggle":
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "toggle":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
        return 2;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
        return 8;
    case "message":
        switch (getCurrentPriorityLevel()) {
        case ImmediatePriority:
            return 2;
        case UserBlockingPriority:
            return 8;
        case NormalPriority$1:
        case LowPriority:
            return 32;
        case IdlePriority:
            return 268435456;
        default:
            return 32
        }
    default:
        return 32
    }
}
var hasScheduledReplayAttempt = !1
  , queuedFocus = null
  , queuedDrag = null
  , queuedMouse = null
  , queuedPointers = new Map
  , queuedPointerCaptures = new Map
  , queuedExplicitHydrationTargets = []
  , discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");
function clearIfContinuousEvent(V, X) {
    switch (V) {
    case "focusin":
    case "focusout":
        queuedFocus = null;
        break;
    case "dragenter":
    case "dragleave":
        queuedDrag = null;
        break;
    case "mouseover":
    case "mouseout":
        queuedMouse = null;
        break;
    case "pointerover":
    case "pointerout":
        queuedPointers.delete(X.pointerId);
        break;
    case "gotpointercapture":
    case "lostpointercapture":
        queuedPointerCaptures.delete(X.pointerId)
    }
}
function accumulateOrCreateContinuousQueuedReplayableEvent(V, X, J, ne, ue, ce) {
    return V === null || V.nativeEvent !== ce ? (V = {
        blockedOn: X,
        domEventName: J,
        eventSystemFlags: ne,
        nativeEvent: ce,
        targetContainers: [ue]
    },
    X !== null && (X = getInstanceFromNode(X),
    X !== null && attemptContinuousHydration(X)),
    V) : (V.eventSystemFlags |= ne,
    X = V.targetContainers,
    ue !== null && X.indexOf(ue) === -1 && X.push(ue),
    V)
}
function queueIfContinuousEvent(V, X, J, ne, ue) {
    switch (X) {
    case "focusin":
        return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, V, X, J, ne, ue),
        !0;
    case "dragenter":
        return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, V, X, J, ne, ue),
        !0;
    case "mouseover":
        return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, V, X, J, ne, ue),
        !0;
    case "pointerover":
        var ce = ue.pointerId;
        return queuedPointers.set(ce, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(ce) || null, V, X, J, ne, ue)),
        !0;
    case "gotpointercapture":
        return ce = ue.pointerId,
        queuedPointerCaptures.set(ce, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(ce) || null, V, X, J, ne, ue)),
        !0
    }
    return !1
}
function attemptExplicitHydrationTarget(V) {
    var X = getClosestInstanceFromNode(V.target);
    if (X !== null) {
        var J = getNearestMountedFiber(X);
        if (J !== null) {
            if (X = J.tag,
            X === 13) {
                if (X = getSuspenseInstanceFromFiber(J),
                X !== null) {
                    V.blockedOn = X,
                    runWithPriority(V.priority, function() {
                        if (J.tag === 13) {
                            var ne = requestUpdateLane();
                            ne = getBumpedLaneForHydrationByLane(ne);
                            var ue = enqueueConcurrentRenderForLane(J, ne);
                            ue !== null && scheduleUpdateOnFiber(ue, J, ne),
                            markRetryLaneIfNotHydrated(J, ne)
                        }
                    });
                    return
                }
            } else if (X === 3 && J.stateNode.current.memoizedState.isDehydrated) {
                V.blockedOn = J.tag === 3 ? J.stateNode.containerInfo : null;
                return
            }
        }
    }
    V.blockedOn = null
}
function attemptReplayContinuousQueuedEvent(V) {
    if (V.blockedOn !== null)
        return !1;
    for (var X = V.targetContainers; 0 < X.length; ) {
        var J = findInstanceBlockingEvent(V.nativeEvent);
        if (J === null) {
            J = V.nativeEvent;
            var ne = new J.constructor(J.type,J);
            currentReplayingEvent = ne,
            J.target.dispatchEvent(ne),
            currentReplayingEvent = null
        } else
            return X = getInstanceFromNode(J),
            X !== null && attemptContinuousHydration(X),
            V.blockedOn = J,
            !1;
        X.shift()
    }
    return !0
}
function attemptReplayContinuousQueuedEventInMap(V, X, J) {
    attemptReplayContinuousQueuedEvent(V) && J.delete(X)
}
function replayUnblockedEvents() {
    hasScheduledReplayAttempt = !1,
    queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null),
    queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null),
    queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null),
    queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap),
    queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap)
}
function scheduleCallbackIfUnblocked(V, X) {
    V.blockedOn === X && (V.blockedOn = null,
    hasScheduledReplayAttempt || (hasScheduledReplayAttempt = !0,
    Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents)))
}
var lastScheduledReplayQueue = null;
function scheduleReplayQueueIfNeeded(V) {
    lastScheduledReplayQueue !== V && (lastScheduledReplayQueue = V,
    Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, function() {
        lastScheduledReplayQueue === V && (lastScheduledReplayQueue = null);
        for (var X = 0; X < V.length; X += 3) {
            var J = V[X]
              , ne = V[X + 1]
              , ue = V[X + 2];
            if (typeof ne != "function") {
                if (findInstanceBlockingTarget(ne || J) === null)
                    continue;
                break
            }
            var ce = getInstanceFromNode(J);
            ce !== null && (V.splice(X, 3),
            X -= 3,
            startHostTransition(ce, {
                pending: !0,
                data: ue,
                method: J.method,
                action: ne
            }, ne, ue))
        }
    }))
}
function retryIfBlockedOn(V) {
    function X(Te) {
        return scheduleCallbackIfUnblocked(Te, V)
    }
    queuedFocus !== null && scheduleCallbackIfUnblocked(queuedFocus, V),
    queuedDrag !== null && scheduleCallbackIfUnblocked(queuedDrag, V),
    queuedMouse !== null && scheduleCallbackIfUnblocked(queuedMouse, V),
    queuedPointers.forEach(X),
    queuedPointerCaptures.forEach(X);
    for (var J = 0; J < queuedExplicitHydrationTargets.length; J++) {
        var ne = queuedExplicitHydrationTargets[J];
        ne.blockedOn === V && (ne.blockedOn = null)
    }
    for (; 0 < queuedExplicitHydrationTargets.length && (J = queuedExplicitHydrationTargets[0],
    J.blockedOn === null); )
        attemptExplicitHydrationTarget(J),
        J.blockedOn === null && queuedExplicitHydrationTargets.shift();
    if (J = (V.ownerDocument || V).$$reactFormReplay,
    J != null)
        for (ne = 0; ne < J.length; ne += 3) {
            var ue = J[ne]
              , ce = J[ne + 1]
              , me = ue[internalPropsKey] || null;
            if (typeof ce == "function")
                me || scheduleReplayQueueIfNeeded(J);
            else if (me) {
                var ge = null;
                if (ce && ce.hasAttribute("formAction")) {
                    if (ue = ce,
                    me = ce[internalPropsKey] || null)
                        ge = me.formAction;
                    else if (findInstanceBlockingTarget(ue) !== null)
                        continue
                } else
                    ge = me.action;
                typeof ge == "function" ? J[ne + 1] = ge : (J.splice(ne, 3),
                ne -= 3),
                scheduleReplayQueueIfNeeded(J)
            }
        }
}
function ReactDOMRoot(V) {
    this._internalRoot = V
}
ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(V) {
    var X = this._internalRoot;
    if (X === null)
        throw Error(formatProdErrorMessage(409));
    var J = X.current
      , ne = requestUpdateLane();
    updateContainerImpl(J, ne, V, X, null, null)
}
;
ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
    var V = this._internalRoot;
    if (V !== null) {
        this._internalRoot = null;
        var X = V.containerInfo;
        updateContainerImpl(V.current, 2, null, V, null, null),
        flushSyncWork$1(),
        X[internalContainerInstanceKey] = null
    }
}
;
function ReactDOMHydrationRoot(V) {
    this._internalRoot = V
}
ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(V) {
    if (V) {
        var X = resolveUpdatePriority();
        V = {
            blockedOn: null,
            target: V,
            priority: X
        };
        for (var J = 0; J < queuedExplicitHydrationTargets.length && X !== 0 && X < queuedExplicitHydrationTargets[J].priority; J++)
            ;
        queuedExplicitHydrationTargets.splice(J, 0, V),
        J === 0 && attemptExplicitHydrationTarget(V)
    }
}
;
var isomorphicReactPackageVersion$jscomp$inline_1785 = React.version;
if (isomorphicReactPackageVersion$jscomp$inline_1785 !== "19.1.1")
    throw Error(formatProdErrorMessage(527, isomorphicReactPackageVersion$jscomp$inline_1785, "19.1.1"));
ReactDOMSharedInternals.findDOMNode = function(V) {
    var X = V._reactInternals;
    if (X === void 0)
        throw typeof V.render == "function" ? Error(formatProdErrorMessage(188)) : (V = Object.keys(V).join(","),
        Error(formatProdErrorMessage(268, V)));
    return V = findCurrentFiberUsingSlowPath(X),
    V = V !== null ? findCurrentHostFiberImpl(V) : null,
    V = V === null ? null : V.stateNode,
    V
}
;
var internals$jscomp$inline_2256 = {
    bundleType: 0,
    version: "19.1.1",
    rendererPackageName: "react-dom",
    currentDispatcherRef: ReactSharedInternals,
    reconcilerVersion: "19.1.1"
};
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var hook$jscomp$inline_2257 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!hook$jscomp$inline_2257.isDisabled && hook$jscomp$inline_2257.supportsFiber)
        try {
            rendererID = hook$jscomp$inline_2257.inject(internals$jscomp$inline_2256),
            injectedHook = hook$jscomp$inline_2257
        } catch {}
}
reactDomClient_production.createRoot = function(V, X) {
    if (!isValidContainer(V))
        throw Error(formatProdErrorMessage(299));
    var J = !1
      , ne = ""
      , ue = defaultOnUncaughtError
      , ce = defaultOnCaughtError
      , me = defaultOnRecoverableError
      , ge = null;
    return X != null && (X.unstable_strictMode === !0 && (J = !0),
    X.identifierPrefix !== void 0 && (ne = X.identifierPrefix),
    X.onUncaughtError !== void 0 && (ue = X.onUncaughtError),
    X.onCaughtError !== void 0 && (ce = X.onCaughtError),
    X.onRecoverableError !== void 0 && (me = X.onRecoverableError),
    X.unstable_transitionCallbacks !== void 0 && (ge = X.unstable_transitionCallbacks)),
    X = createFiberRoot(V, 1, !1, null, null, J, ne, ue, ce, me, ge, null),
    V[internalContainerInstanceKey] = X.current,
    listenToAllSupportedEvents(V),
    new ReactDOMRoot(X)
}
;
reactDomClient_production.hydrateRoot = function(V, X, J) {
    if (!isValidContainer(V))
        throw Error(formatProdErrorMessage(299));
    var ne = !1
      , ue = ""
      , ce = defaultOnUncaughtError
      , me = defaultOnCaughtError
      , ge = defaultOnRecoverableError
      , Te = null
      , _e = null;
    return J != null && (J.unstable_strictMode === !0 && (ne = !0),
    J.identifierPrefix !== void 0 && (ue = J.identifierPrefix),
    J.onUncaughtError !== void 0 && (ce = J.onUncaughtError),
    J.onCaughtError !== void 0 && (me = J.onCaughtError),
    J.onRecoverableError !== void 0 && (ge = J.onRecoverableError),
    J.unstable_transitionCallbacks !== void 0 && (Te = J.unstable_transitionCallbacks),
    J.formState !== void 0 && (_e = J.formState)),
    X = createFiberRoot(V, 1, !0, X, J ?? null, ne, ue, ce, me, ge, Te, _e),
    X.context = getContextForSubtree(null),
    J = X.current,
    ne = requestUpdateLane(),
    ne = getBumpedLaneForHydrationByLane(ne),
    ue = createUpdate(ne),
    ue.callback = null,
    enqueueUpdate(J, ue, ne),
    J = ne,
    X.current.lanes = J,
    markRootUpdated$1(X, J),
    ensureRootIsScheduled(X),
    V[internalContainerInstanceKey] = X.current,
    listenToAllSupportedEvents(V),
    new ReactDOMHydrationRoot(X)
}
;
reactDomClient_production.version = "19.1.1";
function checkDCE() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE)
        } catch (V) {
            console.error(V)
        }
}
checkDCE(),
client.exports = reactDomClient_production;
var clientExports = client.exports;
const ReactDOMClient = getDefaultExportFromCjs(clientExports);
var propTypes = {
    exports: {}
}
  , ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"
  , ReactPropTypesSecret_1 = ReactPropTypesSecret$1
  , ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
    function V(ne, ue, ce, me, ge, Te) {
        if (Te !== ReactPropTypesSecret) {
            var _e = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
            throw _e.name = "Invariant Violation",
            _e
        }
    }
    V.isRequired = V;
    function X() {
        return V
    }
    var J = {
        array: V,
        bigint: V,
        bool: V,
        func: V,
        number: V,
        object: V,
        string: V,
        symbol: V,
        any: V,
        arrayOf: X,
        element: V,
        elementType: V,
        instanceOf: X,
        node: V,
        objectOf: X,
        oneOf: X,
        oneOfType: X,
        shape: X,
        exact: X,
        checkPropTypes: emptyFunctionWithReset,
        resetWarningCache: emptyFunction
    };
    return J.PropTypes = J,
    J
};
propTypes.exports = factoryWithThrowingShims();
var propTypesExports = propTypes.exports;
const r = getDefaultExportFromCjs(propTypesExports);
var hasElementType = typeof Element < "u"
  , hasMap = typeof Map == "function"
  , hasSet = typeof Set == "function"
  , hasArrayBuffer = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView;
function equal(V, X) {
    if (V === X)
        return !0;
    if (V && X && typeof V == "object" && typeof X == "object") {
        if (V.constructor !== X.constructor)
            return !1;
        var J, ne, ue;
        if (Array.isArray(V)) {
            if (J = V.length,
            J != X.length)
                return !1;
            for (ne = J; ne-- !== 0; )
                if (!equal(V[ne], X[ne]))
                    return !1;
            return !0
        }
        var ce;
        if (hasMap && V instanceof Map && X instanceof Map) {
            if (V.size !== X.size)
                return !1;
            for (ce = V.entries(); !(ne = ce.next()).done; )
                if (!X.has(ne.value[0]))
                    return !1;
            for (ce = V.entries(); !(ne = ce.next()).done; )
                if (!equal(ne.value[1], X.get(ne.value[0])))
                    return !1;
            return !0
        }
        if (hasSet && V instanceof Set && X instanceof Set) {
            if (V.size !== X.size)
                return !1;
            for (ce = V.entries(); !(ne = ce.next()).done; )
                if (!X.has(ne.value[0]))
                    return !1;
            return !0
        }
        if (hasArrayBuffer && ArrayBuffer.isView(V) && ArrayBuffer.isView(X)) {
            if (J = V.length,
            J != X.length)
                return !1;
            for (ne = J; ne-- !== 0; )
                if (V[ne] !== X[ne])
                    return !1;
            return !0
        }
        if (V.constructor === RegExp)
            return V.source === X.source && V.flags === X.flags;
        if (V.valueOf !== Object.prototype.valueOf && typeof V.valueOf == "function" && typeof X.valueOf == "function")
            return V.valueOf() === X.valueOf();
        if (V.toString !== Object.prototype.toString && typeof V.toString == "function" && typeof X.toString == "function")
            return V.toString() === X.toString();
        if (ue = Object.keys(V),
        J = ue.length,
        J !== Object.keys(X).length)
            return !1;
        for (ne = J; ne-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(X, ue[ne]))
                return !1;
        if (hasElementType && V instanceof Element)
            return !1;
        for (ne = J; ne-- !== 0; )
            if (!((ue[ne] === "_owner" || ue[ne] === "__v" || ue[ne] === "__o") && V.$$typeof) && !equal(V[ue[ne]], X[ue[ne]]))
                return !1;
        return !0
    }
    return V !== V && X !== X
}
var reactFastCompare = function V(X, J) {
    try {
        return equal(X, J)
    } catch (ne) {
        if ((ne.message || "").match(/stack|recursion/i))
            return console.warn("react-fast-compare cannot handle circular refs"),
            !1;
        throw ne
    }
};
const n = getDefaultExportFromCjs(reactFastCompare);
var invariant$1 = function(V, X, J, ne, ue, ce, me, ge) {
    if (!V) {
        var Te;
        if (X === void 0)
            Te = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
        else {
            var _e = [J, ne, ue, ce, me, ge]
              , Se = 0;
            Te = new Error(X.replace(/%s/g, function() {
                return _e[Se++]
            })),
            Te.name = "Invariant Violation"
        }
        throw Te.framesToPop = 1,
        Te
    }
}
  , browser = invariant$1;
const i = getDefaultExportFromCjs(browser);
var shallowequal = function V(X, J, ne, ue) {
    var ce = ne ? ne.call(ue, X, J) : void 0;
    if (ce !== void 0)
        return !!ce;
    if (X === J)
        return !0;
    if (typeof X != "object" || !X || typeof J != "object" || !J)
        return !1;
    var me = Object.keys(X)
      , ge = Object.keys(J);
    if (me.length !== ge.length)
        return !1;
    for (var Te = Object.prototype.hasOwnProperty.bind(J), _e = 0; _e < me.length; _e++) {
        var Se = me[_e];
        if (!Te(Se))
            return !1;
        var Ie = X[Se]
          , ye = J[Se];
        if (ce = ne ? ne.call(ue, Ie, ye, Se) : void 0,
        ce === !1 || ce === void 0 && Ie !== ye)
            return !1
    }
    return !0
};
const o = getDefaultExportFromCjs(shallowequal);
function a() {
    return a = Object.assign || function(V) {
        for (var X = 1; X < arguments.length; X++) {
            var J = arguments[X];
            for (var ne in J)
                Object.prototype.hasOwnProperty.call(J, ne) && (V[ne] = J[ne])
        }
        return V
    }
    ,
    a.apply(this, arguments)
}
function s(V, X) {
    V.prototype = Object.create(X.prototype),
    V.prototype.constructor = V,
    c(V, X)
}
function c(V, X) {
    return c = Object.setPrototypeOf || function(J, ne) {
        return J.__proto__ = ne,
        J
    }
    ,
    c(V, X)
}
function u(V, X) {
    if (V == null)
        return {};
    var J, ne, ue = {}, ce = Object.keys(V);
    for (ne = 0; ne < ce.length; ne++)
        X.indexOf(J = ce[ne]) >= 0 || (ue[J] = V[J]);
    return ue
}
var l$1 = {
    BASE: "base",
    BODY: "body",
    HEAD: "head",
    HTML: "html",
    LINK: "link",
    META: "meta",
    NOSCRIPT: "noscript",
    SCRIPT: "script",
    STYLE: "style",
    TITLE: "title",
    FRAGMENT: "Symbol(react.fragment)"
}
  , p = {
    rel: ["amphtml", "canonical", "alternate"]
}
  , f = {
    type: ["application/ld+json"]
}
  , d = {
    charset: "",
    name: ["robots", "description"],
    property: ["og:type", "og:title", "og:url", "og:image", "og:image:alt", "og:description", "twitter:url", "twitter:title", "twitter:description", "twitter:image", "twitter:image:alt", "twitter:card", "twitter:site"]
}
  , h$1 = Object.keys(l$1).map(function(V) {
    return l$1[V]
})
  , m = {
    accesskey: "accessKey",
    charset: "charSet",
    class: "className",
    contenteditable: "contentEditable",
    contextmenu: "contextMenu",
    "http-equiv": "httpEquiv",
    itemprop: "itemProp",
    tabindex: "tabIndex"
}
  , y = Object.keys(m).reduce(function(V, X) {
    return V[m[X]] = X,
    V
}, {})
  , T = function(V, X) {
    for (var J = V.length - 1; J >= 0; J -= 1) {
        var ne = V[J];
        if (Object.prototype.hasOwnProperty.call(ne, X))
            return ne[X]
    }
    return null
}
  , g = function(V) {
    var X = T(V, l$1.TITLE)
      , J = T(V, "titleTemplate");
    if (Array.isArray(X) && (X = X.join("")),
    J && X)
        return J.replace(/%s/g, function() {
            return X
        });
    var ne = T(V, "defaultTitle");
    return X || ne || void 0
}
  , b = function(V) {
    return T(V, "onChangeClientState") || function() {}
}
  , v$1 = function(V, X) {
    return X.filter(function(J) {
        return J[V] !== void 0
    }).map(function(J) {
        return J[V]
    }).reduce(function(J, ne) {
        return a({}, J, ne)
    }, {})
}
  , A = function(V, X) {
    return X.filter(function(J) {
        return J[l$1.BASE] !== void 0
    }).map(function(J) {
        return J[l$1.BASE]
    }).reverse().reduce(function(J, ne) {
        if (!J.length)
            for (var ue = Object.keys(ne), ce = 0; ce < ue.length; ce += 1) {
                var me = ue[ce].toLowerCase();
                if (V.indexOf(me) !== -1 && ne[me])
                    return J.concat(ne)
            }
        return J
    }, [])
}
  , C = function(V, X, J) {
    var ne = {};
    return J.filter(function(ue) {
        return !!Array.isArray(ue[V]) || (ue[V] !== void 0 && console && typeof console.warn == "function" && console.warn("Helmet: " + V + ' should be of type "Array". Instead found type "' + typeof ue[V] + '"'),
        !1)
    }).map(function(ue) {
        return ue[V]
    }).reverse().reduce(function(ue, ce) {
        var me = {};
        ce.filter(function(Ie) {
            for (var ye, $e = Object.keys(Ie), Ne = 0; Ne < $e.length; Ne += 1) {
                var ve = $e[Ne]
                  , ke = ve.toLowerCase();
                X.indexOf(ke) === -1 || ye === "rel" && Ie[ye].toLowerCase() === "canonical" || ke === "rel" && Ie[ke].toLowerCase() === "stylesheet" || (ye = ke),
                X.indexOf(ve) === -1 || ve !== "innerHTML" && ve !== "cssText" && ve !== "itemprop" || (ye = ve)
            }
            if (!ye || !Ie[ye])
                return !1;
            var xe = Ie[ye].toLowerCase();
            return ne[ye] || (ne[ye] = {}),
            me[ye] || (me[ye] = {}),
            !ne[ye][xe] && (me[ye][xe] = !0,
            !0)
        }).reverse().forEach(function(Ie) {
            return ue.push(Ie)
        });
        for (var ge = Object.keys(me), Te = 0; Te < ge.length; Te += 1) {
            var _e = ge[Te]
              , Se = a({}, ne[_e], me[_e]);
            ne[_e] = Se
        }
        return ue
    }, []).reverse()
}
  , O = function(V, X) {
    if (Array.isArray(V) && V.length) {
        for (var J = 0; J < V.length; J += 1)
            if (V[J][X])
                return !0
    }
    return !1
}
  , S = function(V) {
    return Array.isArray(V) ? V.join("") : V
}
  , E = function(V, X) {
    return Array.isArray(V) ? V.reduce(function(J, ne) {
        return function(ue, ce) {
            for (var me = Object.keys(ue), ge = 0; ge < me.length; ge += 1)
                if (ce[me[ge]] && ce[me[ge]].includes(ue[me[ge]]))
                    return !0;
            return !1
        }(ne, X) ? J.priority.push(ne) : J.default.push(ne),
        J
    }, {
        priority: [],
        default: []
    }) : {
        default: V
    }
}
  , I = function(V, X) {
    var J;
    return a({}, V, ((J = {})[X] = void 0,
    J))
}
  , P = [l$1.NOSCRIPT, l$1.SCRIPT, l$1.STYLE]
  , w = function(V, X) {
    return X === void 0 && (X = !0),
    X === !1 ? String(V) : String(V).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;")
}
  , x = function(V) {
    return Object.keys(V).reduce(function(X, J) {
        var ne = V[J] !== void 0 ? J + '="' + V[J] + '"' : "" + J;
        return X ? X + " " + ne : ne
    }, "")
}
  , L = function(V, X) {
    return X === void 0 && (X = {}),
    Object.keys(V).reduce(function(J, ne) {
        return J[m[ne] || ne] = V[ne],
        J
    }, X)
}
  , j = function(V, X) {
    return X.map(function(J, ne) {
        var ue, ce = ((ue = {
            key: ne
        })["data-rh"] = !0,
        ue);
        return Object.keys(J).forEach(function(me) {
            var ge = m[me] || me;
            ge === "innerHTML" || ge === "cssText" ? ce.dangerouslySetInnerHTML = {
                __html: J.innerHTML || J.cssText
            } : ce[ge] = J[me]
        }),
        React$2.createElement(V, ce)
    })
}
  , M = function(V, X, J) {
    switch (V) {
    case l$1.TITLE:
        return {
            toComponent: function() {
                return ue = X.titleAttributes,
                (ce = {
                    key: ne = X.title
                })["data-rh"] = !0,
                me = L(ue, ce),
                [React$2.createElement(l$1.TITLE, me, ne)];
                var ne, ue, ce, me
            },
            toString: function() {
                return function(ne, ue, ce, me) {
                    var ge = x(ce)
                      , Te = S(ue);
                    return ge ? "<" + ne + ' data-rh="true" ' + ge + ">" + w(Te, me) + "</" + ne + ">" : "<" + ne + ' data-rh="true">' + w(Te, me) + "</" + ne + ">"
                }(V, X.title, X.titleAttributes, J)
            }
        };
    case "bodyAttributes":
    case "htmlAttributes":
        return {
            toComponent: function() {
                return L(X)
            },
            toString: function() {
                return x(X)
            }
        };
    default:
        return {
            toComponent: function() {
                return j(V, X)
            },
            toString: function() {
                return function(ne, ue, ce) {
                    return ue.reduce(function(me, ge) {
                        var Te = Object.keys(ge).filter(function(Ie) {
                            return !(Ie === "innerHTML" || Ie === "cssText")
                        }).reduce(function(Ie, ye) {
                            var $e = ge[ye] === void 0 ? ye : ye + '="' + w(ge[ye], ce) + '"';
                            return Ie ? Ie + " " + $e : $e
                        }, "")
                          , _e = ge.innerHTML || ge.cssText || ""
                          , Se = P.indexOf(ne) === -1;
                        return me + "<" + ne + ' data-rh="true" ' + Te + (Se ? "/>" : ">" + _e + "</" + ne + ">")
                    }, "")
                }(V, X, J)
            }
        }
    }
}
  , k$1 = function(V) {
    var X = V.baseTag
      , J = V.bodyAttributes
      , ne = V.encode
      , ue = V.htmlAttributes
      , ce = V.noscriptTags
      , me = V.styleTags
      , ge = V.title
      , Te = ge === void 0 ? "" : ge
      , _e = V.titleAttributes
      , Se = V.linkTags
      , Ie = V.metaTags
      , ye = V.scriptTags
      , $e = {
        toComponent: function() {},
        toString: function() {
            return ""
        }
    };
    if (V.prioritizeSeoTags) {
        var Ne = function(ve) {
            var ke = ve.linkTags
              , xe = ve.scriptTags
              , we = ve.encode
              , Fe = E(ve.metaTags, d)
              , je = E(ke, p)
              , Xe = E(xe, f);
            return {
                priorityMethods: {
                    toComponent: function() {
                        return [].concat(j(l$1.META, Fe.priority), j(l$1.LINK, je.priority), j(l$1.SCRIPT, Xe.priority))
                    },
                    toString: function() {
                        return M(l$1.META, Fe.priority, we) + " " + M(l$1.LINK, je.priority, we) + " " + M(l$1.SCRIPT, Xe.priority, we)
                    }
                },
                metaTags: Fe.default,
                linkTags: je.default,
                scriptTags: Xe.default
            }
        }(V);
        $e = Ne.priorityMethods,
        Se = Ne.linkTags,
        Ie = Ne.metaTags,
        ye = Ne.scriptTags
    }
    return {
        priority: $e,
        base: M(l$1.BASE, X, ne),
        bodyAttributes: M("bodyAttributes", J, ne),
        htmlAttributes: M("htmlAttributes", ue, ne),
        link: M(l$1.LINK, Se, ne),
        meta: M(l$1.META, Ie, ne),
        noscript: M(l$1.NOSCRIPT, ce, ne),
        script: M(l$1.SCRIPT, ye, ne),
        style: M(l$1.STYLE, me, ne),
        title: M(l$1.TITLE, {
            title: Te,
            titleAttributes: _e
        }, ne)
    }
}
  , H$1 = []
  , N = function(V, X) {
    var J = this;
    X === void 0 && (X = typeof document < "u"),
    this.instances = [],
    this.value = {
        setHelmet: function(ne) {
            J.context.helmet = ne
        },
        helmetInstances: {
            get: function() {
                return J.canUseDOM ? H$1 : J.instances
            },
            add: function(ne) {
                (J.canUseDOM ? H$1 : J.instances).push(ne)
            },
            remove: function(ne) {
                var ue = (J.canUseDOM ? H$1 : J.instances).indexOf(ne);
                (J.canUseDOM ? H$1 : J.instances).splice(ue, 1)
            }
        }
    },
    this.context = V,
    this.canUseDOM = X,
    X || (V.helmet = k$1({
        baseTag: [],
        bodyAttributes: {},
        encodeSpecialCharacters: !0,
        htmlAttributes: {},
        linkTags: [],
        metaTags: [],
        noscriptTags: [],
        scriptTags: [],
        styleTags: [],
        title: "",
        titleAttributes: {}
    }))
}
  , R = React$2.createContext({})
  , D$1 = r.shape({
    setHelmet: r.func,
    helmetInstances: r.shape({
        get: r.func,
        add: r.func,
        remove: r.func
    })
})
  , U = typeof document < "u"
  , q = function(V) {
    function X(J) {
        var ne;
        return (ne = V.call(this, J) || this).helmetData = new N(ne.props.context,X.canUseDOM),
        ne
    }
    return s(X, V),
    X.prototype.render = function() {
        return React$2.createElement(R.Provider, {
            value: this.helmetData.value
        }, this.props.children)
    }
    ,
    X
}(reactExports.Component);
q.canUseDOM = U,
q.propTypes = {
    context: r.shape({
        helmet: r.shape()
    }),
    children: r.node.isRequired
},
q.defaultProps = {
    context: {}
},
q.displayName = "HelmetProvider";
var Y$1 = function(V, X) {
    var J, ne = document.head || document.querySelector(l$1.HEAD), ue = ne.querySelectorAll(V + "[data-rh]"), ce = [].slice.call(ue), me = [];
    return X && X.length && X.forEach(function(ge) {
        var Te = document.createElement(V);
        for (var _e in ge)
            Object.prototype.hasOwnProperty.call(ge, _e) && (_e === "innerHTML" ? Te.innerHTML = ge.innerHTML : _e === "cssText" ? Te.styleSheet ? Te.styleSheet.cssText = ge.cssText : Te.appendChild(document.createTextNode(ge.cssText)) : Te.setAttribute(_e, ge[_e] === void 0 ? "" : ge[_e]));
        Te.setAttribute("data-rh", "true"),
        ce.some(function(Se, Ie) {
            return J = Ie,
            Te.isEqualNode(Se)
        }) ? ce.splice(J, 1) : me.push(Te)
    }),
    ce.forEach(function(ge) {
        return ge.parentNode.removeChild(ge)
    }),
    me.forEach(function(ge) {
        return ne.appendChild(ge)
    }),
    {
        oldTags: ce,
        newTags: me
    }
}
  , B = function(V, X) {
    var J = document.getElementsByTagName(V)[0];
    if (J) {
        for (var ne = J.getAttribute("data-rh"), ue = ne ? ne.split(",") : [], ce = [].concat(ue), me = Object.keys(X), ge = 0; ge < me.length; ge += 1) {
            var Te = me[ge]
              , _e = X[Te] || "";
            J.getAttribute(Te) !== _e && J.setAttribute(Te, _e),
            ue.indexOf(Te) === -1 && ue.push(Te);
            var Se = ce.indexOf(Te);
            Se !== -1 && ce.splice(Se, 1)
        }
        for (var Ie = ce.length - 1; Ie >= 0; Ie -= 1)
            J.removeAttribute(ce[Ie]);
        ue.length === ce.length ? J.removeAttribute("data-rh") : J.getAttribute("data-rh") !== me.join(",") && J.setAttribute("data-rh", me.join(","))
    }
}
  , K = function(V, X) {
    var J = V.baseTag
      , ne = V.htmlAttributes
      , ue = V.linkTags
      , ce = V.metaTags
      , me = V.noscriptTags
      , ge = V.onChangeClientState
      , Te = V.scriptTags
      , _e = V.styleTags
      , Se = V.title
      , Ie = V.titleAttributes;
    B(l$1.BODY, V.bodyAttributes),
    B(l$1.HTML, ne),
    function(ve, ke) {
        ve !== void 0 && document.title !== ve && (document.title = S(ve)),
        B(l$1.TITLE, ke)
    }(Se, Ie);
    var ye = {
        baseTag: Y$1(l$1.BASE, J),
        linkTags: Y$1(l$1.LINK, ue),
        metaTags: Y$1(l$1.META, ce),
        noscriptTags: Y$1(l$1.NOSCRIPT, me),
        scriptTags: Y$1(l$1.SCRIPT, Te),
        styleTags: Y$1(l$1.STYLE, _e)
    }
      , $e = {}
      , Ne = {};
    Object.keys(ye).forEach(function(ve) {
        var ke = ye[ve]
          , xe = ke.newTags
          , we = ke.oldTags;
        xe.length && ($e[ve] = xe),
        we.length && (Ne[ve] = ye[ve].oldTags)
    }),
    X && X(),
    ge(V, $e, Ne)
}
  , _$1 = null
  , z = function(V) {
    function X() {
        for (var ne, ue = arguments.length, ce = new Array(ue), me = 0; me < ue; me++)
            ce[me] = arguments[me];
        return (ne = V.call.apply(V, [this].concat(ce)) || this).rendered = !1,
        ne
    }
    s(X, V);
    var J = X.prototype;
    return J.shouldComponentUpdate = function(ne) {
        return !o(ne, this.props)
    }
    ,
    J.componentDidUpdate = function() {
        this.emitChange()
    }
    ,
    J.componentWillUnmount = function() {
        this.props.context.helmetInstances.remove(this),
        this.emitChange()
    }
    ,
    J.emitChange = function() {
        var ne, ue, ce = this.props.context, me = ce.setHelmet, ge = null, Te = (ne = ce.helmetInstances.get().map(function(_e) {
            var Se = a({}, _e.props);
            return delete Se.context,
            Se
        }),
        {
            baseTag: A(["href"], ne),
            bodyAttributes: v$1("bodyAttributes", ne),
            defer: T(ne, "defer"),
            encode: T(ne, "encodeSpecialCharacters"),
            htmlAttributes: v$1("htmlAttributes", ne),
            linkTags: C(l$1.LINK, ["rel", "href"], ne),
            metaTags: C(l$1.META, ["name", "charset", "http-equiv", "property", "itemprop"], ne),
            noscriptTags: C(l$1.NOSCRIPT, ["innerHTML"], ne),
            onChangeClientState: b(ne),
            scriptTags: C(l$1.SCRIPT, ["src", "innerHTML"], ne),
            styleTags: C(l$1.STYLE, ["cssText"], ne),
            title: g(ne),
            titleAttributes: v$1("titleAttributes", ne),
            prioritizeSeoTags: O(ne, "prioritizeSeoTags")
        });
        q.canUseDOM ? (ue = Te,
        _$1 && cancelAnimationFrame(_$1),
        ue.defer ? _$1 = requestAnimationFrame(function() {
            K(ue, function() {
                _$1 = null
            })
        }) : (K(ue),
        _$1 = null)) : k$1 && (ge = k$1(Te)),
        me(ge)
    }
    ,
    J.init = function() {
        this.rendered || (this.rendered = !0,
        this.props.context.helmetInstances.add(this),
        this.emitChange())
    }
    ,
    J.render = function() {
        return this.init(),
        null
    }
    ,
    X
}(reactExports.Component);
z.propTypes = {
    context: D$1.isRequired
},
z.displayName = "HelmetDispatcher";
var F = ["children"]
  , G = ["children"]
  , W = function(V) {
    function X() {
        return V.apply(this, arguments) || this
    }
    s(X, V);
    var J = X.prototype;
    return J.shouldComponentUpdate = function(ne) {
        return !n(I(this.props, "helmetData"), I(ne, "helmetData"))
    }
    ,
    J.mapNestedChildrenToProps = function(ne, ue) {
        if (!ue)
            return null;
        switch (ne.type) {
        case l$1.SCRIPT:
        case l$1.NOSCRIPT:
            return {
                innerHTML: ue
            };
        case l$1.STYLE:
            return {
                cssText: ue
            };
        default:
            throw new Error("<" + ne.type + " /> elements are self-closing and can not contain children. Refer to our API for more information.")
        }
    }
    ,
    J.flattenArrayTypeChildren = function(ne) {
        var ue, ce = ne.child, me = ne.arrayTypeChildren;
        return a({}, me, ((ue = {})[ce.type] = [].concat(me[ce.type] || [], [a({}, ne.newChildProps, this.mapNestedChildrenToProps(ce, ne.nestedChildren))]),
        ue))
    }
    ,
    J.mapObjectTypeChildren = function(ne) {
        var ue, ce, me = ne.child, ge = ne.newProps, Te = ne.newChildProps, _e = ne.nestedChildren;
        switch (me.type) {
        case l$1.TITLE:
            return a({}, ge, ((ue = {})[me.type] = _e,
            ue.titleAttributes = a({}, Te),
            ue));
        case l$1.BODY:
            return a({}, ge, {
                bodyAttributes: a({}, Te)
            });
        case l$1.HTML:
            return a({}, ge, {
                htmlAttributes: a({}, Te)
            });
        default:
            return a({}, ge, ((ce = {})[me.type] = a({}, Te),
            ce))
        }
    }
    ,
    J.mapArrayTypeChildrenToProps = function(ne, ue) {
        var ce = a({}, ue);
        return Object.keys(ne).forEach(function(me) {
            var ge;
            ce = a({}, ce, ((ge = {})[me] = ne[me],
            ge))
        }),
        ce
    }
    ,
    J.warnOnInvalidChildren = function(ne, ue) {
        return i(h$1.some(function(ce) {
            return ne.type === ce
        }), typeof ne.type == "function" ? "You may be attempting to nest <Helmet> components within each other, which is not allowed. Refer to our API for more information." : "Only elements types " + h$1.join(", ") + " are allowed. Helmet does not support rendering <" + ne.type + "> elements. Refer to our API for more information."),
        i(!ue || typeof ue == "string" || Array.isArray(ue) && !ue.some(function(ce) {
            return typeof ce != "string"
        }), "Helmet expects a string as a child of <" + ne.type + ">. Did you forget to wrap your children in braces? ( <" + ne.type + ">{``}</" + ne.type + "> ) Refer to our API for more information."),
        !0
    }
    ,
    J.mapChildrenToProps = function(ne, ue) {
        var ce = this
          , me = {};
        return React$2.Children.forEach(ne, function(ge) {
            if (ge && ge.props) {
                var Te = ge.props
                  , _e = Te.children
                  , Se = u(Te, F)
                  , Ie = Object.keys(Se).reduce(function($e, Ne) {
                    return $e[y[Ne] || Ne] = Se[Ne],
                    $e
                }, {})
                  , ye = ge.type;
                switch (typeof ye == "symbol" ? ye = ye.toString() : ce.warnOnInvalidChildren(ge, _e),
                ye) {
                case l$1.FRAGMENT:
                    ue = ce.mapChildrenToProps(_e, ue);
                    break;
                case l$1.LINK:
                case l$1.META:
                case l$1.NOSCRIPT:
                case l$1.SCRIPT:
                case l$1.STYLE:
                    me = ce.flattenArrayTypeChildren({
                        child: ge,
                        arrayTypeChildren: me,
                        newChildProps: Ie,
                        nestedChildren: _e
                    });
                    break;
                default:
                    ue = ce.mapObjectTypeChildren({
                        child: ge,
                        newProps: ue,
                        newChildProps: Ie,
                        nestedChildren: _e
                    })
                }
            }
        }),
        this.mapArrayTypeChildrenToProps(me, ue)
    }
    ,
    J.render = function() {
        var ne = this.props
          , ue = ne.children
          , ce = u(ne, G)
          , me = a({}, ce)
          , ge = ce.helmetData;
        return ue && (me = this.mapChildrenToProps(ue, me)),
        !ge || ge instanceof N || (ge = new N(ge.context,ge.instances)),
        ge ? React$2.createElement(z, a({}, me, {
            context: ge.value,
            helmetData: void 0
        })) : React$2.createElement(R.Consumer, null, function(Te) {
            return React$2.createElement(z, a({}, me, {
                context: Te
            }))
        })
    }
    ,
    X
}(reactExports.Component);
W.propTypes = {
    base: r.object,
    bodyAttributes: r.object,
    children: r.oneOfType([r.arrayOf(r.node), r.node]),
    defaultTitle: r.string,
    defer: r.bool,
    encodeSpecialCharacters: r.bool,
    htmlAttributes: r.object,
    link: r.arrayOf(r.object),
    meta: r.arrayOf(r.object),
    noscript: r.arrayOf(r.object),
    onChangeClientState: r.func,
    script: r.arrayOf(r.object),
    style: r.arrayOf(r.object),
    title: r.string,
    titleAttributes: r.object,
    titleTemplate: r.string,
    prioritizeSeoTags: r.bool,
    helmetData: r.object
},
W.defaultProps = {
    defer: !0,
    encodeSpecialCharacters: !0,
    prioritizeSeoTags: !1
},
W.displayName = "Helmet";
function promisifyRequest(V) {
    return new Promise( (X, J) => {
        V.oncomplete = V.onsuccess = () => X(V.result),
        V.onabort = V.onerror = () => J(V.error)
    }
    )
}
function createStore$1(V, X) {
    const J = indexedDB.open(V);
    J.onupgradeneeded = () => J.result.createObjectStore(X);
    const ne = promisifyRequest(J);
    return (ue, ce) => ne.then(me => ce(me.transaction(X, ue).objectStore(X)))
}
let defaultGetStoreFunc;
function defaultGetStore() {
    return defaultGetStoreFunc || (defaultGetStoreFunc = createStore$1("keyval-store", "keyval")),
    defaultGetStoreFunc
}
function get(V, X=defaultGetStore()) {
    return X("readonly", J => promisifyRequest(J.get(V)))
}
function set(V, X, J=defaultGetStore()) {
    return J("readwrite", ne => (ne.put(X, V),
    promisifyRequest(ne.transaction)))
}
function del(V, X=defaultGetStore()) {
    return X("readwrite", J => (J.delete(V),
    promisifyRequest(J.transaction)))
}
const createIndexedDBPersister = (V="reactQuery") => ({
    persistClient: async X => {
        await set(V, X)
    }
    ,
    restoreClient: async () => await get(V),
    removeClient: async () => {
        await del(V)
    }
});
if (typeof window < "u") {
    let V = function() {
        var X = document.body
          , J = document.getElementById("__svg__icons__dom__");
        J || (J = document.createElementNS("http://www.w3.org/2000/svg", "svg"),
        J.style.position = "absolute",
        J.style.width = "0",
        J.style.height = "0",
        J.id = "__svg__icons__dom__",
        J.setAttribute("xmlns", "http://www.w3.org/2000/svg"),
        J.setAttribute("xmlns:link", "http://www.w3.org/1999/xlink")),
        J.innerHTML = '<symbol fill="none"  viewBox="0 0 152 40" id="icon-bf-portal-logo"><g clip-path="url(#icon-bf-portal-logo_a)" fill="currentColor"><path d="M14.615 21.77h-2.704v6.686H14.6c1.29 0 1.556-.448 1.556-1.33v-4.01c0-.83-.473-1.345-1.541-1.345l.001-.002ZM14.6 11.544h-2.687v6.687h2.704c1.068 0 1.54-.515 1.54-1.346v-4.01c0-.882-.264-1.33-1.555-1.33l-.001-.001Z" /><path d="M41.617 19.467V0H21.35v4.8h-1.067V0H.017v19.467h4.8v1.066h-4.8V40h20.266v-4.8h1.067V40h20.267V20.533h-4.8v-1.066h4.8Zm-21.55 8.206c0 4.646-4.433 4.323-5.386 4.323H8.017V8.006h6.664c.952 0 5.386-.323 5.386 4.322v3.652c0 1.947-.548 2.955-1.06 3.488h-1.924v1.067h1.924c.51.532 1.06 1.541 1.06 3.488v3.652-.002Zm13.55-16.134h-7.315v6.69h5.708v3.539h-5.708v10.23h-3.896V20.533h2.144v-1.067h-2.144V8h11.21v3.539ZM64.025 1.633c1.085 1.085 1.628 2.639 1.628 4.657v13.142c0 1.98-.543 3.524-1.628 4.628-1.086 1.105-2.639 1.657-4.656 1.657h-4.114V40h-6.97V.005h11.084c2.018 0 3.57.543 4.656 1.628Zm-5.343 17.57V6.517c0-.38-.19-.572-.572-.572h-2.857v13.827h2.857c.38 0 .572-.19.572-.572v.001ZM68.909 1.628C70.013.543 71.555 0 73.537 0h4.8c2.019 0 3.57.543 4.656 1.628 1.085 1.085 1.628 2.639 1.628 4.656v27.43c0 1.982-.543 3.525-1.628 4.629C81.908 39.448 80.354 40 78.337 40h-4.8c-1.982 0-3.524-.552-4.628-1.657-1.106-1.104-1.658-2.647-1.658-4.628V6.285c0-2.018.552-3.57 1.658-4.656v-.001Zm5.885 32.43h2.285c.38 0 .573-.191.573-.571V6.513c0-.38-.191-.572-.573-.572h-2.285c-.381 0-.572.191-.572.572v26.974c0 .381.19.57.572.57ZM102.362 1.633c1.085 1.085 1.628 2.639 1.628 4.657v13.142c0 2.59-.896 4.4-2.685 5.428L103.99 40h-6.856L95.19 25.718h-1.6V40h-6.97V.005h11.084c2.018 0 3.57.543 4.656 1.628h.001Zm-5.343 17.57V6.517c0-.38-.19-.572-.572-.572H93.59v13.827h2.857c.38 0 .572-.19.572-.572v.001ZM121.358 5.946h-4.571V40h-6.97V5.947h-4.571V.005h16.112v5.943-.002ZM147.413.005v34.053h4.57v5.943h-11.541V.005h6.971ZM131.814 40h6.971L134.499.005h-10.513l-4.285 39.994h6.97l.47-5.942h4.202l.47 5.942h.001Zm-4.203-11.884 1.631-20.626 1.631 20.626h-3.263.001Z" /></g><defs><clipPath id="icon-bf-portal-logo_a"><path fill="currentColor" transform="translate(.017)" d="M0 0h151.967v40H0z" /></clipPath></defs></symbol><symbol fill="none"  viewBox="0 0 32 32" id="icon-map-size-l"><path fill="#000" d="M1 1h30v30H1z" /><path fill="#FF3C00" d="M1 1h30v30H1z" /><path stroke="currentColor" stroke-width="2" d="M1 1h30v30H1z" /><path stroke="#000" d="M.5 8.5h23v23H.5z" /><path stroke="#000" d="M.5 20.5h11v11H.5z" /></symbol><symbol fill="none"  viewBox="0 0 32 32" id="icon-map-size-m"><path fill="#FF3C00" stroke="currentColor" stroke-width="2" d="M1 9h22v22H1z" /><path stroke="#000" d="M.5 20.5h11v11H.5z" /><path stroke="#000" stroke-width="2" d="M1 1h30v30H1z" /></symbol><symbol fill="none"  viewBox="0 0 32 32" id="icon-map-size-s"><path fill="#FF3C00" stroke="currentColor" stroke-width="2" d="M1 21h10v10H1z" /><path fill="#AEC0CC" fill-opacity=".05" stroke="#000" stroke-width="2" d="M1 1h30v30H1z" /></symbol><symbol  viewBox="0 0 24 24" fill="none" id="icon-assault"><path fill="currentColor" d="M11.83-.834a.2.2 0 0 1 .342 0l11.8 19.442c.018.031.028.067.028.104v4.143a.2.2 0 0 1-.2.2h-4.182l-5.418.014a.2.2 0 0 1-.2-.2v-4.4c0-.11.09-.2.2-.2h4.063a.2.2 0 0 0 .172-.303L12.17 7.645a.2.2 0 0 0-.342 0l-6.264 10.32a.2.2 0 0 0 .172.305H9.8c.11 0 .2.09.2.2v4.399a.2.2 0 0 1-.2.2l-6.226-.014H0v.015-4.358c0-.037.01-.073.029-.104l11.8-19.442Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-bot"><path fill="currentColor" d="M13 14v2h-2v-2h2Zm1-1h-4v4h4v-4Zm7 1v2h-2v-2h2Zm1-1h-4v4h4v-4Zm-2 7v2h-8v-2h8Zm1-1H11v4h10v-4ZM4 16v2H2v-2h2Zm1-1H1v4h4v-4Zm25 1v2h-2v-2h2Zm1-1h-4v4h4v-4Z" /><path fill="currentColor" d="M24 9h-6V7.21c.61-.55 1-1.33 1-2.21 0-1.66-1.34-3-3-3s-3 1.34-3 3c0 .88.39 1.67 1 2.21V9H8l-2 2v14l2 2h16l2-2V11.25L24 9Zm.5 15.18-1.17 1.32H8.68l-1.17-1.32V11.82l1.5-1.32h6V6.72a2 2 0 0 1-1-1.72c0-1.1.9-2 2-2s2 .9 2 2a2 2 0 0 1-1 1.72v3.78h6.33l1.17 1.32v12.36h-.01Z" /><path fill="currentColor" d="M16 6a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-bot2"><path fill="currentColor" d="M20 20h-8v2h8v-2Zm1-6h-2v2h2v-2Zm-8 0h-2v2h2v-2Z" /><path fill="currentColor" d="M24 9h-7V6.72c.6-.35 1-.98 1-1.72 0-1.1-.9-2-2-2s-2 .9-2 2c0 .74.4 1.38 1 1.72V9H8l-2 2.25v13.5L8 27h16l2-2.25v-13.5L24 9Zm-8-5c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1Zm-6.5 8.5h5v5h-5v-5Zm12 11h-11v-5h11v5Zm1-6h-5v-5h5v5ZM4 16H2v2h2v-2Zm26 0h-2v2h2v-2Z" /></symbol><symbol  viewBox="0 0 28 28" id="icon-breakthrough"><path d="m5.4 19.2-.6-1.8.6-.6L6.6 18l5.2-5.2-5.4-5.6L5.1 4l3.3 1.3 5.6 5.6 5.6-5.6L22.8 4l-1.3 3.3-5.6 5.6 5.2 5.2 1.2-1.2.6.6-.6 1.8 1.1 1.1c.6-1.2 1-2.4 1-3.8V.2L14 3.6 3.4.2v16.4c0 1.3.4 2.6 1 3.7l1-1.1z" fill="currentColor" /><path d="m20.4 21.3-1.8.6-.6-.6 1.2-1.2-5.2-5.2L8.7 20l1.2 1.2-.6.6-1.8-.6-1.4 1.4C9.3 26.1 14 28 14 28s4.7-1.9 7.8-5.2l-1.4-1.5z" fill="currentColor" /></symbol><symbol  fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-6 h-6" id="icon-check"><path stroke-linecap="round" stroke-linejoin="round" d="m4.5 12.75 6 6 9-13.5" /></symbol><symbol viewBox="0 0 24 24" class="mat-checkbox-checkmark" id="icon-check2"><path fill="none" stroke-width="2.5" stroke="currentColor" d="M4.1 12.7 9 17.6 20.3 6.3" class="mat-checkbox-checkmark-path" /></symbol><symbol  viewBox="0 0 24 24" fill="none" id="icon-check3"><path fill="currentColor" d="m9.6 19.2-6-6L6 10.8l3.6 3.6 9.6-9.6 2.4 2.4-12 12Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-chevron-down-90"><path fill="currentColor" d="m6.88 12.64 2.4-2.4L16 16.96l6.72-6.72 2.4 2.4L16 21.76l-9.12-9.12Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-chevron-down"><path fill="currentColor" d="M12.31 20.15 16 23.84l3.69-3.69L28 11.84l-3.69-3.69L16 16.46 7.69 8.15 4 11.84l8.31 8.31Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-chevron-left"><path fill="currentColor" d="M11.85 12.31 8.16 16l3.69 3.69L20.16 28l3.69-3.69L15.54 16l8.31-8.31L20.16 4l-8.31 8.31Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-chevron-right"><path fill="currentColor" d="M11.84 4 8.15 7.69 16.46 16l-8.31 8.31L11.84 28l8.31-8.31L23.84 16l-3.69-3.69L11.84 4Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-chevron-up-90"><path fill="currentColor" d="m25.12 19.36-2.4 2.4L16 15.04l-6.72 6.72-2.4-2.4L16 10.24l9.12 9.12Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-clock"><path fill="currentColor" d="M16 5.5c5.79 0 10.5 4.71 10.5 10.5S21.79 26.5 16 26.5 5.5 21.79 5.5 16 10.21 5.5 16 5.5ZM16 3C8.82 3 3 8.82 3 16s5.82 13 13 13 13-5.82 13-13S23.18 3 16 3Z" /><path fill="currentColor" d="M17.25 15.47V8.4h-2.5v8.13l.36.36 4.09 4.1 1.79-1.79-3.74-3.73Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-close"><path fill="currentColor" d="M16 12.31 7.69 4 4 7.69 12.31 16 4 24.31 7.69 28 16 19.69 24.31 28 28 24.31 19.69 16 28 7.69 24.31 4 16 12.31Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-cog"><path fill="currentColor" d="M27.83 17.24v-2.46l2.97-2.79.2-.73-3.27-5.51-.75-.2-4.24 1.18-1.87-1.09-1.05-4.12-.55-.53h-6.28l-.8.53-1.06 4.11-1.87 1.09-4.24-1.19-.75.2-3.28 5.51.2.73 2.96 2.79v2.46l-2.97 2.79-.2.73 3.27 5.51.75.2 4.16-1.15 2.09 1.63.91 3.55.55.53h6.54l.55-.53 1.01-3.93 1.94-1.26 4.21 1.18.75-.2 3.28-5.51-.2-.73-2.96-2.79Zm-5.66-.46-2.42 3.9-1.34.8h-4.83l-1.34-.8-2.42-3.9v-1.55l2.42-3.9 1.08-.8h5.35l1.08.8 2.42 3.9v1.55Z" /></symbol><symbol  viewBox="0 0 28 28" id="icon-conquest"><path d="m14.1 20.2-3.4 6.9c1.1.3 2.2.4 3.3.4 1.2 0 2.4-.2 3.5-.5l-3.4-6.8z" fill="currentColor" /><path d="M14 .5C6.5.5.5 6.5.5 14c0 5.4 3.2 10.1 7.8 12.3l4.4-8.8-2.4-4.7c-.3.3-.7.8-1.2 1.4-1.4 1.9-4.6 2.6-4.6 2.6L2 11.5c1.4-.1 3.3-.7 4.2-2C7.1 8.3 8 7.9 8 7.9l2-1.1 4 7.9 4-7.9 2 1.1s.9.4 1.8 1.7c.9 1.3 2.8 1.9 4.2 2l-2.5 5.3s-3.2-.7-4.6-2.6c-.5-.7-.9-1.1-1.2-1.4l-2.3 4.6 4.5 8.8c4.5-2.2 7.6-6.8 7.6-12.2C27.5 6.5 21.5.5 14 .5z" fill="currentColor" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-copy"><path fill="currentColor" d="M16 10v18H4V10h12Zm2-2H2v22h16V8Zm-2-5h-2v2h2V3Zm14 4h-2v2.25h2V7Z" /><path fill="currentColor" d="M16 7h-2v2.25h2V7Zm14 4h-2v2.25h2V11Zm0 4h-2v2.25h2V15Zm0 4h-2v2.25h2V19Zm0 4h-2v2h2v-2Zm-10.37 0h-2.25v2h2.25v-2Zm3.5 0h-2.25v2h2.25v-2Zm3.5 0h-2.25v2h2.25v-2ZM30 3h-2v2h2V3ZM19.63 3h-2.25v2h2.25V3Zm3.5 0h-2.25v2h2.25V3Zm3.5 0h-2.25v2h2.25V3Z" /></symbol><symbol viewBox="0 0 24 24"  preserveAspectRatio="none" id="icon-crossed-out"><path stroke-width="2.5" stroke="currentColor" d="M0 24 24 0" /></symbol><symbol viewBox="0 0 13 13" fill="none"  id="icon-dashed-corner"><path d="M12 13V1H0" stroke="currentColor" stroke-dasharray="3 2" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-download"><path fill="currentColor" d="m15.99 21.43 7.98-7.98-2.8-2.8-3.2 3.21V1h-3.96v12.86l-3.21-3.22-2.8 2.8 7.99 7.99Z" /><path fill="currentColor" d="M27 20v7H5v-7H1v7.59c0 .27.11.52.29.71l2.41 2.41c.19.19.44.29.71.29h23.17c.27 0 .52-.11.71-.29l2.41-2.41a.99.99 0 0 0 .29-.71V20h-4H27Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-download2"><path fill="currentColor" d="M29.71 8.71 28.3 7.3a.99.99 0 0 0-.71-.29H24v2.5h3.5v11.5h-23V9.51H8v-2.5H4.41c-.27 0-.52.11-.71.29L2.29 8.71a.99.99 0 0 0-.29.71v13.17c0 .27.11.52.29.71l1.41 1.41c.19.19.44.29.71.29H14v2H9v2h14v-2h-5v-2h9.59c.27 0 .52-.11.71-.29l1.41-1.41a.99.99 0 0 0 .29-.71V9.42c0-.27-.11-.52-.29-.71Z" /><path fill="currentColor" d="m16 17 5.99-6-2.1-2.1-2.41 2.41V3h-2.97v8.31L12.1 8.89l-2.1 2.1 6 6V17Z" /></symbol><symbol  viewBox="0 0 24 24" fill="none" id="icon-engineer"><g fill="currentColor" clip-path="url(#icon-engineer_a)"><path d="M.031 8.49 5.927-.838h.001a.2.2 0 0 1 .17-.093h9.358a.2.2 0 0 1 .179.29l-2.206 4.4a.198.198 0 0 1-.178.11h-4.4a.4.4 0 0 0-.338.186l-4.298 6.8a.4.4 0 0 0 0 .427l2.975 4.706a.2.2 0 0 1 .01.196l-2.303 4.593a.2.2 0 0 1-.348.018L.031 13.65A.197.197 0 0 1 0 13.543V8.596c0-.038.011-.075.031-.107Zm19.422-7.146L23.97 8.49h-.001c.02.033.031.07.031.108v4.946a.202.202 0 0 1-.031.107l-5.896 9.326a.199.199 0 0 1-.169.093H8.545a.2.2 0 0 1-.178-.29l2.206-4.4a.198.198 0 0 1 .178-.11h4.399a.4.4 0 0 0 .338-.186l4.299-6.8a.4.4 0 0 0 0-.427l-2.975-4.706a.2.2 0 0 1-.01-.197l2.303-4.592a.2.2 0 0 1 .348-.018Z" /></g><defs><clipPath id="icon-engineer_a"><path fill="currentColor" d="M0-.93h24v24H0z" /></clipPath></defs></symbol><symbol  viewBox="0 0 24 24" fill="none" id="icon-error"><path fill="currentColor" d="M12 2.308c5.345 0 9.692 4.347 9.692 9.692S17.345 21.692 12 21.692 2.308 17.345 2.308 12 6.655 2.308 12 2.308ZM12 0C5.372 0 0 5.372 0 12s5.372 12 12 12 12-5.372 12-12S18.628 0 12 0Z" /><path fill="currentColor" d="M14.794 7.267a.854.854 0 0 1 .564-.247l.459-.01a.75.75 0 0 1 .554.223l.64.64a.782.782 0 0 1 .224.555l-.01.459a.818.818 0 0 1-.247.564L9.45 16.978a.854.854 0 0 1-.564.247l-.459.01a.75.75 0 0 1-.554-.223l-.64-.64a.782.782 0 0 1-.224-.555l.01-.459a.818.818 0 0 1 .247-.564l7.527-7.527Z" /><path fill="currentColor" d="M17.078 14.794c.154.154.234.36.24.571v.47a.802.802 0 0 1-.241.572l-.67.67a.837.837 0 0 1-.572.24h-.47a.8.8 0 0 1-.571-.239L7.267 9.552a.834.834 0 0 1-.24-.572l.001-.469c0-.217.086-.418.24-.572l.67-.67a.837.837 0 0 1 .573-.241h.469a.8.8 0 0 1 .572.24l7.526 7.526Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-export"><path fill="currentColor" d="m16.97 21.02-2.8-2.8-3.21 3.21V8H7.01v13.43L3.8 18.21 1 21.01 8.99 29l7.98-7.98Z" /><path fill="currentColor" fill-rule="evenodd" d="M14 7h2.89l1.22 1.63h2.94L22.27 7H31V4c0-.55-.45-1-1-1H12.99a1 1 0 0 0-1 .99L11.97 6v13.01l2.21-2.21 4.22 4.22h11.62c.55-.01 1-.46 1-1.01v-5h-8.65l-1.3 1.74h-2.94l-1.3-1.74h-2.81V7H14Z" clip-rule="evenodd" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-export2"><path fill="currentColor" d="m16 12-5.99 6 2.1 2.1 2.41-2.41V26h2.97v-8.31l2.41 2.42 2.1-2.1-6-6V12Z" /><path fill="currentColor" d="m26.32 7.4-6.75-5.91c-.36-.32-.83-.49-1.32-.49H5v30h22V8.91c0-.58-.25-1.13-.68-1.51Zm-3.69.1H18.5V3.88l4.13 3.62Zm1.87 21h-17v-25H16V10h8.5v18.5Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-eye"><path fill="currentColor" d="M16 12c2.21 0 4 1.79 4 4s-1.79 4-4 4-4-1.79-4-4 1.79-4 4-4Zm0-1.5c-3.04 0-5.5 2.46-5.5 5.5s2.46 5.5 5.5 5.5 5.5-2.46 5.5-5.5-2.46-5.5-5.5-5.5Z" /><path fill="currentColor" d="M16 7.75c8.43 0 12.12 6.23 13.09 8.25-.98 2.03-4.66 8.25-13.09 8.25S3.88 18.02 2.91 16C3.89 13.97 7.57 7.75 16 7.75ZM16 6C4.75 6 1 16 1 16s3.75 10 15 10 15-10 15-10S27.25 6 16 6Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-flag"><path fill="currentColor" d="M6.5 4H4v24h2.5V4Zm17.94 15.56 3.12-3.12c.28-.28.44-.66.44-1.06V4H9v16h14.38c.4 0 .78-.16 1.06-.44Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-folder"><path fill="currentColor" fill-rule="evenodd" d="m19 8-3.42-5.99A2.016 2.016 0 0 0 13.84 1H1v27.17c0 .53.21 1.04.59 1.41l.83.83c.38.38.88.59 1.41.59h24.34c.53 0 1.04-.21 1.41-.59l.83-.83c.38-.38.59-.88.59-1.41V8H19Zm-5.45-4.5L16.12 8H3.5V3.5h10.05ZM28.5 27.96l-.54.54H4.04l-.54-.54V10.5h25v17.46Z" clip-rule="evenodd" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-gun"><path fill="currentColor" d="M30 11.02h-7l-1.34-.8h-.35v-.8h-.48V7.69h-.66v1.73h-.65v.8h-5.51l-.5.49h-6.4l-.5-.49H4.82v2.08H1v1.19h3.82v.77h.55l.5-.5h1.18l.37.5h4.62l.36-.5h1.1l.96.94s-.07 3.71-.2 4.87c-.18 1.57-.48 2.88-.64 3.48l.26.47 2.49.78.64-.37c.14-.68.38-1.83.45-2.38.1-.74.25-3.28.25-3.28h3.05l1.84 3.35 2.22-.99.05-.15-2.47-3.62c-.15-.3-.24-.45-.27-.78l-.02-1.73.89-.03.23-.55h1.58l5.28 2.65H31v-4.39l-1-1v-.01Zm-9.68 6.31H17.9l-.17-.17v-1.59l.28-.28h1.89l.15.12.34 1.84-.06.07-.01.01Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-hamburger"><path fill="currentColor" d="M28 6H4v4h24V6Zm0 8H4v4h24v-4Zm0 8H4v4h24v-4Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-import"><path fill="currentColor" d="M8.99 3 1 10.99l2.8 2.8 3.21-3.22V24h3.95V10.57l3.21 3.21 2.8-2.8L8.99 3Z" /><path fill="currentColor" fill-rule="evenodd" d="M22.35 24.26 21.05 26h-2.94l-1.3-1.74H14v-8h2.89l1.22 1.63h2.94l1.22-1.63H31V12c0-.55-.45-1-1-1H18.38l-.71.69-3.51 3.51-2.21-2.21V26l.02 2.01c0 .55.45.99 1 .99h17.01c.55 0 1-.45 1-1v-3.74h-8.65.02Z" clip-rule="evenodd" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-importExport"><path fill="currentColor" d="M27 20v7H5v-7H1v7.59c0 .27.11.52.29.71l2.41 2.41c.19.19.44.29.71.29h23.17c.27 0 .52-.11.71-.29l2.41-2.41a.99.99 0 0 0 .29-.71V20h-4H27ZM11 3 5.01 9l2.1 2.1 2.41-2.41V17h2.97V8.69l2.41 2.42 2.1-2.1-6-6V3Z" /><path fill="currentColor" d="m21 22 5.99-6-2.1-2.1-2.41 2.41V8h-2.97v8.31l-2.41-2.42-2.1 2.1 6 6V22Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-infinity"><path fill="currentColor" d="M29.13 10.96c-2.72-2.72-7.14-2.74-9.89-.06l-8.28 8.28c-1.71 1.71-4.51 1.71-6.22 0s-1.71-4.51 0-6.22 4.51-1.71 6.22 0l1.63 1.61 1.85-1.85-1.62-1.62-.14-.14-.18-.16a7.042 7.042 0 0 0-9.63.3c-2.64 2.64-2.74 7.21 0 9.95 2.74 2.74 7.2 2.74 9.95 0l8.22-8.22c1.71-1.71 4.51-1.71 6.22 0s1.71 4.51 0 6.22-4.51 1.71-6.22 0l-1.69-1.67-1.85 1.85 1.68 1.68.14.14.18.16a7.042 7.042 0 0 0 9.63-.3c2.64-2.64 2.74-7.21 0-9.95Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-info"><g fill="currentColor" clip-path="url(#icon-info_a)"><path d="M16 3c7.17 0 13 5.83 13 13s-5.83 13-13 13S3 23.17 3 16 8.83 3 16 3Zm0-2.5C7.44.5.5 7.44.5 16c0 8.56 6.94 15.5 15.5 15.5 8.56 0 15.5-6.94 15.5-15.5C31.5 7.44 24.56.5 16 .5Z" /><path d="M14.5 7.46h3v3.49h-3V7.46Zm2.93 17.08h-2.86V12.2h2.86v12.34Z" /></g><defs><clipPath id="icon-info_a"><path fill="currentColor" d="M0 0h32v32H0z" /></clipPath></defs></symbol><symbol  viewBox="0 0 24 24" fill="none" id="icon-infoBlock"><path fill="currentColor" d="M4 22h16l2-2V4l-2-2H4L2 4v16l2 2Zm6.5-18h3v3h-3V4Zm0 5h3v11h-3V9Z" /></symbol><symbol  fill="none" viewBox="0 0 17 44" id="icon-internal-use-tooltip-arrow"><path fill="var(--tmln-colors-shade100)" d="m1.75 22 14.5-11.5v23L1.75 22Z" /><path stroke="var(--tmln-colors-primary)" d="M15.739 10.825 1.75 22l14 10.825" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-link-out"><path fill="currentColor" d="M25.5 17.5v5.96L23.96 25H8.03l-1.54-1.54V11.53l1.54-1.54h5.96v-2.5H7.4c-.27 0-.52.11-.71.29l-2.41 2.41a.99.99 0 0 0-.29.71v13.17c0 .27.11.52.29.71l2.41 2.41c.19.19.44.29.71.29h17.17c.27 0 .52-.11.71-.29l2.41-2.41a.99.99 0 0 0 .29-.71v-6.59h-2.5l.02.02Z" /><path fill="currentColor" d="M28.01 4.51h-8.48v2.97h3.41l-9.99 9.99 2.1 2.1 9.99-9.99v3.41h2.97V4.5v.01Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-link"><path fill="currentColor" d="M20.59 15H19v-2.5h1.5v-8h-9v8H13V15h-1.59c-.27 0-.52-.11-.71-.29L9.29 13.3a.99.99 0 0 1-.29-.71V4.41c0-.27.11-.52.29-.71l1.41-1.41a.99.99 0 0 1 .71-.29h9.17c.27 0 .52.11.71.29L22.7 3.7c.19.19.29.44.29.71v8.17c0 .27-.11.52-.29.71l-1.41 1.41a.99.99 0 0 1-.71.29l.01.01Zm-9.18 2H13v2.5h-1.5v8h9v-8H19V17h1.59c.27 0 .52.11.71.29l1.41 1.41c.19.19.29.44.29.71v8.17c0 .27-.11.52-.29.71L21.3 29.7a.99.99 0 0 1-.71.29h-9.17c-.27 0-.52-.11-.71-.29L9.3 28.29a.99.99 0 0 1-.29-.71v-8.17c0-.27.11-.52.29-.71l1.41-1.41a.99.99 0 0 1 .71-.29h-.01Z" /><path fill="currentColor" d="M15 21.5v-11h2v11h-2Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-locked"><path fill="currentColor" d="M26 12V3.83c0-.53-.21-1.04-.59-1.41l-.83-.83C24.2 1.21 23.7 1 23.17 1H8.83c-.53 0-1.04.21-1.41.59l-.83.83C6.21 2.8 6 3.3 6 3.83V12H3v16.17c0 .53.21 1.04.59 1.41l.83.83c.38.38.88.59 1.41.59h20.34c.53 0 1.04-.21 1.41-.59l.83-.83c.38-.38.59-.88.59-1.41V12h-3Zm-7 12h-6v-6h6v6Zm3-12H10V5h12v7Z" /></symbol><symbol  viewBox="0 0 80 32" fill="none" id="icon-logo"><path fill="currentColor" d="M12.93 2.23c.81.81 1.22 1.98 1.22 3.49v9.85c0 1.49-.41 2.64-1.22 3.47-.81.83-1.98 1.24-3.49 1.24H6.35v10.71H1.12V1h8.31c1.52 0 2.68.41 3.49 1.22l.01.01ZM8.92 15.4V5.89c0-.28-.14-.43-.43-.43H6.35v10.37h2.14c.28 0 .43-.14.43-.43Zm7.67-13.18C17.42 1.41 18.57 1 20.06 1h3.6c1.52 0 2.68.41 3.49 1.22s1.22 1.98 1.22 3.49v20.57c0 1.49-.41 2.64-1.22 3.47-.81.83-1.98 1.24-3.49 1.24h-3.6c-1.49 0-2.64-.41-3.47-1.24-.83-.83-1.24-1.98-1.24-3.47V5.72c0-1.52.41-2.68 1.24-3.49v-.01ZM21 26.54h1.71c.28 0 .43-.14.43-.43V5.88c0-.28-.14-.43-.43-.43H21c-.28 0-.43.14-.43.43v20.23c0 .28.14.43.43.43ZM41.67 2.23c.81.81 1.22 1.98 1.22 3.49v9.85c0 1.94-.67 3.3-2.01 4.07l2.01 11.35h-5.14l-1.46-10.71h-1.2v10.71h-5.23V1h8.31c1.52 0 2.68.41 3.49 1.22l.01.01Zm-4 13.17V5.89c0-.28-.14-.43-.43-.43H35.1v10.37h2.14c.28 0 .43-.14.43-.43Zm18.24-9.94h-3.43v25.53h-5.23V5.46h-3.43V1H55.9v4.46h.01ZM75.45 1v25.53h3.43v4.46h-8.65V1h5.23-.01Zm-11.7 30h5.23L65.77 1.01h-7.89L54.67 31h5.23l.35-4.46h3.15l.35 4.46Zm-3.15-8.92 1.22-15.47 1.22 15.47h-2.45.01Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-magnifying-glass"><g clip-path="url(#icon-magnifying-glass_a)"><path fill="currentColor" d="M31.71 28.88 20.92 18.09C22.23 16.22 23 13.95 23 11.5 23 5.15 17.85 0 11.5 0S0 5.15 0 11.5 5.15 23 11.5 23c2.45 0 4.72-.77 6.59-2.08l10.79 10.79c.19.19.44.29.71.29h.59c.27 0 .52-.11.71-.29l.83-.83a.99.99 0 0 0 .29-.71v-.59c0-.27-.11-.52-.29-.71l-.01.01ZM11.5 19C7.36 19 4 15.64 4 11.5 4 7.36 7.36 4 11.5 4c4.14 0 7.5 3.36 7.5 7.5 0 4.14-3.36 7.5-7.5 7.5Z" /></g><defs><clipPath id="icon-magnifying-glass_a"><path fill="currentColor" d="M0 0h32v32H0z" /></clipPath></defs></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-manage"><path fill="currentColor" fill-rule="evenodd" d="m19 8-3.42-5.99A2.016 2.016 0 0 0 13.84 1H1v27.17c0 .53.21 1.04.59 1.41l.83.83c.38.38.88.59 1.41.59h24.34c.53 0 1.04-.21 1.41-.59l.83-.83c.38-.38.59-.88.59-1.41V8H19Zm-5.45-4.5L16.12 8H3.5V3.5h10.05ZM28.5 27.96l-.54.54H4.04l-.54-.54V10.5h25v17.46Z" clip-rule="evenodd" /><path fill="currentColor" d="M21.23 20v-.98l1.19-1.12.08-.29-1.31-2.2-.3-.08-1.7.47-.75-.44-.42-1.65-.22-.21h-2.51l-.32.21-.42 1.64-.75.44-1.7-.47-.3.08-1.31 2.2.08.29 1.18 1.12v.98l-1.19 1.12-.08.29 1.31 2.2.3.08 1.66-.46.84.65.36 1.42.22.21h2.62l.22-.21.41-1.57.78-.5 1.68.47.3-.08 1.31-2.2-.08-.29L21.23 20Zm-2.26-.19L18 21.37l-.53.32h-1.93l-.53-.32-.97-1.56v-.62l.97-1.56.43-.32h2.14l.43.32.97 1.56v.62h-.01Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-map-pin"><path fill="currentColor" d="M22.89 5.95A9.686 9.686 0 0 0 16 3.09c-2.69 0-5.13 1.09-6.89 2.86a9.686 9.686 0 0 0-2.86 6.89v.03c0 1.31.26 2.56.74 3.7l.26.57c.25.47.53.92.81 1.37.3.45.61.89.94 1.31l6.99 9.07v.03h.02v-.03L23 19.82c.33-.42.64-.86.94-1.31.28-.45.56-.9.81-1.37l.26-.57c.48-1.14.74-2.39.74-3.7v-.03c0-2.69-1.09-5.13-2.86-6.89Zm-3.45 9.88c-.44.44-.94.77-1.47 1-.63.28-1.3.42-1.97.42-.67 0-1.34-.14-1.97-.42-.53-.23-1.03-.56-1.47-1-1.89-1.9-1.89-4.99 0-6.88.44-.44.94-.77 1.47-1 .63-.28 1.3-.42 1.97-.42.67 0 1.34.14 1.97.42.53.23 1.03.56 1.47 1 1.89 1.89 1.89 4.98 0 6.88Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-minus"><path fill="currentColor" d="M22.59 14c.27 0 .52.11.71.29l.41.41c.19.19.29.44.29.71v1.17c0 .27-.11.52-.29.71l-.41.41a.99.99 0 0 1-.71.29H9.42c-.27 0-.52-.11-.71-.29l-.41-.41a.99.99 0 0 1-.29-.71v-1.17c0-.27.11-.52.29-.71l.41-.41a.99.99 0 0 1 .71-.29h13.17Z" /><path fill="currentColor" d="M16 5.5c5.79 0 10.5 4.71 10.5 10.5S21.79 26.5 16 26.5 5.5 21.79 5.5 16 10.21 5.5 16 5.5ZM16 3C8.82 3 3 8.82 3 16s5.82 13 13 13 13-5.82 13-13S23.18 3 16 3Z" /></symbol><symbol  viewBox="0 0 16 16" fill="none" id="icon-minus2"><path fill="currentColor" d="m15 6.5.5.5v2l-.5.5H1L.5 9V7l.5-.5h14Z" /></symbol><symbol  viewBox="0 0 128 128" id="icon-mode-battle_royale-framed"><g fill="currentColor"><path d="M64.07 31.17c-10.92 0-19.78 8.85-19.78 19.78 0 10.92 8.85 19.78 19.78 19.78 10.92 0 19.78-8.85 19.78-19.78S75 31.17 64.07 31.17Zm10.26 26.32H54.41l-4.27-11.07 8.54 3.69 5.69-11.07 5.69 11.07 8.54-3.69-4.27 11.07ZM35.55 34.2l11.69-11.69V34.2H35.55zM92.51 34.2 80.82 22.51V34.2h11.69zM35.49 67.8l11.69 11.69V67.8H35.49zM92.45 67.8 80.76 79.49V67.8h11.69z" /></g><g fill="currentColor"><path d="M104 8.43v80.26l-40 30.37-40-30.37V8.43h80m2-2H22v83.25l42 31.89 42-31.89V6.43Z" /><path d="M98.29 14v71.94L64 111.5 29.71 85.94V14h68.58m2-2H27.71v74.95L64 114l36.29-27.05V12Z" /></g></symbol><symbol  viewBox="0 0 128 128" id="icon-mode-battle_royale"><path d="M64.14 24.35c-21.84 0-39.54 17.7-39.54 39.54s17.7 39.54 39.54 39.54 39.54-17.7 39.54-39.54-17.7-39.54-39.54-39.54Zm20.51 52.63H44.82l-8.53-22.13 17.07 7.38L64.74 40.1l11.38 22.13 17.07-7.38-8.53 22.13ZM7.11 30.41 30.48 7.04v23.37H7.11zM121 30.41 97.63 7.04v23.37H121zM7 97.59l23.37 23.37V97.59H7zM120.89 97.59l-23.37 23.37V97.59h23.37z" fill="currentColor" /></symbol><symbol  viewBox="0 0 128 128" id="icon-mode-breakthrough-framed"><g fill="currentColor"><path d="M56.21 40.42v40.07L39.98 63.88V40.42h16.23zM71.79 40.42v40.07l16.23-16.61V40.42H71.79z" /><path d="m73.08 34.48-7.95-3.09v-5.11l1.14-1.26v-1.01h-4.55v1.01l1.14 1.26v5.11l-7.95 3.09v2.01h5.68v48.09L64 88l3.41-3.42V36.49h5.68v-2.01Z" /></g><path d="M102 12.14v73.85l-38 28.85-38-28.85V12.14h76m4-4H22v79.83l42 31.89 42-31.89V8.14Z" fill="currentColor" /></symbol><symbol  viewBox="0 0 128 128" id="icon-mode-breakthrough"><path fill="currentColor" d="M50.13 36.25v71.36L21.21 78.04V36.25h28.92zM77.87 36.25v71.36l28.92-29.57V36.25H77.87z" /><path d="m80.18 25.66-14.16-5.51v-9.11l2.03-2.24V6.99h-8.1V8.8l2.03 2.24v9.11l-14.16 5.51v3.58h10.11v85.66L64 121l6.07-6.1V29.24h10.11v-3.58Z" fill="currentColor" /></symbol><symbol  viewBox="0 0 128 128" id="icon-mode-conquest-framed"><path d="m66.33 71.2 13.92 13.76 2.04-1.89-13.98-13.83-1.98 1.96ZM45.58 83.11 47.62 85l31.51-31.15v4.01l-2.53 2.5v12.21l12.13-11.99v-4.23l2.53-2.5v-15.9L45.57 83.11Zm5.82-10.55V60.35l-2.53-2.5v-4.01L59.1 63.95l1.98-1.96-24.34-24.05v15.9l2.53 2.5v4.23L51.4 72.56Zm27.24-30.92L63.98 27 49.36 41.64l14.62 14.64 14.66-14.64Zm-14.66-9.79 9.9 9.78-9.9 9.98V31.85Z" fill="currentColor" /><path d="M102 15.44v83.01c-6.99 8.74-21.39 14.12-38 14.12s-30.99-5.38-38-14.12V15.44h76m4-4H22v88.35c8.03 11.19 25.02 16.77 42 16.77s33.99-5.6 42-16.77V11.44Z" fill="currentColor" /></symbol><symbol  viewBox="0 0 128 128" id="icon-mode-conquest"><path d="m68.58 93.88 27.35 27.06 4.01-3.72-27.48-27.18-3.89 3.84Zm-40.79 23.4L31.8 121l61.94-61.23v7.88l-4.97 4.91v24L112.62 73v-8.31l4.97-4.91V28.53l-89.8 88.75Zm11.44-20.72v-24l-4.97-4.91v-7.88l20.12 19.88 3.89-3.84-47.85-47.29V59.78l4.97 4.91V73l23.85 23.56Zm53.54-60.79L63.96 7 35.22 35.77l28.74 28.77 28.81-28.77ZM63.96 16.54l19.46 19.23-19.46 19.62V16.54Z" fill="currentColor" /></symbol><symbol  viewBox="0 0 128 128" id="icon-mode-gauntlet-framed"><g fill="currentColor"><path d="M42.29 27.47v36.19h7.24V56.4h7.24v-7.24h14.48v7.24h7.24v7.24h7.24V27.47H42.3Zm25.84 17.26L64 41.9l-4.13 2.83 1.42-4.8-3.97-3.05 5-.13 1.67-4.72 1.67 4.72 5 .13-3.97 3.05 1.42 4.8ZM42.28 70.91h43.44v3.62H42.28z" /></g><g fill="currentColor"><path d="M104 8.43v80.26l-40 30.37-40-30.37V8.43h80m2-2H22v83.25l42 31.89 42-31.89V6.43Z" /><path d="M98.29 14v71.94L64 111.5 29.71 85.94V14h68.58m2-2H27.71v74.95L64 114l36.29-27.05V12Z" /></g></symbol><symbol  viewBox="0 0 128 128" id="icon-mode-gauntlet"><path d="M17.88 14v76.9h15.38V75.48h15.38V60.1H79.4v15.38h15.38v15.38h15.38V14H17.88Zm54.9 36.69-8.77-6.02-8.77 6.02 3.01-10.2-8.43-6.48 10.63-.28 3.56-10.02 3.56 10.02 10.63.28-8.43 6.48 3.01 10.2ZM17.85 106.31h92.3V114h-92.3z" fill="currentColor" /></symbol><symbol  viewBox="0 0 128 128" id="icon-mode-rush-framed"><g fill="currentColor"><path d="M50.03 56c0 3.84 2.22 7.16 5.44 8.76V47.24c-3.22 1.6-5.44 4.92-5.44 8.76ZM77.97 56c0 3.84-2.22 7.16-5.44 8.76V47.24c3.22 1.6 5.44 4.92 5.44 8.76ZM73.08 34.48l-7.95-3.09v-5.11l1.14-1.26v-1.01h-4.55v1.01l1.14 1.26v5.11l-7.95 3.09v2.01h5.68v48.09L64 88l3.41-3.42V36.49h5.68v-2.01Z" /><path d="M50.84 69.78c-3.43-3.39-5.56-8.1-5.56-13.3s2.1-9.81 5.47-13.2l-4.93-4.93c-4.64 4.64-7.5 11.05-7.5 18.13s2.91 13.57 7.59 18.22l4.92-4.92ZM82.19 38.37l-4.93 4.93c3.37 3.39 5.46 8.04 5.46 13.19s-2.12 9.89-5.55 13.28l4.92 4.92c4.68-4.65 7.58-11.09 7.58-18.21S86.81 43 82.18 38.36Z" /></g><path d="M102 12.14v73.85l-38 28.85-38-28.85V12.14h76m4-4H22v79.83l42 31.89 42-31.89V8.14Z" fill="currentColor" /></symbol><symbol  viewBox="0 0 128 128" id="icon-mode-rush"><path d="M39.11 64c0 6.84 3.95 12.76 9.69 15.61V48.4c-5.74 2.85-9.69 8.76-9.69 15.61ZM88.89 64c0 6.84-3.95 12.76-9.69 15.61V48.4c5.74 2.85 9.69 8.76 9.69 15.61ZM80.18 25.66l-14.16-5.51v-9.11l2.03-2.24V6.99h-8.1V8.8l2.03 2.24v9.11l-14.16 5.51v3.58h10.11v85.66L64 121l6.07-6.1V29.24h10.11v-3.58Z" fill="currentColor" /><path d="M40.55 88.54c-6.11-6.05-9.9-14.43-9.9-23.68s3.74-17.48 9.75-23.51l-8.78-8.78c-8.26 8.27-13.37 19.68-13.37 32.3s5.18 24.17 13.53 32.45l8.77-8.77ZM96.4 32.59l-8.78 8.78c6 6.03 9.73 14.33 9.73 23.49s-3.78 17.61-9.88 23.66l8.77 8.77c8.34-8.28 13.51-19.75 13.51-32.43s-5.1-24-13.34-32.27Z" fill="currentColor" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-no-xp"><path fill="currentColor" d="m20.99 9.01-2.98 2.98v4l2.62-2.62v-1.74h1.74l2.62-2.62h-4Zm-1.76 0h-1.22v1.22l1.22-1.22Zm7.88.58a2.08 2.08 0 0 0-.55-.38l-2.42 2.42h.88c.13 0 .26.05.35.15l.37.36c.09.09.15.22.15.35v1.12h-.01c0 .12-.05.25-.15.34l-1.02 1.03c-.09.08-.21.14-.33.14h-3.73l-2.64 2.64V23h2.62v-5.26h3.88c.46 0 .91-.18 1.24-.51l2.28-2.28c.31-.3.48-.72.48-1.16v-2.28c0-.35-.14-.68-.39-.92l-1.01-1.01v.01ZM7 23h1.04l1.41-2.45L7 23Zm6.18-6.18-1.86 1.86 1.44 2.56 1.9-1.9-1.48-2.52ZM5.23 23l7.5-7.49 4.09-6.5h-3.06l-2.85 4.52-2.84-4.52H5.01l4.26 6.76L5.01 23h.22Zm8.17-.63.36.63h3.06l-1.5-2.55-1.92 1.92Z" /><path fill="currentColor" fill-rule="evenodd" d="M27.59 1H4.41c-.27 0-.52.11-.71.29L1.29 3.71a.99.99 0 0 0-.29.71v23.17c0 .27.11.52.29.71l2.41 2.41c.19.19.44.29.71.29h23.17c.27 0 .52-.11.71-.29l2.41-2.41a.99.99 0 0 0 .29-.71V4.41c0-.27-.11-.52-.29-.71l-2.41-2.41a.99.99 0 0 0-.71-.29h.01ZM29 27l-2 2H5l-2-2V5l2-2h22l2 2v22Z" clip-rule="evenodd" /><path fill="currentColor" d="m27 3.003-24 24 2.002 2 24-23.999-2.002-2Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-pencil"><path fill="currentColor" d="m28.86 10.29-7.14-7.14 1.85-1.85c.19-.19.45-.3.71-.3h3.45a1 1 0 0 1 .71.3l2.27 2.27c.19.19.3.45.3.71v3.45a1 1 0 0 1-.3.71l-1.85 1.85Zm-8.57-2.18 3.61 3.61L7.11 28.5H3.5v-3.61L20.29 8.11Zm0-3.54L1 23.86V31h7.14l19.29-19.29-7.14-7.14Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-pencil2"><path fill="currentColor" d="M23.39 5 27 8.61 7.11 28.5H3.5v-3.61L23.39 5Zm0-3.53L1 23.86V31h7.14L30.53 8.61l-7.14-7.14Z" /><path fill="currentColor" d="M4.08 27.92h2.83l-2.83-2.83" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-player"><path fill="currentColor" d="M18 11h-4l-1-1V6l1-1h4l1 1v4l-1 1Zm-7 12v-8.59c0-.27.11-.52.29-.71l.41-.41a.99.99 0 0 1 .71-.29h7.17c.27 0 .52.11.71.29l.41.41c.19.19.29.44.29.71V23h-2v4h-6v-4h-2H11Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-players"><path fill="currentColor" d="M18 11h-4l-1-1V6l1-1h4l1 1v4l-1 1Zm-7 12v-8.59c0-.27.11-.52.29-.71l.41-.41a.99.99 0 0 1 .71-.29h7.17c.27 0 .52.11.71.29l.41.41c.19.19.29.44.29.71V23h-2v4h-6v-4h-2H11Zm15-11h-4l-1-1V7l1-1h4l1 1v4l-1 1Zm-5 15v-2h2V14h4.59c.27 0 .52.11.71.29l.41.41c.19.19.29.44.29.71V24h-2v3h-6ZM5 11V7l1-1h4l1 1v4l-1 1H6l-1-1Zm0 16v-3H3v-8.59c0-.27.11-.52.29-.71l.41-.41a.99.99 0 0 1 .71-.29H9v11h2v2H5Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-plus"><path fill="currentColor" d="M18 9.41V14h4.59c.27 0 .52.11.71.29l.41.41c.19.19.29.44.29.71v1.17c0 .27-.11.52-.29.71l-.41.41a.99.99 0 0 1-.71.29H18v4.59c0 .27-.11.52-.29.71l-.41.41a.99.99 0 0 1-.71.29h-1.17c-.27 0-.52-.11-.71-.29l-.41-.41a.99.99 0 0 1-.29-.71v-4.59H9.42c-.27 0-.52-.11-.71-.29l-.41-.41a.99.99 0 0 1-.29-.71v-1.17c0-.27.11-.52.29-.71l.41-.41a.99.99 0 0 1 .71-.29h4.59V9.41c0-.27.11-.52.29-.71l.41-.41a.99.99 0 0 1 .71-.29h1.17c.27 0 .52.11.71.29l.41.41c.19.19.29.44.29.71Z" /><path fill="currentColor" d="M16 5.5c5.79 0 10.5 4.71 10.5 10.5S21.79 26.5 16 26.5 5.5 21.79 5.5 16 10.21 5.5 16 5.5ZM16 3C8.82 3 3 8.82 3 16s5.82 13 13 13 13-5.82 13-13S23.18 3 16 3Z" /></symbol><symbol  viewBox="0 0 16 16" fill="none" id="icon-plus2"><path fill="currentColor" d="M9.5 1v5.5H15l.5.5v2l-.5.5H9.5V15l-.5.5H7l-.5-.5V9.5H1L.5 9V7l.5-.5h5.5V1L7 .5h2l.5.5Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-price-tag"><path fill="currentColor" d="M2.87 4.17 6.7 8.04l1.35-1.35-4.33-4.37-.77-.73L1.6 2.94l1.27 1.23Z" /><path fill="currentColor" d="M30.4 16.55 16.54 2.65l-11.35.1L7.64 5.2h3.4v5.85H5.19V7.6l-2.4-2.4-.1 11.3 13.85 13.9h2.2l11.65-11.7v-2.15h.01Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-question-mark"><g fill="currentColor" clip-path="url(#icon-question-mark_a)"><path d="M16 3c7.17 0 13 5.83 13 13s-5.83 13-13 13S3 23.17 3 16 8.83 3 16 3Zm0-2.5C7.44.5.5 7.44.5 16c0 8.56 6.94 15.5 15.5 15.5 8.56 0 15.5-6.94 15.5-15.5C31.5 7.44 24.56.5 16 .5Z" /><path d="M14.98 16.03c.35-.56.76-1 1.23-1.33.47-.33 1.08-.68 1.82-1.05.66-.35 1.14-.64 1.43-.86.3-.23.45-.49.45-.8v-1.33c0-.23-.07-.41-.22-.56a.769.769 0 0 0-.56-.22h-5.8c-.35 0-.65.13-.89.39-.25.26-.37.56-.37.91v.92H8.99v-.92c0-.78.2-1.51.59-2.19.39-.68.92-1.21 1.59-1.6.67-.39 1.39-.59 2.17-.59h5.8c1.07 0 1.98.38 2.73 1.13.75.75 1.13 1.66 1.13 2.73v1.33c0 .68-.11 1.24-.34 1.68-.23.44-.52.81-.89 1.09-.37.29-.88.64-1.54 1.05-.88.51-1.6 1.01-2.16 1.48-.14.12-.27.24-.37.35a.56.56 0 0 0-.15.39v2.25h-3.08v-2.25c0-.78.17-1.45.52-2h-.01Zm2.56 6.07v3.08h-3.08V22.1h3.08Z" /></g><defs><clipPath id="icon-question-mark_a"><path fill="currentColor" d="M0 0h32v32H0z" /></clipPath></defs></symbol><symbol  viewBox="0 0 24 24" fill="none" id="icon-recon"><g fill="CurrentColor" clip-path="url(#icon-recon_a)"><path d="M.058 2.211 3.142-.872a.2.2 0 0 1 .141-.058H9.4c.11 0 .2.09.2.2v4.4a.2.2 0 0 1-.2.2H5.2a.4.4 0 0 0-.4.4v4.2a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V2.353a.2.2 0 0 1 .058-.142Zm20.8-3.083 3.084 3.083a.2.2 0 0 1 .058.142V8.47a.2.2 0 0 1-.2.2h-4.4a.2.2 0 0 1-.2-.2v-4.2a.4.4 0 0 0-.4-.4h-4.2a.2.2 0 0 1-.2-.2v-4.4c0-.11.09-.2.2-.2h6.117a.2.2 0 0 1 .141.058ZM3.142 23.011.058 19.928A.2.2 0 0 1 0 19.787V13.67c0-.11.09-.2.2-.2h4.4c.11 0 .2.09.2.2v4.2c0 .22.18.4.4.4h4.2c.11 0 .2.09.2.2v4.4a.2.2 0 0 1-.2.2H3.283a.2.2 0 0 1-.141-.059Zm17.716 0 3.084-3.083a.2.2 0 0 0 .058-.141V13.67a.2.2 0 0 0-.2-.2h-4.4a.2.2 0 0 0-.2.2v4.2a.4.4 0 0 1-.4.4h-4.2a.2.2 0 0 0-.2.2v4.4c0 .11.09.2.2.2h6.117a.2.2 0 0 0 .141-.059Z" /></g><defs><clipPath id="icon-recon_a"><path fill="CurrentColor" d="M0-.93h24v24H0z" /></clipPath></defs></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-reset"><path fill="currentColor" d="m19.4 21.51-2.41 2.41V22.5C16.72 18.32 13.24 15 9 15s-8 3.59-8 8 3.59 8 8 8v-3c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5l.02.92-2.41-2.42-2.1 2.1 6 6 5.99-6-2.1-2.1v.01Z" /><path fill="currentColor" fill-rule="evenodd" d="m16.89 7 1.22 1.63h2.94L22.27 7H31V4c0-.55-.45-1-1-1H12.99a1 1 0 0 0-1 .99v10.53a9.017 9.017 0 0 1 5.77 6.49h.71l.92-.92.92.92h9.68c.55-.01 1-.46 1-1.01v-5h-8.65l-1.3 1.74H18.1L16.8 15h-2.81V7h2.9Z" clip-rule="evenodd" /></symbol><symbol  viewBox="0 0 28 28" id="icon-rush"><path d="M14 3.6 2.9 0v17.2c0 5.2 5.2 8.9 8.5 10.8l1-.5v-2.8c-1.7-.3-3.4-1.1-4.7-2.5L20.3 9.5c3.5 3.5 3.5 9.1 0 12.6-1.4 1.4-3.1 2.2-4.8 2.5v2.8l1 .5c3.3-1.8 8.6-5.6 8.6-10.8V-.1L14 3.6zm0 9.9h-.1c-.6 0-1.2.2-1.6.7-.4.4-.7 1-.7 1.6v.1l-.7.7c-.3-1.1 0-2.3.8-3.1.6-.6 1.4-.9 2.2-.9.3 0 .6 0 .9.1l-.8.8zm2.3-2.2c-.7-.4-1.6-.6-2.4-.6-1.4 0-2.7.5-3.6 1.5-1 1-1.5 2.3-1.5 3.6 0 .9.2 1.7.6 2.4l-.6.6c-1.4-2.3-1-5.3.9-7.3 1.2-1.2 2.7-1.8 4.2-1.8 1.1 0 2.1.3 3 .8l-.6.8zm2.1-2.1c-1.3-.8-2.8-1.3-4.4-1.3-2.2 0-4.2.8-5.7 2.4-1.5 1.5-2.4 3.5-2.4 5.7 0 1.6.5 3.1 1.3 4.4l-.6.6c-2.4-3.5-2-8.2 1.1-11.3C9.4 7.9 11.7 7 14 7c1.7 0 3.5.5 5 1.5l-.6.7z" fill="currentColor" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-save"><path fill="currentColor" d="M25 1v8H7V1H5L2 4v24l3 3h22l3-3V6l-5-5Zm2 25-2 2H7l-2-2V14l2-2h18l2 2v12Z" /><path fill="currentColor" d="M23 1H9v6.5h14V1Zm-9 5.45h-2.73V2.36H14v4.09ZM8 13.5 6.5 15v10L8 26.5h16l1.5-1.5V15L24 13.5H8Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-settings"><path fill="currentColor" d="M15.458 23.151H29v3.6H15.459L15.458 29H6.634v-2.249H3v-3.6h3.634v-2.289h8.824v2.29Zm-6.11 3.6h3.31v-3.6h-3.31v3.6Zm15.86-12.399H29v3.601h-3.792v2.248h-8.824v-2.248H3v-3.6h13.384v-2.289h8.824v2.288Zm-6.11 3.601h3.31v-3.6h-3.31v3.6ZM15.459 5.29H29v3.6H15.459l-.001 2.249H6.634v-2.25H3V5.29h3.634V3h8.824v2.29Zm-6.11 3.6h3.31v-3.6h-3.31v3.6Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-share"><path fill="currentColor" d="M27.48 5.32 18.99 27.7h-1.37l-4.12-8.65-1.31-1.31-8.88-4.37V12l22.37-8.48 1.8 1.8Zm2.25-.98-3.07-3.07a.916.916 0 0 0-.98-.21l-24.1 9.13c-.35.13-.59.47-.58.85l.02 2.88c0 .24.1.48.27.65l9.62 4.46 1.31 1.31 4.21 9.36c.17.17.41.27.65.27l2.88.02c.38 0 .72-.23.85-.58l9.13-24.09c.13-.34.04-.72-.21-.98Z" /><path fill="currentColor" d="M26.37 3.576 11.55 18.397l1.307 1.308 14.821-14.82-1.308-1.309Z" /></symbol><symbol  viewBox="0 0 24 24" fill="none" id="icon-skull"><path fill="currentColor" d="m19.224 10.103.91 3.628.849-5.895c.045-.287 0-.59-.137-.862l-1.455-2.902a1.545 1.545 0 0 0-.424-.514l-2.38-1.95a1.794 1.794 0 0 0-1.123-.408H8.536c-.41 0-.804.136-1.122.408l-2.38 1.95a1.384 1.384 0 0 0-.425.514L3.154 6.974c-.137.272-.182.56-.137.862l.85 5.895.909-3.628v3.628l-1.562 2.343a.685.685 0 0 0 0 .755l1.274 1.905a.982.982 0 0 0 .818.438h2.199l.788 2.343a.739.739 0 0 0 .5.469l3.245.816 3.244-.816a.71.71 0 0 0 .5-.469l.79-2.343h2.197a.981.981 0 0 0 .82-.438l1.273-1.905a.685.685 0 0 0 0-.755L19.3 13.73v-3.628h-.076Zm-13.463 5.32V13.46l.773-.771 2.85.468c.167.03.289.136.365.287l.545 1.27a.488.488 0 0 1-.106.53l-1.137 1.133c-.121.12-.288.166-.455.12l-2.486-.619a.486.486 0 0 1-.364-.468l.015.015Zm6.216 3.477-1.197-.604c-.182-.091-.258-.333-.137-.5l1.334-1.994 1.334 1.995a.331.331 0 0 1-.136.499l-1.198.604Zm5.852-3.008-2.486.62a.46.46 0 0 1-.455-.12l-1.137-1.135a.488.488 0 0 1-.106-.529l.546-1.27a.476.476 0 0 1 .364-.287l2.85-.468.773.77v1.966a.5.5 0 0 1-.364.468l.015-.015Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-speech-bubble"><path fill="currentColor" d="m29.41 7.41-.83-.83c-.38-.38-.88-.59-1.41-.59H2v13.17c0 .53.21 1.04.59 1.41l.83.83c.38.38.88.59 1.41.59H8v6l6-6h13.17c.53 0 1.04-.21 1.41-.59l.83-.83c.38-.38.59-.88.59-1.59V8.64c0-.36-.21-.87-.59-1.24v.01ZM10 16H6v-4h4v4Zm8 0h-4v-4h4v4Zm8 0h-4v-4h4v4Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-summary"><path fill="currentColor" d="m26.32 7.4-6.75-5.91c-.36-.32-.83-.49-1.32-.49H5v30h22V8.91c0-.58-.25-1.13-.68-1.51Zm-3.69.1H18.5V3.88l4.13 3.62Zm1.87 21h-17v-25H16V10h8.5v18.5Z" /><path fill="currentColor" d="M23 13H9v2h14v-2Zm0 5H9v2h14v-2Zm0 5H9v2h14v-2Z" /></symbol><symbol  viewBox="0 0 24 24" fill="none" id="icon-support"><path fill="currentColor" d="m15.117 4.987 2.966 2.966a.403.403 0 0 0 .283.117H23.8c.11 0 .2.09.2.2v5.6a.2.2 0 0 1-.2.2h-5.889a.2.2 0 0 1-.141-.059l-8.711-8.71A.2.2 0 0 1 9 5.158v-5.89c0-.11.09-.2.2-.2h5.6c.11 0 .2.09.2.2v5.435a.4.4 0 0 0 .116.283ZM8.882 17.152l-2.965-2.965a.401.401 0 0 0-.283-.117H.2a.2.2 0 0 1-.2-.2v-5.6c0-.11.09-.2.2-.2h5.888c.053 0 .104.02.141.058l8.711 8.711a.2.2 0 0 1 .059.142v5.889a.2.2 0 0 1-.2.2h-5.6a.2.2 0 0 1-.2-.2v-5.435a.4.4 0 0 0-.117-.283Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-thumbs-up"><path fill="currentColor" d="M31 13c0-1.65-1.35-3-3-3h-3.5V6.33c0-.61-.19-1.22-.55-1.73l-1.47-2.29-.04-.06-.04-.06c-.56-.75-1.46-1.2-2.4-1.2h-1c-1.65 0-3 1.35-3 3v3.17l-4.83 4.83H1v19h6c.88 0 1.67-.39 2.22-1h1.95l.12.12c.57.57 1.32.88 2.12.88H26c1.65 0 3-1.35 3-3v-1c0-.15-.01-.31-.03-.45.64-.56 1.03-1.38 1.03-2.27v-1.28c0-.15-.01-.31-.03-.45.64-.56 1.03-1.38 1.03-2.27v-2.28c0-.47-.11-.91-.3-1.31.19-.4.3-.85.3-1.31v-2.38.01ZM7 29H3V14h5v14c0 .55-.45 1-1 1Zm22-13.62c0 .38-.21.73-.55.89l-1.45.72h1c.55 0 1 .45 1 1v2.28c0 .43-.28.81-.68.95l-2.32.77h1c.55 0 1 .45 1 1v1.28c0 .43-.28.81-.68.95l-2.32.77h1c.55 0 1 .45 1 1v1c0 .55-.45 1-1 1H13.41c-.27 0-.52-.11-.71-.29l-.41-.41a.99.99 0 0 0-.71-.29H9.99V14h1.59c.27 0 .52-.11.71-.29L17.7 8.3a.99.99 0 0 0 .29-.71V4c0-.55.45-1 1-1h1c.31 0 .61.15.8.4l1.5 2.33c.13.17.2.38.2.6V11l-1 1h6.5c.55 0 1 .45 1 1v2.38H29Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-trash"><path fill="currentColor" d="M14 11h-2v15h2V11Zm6 0h-2v15h2V11Z" /><path fill="currentColor" d="M30 6h-9V2.41c0-.27-.11-.52-.29-.71l-.41-.41a.99.99 0 0 0-.71-.29h-7.17c-.27 0-.52.11-.71.29l-.41.41a.99.99 0 0 0-.29.71V6H2v2.5h3v20.09c0 .27.11.52.29.71l1.41 1.41c.19.19.44.29.71.29h17.17c.27 0 .52-.11.71-.29l1.41-1.41a.99.99 0 0 0 .29-.71V8.5h3V6H30ZM13.5 3.5h5V6h-5V3.5Zm11 25h-17v-20h17v20Z" /></symbol><symbol  viewBox="0 0 17 17" fill="none" id="icon-triangle"><path fill="currentColor" fill-rule="evenodd" d="m8.5 0-8 12h16l-8-12Zm0 4.665L5.21 9.6h6.58L8.5 4.665Z" clip-rule="evenodd" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-unlink"><path fill="currentColor" d="M20.59 15H19v-2.5h1.5v-8h-9v8H13V15h-1.59c-.27 0-.52-.11-.71-.29L9.29 13.3a.99.99 0 0 1-.29-.71V4.41c0-.27.11-.52.29-.71l1.41-1.41a.99.99 0 0 1 .71-.29h9.17c.27 0 .52.11.71.29L22.7 3.7c.19.19.29.44.29.71v8.17c0 .27-.11.52-.29.71l-1.41 1.41a.99.99 0 0 1-.71.29l.01.01Zm-9.18 2H13v2.5h-1.5v8h9v-8H19V17h1.59c.27 0 .52.11.71.29l1.41 1.41c.19.19.29.44.29.71v8.17c0 .27-.11.52-.29.71L21.3 29.7a.99.99 0 0 1-.71.29h-9.17c-.27 0-.52-.11-.71-.29L9.3 28.29a.99.99 0 0 1-.29-.71v-8.17c0-.27.11-.52.29-.71l1.41-1.41a.99.99 0 0 1 .71-.29h-.01Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-upload"><path fill="currentColor" d="M15.99 1 8.01 8.98l2.8 2.8 3.2-3.21v12.86h3.96V8.57l3.21 3.22 2.8-2.8L15.99 1Z" /><path fill="currentColor" d="M27 20v7H5v-7H1v7.59c0 .27.11.52.29.71l2.41 2.41c.19.19.44.29.71.29h23.17c.27 0 .52-.11.71-.29l2.41-2.41a.99.99 0 0 0 .29-.71V20h-4H27Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-upload2"><path fill="currentColor" d="M29.71 8.71 28.3 7.3a.99.99 0 0 0-.71-.29H24v2.5h3.5v11.5h-23V9.51H8v-2.5H4.41c-.27 0-.52.11-.71.29L2.29 8.71a.99.99 0 0 0-.29.71v13.17c0 .27.11.52.29.71l1.41 1.41c.19.19.44.29.71.29H14v2H9v2h14v-2h-5v-2h9.59c.27 0 .52-.11.71-.29l1.41-1.41a.99.99 0 0 0 .29-.71V9.42c0-.27-.11-.52-.29-.71Z" /><path fill="currentColor" d="m16 3-5.99 6 2.1 2.1 2.41-2.41V17h2.97V8.69l2.41 2.42 2.1-2.1-6-6V3Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-vertical-dots"><path fill="currentColor" d="M16 10c1.65 0 3-1.35 3-3s-1.35-3-3-3-3 1.35-3 3 1.35 3 3 3Zm0 3c-1.65 0-3 1.35-3 3s1.35 3 3 3 3-1.35 3-3-1.35-3-3-3Zm0 9c-1.65 0-3 1.35-3 3s1.35 3 3 3 3-1.35 3-3-1.35-3-3-3Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-warning-circle"><g fill="currentColor" clip-path="url(#icon-warning-circle_a)"><path d="M16 3c7.17 0 13 5.83 13 13s-5.83 13-13 13S3 23.17 3 16 8.83 3 16 3Zm0-2.5C7.44.5.5 7.44.5 16c0 8.56 6.94 15.5 15.5 15.5 8.56 0 15.5-6.94 15.5-15.5C31.5 7.44 24.56.5 16 .5Z" /><path d="M14.46 6.81h3.07V19.9h-3.07V6.81Zm3.08 15.3v3.07h-3.07v-3.07h3.07Z" /></g><defs><clipPath id="icon-warning-circle_a"><path fill="currentColor" d="M0 0h32v32H0z" /></clipPath></defs></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-warning-diamond"><g fill="currentColor" clip-path="url(#icon-warning-diamond_a)"><path d="M16 3.08 28.92 16 16 28.92 3.08 16 16 3.08Zm0-2.83L.25 16 16 31.75 31.75 16 16 .25Z" /><path d="M17.5 24.3h-3v-3h3v3ZM14.57 8.27h2.86v10.65h-2.86V8.27Z" /></g><defs><clipPath id="icon-warning-diamond_a"><path fill="currentColor" d="M0 0h32v32H0z" /></clipPath></defs></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-warning"><path fill="currentColor" d="m17.38 3.5 10.64 23.95-1.05 1.05H5.04l-1.05-1.05L14.62 3.5h2.75m.98-2.5h-4.7c-.4 0-.75.23-.91.59L1.28 27.37c-.17.38-.09.82.21 1.11l2.22 2.22c.19.19.44.29.71.29h23.17c.27 0 .52-.11.71-.29l2.22-2.22c.29-.29.37-.74.21-1.11L19.26 1.59a.998.998 0 0 0-.91-.59Z" /><path fill="currentColor" d="M14.46 8h3.07v13.09h-3.07V8Zm3.08 15.3v3.07h-3.07V23.3h3.07Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-wrench-hammer"><path fill="currentColor" d="m19.07 6.57 2.12 2.12L5.25 24.63l2.12 2.12 15.84-15.84 2.83 2.83 3.54-3.54-3.39-3.3-.75-.75-4.68-1.28-1.69 1.69v.01Z" /><path fill="currentColor" d="m24.84 28.37.71-.7-2.83-2.83 1.41-1.42.71-.7 2.83 2.83.7-.71-2.12-3.54-2.12-.7h-1.41l-3.54-3.54-2.12 2.12 3.54 3.54v1.41l.7 2.12 3.54 2.12ZM7.16 3.63l-.71.7 2.83 2.83-1.41 1.42-.71.7-2.83-2.83-.7.71 2.12 3.54 2.12.7h1.41l3.54 3.54 2.12-2.12-3.54-3.54V7.87l-.7-2.12-3.54-2.12Z" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-wrench"><path fill="currentColor" fill-rule="evenodd" d="M30.59 13.41c0-.17-.51-1.42-.59-1.51l-.71-.71h-1.41l-6.07 6.07a.99.99 0 0 1-.71.29h-.56a1 1 0 0 1-.74-.33l-2.52-2.51-2.51-2.52a1 1 0 0 1-.33-.74v-.56c0-.27.11-.52.29-.71l6.07-6.07V2.7l-.71-.71c-.09-.09-1.34-.59-1.51-.59-6.63 0-12 5.37-12 12 0 1.47.28 2.87.76 4.17L.99 23.92v1.41l2.83 2.83 2.83 2.83h1.41l6.35-6.35c1.3.48 2.7.76 4.17.76 6.63 0 12-5.37 12-12l.01.01Z" clip-rule="evenodd" /></symbol><symbol  viewBox="0 0 32 32" fill="none" id="icon-xp"><path fill="currentColor" fill-rule="evenodd" d="M25.37 11.78a.518.518 0 0 0-.35-.14h-4.39v3.49h3.75c.12 0 .25-.06.33-.14l1.02-1.02a.51.51 0 0 0 .15-.35h.01V12.5a.51.51 0 0 0-.15-.35l-.37-.36v-.01Z" clip-rule="evenodd" /><path fill="currentColor" fill-rule="evenodd" d="m30.7 3.71-2.41-2.42a1 1 0 0 0-.71-.3H26.5v3h-3V1.01h-3v3h-3v-3h-3v3h-3v-3h-3v3h-3v-3H4.41c-.26 0-.52.1-.7.29L1.29 3.71c-.19.19-.29.44-.29.7v23.17c0 .27.11.52.29.71l2.42 2.41c.19.19.44.3.7.3H5.5v-3h3v3h3v-3h3v3h3v-3h3v3h3v-3h3v3h1.08c.27 0 .52-.1.71-.3l2.41-2.41a1 1 0 0 0 .3-.71V4.42c0-.27-.1-.52-.3-.71ZM16.82 23h-3.06l-2.84-5.02L8.04 23H5l4.26-7.23L5 9.01h3.06l2.85 4.52 2.85-4.52h3.06l-4.26 6.76L16.82 23Zm11.68-9.2c0 .44-.17.85-.48 1.16l-2.27 2.28c-.33.33-.78.51-1.24.51h-3.88V23h-2.62V9.01h7.71c.52 0 1.02.21 1.4.58l1 1c.25.24.39.57.39.92v2.28l-.01.01Z" clip-rule="evenodd" /></symbol>',
        X.insertBefore(J, X.lastChild)
    };
    var loadSvg = V;
    document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", V) : V()
}
const __vite_import_meta_env__$3 = {
    BASE_URL: "/bf6/11303125",
    DEV: !1,
    MODE: "santiagoprod",
    PROD: !0,
    SSR: !1,
    VITE_ASSETS_PATH: "https://eaassets-a.akamaihd.net/battlelog/battlebinary",
    VITE_AUTH_CLIENT_ID: "GLACIER_COMP_APP",
    VITE_AUTH_REDIRECT_URI: "https://portal.battlefield.com",
    VITE_AUTH_SSO_ENABLED: "false",
    VITE_AUTH_SSO_HOST: "https://accounts.ea.com",
    VITE_BACKEND_KINGSTON_HOST: "https://santiago-prod-wgw-envoy.ops.dice.se",
    VITE_BACKEND_KINGSTON_TENANCY: "prod_default-prod_default-santiago-common",
    VITE_BUILD_SUBDIR: "bf6",
    VITE_EA_CONTENT_HOST: "https://nds-network-nav.ea.com",
    VITE_EA_HOST: "https://www.ea.com",
    VITE_EA_KINGSTON_PATH: "games/battlefield/battlefield-6",
    VITE_ENVIRONMENT: "production",
    VITE_PIN_RIVER_HOST: "https://pin-river.data.ea.com/pinEvents",
    VITE_PIN_RIVER_TITLE_ID: "bf6_webportal",
    VITE_SDK_DOWNLOAD_LINK: "https://download.portal.battlefield.com/PortalSDK.zip",
    VITE_SDK_VERSION_MANIFEST_URL: "https://download.portal.battlefield.com/versions.json",
    VITE_USE_MOCKED_API_RESPONSES: "false",
    VITE_VERSION: "0"
};
function isSelfAtom(V, X) {
    return V.unstable_is ? V.unstable_is(X) : X === V
}
function hasInitialValue(V) {
    return "init"in V
}
function isActuallyWritableAtom(V) {
    return !!V.write
}
function isAtomStateInitialized(V) {
    return "v"in V || "e"in V
}
function returnAtomValue(V) {
    if ("e"in V)
        throw V.e;
    if ((__vite_import_meta_env__$3 ? "santiagoprod" : void 0) !== "production" && !("v"in V))
        throw new Error("[Bug] atom state is not initialized");
    return V.v
}
const promiseStateMap = new WeakMap;
function isPendingPromise(V) {
    var X;
    return isPromiseLike$1(V) && !!((X = promiseStateMap.get(V)) != null && X[0])
}
function abortPromise(V) {
    const X = promiseStateMap.get(V);
    X != null && X[0] && (X[0] = !1,
    X[1].forEach(J => J()))
}
function registerAbortHandler(V, X) {
    let J = promiseStateMap.get(V);
    if (!J) {
        J = [!0, new Set],
        promiseStateMap.set(V, J);
        const ne = () => {
            J[0] = !1
        }
        ;
        V.then(ne, ne)
    }
    J[1].add(X)
}
function isPromiseLike$1(V) {
    return typeof (V == null ? void 0 : V.then) == "function"
}
function addPendingPromiseToDependency(V, X, J) {
    if (!J.p.has(V)) {
        J.p.add(V);
        const ne = () => J.p.delete(V);
        X.then(ne, ne)
    }
}
function getMountedOrPendingDependents(V, X, J) {
    var ne;
    const ue = new Set;
    for (const ce of ((ne = J.get(V)) == null ? void 0 : ne.t) || [])
        J.has(ce) && ue.add(ce);
    for (const ce of X.p)
        ue.add(ce);
    return ue
}
const atomRead = (V, X, ...J) => X.read(...J)
  , atomWrite = (V, X, ...J) => X.write(...J)
  , atomOnInit = (V, X) => {
    var J;
    return (J = X.unstable_onInit) == null ? void 0 : J.call(X, V)
}
  , atomOnMount = (V, X, J) => {
    var ne;
    return (ne = X.onMount) == null ? void 0 : ne.call(X, J)
}
  , ensureAtomState = (V, X) => {
    const J = getBuildingBlocks(V)
      , ne = J[0]
      , ue = J[9];
    if ((__vite_import_meta_env__$3 ? "santiagoprod" : void 0) !== "production" && !X)
        throw new Error("Atom is undefined or null");
    let ce = ne.get(X);
    return ce || (ce = {
        d: new Map,
        p: new Set,
        n: 0
    },
    ne.set(X, ce),
    ue == null || ue(V, X)),
    ce
}
  , flushCallbacks = V => {
    const X = getBuildingBlocks(V)
      , J = X[1]
      , ne = X[3]
      , ue = X[4]
      , ce = X[5]
      , me = X[6]
      , ge = X[13]
      , Te = []
      , _e = Se => {
        try {
            Se()
        } catch (Ie) {
            Te.push(Ie)
        }
    }
    ;
    do {
        me.f && _e(me.f);
        const Se = new Set
          , Ie = Se.add.bind(Se);
        ne.forEach(ye => {
            var $e;
            return ($e = J.get(ye)) == null ? void 0 : $e.l.forEach(Ie)
        }
        ),
        ne.clear(),
        ce.forEach(Ie),
        ce.clear(),
        ue.forEach(Ie),
        ue.clear(),
        Se.forEach(_e),
        ne.size && ge(V)
    } while (ne.size || ce.size || ue.size);
    if (Te.length)
        throw new AggregateError(Te)
}
  , recomputeInvalidatedAtoms = V => {
    const X = getBuildingBlocks(V)
      , J = X[1]
      , ne = X[2]
      , ue = X[3]
      , ce = X[11]
      , me = X[14]
      , ge = X[17]
      , Te = []
      , _e = new WeakSet
      , Se = new WeakSet
      , Ie = Array.from(ue);
    for (; Ie.length; ) {
        const ye = Ie[Ie.length - 1]
          , $e = ce(V, ye);
        if (Se.has(ye)) {
            Ie.pop();
            continue
        }
        if (_e.has(ye)) {
            if (ne.get(ye) === $e.n)
                Te.push([ye, $e]);
            else if ((__vite_import_meta_env__$3 ? "santiagoprod" : void 0) !== "production" && ne.has(ye))
                throw new Error("[Bug] invalidated atom exists");
            Se.add(ye),
            Ie.pop();
            continue
        }
        _e.add(ye);
        for (const Ne of getMountedOrPendingDependents(ye, $e, J))
            _e.has(Ne) || Ie.push(Ne)
    }
    for (let ye = Te.length - 1; ye >= 0; --ye) {
        const [$e,Ne] = Te[ye];
        let ve = !1;
        for (const ke of Ne.d.keys())
            if (ke !== $e && ue.has(ke)) {
                ve = !0;
                break
            }
        ve && (me(V, $e),
        ge(V, $e)),
        ne.delete($e)
    }
}
  , readAtomState = (V, X) => {
    var J;
    const ne = getBuildingBlocks(V)
      , ue = ne[1]
      , ce = ne[2]
      , me = ne[3]
      , ge = ne[6]
      , Te = ne[7]
      , _e = ne[11]
      , Se = ne[12]
      , Ie = ne[13]
      , ye = ne[14]
      , $e = ne[16]
      , Ne = ne[17]
      , ve = _e(V, X);
    if (isAtomStateInitialized(ve) && (ue.has(X) && ce.get(X) !== ve.n || Array.from(ve.d).every( ([qe,Ze]) => ye(V, qe).n === Ze)))
        return ve;
    ve.d.clear();
    let ke = !0;
    function xe() {
        ue.has(X) && (Ne(V, X),
        Ie(V),
        Se(V))
    }
    function we(qe) {
        var Ze;
        if (isSelfAtom(X, qe)) {
            const it = _e(V, qe);
            if (!isAtomStateInitialized(it))
                if (hasInitialValue(qe))
                    setAtomStateValueOrPromise(V, qe, qe.init);
                else
                    throw new Error("no atom init");
            return returnAtomValue(it)
        }
        const et = ye(V, qe);
        try {
            return returnAtomValue(et)
        } finally {
            ve.d.set(qe, et.n),
            isPendingPromise(ve.v) && addPendingPromiseToDependency(X, ve.v, et),
            (Ze = ue.get(qe)) == null || Ze.t.add(X),
            ke || xe()
        }
    }
    let Fe, je;
    const Xe = {
        get signal() {
            return Fe || (Fe = new AbortController),
            Fe.signal
        },
        get setSelf() {
            return (__vite_import_meta_env__$3 ? "santiagoprod" : void 0) !== "production" && !isActuallyWritableAtom(X) && console.warn("setSelf function cannot be used with read-only atom"),
            !je && isActuallyWritableAtom(X) && (je = (...qe) => {
                if ((__vite_import_meta_env__$3 ? "santiagoprod" : void 0) !== "production" && ke && console.warn("setSelf function cannot be called in sync"),
                !ke)
                    try {
                        return $e(V, X, ...qe)
                    } finally {
                        Ie(V),
                        Se(V)
                    }
            }
            ),
            je
        }
    }
      , ze = ve.n;
    try {
        const qe = Te(V, X, we, Xe);
        return setAtomStateValueOrPromise(V, X, qe),
        isPromiseLike$1(qe) && (registerAbortHandler(qe, () => Fe == null ? void 0 : Fe.abort()),
        qe.then(xe, xe)),
        ve
    } catch (qe) {
        return delete ve.v,
        ve.e = qe,
        ++ve.n,
        ve
    } finally {
        ke = !1,
        ze !== ve.n && ce.get(X) === ze && (ce.set(X, ve.n),
        me.add(X),
        (J = ge.c) == null || J.call(ge, X))
    }
}
  , invalidateDependents = (V, X) => {
    const J = getBuildingBlocks(V)
      , ne = J[1]
      , ue = J[2]
      , ce = J[11]
      , me = [X];
    for (; me.length; ) {
        const ge = me.pop()
          , Te = ce(V, ge);
        for (const _e of getMountedOrPendingDependents(ge, Te, ne)) {
            const Se = ce(V, _e);
            ue.set(_e, Se.n),
            me.push(_e)
        }
    }
}
  , writeAtomState = (V, X, ...J) => {
    const ne = getBuildingBlocks(V)
      , ue = ne[3]
      , ce = ne[6]
      , me = ne[8]
      , ge = ne[11]
      , Te = ne[12]
      , _e = ne[13]
      , Se = ne[14]
      , Ie = ne[15]
      , ye = ne[17];
    let $e = !0;
    const Ne = ke => returnAtomValue(Se(V, ke))
      , ve = (ke, ...xe) => {
        var we;
        const Fe = ge(V, ke);
        try {
            if (isSelfAtom(X, ke)) {
                if (!hasInitialValue(ke))
                    throw new Error("atom not writable");
                const je = Fe.n
                  , Xe = xe[0];
                setAtomStateValueOrPromise(V, ke, Xe),
                ye(V, ke),
                je !== Fe.n && (ue.add(ke),
                (we = ce.c) == null || we.call(ce, ke),
                Ie(V, ke));
                return
            } else
                return writeAtomState(V, ke, ...xe)
        } finally {
            $e || (_e(V),
            Te(V))
        }
    }
    ;
    try {
        return me(V, X, Ne, ve, ...J)
    } finally {
        $e = !1
    }
}
  , mountDependencies = (V, X) => {
    var J;
    const ne = getBuildingBlocks(V)
      , ue = ne[1]
      , ce = ne[3]
      , me = ne[6]
      , ge = ne[11]
      , Te = ne[15]
      , _e = ne[18]
      , Se = ne[19]
      , Ie = ge(V, X)
      , ye = ue.get(X);
    if (ye && !isPendingPromise(Ie.v)) {
        for (const [$e,Ne] of Ie.d)
            if (!ye.d.has($e)) {
                const ve = ge(V, $e);
                _e(V, $e).t.add(X),
                ye.d.add($e),
                Ne !== ve.n && (ce.add($e),
                (J = me.c) == null || J.call(me, $e),
                Te(V, $e))
            }
        for (const $e of ye.d || [])
            if (!Ie.d.has($e)) {
                ye.d.delete($e);
                const Ne = Se(V, $e);
                Ne == null || Ne.t.delete(X)
            }
    }
}
  , mountAtom = (V, X) => {
    var J;
    const ne = getBuildingBlocks(V)
      , ue = ne[1]
      , ce = ne[4]
      , me = ne[6]
      , ge = ne[10]
      , Te = ne[11]
      , _e = ne[12]
      , Se = ne[13]
      , Ie = ne[14]
      , ye = ne[16]
      , $e = Te(V, X);
    let Ne = ue.get(X);
    if (!Ne) {
        Ie(V, X);
        for (const ve of $e.d.keys())
            mountAtom(V, ve).t.add(X);
        if (Ne = {
            l: new Set,
            d: new Set($e.d.keys()),
            t: new Set
        },
        ue.set(X, Ne),
        (J = me.m) == null || J.call(me, X),
        isActuallyWritableAtom(X)) {
            const ve = () => {
                let ke = !0;
                const xe = (...we) => {
                    try {
                        return ye(V, X, ...we)
                    } finally {
                        ke || (Se(V),
                        _e(V))
                    }
                }
                ;
                try {
                    const we = ge(V, X, xe);
                    we && (Ne.u = () => {
                        ke = !0;
                        try {
                            we()
                        } finally {
                            ke = !1
                        }
                    }
                    )
                } finally {
                    ke = !1
                }
            }
            ;
            ce.add(ve)
        }
    }
    return Ne
}
  , unmountAtom = (V, X) => {
    var J;
    const ne = getBuildingBlocks(V)
      , ue = ne[1]
      , ce = ne[5]
      , me = ne[6]
      , ge = ne[11]
      , Te = ne[19]
      , _e = ge(V, X);
    let Se = ue.get(X);
    if (Se && !Se.l.size && !Array.from(Se.t).some(Ie => {
        var ye;
        return (ye = ue.get(Ie)) == null ? void 0 : ye.d.has(X)
    }
    )) {
        Se.u && ce.add(Se.u),
        Se = void 0,
        ue.delete(X),
        (J = me.u) == null || J.call(me, X);
        for (const Ie of _e.d.keys()) {
            const ye = Te(V, Ie);
            ye == null || ye.t.delete(X)
        }
        return
    }
    return Se
}
  , setAtomStateValueOrPromise = (V, X, J) => {
    const ne = getBuildingBlocks(V)[11]
      , ue = ne(V, X)
      , ce = "v"in ue
      , me = ue.v;
    if (isPromiseLike$1(J))
        for (const ge of ue.d.keys())
            addPendingPromiseToDependency(X, J, ne(V, ge));
    ue.v = J,
    delete ue.e,
    (!ce || !Object.is(me, ue.v)) && (++ue.n,
    isPromiseLike$1(me) && abortPromise(me))
}
  , storeGet = (V, X) => {
    const J = getBuildingBlocks(V)[14];
    return returnAtomValue(J(V, X))
}
  , storeSet = (V, X, ...J) => {
    const ne = getBuildingBlocks(V)
      , ue = ne[12]
      , ce = ne[13]
      , me = ne[16];
    try {
        return me(V, X, ...J)
    } finally {
        ce(V),
        ue(V)
    }
}
  , storeSub = (V, X, J) => {
    const ne = getBuildingBlocks(V)
      , ue = ne[12]
      , ce = ne[18]
      , me = ne[19]
      , Te = ce(V, X).l;
    return Te.add(J),
    ue(V),
    () => {
        Te.delete(J),
        me(V, X),
        ue(V)
    }
}
  , buildingBlockMap = new WeakMap;
function getBuildingBlocks(V) {
    const X = buildingBlockMap.get(V);
    if ((__vite_import_meta_env__$3 ? "santiagoprod" : void 0) !== "production" && !X)
        throw new Error("Store must be created by buildStore to read its building blocks");
    return X
}
function buildStore(...V) {
    const X = {
        get(ne) {
            const ue = getBuildingBlocks(X)[21];
            return ue(X, ne)
        },
        set(ne, ...ue) {
            const ce = getBuildingBlocks(X)[22];
            return ce(X, ne, ...ue)
        },
        sub(ne, ue) {
            const ce = getBuildingBlocks(X)[23];
            return ce(X, ne, ue)
        }
    }
      , J = [new WeakMap, new WeakMap, new WeakMap, new Set, new Set, new Set, {}, atomRead, atomWrite, atomOnInit, atomOnMount, ensureAtomState, flushCallbacks, recomputeInvalidatedAtoms, readAtomState, invalidateDependents, writeAtomState, mountDependencies, mountAtom, unmountAtom, setAtomStateValueOrPromise, storeGet, storeSet, storeSub].map( (ne, ue) => V[ue] || ne);
    return buildingBlockMap.set(X, Object.freeze(J)),
    X
}
const __vite_import_meta_env__$2 = {
    BASE_URL: "/bf6/11303125",
    DEV: !1,
    MODE: "santiagoprod",
    PROD: !0,
    SSR: !1,
    VITE_ASSETS_PATH: "https://eaassets-a.akamaihd.net/battlelog/battlebinary",
    VITE_AUTH_CLIENT_ID: "GLACIER_COMP_APP",
    VITE_AUTH_REDIRECT_URI: "https://portal.battlefield.com",
    VITE_AUTH_SSO_ENABLED: "false",
    VITE_AUTH_SSO_HOST: "https://accounts.ea.com",
    VITE_BACKEND_KINGSTON_HOST: "https://santiago-prod-wgw-envoy.ops.dice.se",
    VITE_BACKEND_KINGSTON_TENANCY: "prod_default-prod_default-santiago-common",
    VITE_BUILD_SUBDIR: "bf6",
    VITE_EA_CONTENT_HOST: "https://nds-network-nav.ea.com",
    VITE_EA_HOST: "https://www.ea.com",
    VITE_EA_KINGSTON_PATH: "games/battlefield/battlefield-6",
    VITE_ENVIRONMENT: "production",
    VITE_PIN_RIVER_HOST: "https://pin-river.data.ea.com/pinEvents",
    VITE_PIN_RIVER_TITLE_ID: "bf6_webportal",
    VITE_SDK_DOWNLOAD_LINK: "https://download.portal.battlefield.com/PortalSDK.zip",
    VITE_SDK_VERSION_MANIFEST_URL: "https://download.portal.battlefield.com/versions.json",
    VITE_USE_MOCKED_API_RESPONSES: "false",
    VITE_VERSION: "0"
};
let keyCount = 0;
function atom(V, X) {
    const J = `atom${++keyCount}`
      , ne = {
        toString() {
            return (__vite_import_meta_env__$2 ? "santiagoprod" : void 0) !== "production" && this.debugLabel ? J + ":" + this.debugLabel : J
        }
    };
    return typeof V == "function" ? ne.read = V : (ne.init = V,
    ne.read = defaultRead$1,
    ne.write = defaultWrite$1),
    X && (ne.write = X),
    ne
}
function defaultRead$1(V) {
    return V(this)
}
function defaultWrite$1(V, X, J) {
    return X(this, typeof J == "function" ? J(V(this)) : J)
}
function createStore() {
    return buildStore()
}
let defaultStore;
function getDefaultStore() {
    return defaultStore || (defaultStore = createStore(),
    (__vite_import_meta_env__$2 ? "santiagoprod" : void 0) !== "production" && (globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore),
    globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore && console.warn("Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044"))),
    defaultStore
}
const __vite_import_meta_env__$1 = {
    BASE_URL: "/bf6/11303125",
    DEV: !1,
    MODE: "santiagoprod",
    PROD: !0,
    SSR: !1,
    VITE_ASSETS_PATH: "https://eaassets-a.akamaihd.net/battlelog/battlebinary",
    VITE_AUTH_CLIENT_ID: "GLACIER_COMP_APP",
    VITE_AUTH_REDIRECT_URI: "https://portal.battlefield.com",
    VITE_AUTH_SSO_ENABLED: "false",
    VITE_AUTH_SSO_HOST: "https://accounts.ea.com",
    VITE_BACKEND_KINGSTON_HOST: "https://santiago-prod-wgw-envoy.ops.dice.se",
    VITE_BACKEND_KINGSTON_TENANCY: "prod_default-prod_default-santiago-common",
    VITE_BUILD_SUBDIR: "bf6",
    VITE_EA_CONTENT_HOST: "https://nds-network-nav.ea.com",
    VITE_EA_HOST: "https://www.ea.com",
    VITE_EA_KINGSTON_PATH: "games/battlefield/battlefield-6",
    VITE_ENVIRONMENT: "production",
    VITE_PIN_RIVER_HOST: "https://pin-river.data.ea.com/pinEvents",
    VITE_PIN_RIVER_TITLE_ID: "bf6_webportal",
    VITE_SDK_DOWNLOAD_LINK: "https://download.portal.battlefield.com/PortalSDK.zip",
    VITE_SDK_VERSION_MANIFEST_URL: "https://download.portal.battlefield.com/versions.json",
    VITE_USE_MOCKED_API_RESPONSES: "false",
    VITE_VERSION: "0"
}
  , StoreContext = reactExports.createContext(void 0);
function useStore(V) {
    return reactExports.useContext(StoreContext) || getDefaultStore()
}
function Provider({children: V, store: X}) {
    const J = reactExports.useRef(void 0);
    return !X && !J.current && (J.current = createStore()),
    reactExports.createElement(StoreContext.Provider, {
        value: X || J.current
    }, V)
}
const isPromiseLike = V => typeof (V == null ? void 0 : V.then) == "function"
  , attachPromiseStatus = V => {
    V.status || (V.status = "pending",
    V.then(X => {
        V.status = "fulfilled",
        V.value = X
    }
    , X => {
        V.status = "rejected",
        V.reason = X
    }
    ))
}
  , use = React$2.use || (V => {
    if (V.status === "pending")
        throw V;
    if (V.status === "fulfilled")
        return V.value;
    throw V.status === "rejected" ? V.reason : (attachPromiseStatus(V),
    V)
}
)
  , continuablePromiseMap = new WeakMap
  , createContinuablePromise = (V, X) => {
    let J = continuablePromiseMap.get(V);
    return J || (J = new Promise( (ne, ue) => {
        let ce = V;
        const me = _e => Se => {
            ce === _e && ne(Se)
        }
          , ge = _e => Se => {
            ce === _e && ue(Se)
        }
          , Te = () => {
            try {
                const _e = X();
                isPromiseLike(_e) ? (continuablePromiseMap.set(_e, J),
                ce = _e,
                _e.then(me(_e), ge(_e)),
                registerAbortHandler(_e, Te)) : ne(_e)
            } catch (_e) {
                ue(_e)
            }
        }
        ;
        V.then(me(V), ge(V)),
        registerAbortHandler(V, Te)
    }
    ),
    continuablePromiseMap.set(V, J)),
    J
}
;
function useAtomValue(V, X) {
    const {delay: J, unstable_promiseStatus: ne=!React$2.use} = {}
      , ue = useStore()
      , [[ce,me,ge],Te] = reactExports.useReducer(Se => {
        const Ie = ue.get(V);
        return Object.is(Se[0], Ie) && Se[1] === ue && Se[2] === V ? Se : [Ie, ue, V]
    }
    , void 0, () => [ue.get(V), ue, V]);
    let _e = ce;
    if ((me !== ue || ge !== V) && (Te(),
    _e = ue.get(V)),
    reactExports.useEffect( () => {
        const Se = ue.sub(V, () => {
            if (ne)
                try {
                    const Ie = ue.get(V);
                    isPromiseLike(Ie) && attachPromiseStatus(createContinuablePromise(Ie, () => ue.get(V)))
                } catch {}
            if (typeof J == "number") {
                setTimeout(Te, J);
                return
            }
            Te()
        }
        );
        return Te(),
        Se
    }
    , [ue, V, J, ne]),
    reactExports.useDebugValue(_e),
    isPromiseLike(_e)) {
        const Se = createContinuablePromise(_e, () => ue.get(V));
        return ne && attachPromiseStatus(Se),
        use(Se)
    }
    return _e
}
function useSetAtom(V, X) {
    const J = useStore();
    return reactExports.useCallback( (...ue) => {
        if ((__vite_import_meta_env__$1 ? "santiagoprod" : void 0) !== "production" && !("write"in V))
            throw new Error("not writable atom");
        return J.set(V, ...ue)
    }
    , [J, V])
}
function useAtom(V, X) {
    return [useAtomValue(V), useSetAtom(V)]
}
const logger$f = Logger$1.get("delete")
  , useDeleteExperienceMutation = V => {
    const {sessionId: X, player: J} = reactExports.useContext(SessionContext)
      , ne = useAtomValue(playElementIdAtom)
      , ue = useQueryClient()
      , ce = useMutation({
        mutationFn: () => X ? clients.play.deletePlayElement({
            playElementId: V || ne
        }, new grpcWebClient_umdExports.grpc.Metadata({
            "x-gateway-session-id": X
        })) : Promise.reject()
    });
    return async (ge, Te) => {
        try {
            const _e = await ce.mutateAsync();
            _e && (logger$f.log("Delete successful!", _e),
            await ue.invalidateQueries({
                queryKey: [QUERY_KEY.PLAY_ELEMENT, ne]
            }),
            await ue.invalidateQueries({
                queryKey: [QUERY_KEY.LIST_PLAY_ELEMENTS, J == null ? void 0 : J.nucleusId]
            }),
            ge && ge())
        } catch (_e) {
            Logger$1.error("Failed to delete play element: ", _e),
            Te && Te()
        }
    }
}
  , __vite_import_meta_env__ = {
    BASE_URL: "/bf6/11303125",
    DEV: !1,
    MODE: "santiagoprod",
    PROD: !0,
    SSR: !1,
    VITE_ASSETS_PATH: "https://eaassets-a.akamaihd.net/battlelog/battlebinary",
    VITE_AUTH_CLIENT_ID: "GLACIER_COMP_APP",
    VITE_AUTH_REDIRECT_URI: "https://portal.battlefield.com",
    VITE_AUTH_SSO_ENABLED: "false",
    VITE_AUTH_SSO_HOST: "https://accounts.ea.com",
    VITE_BACKEND_KINGSTON_HOST: "https://santiago-prod-wgw-envoy.ops.dice.se",
    VITE_BACKEND_KINGSTON_TENANCY: "prod_default-prod_default-santiago-common",
    VITE_BUILD_SUBDIR: "bf6",
    VITE_EA_CONTENT_HOST: "https://nds-network-nav.ea.com",
    VITE_EA_HOST: "https://www.ea.com",
    VITE_EA_KINGSTON_PATH: "games/battlefield/battlefield-6",
    VITE_ENVIRONMENT: "production",
    VITE_PIN_RIVER_HOST: "https://pin-river.data.ea.com/pinEvents",
    VITE_PIN_RIVER_TITLE_ID: "bf6_webportal",
    VITE_SDK_DOWNLOAD_LINK: "https://download.portal.battlefield.com/PortalSDK.zip",
    VITE_SDK_VERSION_MANIFEST_URL: "https://download.portal.battlefield.com/versions.json",
    VITE_USE_MOCKED_API_RESPONSES: "false",
    VITE_VERSION: "0"
}
  , RESET = Symbol((__vite_import_meta_env__ ? "santiagoprod" : void 0) !== "production" ? "RESET" : "");
function atomWithReset(V) {
    const X = atom(V, (J, ne, ue) => {
        const ce = typeof ue == "function" ? ue(J(X)) : ue;
        ne(X, ce === RESET ? V : ce)
    }
    );
    return X
}
const isPromiseLike$3 = V => typeof (V == null ? void 0 : V.then) == "function";
function createJSONStorage(V= () => {
    try {
        return window.localStorage
    } catch (J) {
        (__vite_import_meta_env__ ? "santiagoprod" : void 0) !== "production" && typeof window < "u" && console.warn(J);
        return
    }
}
, X) {
    var J;
    let ne, ue;
    const ce = {
        getItem: (Te, _e) => {
            var Se, Ie;
            const ye = Ne => {
                if (Ne = Ne || "",
                ne !== Ne) {
                    try {
                        ue = JSON.parse(Ne, X == null ? void 0 : X.reviver)
                    } catch {
                        return _e
                    }
                    ne = Ne
                }
                return ue
            }
              , $e = (Ie = (Se = V()) == null ? void 0 : Se.getItem(Te)) != null ? Ie : null;
            return isPromiseLike$3($e) ? $e.then(ye) : ye($e)
        }
        ,
        setItem: (Te, _e) => {
            var Se;
            return (Se = V()) == null ? void 0 : Se.setItem(Te, JSON.stringify(_e, void 0))
        }
        ,
        removeItem: Te => {
            var _e;
            return (_e = V()) == null ? void 0 : _e.removeItem(Te)
        }
    }
      , me = Te => (_e, Se, Ie) => Te(_e, ye => {
        let $e;
        try {
            $e = JSON.parse(ye || "")
        } catch {
            $e = Ie
        }
        Se($e)
    }
    );
    let ge;
    try {
        ge = (J = V()) == null ? void 0 : J.subscribe
    } catch {}
    return !ge && typeof window < "u" && typeof window.addEventListener == "function" && window.Storage && (ge = (Te, _e) => {
        if (!(V()instanceof window.Storage))
            return () => {}
            ;
        const Se = Ie => {
            Ie.storageArea === V() && Ie.key === Te && _e(Ie.newValue)
        }
        ;
        return window.addEventListener("storage", Se),
        () => {
            window.removeEventListener("storage", Se)
        }
    }
    ),
    ge && (ce.subscribe = me(ge)),
    ce
}
createJSONStorage();
const hydratedMap = new WeakMap;
function useHydrateAtoms(V, X) {
    const J = useStore()
      , ne = getHydratedSet(J);
    for (const [ue,...ce] of V)
        ne.has(ue) || (ne.add(ue),
        J.set(ue, ...ce))
}
const getHydratedSet = V => {
    let X = hydratedMap.get(V);
    return X || (X = new WeakSet,
    hydratedMap.set(V, X)),
    X
}
;
function PatchedStore() {}
function createPatchedStore(V, X) {
    const J = {
        ...V,
        get(ne, ...ue) {
            const [ce] = X.getAtom(ne);
            return V.get(ce, ...ue)
        },
        set(ne, ...ue) {
            const [ce,me] = X.getAtom(ne)
              , ge = X.prepareWriteAtom(ce, ne, me);
            try {
                return V.set(ce, ...ue)
            } finally {
                ge == null || ge()
            }
        },
        sub(ne, ...ue) {
            const [ce] = X.getAtom(ne);
            return V.sub(ce, ...ue)
        }
    };
    return Object.assign(Object.create(PatchedStore.prototype), J)
}
function isTopLevelScope(V) {
    return !(V instanceof PatchedStore)
}
const globalScopeKey = {};
function createScope(V, X, J, ne) {
    const ue = new WeakMap
      , ce = new WeakMap
      , me = new WeakMap
      , ge = {
        getAtom: _e,
        cleanup() {},
        prepareWriteAtom(ve, ke, xe) {
            if (ke.read === defaultRead && isWritableAtom(ke) && isWritableAtom(ve) && ke.write !== defaultWrite && ge !== xe) {
                const {write: we} = ke;
                return ve.write = Ne(ke.write.bind(ke), xe),
                () => {
                    ve.write = we
                }
            }
        }
    };
    for (const ve of V)
        ue.set(ve, [ye(ve, ge), ge]);
    const Te = new Set;
    for (const ve of X) {
        for (const xe of ve.getParams()) {
            const we = ve(xe);
            ue.has(we) || ue.set(we, [ye(we, ge), ge])
        }
        const ke = ve.unstable_listen(xe => {
            xe.type === "CREATE" && !ue.has(xe.atom) ? ue.set(xe.atom, [ye(xe.atom, ge), ge]) : V.has(xe.atom) || ue.delete(xe.atom)
        }
        );
        Te.add(ke)
    }
    ge.cleanup = combineVoidFunctions(ge.cleanup, ...Array.from(Te));
    function _e(ve, ke) {
        var we, Fe;
        if (ue.has(ve))
            return ue.get(ve);
        if (ke === ge)
            return ce.has(ve) || ce.set(ve, [ye(ve, ke), ke]),
            ce.get(ve);
        const xe = ke ?? globalScopeKey;
        if (J) {
            if (!((we = me.get(xe)) != null && we.has(ve))) {
                const [je,Xe] = J.getAtom(ve, ke);
                Se(Ie(je, ve, Xe), ve, ke, Xe)
            }
            return me.get(xe).get(ve)
        }
        return (Fe = me.get(xe)) != null && Fe.has(ve) || Se(Ie(ve, ve), ve),
        me.get(xe).get(ve)
    }
    function Se(ve, ke, xe, we) {
        const Fe = xe ?? globalScopeKey;
        me.has(Fe) || me.set(Fe, new WeakMap),
        me.get(Fe).set(ke, [ve, we].filter(Boolean))
    }
    function Ie(ve, ke, xe) {
        return ke.read !== defaultRead ? ye(ke, xe) : ve
    }
    function ye(ve, ke) {
        const xe = Object.create(Object.getPrototypeOf(ve), Object.getOwnPropertyDescriptors(ve));
        return xe.read !== defaultRead && (xe.read = $e(ve.read.bind(ve), ke)),
        isWritableAtom(xe) && isWritableAtom(ve) && xe.write !== defaultWrite && (xe.write = Ne(ve.write.bind(ve), ke)),
        xe
    }
    function $e(ve, ke) {
        return function(we, Fe) {
            return ve(function(Xe) {
                const [ze] = _e(Xe, ke);
                return we(ze)
            }, Fe)
        }
    }
    function Ne(ve, ke) {
        return function(we, Fe, ...je) {
            return ve(function(ze) {
                const [qe] = _e(ze, ke);
                return we(qe)
            }, function(ze, ...qe) {
                const [Ze] = _e(ze, ke);
                return Fe(Ze, ...qe)
            }, ...je)
        }
    }
    return ge
}
function isWritableAtom(V) {
    return "write"in V
}
const {read: defaultRead, write: defaultWrite} = atom(null);
function toString$2() {
    return this.name
}
function combineVoidFunctions(...V) {
    return function() {
        for (const J of V)
            J()
    }
}
const ScopeContext = reactExports.createContext({
    scope: void 0,
    baseStore: void 0
});
function ScopeProvider({atoms: V, atomFamilies: X, children: J, debugName: ne}) {
    var ke;
    const ue = useStore();
    let {scope: ce, baseStore: me=ue} = reactExports.useContext(ScopeContext);
    isTopLevelScope(ue) && (ce = void 0,
    me = ue);
    const ge = new Set(V)
      , Te = new Set(X);
    function _e() {
        const xe = createScope(ge, Te, ce, ne);
        return {
            patchedStore: createPatchedStore(me, xe),
            scopeContext: {
                scope: xe,
                baseStore: me
            },
            hasChanged(we) {
                return ce !== we.parentScope || me !== we.baseStore || !isEqualSet(ge, we.atomSet) || !isEqualSet(Te, we.atomFamilySet)
            }
        }
    }
    const [Se,Ie] = reactExports.useState(_e)
      , {hasChanged: ye, scopeContext: $e, patchedStore: Ne} = Se;
    ye({
        parentScope: ce,
        atomSet: ge,
        atomFamilySet: Te,
        baseStore: me
    }) && ((ke = $e.scope) == null || ke.cleanup(),
    Ie(_e));
    const {cleanup: ve} = $e.scope;
    return useEvent( () => ve, []),
    jsxRuntimeExports.jsx(ScopeContext.Provider, {
        value: $e,
        children: jsxRuntimeExports.jsx(Provider, {
            store: Ne,
            children: J
        })
    })
}
function isEqualSet(V, X) {
    return V === X || V.size === X.size && Array.from(V).every(J => X.has(J))
}
function useEvent(V, X) {
    const J = reactExports.useRef(V);
    J.current = V,
    reactExports.useEffect( () => J.current(), X)
}
var dist = {};
Object.defineProperty(dist, "__esModule", {
    value: !0
});
dist.parse = parse$1;
dist.serialize = serialize$1;
const cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/
  , cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/
  , domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i
  , pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/
  , __toString = Object.prototype.toString
  , NullObject = ( () => {
    const V = function() {};
    return V.prototype = Object.create(null),
    V
}
)();
function parse$1(V, X) {
    const J = new NullObject
      , ne = V.length;
    if (ne < 2)
        return J;
    const ue = (X == null ? void 0 : X.decode) || decode$1;
    let ce = 0;
    do {
        const me = V.indexOf("=", ce);
        if (me === -1)
            break;
        const ge = V.indexOf(";", ce)
          , Te = ge === -1 ? ne : ge;
        if (me > Te) {
            ce = V.lastIndexOf(";", me - 1) + 1;
            continue
        }
        const _e = startIndex(V, ce, me)
          , Se = endIndex(V, me, _e)
          , Ie = V.slice(_e, Se);
        if (J[Ie] === void 0) {
            let ye = startIndex(V, me + 1, Te)
              , $e = endIndex(V, Te, ye);
            const Ne = ue(V.slice(ye, $e));
            J[Ie] = Ne
        }
        ce = Te + 1
    } while (ce < ne);
    return J
}
function startIndex(V, X, J) {
    do {
        const ne = V.charCodeAt(X);
        if (ne !== 32 && ne !== 9)
            return X
    } while (++X < J);
    return J
}
function endIndex(V, X, J) {
    for (; X > J; ) {
        const ne = V.charCodeAt(--X);
        if (ne !== 32 && ne !== 9)
            return X + 1
    }
    return J
}
function serialize$1(V, X, J) {
    const ne = (J == null ? void 0 : J.encode) || encodeURIComponent;
    if (!cookieNameRegExp.test(V))
        throw new TypeError(`argument name is invalid: ${V}`);
    const ue = ne(X);
    if (!cookieValueRegExp.test(ue))
        throw new TypeError(`argument val is invalid: ${X}`);
    let ce = V + "=" + ue;
    if (!J)
        return ce;
    if (J.maxAge !== void 0) {
        if (!Number.isInteger(J.maxAge))
            throw new TypeError(`option maxAge is invalid: ${J.maxAge}`);
        ce += "; Max-Age=" + J.maxAge
    }
    if (J.domain) {
        if (!domainValueRegExp.test(J.domain))
            throw new TypeError(`option domain is invalid: ${J.domain}`);
        ce += "; Domain=" + J.domain
    }
    if (J.path) {
        if (!pathValueRegExp.test(J.path))
            throw new TypeError(`option path is invalid: ${J.path}`);
        ce += "; Path=" + J.path
    }
    if (J.expires) {
        if (!isDate(J.expires) || !Number.isFinite(J.expires.valueOf()))
            throw new TypeError(`option expires is invalid: ${J.expires}`);
        ce += "; Expires=" + J.expires.toUTCString()
    }
    if (J.httpOnly && (ce += "; HttpOnly"),
    J.secure && (ce += "; Secure"),
    J.partitioned && (ce += "; Partitioned"),
    J.priority)
        switch (typeof J.priority == "string" ? J.priority.toLowerCase() : void 0) {
        case "low":
            ce += "; Priority=Low";
            break;
        case "medium":
            ce += "; Priority=Medium";
            break;
        case "high":
            ce += "; Priority=High";
            break;
        default:
            throw new TypeError(`option priority is invalid: ${J.priority}`)
        }
    if (J.sameSite)
        switch (typeof J.sameSite == "string" ? J.sameSite.toLowerCase() : J.sameSite) {
        case !0:
        case "strict":
            ce += "; SameSite=Strict";
            break;
        case "lax":
            ce += "; SameSite=Lax";
            break;
        case "none":
            ce += "; SameSite=None";
            break;
        default:
            throw new TypeError(`option sameSite is invalid: ${J.sameSite}`)
        }
    return ce
}
function decode$1(V) {
    if (V.indexOf("%") === -1)
        return V;
    try {
        return decodeURIComponent(V)
    } catch {
        return V
    }
}
function isDate(V) {
    return __toString.call(V) === "[object Date]"
}
/**
 * react-router v7.3.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
var __typeError = V => {
    throw TypeError(V)
}
  , __accessCheck = (V, X, J) => X.has(V) || __typeError("Cannot " + J)
  , __privateGet = (V, X, J) => (__accessCheck(V, X, "read from private field"),
J ? J.call(V) : X.get(V))
  , __privateAdd = (V, X, J) => X.has(V) ? __typeError("Cannot add the same private member more than once") : X instanceof WeakSet ? X.add(V) : X.set(V, J)
  , PopStateEventType = "popstate";
function createBrowserHistory(V={}) {
    function X(ne, ue) {
        let {pathname: ce, search: me, hash: ge} = ne.location;
        return createLocation("", {
            pathname: ce,
            search: me,
            hash: ge
        }, ue.state && ue.state.usr || null, ue.state && ue.state.key || "default")
    }
    function J(ne, ue) {
        return typeof ue == "string" ? ue : createPath(ue)
    }
    return getUrlBasedHistory(X, J, null, V)
}
function invariant(V, X) {
    if (V === !1 || V === null || typeof V > "u")
        throw new Error(X)
}
function warning(V, X) {
    if (!V) {
        typeof console < "u" && console.warn(X);
        try {
            throw new Error(X)
        } catch {}
    }
}
function createKey() {
    return Math.random().toString(36).substring(2, 10)
}
function getHistoryState(V, X) {
    return {
        usr: V.state,
        key: V.key,
        idx: X
    }
}
function createLocation(V, X, J=null, ne) {
    return {
        pathname: typeof V == "string" ? V : V.pathname,
        search: "",
        hash: "",
        ...typeof X == "string" ? parsePath(X) : X,
        state: J,
        key: X && X.key || ne || createKey()
    }
}
function createPath({pathname: V="/", search: X="", hash: J=""}) {
    return X && X !== "?" && (V += X.charAt(0) === "?" ? X : "?" + X),
    J && J !== "#" && (V += J.charAt(0) === "#" ? J : "#" + J),
    V
}
function parsePath(V) {
    let X = {};
    if (V) {
        let J = V.indexOf("#");
        J >= 0 && (X.hash = V.substring(J),
        V = V.substring(0, J));
        let ne = V.indexOf("?");
        ne >= 0 && (X.search = V.substring(ne),
        V = V.substring(0, ne)),
        V && (X.pathname = V)
    }
    return X
}
function getUrlBasedHistory(V, X, J, ne={}) {
    let {window: ue=document.defaultView, v5Compat: ce=!1} = ne
      , me = ue.history
      , ge = "POP"
      , Te = null
      , _e = Se();
    _e == null && (_e = 0,
    me.replaceState({
        ...me.state,
        idx: _e
    }, ""));
    function Se() {
        return (me.state || {
            idx: null
        }).idx
    }
    function Ie() {
        ge = "POP";
        let ke = Se()
          , xe = ke == null ? null : ke - _e;
        _e = ke,
        Te && Te({
            action: ge,
            location: ve.location,
            delta: xe
        })
    }
    function ye(ke, xe) {
        ge = "PUSH";
        let we = createLocation(ve.location, ke, xe);
        _e = Se() + 1;
        let Fe = getHistoryState(we, _e)
          , je = ve.createHref(we);
        try {
            me.pushState(Fe, "", je)
        } catch (Xe) {
            if (Xe instanceof DOMException && Xe.name === "DataCloneError")
                throw Xe;
            ue.location.assign(je)
        }
        ce && Te && Te({
            action: ge,
            location: ve.location,
            delta: 1
        })
    }
    function $e(ke, xe) {
        ge = "REPLACE";
        let we = createLocation(ve.location, ke, xe);
        _e = Se();
        let Fe = getHistoryState(we, _e)
          , je = ve.createHref(we);
        me.replaceState(Fe, "", je),
        ce && Te && Te({
            action: ge,
            location: ve.location,
            delta: 0
        })
    }
    function Ne(ke) {
        let xe = ue.location.origin !== "null" ? ue.location.origin : ue.location.href
          , we = typeof ke == "string" ? ke : createPath(ke);
        return we = we.replace(/ $/, "%20"),
        invariant(xe, `No window.location.(origin|href) available to create URL for href: ${we}`),
        new URL(we,xe)
    }
    let ve = {
        get action() {
            return ge
        },
        get location() {
            return V(ue, me)
        },
        listen(ke) {
            if (Te)
                throw new Error("A history only accepts one active listener");
            return ue.addEventListener(PopStateEventType, Ie),
            Te = ke,
            () => {
                ue.removeEventListener(PopStateEventType, Ie),
                Te = null
            }
        },
        createHref(ke) {
            return X(ue, ke)
        },
        createURL: Ne,
        encodeLocation(ke) {
            let xe = Ne(ke);
            return {
                pathname: xe.pathname,
                search: xe.search,
                hash: xe.hash
            }
        },
        push: ye,
        replace: $e,
        go(ke) {
            return me.go(ke)
        }
    };
    return ve
}
var _map, unstable_RouterContextProvider = class {
    constructor(V) {
        if (__privateAdd(this, _map, new Map),
        V)
            for (let[X,J] of V)
                this.set(X, J)
    }
    get(V) {
        if (__privateGet(this, _map).has(V))
            return __privateGet(this, _map).get(V);
        if (V.defaultValue !== void 0)
            return V.defaultValue;
        throw new Error("No value found for context")
    }
    set(V, X) {
        __privateGet(this, _map).set(V, X)
    }
}
;
_map = new WeakMap;
var immutableRouteKeys = new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
function isIndexRoute(V) {
    return V.index === !0
}
function convertRoutesToDataRoutes(V, X, J=[], ne={}) {
    return V.map( (ue, ce) => {
        let me = [...J, String(ce)]
          , ge = typeof ue.id == "string" ? ue.id : me.join("-");
        if (invariant(ue.index !== !0 || !ue.children, "Cannot specify children on an index route"),
        invariant(!ne[ge], `Found a route id collision on id "${ge}".  Route id's must be globally unique within Data Router usages`),
        isIndexRoute(ue)) {
            let Te = {
                ...ue,
                ...X(ue),
                id: ge
            };
            return ne[ge] = Te,
            Te
        } else {
            let Te = {
                ...ue,
                ...X(ue),
                id: ge,
                children: void 0
            };
            return ne[ge] = Te,
            ue.children && (Te.children = convertRoutesToDataRoutes(ue.children, X, me, ne)),
            Te
        }
    }
    )
}
function matchRoutes(V, X, J="/") {
    return matchRoutesImpl(V, X, J, !1)
}
function matchRoutesImpl(V, X, J, ne) {
    let ue = typeof X == "string" ? parsePath(X) : X
      , ce = stripBasename(ue.pathname || "/", J);
    if (ce == null)
        return null;
    let me = flattenRoutes(V);
    rankRouteBranches(me);
    let ge = null;
    for (let Te = 0; ge == null && Te < me.length; ++Te) {
        let _e = decodePath(ce);
        ge = matchRouteBranch(me[Te], _e, ne)
    }
    return ge
}
function convertRouteMatchToUiMatch(V, X) {
    let {route: J, pathname: ne, params: ue} = V;
    return {
        id: J.id,
        pathname: ne,
        params: ue,
        data: X[J.id],
        handle: J.handle
    }
}
function flattenRoutes(V, X=[], J=[], ne="") {
    let ue = (ce, me, ge) => {
        let Te = {
            relativePath: ge === void 0 ? ce.path || "" : ge,
            caseSensitive: ce.caseSensitive === !0,
            childrenIndex: me,
            route: ce
        };
        Te.relativePath.startsWith("/") && (invariant(Te.relativePath.startsWith(ne), `Absolute route path "${Te.relativePath}" nested under path "${ne}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`),
        Te.relativePath = Te.relativePath.slice(ne.length));
        let _e = joinPaths([ne, Te.relativePath])
          , Se = J.concat(Te);
        ce.children && ce.children.length > 0 && (invariant(ce.index !== !0, `Index routes must not have child routes. Please remove all child routes from route path "${_e}".`),
        flattenRoutes(ce.children, X, Se, _e)),
        !(ce.path == null && !ce.index) && X.push({
            path: _e,
            score: computeScore(_e, ce.index),
            routesMeta: Se
        })
    }
    ;
    return V.forEach( (ce, me) => {
        var ge;
        if (ce.path === "" || !((ge = ce.path) != null && ge.includes("?")))
            ue(ce, me);
        else
            for (let Te of explodeOptionalSegments(ce.path))
                ue(ce, me, Te)
    }
    ),
    X
}
function explodeOptionalSegments(V) {
    let X = V.split("/");
    if (X.length === 0)
        return [];
    let[J,...ne] = X
      , ue = J.endsWith("?")
      , ce = J.replace(/\?$/, "");
    if (ne.length === 0)
        return ue ? [ce, ""] : [ce];
    let me = explodeOptionalSegments(ne.join("/"))
      , ge = [];
    return ge.push(...me.map(Te => Te === "" ? ce : [ce, Te].join("/"))),
    ue && ge.push(...me),
    ge.map(Te => V.startsWith("/") && Te === "" ? "/" : Te)
}
function rankRouteBranches(V) {
    V.sort( (X, J) => X.score !== J.score ? J.score - X.score : compareIndexes(X.routesMeta.map(ne => ne.childrenIndex), J.routesMeta.map(ne => ne.childrenIndex)))
}
var paramRe = /^:[\w-]+$/
  , dynamicSegmentValue = 3
  , indexRouteValue = 2
  , emptySegmentValue = 1
  , staticSegmentValue = 10
  , splatPenalty = -2
  , isSplat = V => V === "*";
function computeScore(V, X) {
    let J = V.split("/")
      , ne = J.length;
    return J.some(isSplat) && (ne += splatPenalty),
    X && (ne += indexRouteValue),
    J.filter(ue => !isSplat(ue)).reduce( (ue, ce) => ue + (paramRe.test(ce) ? dynamicSegmentValue : ce === "" ? emptySegmentValue : staticSegmentValue), ne)
}
function compareIndexes(V, X) {
    return V.length === X.length && V.slice(0, -1).every( (ne, ue) => ne === X[ue]) ? V[V.length - 1] - X[X.length - 1] : 0
}
function matchRouteBranch(V, X, J=!1) {
    let {routesMeta: ne} = V
      , ue = {}
      , ce = "/"
      , me = [];
    for (let ge = 0; ge < ne.length; ++ge) {
        let Te = ne[ge]
          , _e = ge === ne.length - 1
          , Se = ce === "/" ? X : X.slice(ce.length) || "/"
          , Ie = matchPath({
            path: Te.relativePath,
            caseSensitive: Te.caseSensitive,
            end: _e
        }, Se)
          , ye = Te.route;
        if (!Ie && _e && J && !ne[ne.length - 1].route.index && (Ie = matchPath({
            path: Te.relativePath,
            caseSensitive: Te.caseSensitive,
            end: !1
        }, Se)),
        !Ie)
            return null;
        Object.assign(ue, Ie.params),
        me.push({
            params: ue,
            pathname: joinPaths([ce, Ie.pathname]),
            pathnameBase: normalizePathname(joinPaths([ce, Ie.pathnameBase])),
            route: ye
        }),
        Ie.pathnameBase !== "/" && (ce = joinPaths([ce, Ie.pathnameBase]))
    }
    return me
}
function matchPath(V, X) {
    typeof V == "string" && (V = {
        path: V,
        caseSensitive: !1,
        end: !0
    });
    let[J,ne] = compilePath(V.path, V.caseSensitive, V.end)
      , ue = X.match(J);
    if (!ue)
        return null;
    let ce = ue[0]
      , me = ce.replace(/(.)\/+$/, "$1")
      , ge = ue.slice(1);
    return {
        params: ne.reduce( (_e, {paramName: Se, isOptional: Ie}, ye) => {
            if (Se === "*") {
                let Ne = ge[ye] || "";
                me = ce.slice(0, ce.length - Ne.length).replace(/(.)\/+$/, "$1")
            }
            const $e = ge[ye];
            return Ie && !$e ? _e[Se] = void 0 : _e[Se] = ($e || "").replace(/%2F/g, "/"),
            _e
        }
        , {}),
        pathname: ce,
        pathnameBase: me,
        pattern: V
    }
}
function compilePath(V, X=!1, J=!0) {
    warning(V === "*" || !V.endsWith("*") || V.endsWith("/*"), `Route path "${V}" will be treated as if it were "${V.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${V.replace(/\*$/, "/*")}".`);
    let ne = []
      , ue = "^" + V.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (me, ge, Te) => (ne.push({
        paramName: ge,
        isOptional: Te != null
    }),
    Te ? "/?([^\\/]+)?" : "/([^\\/]+)"));
    return V.endsWith("*") ? (ne.push({
        paramName: "*"
    }),
    ue += V === "*" || V === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : J ? ue += "\\/*$" : V !== "" && V !== "/" && (ue += "(?:(?=\\/|$))"),
    [new RegExp(ue,X ? void 0 : "i"), ne]
}
function decodePath(V) {
    try {
        return V.split("/").map(X => decodeURIComponent(X).replace(/\//g, "%2F")).join("/")
    } catch (X) {
        return warning(!1, `The URL path "${V}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${X}).`),
        V
    }
}
function stripBasename(V, X) {
    if (X === "/")
        return V;
    if (!V.toLowerCase().startsWith(X.toLowerCase()))
        return null;
    let J = X.endsWith("/") ? X.length - 1 : X.length
      , ne = V.charAt(J);
    return ne && ne !== "/" ? null : V.slice(J) || "/"
}
function resolvePath(V, X="/") {
    let {pathname: J, search: ne="", hash: ue=""} = typeof V == "string" ? parsePath(V) : V;
    return {
        pathname: J ? J.startsWith("/") ? J : resolvePathname(J, X) : X,
        search: normalizeSearch(ne),
        hash: normalizeHash(ue)
    }
}
function resolvePathname(V, X) {
    let J = X.replace(/\/+$/, "").split("/");
    return V.split("/").forEach(ue => {
        ue === ".." ? J.length > 1 && J.pop() : ue !== "." && J.push(ue)
    }
    ),
    J.length > 1 ? J.join("/") : "/"
}
function getInvalidPathError(V, X, J, ne) {
    return `Cannot include a '${V}' character in a manually specified \`to.${X}\` field [${JSON.stringify(ne)}].  Please separate it out to the \`to.${J}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`
}
function getPathContributingMatches(V) {
    return V.filter( (X, J) => J === 0 || X.route.path && X.route.path.length > 0)
}
function getResolveToMatches(V) {
    let X = getPathContributingMatches(V);
    return X.map( (J, ne) => ne === X.length - 1 ? J.pathname : J.pathnameBase)
}
function resolveTo(V, X, J, ne=!1) {
    let ue;
    typeof V == "string" ? ue = parsePath(V) : (ue = {
        ...V
    },
    invariant(!ue.pathname || !ue.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", ue)),
    invariant(!ue.pathname || !ue.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", ue)),
    invariant(!ue.search || !ue.search.includes("#"), getInvalidPathError("#", "search", "hash", ue)));
    let ce = V === "" || ue.pathname === "", me = ce ? "/" : ue.pathname, ge;
    if (me == null)
        ge = J;
    else {
        let Ie = X.length - 1;
        if (!ne && me.startsWith("..")) {
            let ye = me.split("/");
            for (; ye[0] === ".."; )
                ye.shift(),
                Ie -= 1;
            ue.pathname = ye.join("/")
        }
        ge = Ie >= 0 ? X[Ie] : "/"
    }
    let Te = resolvePath(ue, ge)
      , _e = me && me !== "/" && me.endsWith("/")
      , Se = (ce || me === ".") && J.endsWith("/");
    return !Te.pathname.endsWith("/") && (_e || Se) && (Te.pathname += "/"),
    Te
}
var joinPaths = V => V.join("/").replace(/\/\/+/g, "/")
  , normalizePathname = V => V.replace(/\/+$/, "").replace(/^\/*/, "/")
  , normalizeSearch = V => !V || V === "?" ? "" : V.startsWith("?") ? V : "?" + V
  , normalizeHash = V => !V || V === "#" ? "" : V.startsWith("#") ? V : "#" + V
  , ErrorResponseImpl = class {
    constructor(V, X, J, ne=!1) {
        this.status = V,
        this.statusText = X || "",
        this.internal = ne,
        J instanceof Error ? (this.data = J.toString(),
        this.error = J) : this.data = J
    }
}
;
function isRouteErrorResponse(V) {
    return V != null && typeof V.status == "number" && typeof V.statusText == "string" && typeof V.internal == "boolean" && "data"in V
}
var validMutationMethodsArr = ["POST", "PUT", "PATCH", "DELETE"]
  , validMutationMethods = new Set(validMutationMethodsArr)
  , validRequestMethodsArr = ["GET", ...validMutationMethodsArr]
  , validRequestMethods = new Set(validRequestMethodsArr)
  , redirectStatusCodes = new Set([301, 302, 303, 307, 308])
  , redirectPreserveMethodStatusCodes = new Set([307, 308])
  , IDLE_NAVIGATION = {
    state: "idle",
    location: void 0,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0
}
  , IDLE_FETCHER = {
    state: "idle",
    data: void 0,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0
}
  , IDLE_BLOCKER = {
    state: "unblocked",
    proceed: void 0,
    reset: void 0,
    location: void 0
}
  , ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i
  , defaultMapRouteProperties = V => ({
    hasErrorBoundary: !!V.hasErrorBoundary
})
  , TRANSITIONS_STORAGE_KEY = "remix-router-transitions"
  , ResetLoaderDataSymbol = Symbol("ResetLoaderData");
function createRouter(V) {
    const X = V.window ? V.window : typeof window < "u" ? window : void 0
      , J = typeof X < "u" && typeof X.document < "u" && typeof X.document.createElement < "u";
    invariant(V.routes.length > 0, "You must provide a non-empty routes array to createRouter");
    let ne = V.mapRouteProperties || defaultMapRouteProperties, ue = {}, ce = convertRoutesToDataRoutes(V.routes, ne, void 0, ue), me, ge = V.basename || "/", Te = V.dataStrategy || defaultDataStrategyWithMiddleware, _e = {
        unstable_middleware: !1,
        ...V.future
    }, Se = null, Ie = new Set, ye = null, $e = null, Ne = null, ve = V.hydrationData != null, ke = matchRoutes(ce, V.history.location, ge), xe = !1, we = null;
    if (ke == null && !V.patchRoutesOnNavigation) {
        let _t = getInternalRouterError(404, {
            pathname: V.history.location.pathname
        })
          , {matches: Be, route: Je} = getShortCircuitMatches(ce);
        ke = Be,
        we = {
            [Je.id]: _t
        }
    }
    ke && !V.hydrationData && wn(ke, ce, V.history.location.pathname).active && (ke = null);
    let Fe;
    if (ke)
        if (ke.some(_t => _t.route.lazy))
            Fe = !1;
        else if (!ke.some(_t => _t.route.loader))
            Fe = !0;
        else {
            let _t = V.hydrationData ? V.hydrationData.loaderData : null
              , Be = V.hydrationData ? V.hydrationData.errors : null;
            if (Be) {
                let Je = ke.findIndex(ot => Be[ot.route.id] !== void 0);
                Fe = ke.slice(0, Je + 1).every(ot => !shouldLoadRouteOnHydration(ot.route, _t, Be))
            } else
                Fe = ke.every(Je => !shouldLoadRouteOnHydration(Je.route, _t, Be))
        }
    else {
        Fe = !1,
        ke = [];
        let _t = wn(null, ce, V.history.location.pathname);
        _t.active && _t.matches && (xe = !0,
        ke = _t.matches)
    }
    let je, Xe = {
        historyAction: V.history.action,
        location: V.history.location,
        matches: ke,
        initialized: Fe,
        navigation: IDLE_NAVIGATION,
        restoreScrollPosition: V.hydrationData != null ? !1 : null,
        preventScrollReset: !1,
        revalidation: "idle",
        loaderData: V.hydrationData && V.hydrationData.loaderData || {},
        actionData: V.hydrationData && V.hydrationData.actionData || null,
        errors: V.hydrationData && V.hydrationData.errors || we,
        fetchers: new Map,
        blockers: new Map
    }, ze = "POP", qe = !1, Ze, et = !1, it = new Map, at = null, rt = !1, ft = !1, St = new Set, Ye = new Map, We = 0, nt = -1, ct = new Map, Et = new Set, Ke = new Map, mt = new Map, lt = new Set, Qe = new Map, gt, Nt = null;
    function Gt() {
        if (Se = V.history.listen( ({action: _t, location: Be, delta: Je}) => {
            if (gt) {
                gt(),
                gt = void 0;
                return
            }
            warning(Qe.size === 0 || Je != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
            let ot = Sn({
                currentLocation: Xe.location,
                nextLocation: Be,
                historyAction: _t
            });
            if (ot && Je != null) {
                let pt = new Promise(xt => {
                    gt = xt
                }
                );
                V.history.go(Je * -1),
                an(ot, {
                    state: "blocked",
                    location: Be,
                    proceed() {
                        an(ot, {
                            state: "proceeding",
                            proceed: void 0,
                            reset: void 0,
                            location: Be
                        }),
                        pt.then( () => V.history.go(Je))
                    },
                    reset() {
                        let xt = new Map(Xe.blockers);
                        xt.set(ot, IDLE_BLOCKER),
                        Ot({
                            blockers: xt
                        })
                    }
                });
                return
            }
            return Jt(_t, Be)
        }
        ),
        J) {
            restoreAppliedTransitions(X, it);
            let _t = () => persistAppliedTransitions(X, it);
            X.addEventListener("pagehide", _t),
            at = () => X.removeEventListener("pagehide", _t)
        }
        return Xe.initialized || Jt("POP", Xe.location, {
            initialHydration: !0
        }),
        je
    }
    function Ht() {
        Se && Se(),
        at && at(),
        Ie.clear(),
        Ze && Ze.abort(),
        Xe.fetchers.forEach( (_t, Be) => Bt(Be)),
        Xe.blockers.forEach( (_t, Be) => Ft(Be))
    }
    function Kt(_t) {
        return Ie.add(_t),
        () => Ie.delete(_t)
    }
    function Ot(_t, Be={}) {
        Xe = {
            ...Xe,
            ..._t
        };
        let Je = []
          , ot = [];
        Xe.fetchers.forEach( (pt, xt) => {
            pt.state === "idle" && (lt.has(xt) ? Je.push(xt) : ot.push(xt))
        }
        ),
        lt.forEach(pt => {
            !Xe.fetchers.has(pt) && !Ye.has(pt) && Je.push(pt)
        }
        ),
        [...Ie].forEach(pt => pt(Xe, {
            deletedFetchers: Je,
            viewTransitionOpts: Be.viewTransitionOpts,
            flushSync: Be.flushSync === !0
        })),
        Je.forEach(pt => Bt(pt)),
        ot.forEach(pt => Xe.fetchers.delete(pt))
    }
    function kt(_t, Be, {flushSync: Je}={}) {
        var rn, un;
        let ot = Xe.actionData != null && Xe.navigation.formMethod != null && isMutationMethod(Xe.navigation.formMethod) && Xe.navigation.state === "loading" && ((rn = _t.state) == null ? void 0 : rn._isRedirect) !== !0, pt;
        Be.actionData ? Object.keys(Be.actionData).length > 0 ? pt = Be.actionData : pt = null : ot ? pt = Xe.actionData : pt = null;
        let xt = Be.loaderData ? mergeLoaderData(Xe.loaderData, Be.loaderData, Be.matches || [], Be.errors) : Xe.loaderData
          , Vt = Xe.blockers;
        Vt.size > 0 && (Vt = new Map(Vt),
        Vt.forEach( (fn, On) => Vt.set(On, IDLE_BLOCKER)));
        let Pt = qe === !0 || Xe.navigation.formMethod != null && isMutationMethod(Xe.navigation.formMethod) && ((un = _t.state) == null ? void 0 : un._isRedirect) !== !0;
        me && (ce = me,
        me = void 0),
        rt || ze === "POP" || (ze === "PUSH" ? V.history.push(_t, _t.state) : ze === "REPLACE" && V.history.replace(_t, _t.state));
        let qt;
        if (ze === "POP") {
            let fn = it.get(Xe.location.pathname);
            fn && fn.has(_t.pathname) ? qt = {
                currentLocation: Xe.location,
                nextLocation: _t
            } : it.has(_t.pathname) && (qt = {
                currentLocation: _t,
                nextLocation: Xe.location
            })
        } else if (et) {
            let fn = it.get(Xe.location.pathname);
            fn ? fn.add(_t.pathname) : (fn = new Set([_t.pathname]),
            it.set(Xe.location.pathname, fn)),
            qt = {
                currentLocation: Xe.location,
                nextLocation: _t
            }
        }
        Ot({
            ...Be,
            actionData: pt,
            loaderData: xt,
            historyAction: ze,
            location: _t,
            initialized: !0,
            navigation: IDLE_NAVIGATION,
            revalidation: "idle",
            restoreScrollPosition: En(_t, Be.matches || Xe.matches),
            preventScrollReset: Pt,
            blockers: Vt
        }, {
            viewTransitionOpts: qt,
            flushSync: Je === !0
        }),
        ze = "POP",
        qe = !1,
        et = !1,
        rt = !1,
        ft = !1,
        Nt == null || Nt.resolve(),
        Nt = null
    }
    async function Xt(_t, Be) {
        if (typeof _t == "number") {
            V.history.go(_t);
            return
        }
        let Je = normalizeTo(Xe.location, Xe.matches, ge, _t, Be == null ? void 0 : Be.fromRouteId, Be == null ? void 0 : Be.relative)
          , {path: ot, submission: pt, error: xt} = normalizeNavigateOptions(!1, Je, Be)
          , Vt = Xe.location
          , Pt = createLocation(Xe.location, ot, Be && Be.state);
        Pt = {
            ...Pt,
            ...V.history.encodeLocation(Pt)
        };
        let qt = Be && Be.replace != null ? Be.replace : void 0
          , rn = "PUSH";
        qt === !0 ? rn = "REPLACE" : qt === !1 || pt != null && isMutationMethod(pt.formMethod) && pt.formAction === Xe.location.pathname + Xe.location.search && (rn = "REPLACE");
        let un = Be && "preventScrollReset"in Be ? Be.preventScrollReset === !0 : void 0
          , fn = (Be && Be.flushSync) === !0
          , On = Sn({
            currentLocation: Vt,
            nextLocation: Pt,
            historyAction: rn
        });
        if (On) {
            an(On, {
                state: "blocked",
                location: Pt,
                proceed() {
                    an(On, {
                        state: "proceeding",
                        proceed: void 0,
                        reset: void 0,
                        location: Pt
                    }),
                    Xt(_t, Be)
                },
                reset() {
                    let Hn = new Map(Xe.blockers);
                    Hn.set(On, IDLE_BLOCKER),
                    Ot({
                        blockers: Hn
                    })
                }
            });
            return
        }
        await Jt(rn, Pt, {
            submission: pt,
            pendingError: xt,
            preventScrollReset: un,
            replace: Be && Be.replace,
            enableViewTransition: Be && Be.viewTransition,
            flushSync: fn
        })
    }
    function vt() {
        Nt || (Nt = createDeferred()),
        Ut(),
        Ot({
            revalidation: "loading"
        });
        let _t = Nt.promise;
        return Xe.navigation.state === "submitting" ? _t : Xe.navigation.state === "idle" ? (Jt(Xe.historyAction, Xe.location, {
            startUninterruptedRevalidation: !0
        }),
        _t) : (Jt(ze || Xe.historyAction, Xe.navigation.location, {
            overrideNavigation: Xe.navigation,
            enableViewTransition: et === !0
        }),
        _t)
    }
    async function Jt(_t, Be, Je) {
        Ze && Ze.abort(),
        Ze = null,
        ze = _t,
        rt = (Je && Je.startUninterruptedRevalidation) === !0,
        xn(Xe.location, Xe.matches),
        qe = (Je && Je.preventScrollReset) === !0,
        et = (Je && Je.enableViewTransition) === !0;
        let ot = me || ce
          , pt = Je && Je.overrideNavigation
          , xt = Je != null && Je.initialHydration && Xe.matches && Xe.matches.length > 0 && !xe ? Xe.matches : matchRoutes(ot, Be, ge)
          , Vt = (Je && Je.flushSync) === !0;
        if (xt && Xe.initialized && !ft && isHashChangeOnly(Xe.location, Be) && !(Je && Je.submission && isMutationMethod(Je.submission.formMethod))) {
            kt(Be, {
                matches: xt
            }, {
                flushSync: Vt
            });
            return
        }
        let Pt = wn(xt, ot, Be.pathname);
        if (Pt.active && Pt.matches && (xt = Pt.matches),
        !xt) {
            let {error: er, notFoundMatches: Wn, route: tr} = Rn(Be.pathname);
            kt(Be, {
                matches: Wn,
                loaderData: {},
                errors: {
                    [tr.id]: er
                }
            }, {
                flushSync: Vt
            });
            return
        }
        Ze = new AbortController;
        let qt = createClientSideRequest(V.history, Be, Ze.signal, Je && Je.submission), rn = new unstable_RouterContextProvider(V.unstable_getContext ? await V.unstable_getContext() : void 0), un;
        if (Je && Je.pendingError)
            un = [findNearestBoundary(xt).route.id, {
                type: "error",
                error: Je.pendingError
            }];
        else if (Je && Je.submission && isMutationMethod(Je.submission.formMethod)) {
            let er = await Ct(qt, Be, Je.submission, xt, rn, Pt.active, {
                replace: Je.replace,
                flushSync: Vt
            });
            if (er.shortCircuited)
                return;
            if (er.pendingActionResult) {
                let[Wn,tr] = er.pendingActionResult;
                if (isErrorResult(tr) && isRouteErrorResponse(tr.error) && tr.error.status === 404) {
                    Ze = null,
                    kt(Be, {
                        matches: er.matches,
                        loaderData: {},
                        errors: {
                            [Wn]: tr.error
                        }
                    });
                    return
                }
            }
            xt = er.matches || xt,
            un = er.pendingActionResult,
            pt = getLoadingNavigation(Be, Je.submission),
            Vt = !1,
            Pt.active = !1,
            qt = createClientSideRequest(V.history, qt.url, qt.signal)
        }
        let {shortCircuited: fn, matches: On, loaderData: Hn, errors: Kn} = await Mt(qt, Be, xt, rn, Pt.active, pt, Je && Je.submission, Je && Je.fetcherSubmission, Je && Je.replace, Je && Je.initialHydration === !0, Vt, un);
        fn || (Ze = null,
        kt(Be, {
            matches: On || xt,
            ...getActionDataForCommit(un),
            loaderData: Hn,
            errors: Kn
        }))
    }
    async function Ct(_t, Be, Je, ot, pt, xt, Vt={}) {
        Ut();
        let Pt = getSubmittingNavigation(Be, Je);
        if (Ot({
            navigation: Pt
        }, {
            flushSync: Vt.flushSync === !0
        }),
        xt) {
            let un = await Qn(ot, Be.pathname, _t.signal);
            if (un.type === "aborted")
                return {
                    shortCircuited: !0
                };
            if (un.type === "error") {
                let fn = findNearestBoundary(un.partialMatches).route.id;
                return {
                    matches: un.partialMatches,
                    pendingActionResult: [fn, {
                        type: "error",
                        error: un.error
                    }]
                }
            } else if (un.matches)
                ot = un.matches;
            else {
                let {notFoundMatches: fn, error: On, route: Hn} = Rn(Be.pathname);
                return {
                    matches: fn,
                    pendingActionResult: [Hn.id, {
                        type: "error",
                        error: On
                    }]
                }
            }
        }
        let qt, rn = getTargetMatch(ot, Be);
        if (!rn.route.action && !rn.route.lazy)
            qt = {
                type: "error",
                error: getInternalRouterError(405, {
                    method: _t.method,
                    pathname: Be.pathname,
                    routeId: rn.route.id
                })
            };
        else {
            let un = await zt("action", _t, [rn], ot, pt, null);
            if (qt = un[rn.route.id],
            !qt) {
                for (let fn of ot)
                    if (un[fn.route.id]) {
                        qt = un[fn.route.id];
                        break
                    }
            }
            if (_t.signal.aborted)
                return {
                    shortCircuited: !0
                }
        }
        if (isRedirectResult(qt)) {
            let un;
            return Vt && Vt.replace != null ? un = Vt.replace : un = normalizeRedirectLocation(qt.response.headers.get("Location"), new URL(_t.url), ge) === Xe.location.pathname + Xe.location.search,
            await on(_t, qt, !0, {
                submission: Je,
                replace: un
            }),
            {
                shortCircuited: !0
            }
        }
        if (isErrorResult(qt)) {
            let un = findNearestBoundary(ot, rn.route.id);
            return (Vt && Vt.replace) !== !0 && (ze = "PUSH"),
            {
                matches: ot,
                pendingActionResult: [un.route.id, qt]
            }
        }
        return {
            matches: ot,
            pendingActionResult: [rn.route.id, qt]
        }
    }
    async function Mt(_t, Be, Je, ot, pt, xt, Vt, Pt, qt, rn, un, fn) {
        let On = xt || getLoadingNavigation(Be, Vt)
          , Hn = Vt || Pt || getSubmissionFromNavigation(On)
          , Kn = !rt && !rn;
        if (pt) {
            if (Kn) {
                let ur = nn(fn);
                Ot({
                    navigation: On,
                    ...ur !== void 0 ? {
                        actionData: ur
                    } : {}
                }, {
                    flushSync: un
                })
            }
            let Un = await Qn(Je, Be.pathname, _t.signal);
            if (Un.type === "aborted")
                return {
                    shortCircuited: !0
                };
            if (Un.type === "error") {
                let ur = findNearestBoundary(Un.partialMatches).route.id;
                return {
                    matches: Un.partialMatches,
                    loaderData: {},
                    errors: {
                        [ur]: Un.error
                    }
                }
            } else if (Un.matches)
                Je = Un.matches;
            else {
                let {error: ur, notFoundMatches: io, route: Kr} = Rn(Be.pathname);
                return {
                    matches: io,
                    loaderData: {},
                    errors: {
                        [Kr.id]: ur
                    }
                }
            }
        }
        let er = me || ce
          , [Wn,tr] = getMatchesToLoad(V.history, Xe, Je, Hn, Be, rn === !0, ft, St, lt, Ke, Et, er, ge, fn);
        if (nt = ++We,
        Wn.length === 0 && tr.length === 0) {
            let Un = st();
            return kt(Be, {
                matches: Je,
                loaderData: {},
                errors: fn && isErrorResult(fn[1]) ? {
                    [fn[0]]: fn[1].error
                } : null,
                ...getActionDataForCommit(fn),
                ...Un ? {
                    fetchers: new Map(Xe.fetchers)
                } : {}
            }, {
                flushSync: un
            }),
            {
                shortCircuited: !0
            }
        }
        if (Kn) {
            let Un = {};
            if (!pt) {
                Un.navigation = On;
                let ur = nn(fn);
                ur !== void 0 && (Un.actionData = ur)
            }
            tr.length > 0 && (Un.fetchers = tn(tr)),
            Ot(Un, {
                flushSync: un
            })
        }
        tr.forEach(Un => {
            ut(Un.key),
            Un.controller && Ye.set(Un.key, Un.controller)
        }
        );
        let ms = () => tr.forEach(Un => ut(Un.key));
        Ze && Ze.signal.addEventListener("abort", ms);
        let {loaderResults: fs, fetcherResults: vr} = await $t(Je, Wn, tr, _t, ot);
        if (_t.signal.aborted)
            return {
                shortCircuited: !0
            };
        Ze && Ze.signal.removeEventListener("abort", ms),
        tr.forEach(Un => Ye.delete(Un.key));
        let _r = findRedirect(fs);
        if (_r)
            return await on(_t, _r.result, !0, {
                replace: qt
            }),
            {
                shortCircuited: !0
            };
        if (_r = findRedirect(vr),
        _r)
            return Et.add(_r.key),
            await on(_t, _r.result, !0, {
                replace: qt
            }),
            {
                shortCircuited: !0
            };
        let {loaderData: Hs, errors: oo} = processLoaderData(Xe, Je, fs, fn, tr, vr);
        rn && Xe.errors && (oo = {
            ...Xe.errors,
            ...oo
        });
        let zr = st()
          , wo = ht(nt)
          , Bo = zr || wo || tr.length > 0;
        return {
            matches: Je,
            loaderData: Hs,
            errors: oo,
            ...Bo ? {
                fetchers: new Map(Xe.fetchers)
            } : {}
        }
    }
    function nn(_t) {
        if (_t && !isErrorResult(_t[1]))
            return {
                [_t[0]]: _t[1].data
            };
        if (Xe.actionData)
            return Object.keys(Xe.actionData).length === 0 ? null : Xe.actionData
    }
    function tn(_t) {
        return _t.forEach(Be => {
            let Je = Xe.fetchers.get(Be.key)
              , ot = getLoadingFetcher(void 0, Je ? Je.data : void 0);
            Xe.fetchers.set(Be.key, ot)
        }
        ),
        new Map(Xe.fetchers)
    }
    async function mn(_t, Be, Je, ot) {
        ut(_t);
        let pt = (ot && ot.flushSync) === !0
          , xt = me || ce
          , Vt = normalizeTo(Xe.location, Xe.matches, ge, Je, Be, ot == null ? void 0 : ot.relative)
          , Pt = matchRoutes(xt, Vt, ge)
          , qt = wn(Pt, xt, Vt);
        if (qt.active && qt.matches && (Pt = qt.matches),
        !Pt) {
            yt(_t, Be, getInternalRouterError(404, {
                pathname: Vt
            }), {
                flushSync: pt
            });
            return
        }
        let {path: rn, submission: un, error: fn} = normalizeNavigateOptions(!0, Vt, ot);
        if (fn) {
            yt(_t, Be, fn, {
                flushSync: pt
            });
            return
        }
        let On = getTargetMatch(Pt, rn)
          , Hn = new unstable_RouterContextProvider(V.unstable_getContext ? await V.unstable_getContext() : void 0)
          , Kn = (ot && ot.preventScrollReset) === !0;
        if (un && isMutationMethod(un.formMethod)) {
            await dn(_t, Be, rn, On, Pt, Hn, qt.active, pt, Kn, un);
            return
        }
        Ke.set(_t, {
            routeId: Be,
            path: rn
        }),
        await Qt(_t, Be, rn, On, Pt, Hn, qt.active, pt, Kn, un)
    }
    async function dn(_t, Be, Je, ot, pt, xt, Vt, Pt, qt, rn) {
        Ut(),
        Ke.delete(_t);
        function un(nr) {
            if (!nr.route.action && !nr.route.lazy) {
                let ns = getInternalRouterError(405, {
                    method: rn.formMethod,
                    pathname: Je,
                    routeId: Be
                });
                return yt(_t, Be, ns, {
                    flushSync: Pt
                }),
                !0
            }
            return !1
        }
        if (!Vt && un(ot))
            return;
        let fn = Xe.fetchers.get(_t);
        An(_t, getSubmittingFetcher(rn, fn), {
            flushSync: Pt
        });
        let On = new AbortController
          , Hn = createClientSideRequest(V.history, Je, On.signal, rn);
        if (Vt) {
            let nr = await Qn(pt, Je, Hn.signal, _t);
            if (nr.type === "aborted")
                return;
            if (nr.type === "error") {
                yt(_t, Be, nr.error, {
                    flushSync: Pt
                });
                return
            } else if (nr.matches) {
                if (pt = nr.matches,
                ot = getTargetMatch(pt, Je),
                un(ot))
                    return
            } else {
                yt(_t, Be, getInternalRouterError(404, {
                    pathname: Je
                }), {
                    flushSync: Pt
                });
                return
            }
        }
        Ye.set(_t, On);
        let Kn = We
          , Wn = (await zt("action", Hn, [ot], pt, xt, _t))[ot.route.id];
        if (Hn.signal.aborted) {
            Ye.get(_t) === On && Ye.delete(_t);
            return
        }
        if (lt.has(_t)) {
            if (isRedirectResult(Wn) || isErrorResult(Wn)) {
                An(_t, getDoneFetcher(void 0));
                return
            }
        } else {
            if (isRedirectResult(Wn))
                if (Ye.delete(_t),
                nt > Kn) {
                    An(_t, getDoneFetcher(void 0));
                    return
                } else
                    return Et.add(_t),
                    An(_t, getLoadingFetcher(rn)),
                    on(Hn, Wn, !1, {
                        fetcherSubmission: rn,
                        preventScrollReset: qt
                    });
            if (isErrorResult(Wn)) {
                yt(_t, Be, Wn.error);
                return
            }
        }
        let tr = Xe.navigation.location || Xe.location
          , ms = createClientSideRequest(V.history, tr, On.signal)
          , fs = me || ce
          , vr = Xe.navigation.state !== "idle" ? matchRoutes(fs, Xe.navigation.location, ge) : Xe.matches;
        invariant(vr, "Didn't find any matches after fetcher action");
        let _r = ++We;
        ct.set(_t, _r);
        let Hs = getLoadingFetcher(rn, Wn.data);
        Xe.fetchers.set(_t, Hs);
        let[oo,zr] = getMatchesToLoad(V.history, Xe, vr, rn, tr, !1, ft, St, lt, Ke, Et, fs, ge, [ot.route.id, Wn]);
        zr.filter(nr => nr.key !== _t).forEach(nr => {
            let ns = nr.key
              , Si = Xe.fetchers.get(ns)
              , xa = getLoadingFetcher(void 0, Si ? Si.data : void 0);
            Xe.fetchers.set(ns, xa),
            ut(ns),
            nr.controller && Ye.set(ns, nr.controller)
        }
        ),
        Ot({
            fetchers: new Map(Xe.fetchers)
        });
        let wo = () => zr.forEach(nr => ut(nr.key));
        On.signal.addEventListener("abort", wo);
        let {loaderResults: Bo, fetcherResults: Un} = await $t(vr, oo, zr, ms, xt);
        if (On.signal.aborted)
            return;
        On.signal.removeEventListener("abort", wo),
        ct.delete(_t),
        Ye.delete(_t),
        zr.forEach(nr => Ye.delete(nr.key));
        let ur = findRedirect(Bo);
        if (ur)
            return on(ms, ur.result, !1, {
                preventScrollReset: qt
            });
        if (ur = findRedirect(Un),
        ur)
            return Et.add(ur.key),
            on(ms, ur.result, !1, {
                preventScrollReset: qt
            });
        let {loaderData: io, errors: Kr} = processLoaderData(Xe, vr, Bo, void 0, zr, Un);
        if (Xe.fetchers.has(_t)) {
            let nr = getDoneFetcher(Wn.data);
            Xe.fetchers.set(_t, nr)
        }
        ht(_r),
        Xe.navigation.state === "loading" && _r > nt ? (invariant(ze, "Expected pending action"),
        Ze && Ze.abort(),
        kt(Xe.navigation.location, {
            matches: vr,
            loaderData: io,
            errors: Kr,
            fetchers: new Map(Xe.fetchers)
        })) : (Ot({
            errors: Kr,
            loaderData: mergeLoaderData(Xe.loaderData, io, vr, Kr),
            fetchers: new Map(Xe.fetchers)
        }),
        ft = !1)
    }
    async function Qt(_t, Be, Je, ot, pt, xt, Vt, Pt, qt, rn) {
        let un = Xe.fetchers.get(_t);
        An(_t, getLoadingFetcher(rn, un ? un.data : void 0), {
            flushSync: Pt
        });
        let fn = new AbortController
          , On = createClientSideRequest(V.history, Je, fn.signal);
        if (Vt) {
            let Wn = await Qn(pt, Je, On.signal, _t);
            if (Wn.type === "aborted")
                return;
            if (Wn.type === "error") {
                yt(_t, Be, Wn.error, {
                    flushSync: Pt
                });
                return
            } else if (Wn.matches)
                pt = Wn.matches,
                ot = getTargetMatch(pt, Je);
            else {
                yt(_t, Be, getInternalRouterError(404, {
                    pathname: Je
                }), {
                    flushSync: Pt
                });
                return
            }
        }
        Ye.set(_t, fn);
        let Hn = We
          , er = (await zt("loader", On, [ot], pt, xt, _t))[ot.route.id];
        if (Ye.get(_t) === fn && Ye.delete(_t),
        !On.signal.aborted) {
            if (lt.has(_t)) {
                An(_t, getDoneFetcher(void 0));
                return
            }
            if (isRedirectResult(er))
                if (nt > Hn) {
                    An(_t, getDoneFetcher(void 0));
                    return
                } else {
                    Et.add(_t),
                    await on(On, er, !1, {
                        preventScrollReset: qt
                    });
                    return
                }
            if (isErrorResult(er)) {
                yt(_t, Be, er.error);
                return
            }
            An(_t, getDoneFetcher(er.data))
        }
    }
    async function on(_t, Be, Je, {submission: ot, fetcherSubmission: pt, preventScrollReset: xt, replace: Vt}={}) {
        Be.response.headers.has("X-Remix-Revalidate") && (ft = !0);
        let Pt = Be.response.headers.get("Location");
        invariant(Pt, "Expected a Location header on the redirect Response"),
        Pt = normalizeRedirectLocation(Pt, new URL(_t.url), ge);
        let qt = createLocation(Xe.location, Pt, {
            _isRedirect: !0
        });
        if (J) {
            let Kn = !1;
            if (Be.response.headers.has("X-Remix-Reload-Document"))
                Kn = !0;
            else if (ABSOLUTE_URL_REGEX.test(Pt)) {
                const er = V.history.createURL(Pt);
                Kn = er.origin !== X.location.origin || stripBasename(er.pathname, ge) == null
            }
            if (Kn) {
                Vt ? X.location.replace(Pt) : X.location.assign(Pt);
                return
            }
        }
        Ze = null;
        let rn = Vt === !0 || Be.response.headers.has("X-Remix-Replace") ? "REPLACE" : "PUSH"
          , {formMethod: un, formAction: fn, formEncType: On} = Xe.navigation;
        !ot && !pt && un && fn && On && (ot = getSubmissionFromNavigation(Xe.navigation));
        let Hn = ot || pt;
        if (redirectPreserveMethodStatusCodes.has(Be.response.status) && Hn && isMutationMethod(Hn.formMethod))
            await Jt(rn, qt, {
                submission: {
                    ...Hn,
                    formAction: Pt
                },
                preventScrollReset: xt || qe,
                enableViewTransition: Je ? et : void 0
            });
        else {
            let Kn = getLoadingNavigation(qt, ot);
            await Jt(rn, qt, {
                overrideNavigation: Kn,
                fetcherSubmission: pt,
                preventScrollReset: xt || qe,
                enableViewTransition: Je ? et : void 0
            })
        }
    }
    async function zt(_t, Be, Je, ot, pt, xt) {
        let Vt, Pt = {};
        try {
            Vt = await callDataStrategyImpl(Te, _t, Be, Je, ot, xt, ue, ne, pt, _e.unstable_middleware)
        } catch (qt) {
            return Je.forEach(rn => {
                Pt[rn.route.id] = {
                    type: "error",
                    error: qt
                }
            }
            ),
            Pt
        }
        for (let[qt,rn] of Object.entries(Vt))
            if (isRedirectDataStrategyResult(rn)) {
                let un = rn.result;
                Pt[qt] = {
                    type: "redirect",
                    response: normalizeRelativeRoutingRedirectResponse(un, Be, qt, ot, ge)
                }
            } else
                Pt[qt] = await convertDataStrategyResultToDataResult(rn);
        return Pt
    }
    async function $t(_t, Be, Je, ot, pt) {
        let xt = zt("loader", ot, Be, _t, pt, null)
          , Vt = Promise.all(Je.map(async rn => {
            if (rn.matches && rn.match && rn.controller) {
                let fn = (await zt("loader", createClientSideRequest(V.history, rn.path, rn.controller.signal), [rn.match], rn.matches, pt, rn.key))[rn.match.route.id];
                return {
                    [rn.key]: fn
                }
            } else
                return Promise.resolve({
                    [rn.key]: {
                        type: "error",
                        error: getInternalRouterError(404, {
                            pathname: rn.path
                        })
                    }
                })
        }
        ))
          , Pt = await xt
          , qt = (await Vt).reduce( (rn, un) => Object.assign(rn, un), {});
        return {
            loaderResults: Pt,
            fetcherResults: qt
        }
    }
    function Ut() {
        ft = !0,
        Ke.forEach( (_t, Be) => {
            Ye.has(Be) && St.add(Be),
            ut(Be)
        }
        )
    }
    function An(_t, Be, Je={}) {
        Xe.fetchers.set(_t, Be),
        Ot({
            fetchers: new Map(Xe.fetchers)
        }, {
            flushSync: (Je && Je.flushSync) === !0
        })
    }
    function yt(_t, Be, Je, ot={}) {
        let pt = findNearestBoundary(Xe.matches, Be);
        Bt(_t),
        Ot({
            errors: {
                [pt.route.id]: Je
            },
            fetchers: new Map(Xe.fetchers)
        }, {
            flushSync: (ot && ot.flushSync) === !0
        })
    }
    function Dt(_t) {
        return mt.set(_t, (mt.get(_t) || 0) + 1),
        lt.has(_t) && lt.delete(_t),
        Xe.fetchers.get(_t) || IDLE_FETCHER
    }
    function Bt(_t) {
        let Be = Xe.fetchers.get(_t);
        Ye.has(_t) && !(Be && Be.state === "loading" && ct.has(_t)) && ut(_t),
        Ke.delete(_t),
        ct.delete(_t),
        Et.delete(_t),
        lt.delete(_t),
        St.delete(_t),
        Xe.fetchers.delete(_t)
    }
    function Wt(_t) {
        let Be = (mt.get(_t) || 0) - 1;
        Be <= 0 ? (mt.delete(_t),
        lt.add(_t)) : mt.set(_t, Be),
        Ot({
            fetchers: new Map(Xe.fetchers)
        })
    }
    function ut(_t) {
        let Be = Ye.get(_t);
        Be && (Be.abort(),
        Ye.delete(_t))
    }
    function Ge(_t) {
        for (let Be of _t) {
            let Je = Dt(Be)
              , ot = getDoneFetcher(Je.data);
            Xe.fetchers.set(Be, ot)
        }
    }
    function st() {
        let _t = []
          , Be = !1;
        for (let Je of Et) {
            let ot = Xe.fetchers.get(Je);
            invariant(ot, `Expected fetcher: ${Je}`),
            ot.state === "loading" && (Et.delete(Je),
            _t.push(Je),
            Be = !0)
        }
        return Ge(_t),
        Be
    }
    function ht(_t) {
        let Be = [];
        for (let[Je,ot] of ct)
            if (ot < _t) {
                let pt = Xe.fetchers.get(Je);
                invariant(pt, `Expected fetcher: ${Je}`),
                pt.state === "loading" && (ut(Je),
                ct.delete(Je),
                Be.push(Je))
            }
        return Ge(Be),
        Be.length > 0
    }
    function At(_t, Be) {
        let Je = Xe.blockers.get(_t) || IDLE_BLOCKER;
        return Qe.get(_t) !== Be && Qe.set(_t, Be),
        Je
    }
    function Ft(_t) {
        Xe.blockers.delete(_t),
        Qe.delete(_t)
    }
    function an(_t, Be) {
        let Je = Xe.blockers.get(_t) || IDLE_BLOCKER;
        invariant(Je.state === "unblocked" && Be.state === "blocked" || Je.state === "blocked" && Be.state === "blocked" || Je.state === "blocked" && Be.state === "proceeding" || Je.state === "blocked" && Be.state === "unblocked" || Je.state === "proceeding" && Be.state === "unblocked", `Invalid blocker state transition: ${Je.state} -> ${Be.state}`);
        let ot = new Map(Xe.blockers);
        ot.set(_t, Be),
        Ot({
            blockers: ot
        })
    }
    function Sn({currentLocation: _t, nextLocation: Be, historyAction: Je}) {
        if (Qe.size === 0)
            return;
        Qe.size > 1 && warning(!1, "A router only supports one blocker at a time");
        let ot = Array.from(Qe.entries())
          , [pt,xt] = ot[ot.length - 1]
          , Vt = Xe.blockers.get(pt);
        if (!(Vt && Vt.state === "proceeding") && xt({
            currentLocation: _t,
            nextLocation: Be,
            historyAction: Je
        }))
            return pt
    }
    function Rn(_t) {
        let Be = getInternalRouterError(404, {
            pathname: _t
        })
          , Je = me || ce
          , {matches: ot, route: pt} = getShortCircuitMatches(Je);
        return {
            notFoundMatches: ot,
            route: pt,
            error: Be
        }
    }
    function ts(_t, Be, Je) {
        if (ye = _t,
        Ne = Be,
        $e = Je || null,
        !ve && Xe.navigation === IDLE_NAVIGATION) {
            ve = !0;
            let ot = En(Xe.location, Xe.matches);
            ot != null && Ot({
                restoreScrollPosition: ot
            })
        }
        return () => {
            ye = null,
            Ne = null,
            $e = null
        }
    }
    function yn(_t, Be) {
        return $e && $e(_t, Be.map(ot => convertRouteMatchToUiMatch(ot, Xe.loaderData))) || _t.key
    }
    function xn(_t, Be) {
        if (ye && Ne) {
            let Je = yn(_t, Be);
            ye[Je] = Ne()
        }
    }
    function En(_t, Be) {
        if (ye) {
            let Je = yn(_t, Be)
              , ot = ye[Je];
            if (typeof ot == "number")
                return ot
        }
        return null
    }
    function wn(_t, Be, Je) {
        if (V.patchRoutesOnNavigation)
            if (_t) {
                if (Object.keys(_t[0].params).length > 0)
                    return {
                        active: !0,
                        matches: matchRoutesImpl(Be, Je, ge, !0)
                    }
            } else
                return {
                    active: !0,
                    matches: matchRoutesImpl(Be, Je, ge, !0) || []
                };
        return {
            active: !1,
            matches: null
        }
    }
    async function Qn(_t, Be, Je, ot) {
        if (!V.patchRoutesOnNavigation)
            return {
                type: "success",
                matches: _t
            };
        let pt = _t;
        for (; ; ) {
            let xt = me == null
              , Vt = me || ce
              , Pt = ue;
            try {
                await V.patchRoutesOnNavigation({
                    signal: Je,
                    path: Be,
                    matches: pt,
                    fetcherKey: ot,
                    patch: (un, fn) => {
                        Je.aborted || patchRoutesImpl(un, fn, Vt, Pt, ne)
                    }
                })
            } catch (un) {
                return {
                    type: "error",
                    error: un,
                    partialMatches: pt
                }
            } finally {
                xt && !Je.aborted && (ce = [...ce])
            }
            if (Je.aborted)
                return {
                    type: "aborted"
                };
            let qt = matchRoutes(Vt, Be, ge);
            if (qt)
                return {
                    type: "success",
                    matches: qt
                };
            let rn = matchRoutesImpl(Vt, Be, ge, !0);
            if (!rn || pt.length === rn.length && pt.every( (un, fn) => un.route.id === rn[fn].route.id))
                return {
                    type: "success",
                    matches: null
                };
            pt = rn
        }
    }
    function pr(_t) {
        ue = {},
        me = convertRoutesToDataRoutes(_t, ne, void 0, ue)
    }
    function ar(_t, Be) {
        let Je = me == null;
        patchRoutesImpl(_t, Be, me || ce, ue, ne),
        Je && (ce = [...ce],
        Ot({}))
    }
    return je = {
        get basename() {
            return ge
        },
        get future() {
            return _e
        },
        get state() {
            return Xe
        },
        get routes() {
            return ce
        },
        get window() {
            return X
        },
        initialize: Gt,
        subscribe: Kt,
        enableScrollRestoration: ts,
        navigate: Xt,
        fetch: mn,
        revalidate: vt,
        createHref: _t => V.history.createHref(_t),
        encodeLocation: _t => V.history.encodeLocation(_t),
        getFetcher: Dt,
        deleteFetcher: Wt,
        dispose: Ht,
        getBlocker: At,
        deleteBlocker: Ft,
        patchRoutes: ar,
        _internalFetchControllers: Ye,
        _internalSetRoutes: pr
    },
    je
}
function isSubmissionNavigation(V) {
    return V != null && ("formData"in V && V.formData != null || "body"in V && V.body !== void 0)
}
function normalizeTo(V, X, J, ne, ue, ce) {
    let me, ge;
    if (ue) {
        me = [];
        for (let _e of X)
            if (me.push(_e),
            _e.route.id === ue) {
                ge = _e;
                break
            }
    } else
        me = X,
        ge = X[X.length - 1];
    let Te = resolveTo(ne || ".", getResolveToMatches(me), stripBasename(V.pathname, J) || V.pathname, ce === "path");
    if (ne == null && (Te.search = V.search,
    Te.hash = V.hash),
    (ne == null || ne === "" || ne === ".") && ge) {
        let _e = hasNakedIndexQuery(Te.search);
        if (ge.route.index && !_e)
            Te.search = Te.search ? Te.search.replace(/^\?/, "?index&") : "?index";
        else if (!ge.route.index && _e) {
            let Se = new URLSearchParams(Te.search)
              , Ie = Se.getAll("index");
            Se.delete("index"),
            Ie.filter($e => $e).forEach($e => Se.append("index", $e));
            let ye = Se.toString();
            Te.search = ye ? `?${ye}` : ""
        }
    }
    return J !== "/" && (Te.pathname = Te.pathname === "/" ? J : joinPaths([J, Te.pathname])),
    createPath(Te)
}
function normalizeNavigateOptions(V, X, J) {
    if (!J || !isSubmissionNavigation(J))
        return {
            path: X
        };
    if (J.formMethod && !isValidMethod(J.formMethod))
        return {
            path: X,
            error: getInternalRouterError(405, {
                method: J.formMethod
            })
        };
    let ne = () => ({
        path: X,
        error: getInternalRouterError(400, {
            type: "invalid-body"
        })
    })
      , ce = (J.formMethod || "get").toUpperCase()
      , me = stripHashFromPath(X);
    if (J.body !== void 0) {
        if (J.formEncType === "text/plain") {
            if (!isMutationMethod(ce))
                return ne();
            let Ie = typeof J.body == "string" ? J.body : J.body instanceof FormData || J.body instanceof URLSearchParams ? Array.from(J.body.entries()).reduce( (ye, [$e,Ne]) => `${ye}${$e}=${Ne}
`, "") : String(J.body);
            return {
                path: X,
                submission: {
                    formMethod: ce,
                    formAction: me,
                    formEncType: J.formEncType,
                    formData: void 0,
                    json: void 0,
                    text: Ie
                }
            }
        } else if (J.formEncType === "application/json") {
            if (!isMutationMethod(ce))
                return ne();
            try {
                let Ie = typeof J.body == "string" ? JSON.parse(J.body) : J.body;
                return {
                    path: X,
                    submission: {
                        formMethod: ce,
                        formAction: me,
                        formEncType: J.formEncType,
                        formData: void 0,
                        json: Ie,
                        text: void 0
                    }
                }
            } catch {
                return ne()
            }
        }
    }
    invariant(typeof FormData == "function", "FormData is not available in this environment");
    let ge, Te;
    if (J.formData)
        ge = convertFormDataToSearchParams(J.formData),
        Te = J.formData;
    else if (J.body instanceof FormData)
        ge = convertFormDataToSearchParams(J.body),
        Te = J.body;
    else if (J.body instanceof URLSearchParams)
        ge = J.body,
        Te = convertSearchParamsToFormData(ge);
    else if (J.body == null)
        ge = new URLSearchParams,
        Te = new FormData;
    else
        try {
            ge = new URLSearchParams(J.body),
            Te = convertSearchParamsToFormData(ge)
        } catch {
            return ne()
        }
    let _e = {
        formMethod: ce,
        formAction: me,
        formEncType: J && J.formEncType || "application/x-www-form-urlencoded",
        formData: Te,
        json: void 0,
        text: void 0
    };
    if (isMutationMethod(_e.formMethod))
        return {
            path: X,
            submission: _e
        };
    let Se = parsePath(X);
    return V && Se.search && hasNakedIndexQuery(Se.search) && ge.append("index", ""),
    Se.search = `?${ge}`,
    {
        path: createPath(Se),
        submission: _e
    }
}
function getLoaderMatchesUntilBoundary(V, X, J=!1) {
    let ne = V.findIndex(ue => ue.route.id === X);
    return ne >= 0 ? V.slice(0, J ? ne + 1 : ne) : V
}
function getMatchesToLoad(V, X, J, ne, ue, ce, me, ge, Te, _e, Se, Ie, ye, $e) {
    let Ne = $e ? isErrorResult($e[1]) ? $e[1].error : $e[1].data : void 0
      , ve = V.createURL(X.location)
      , ke = V.createURL(ue)
      , xe = J;
    ce && X.errors ? xe = getLoaderMatchesUntilBoundary(J, Object.keys(X.errors)[0], !0) : $e && isErrorResult($e[1]) && (xe = getLoaderMatchesUntilBoundary(J, $e[0]));
    let we = $e ? $e[1].statusCode : void 0
      , Fe = we && we >= 400
      , je = xe.filter( (ze, qe) => {
        let {route: Ze} = ze;
        if (Ze.lazy)
            return !0;
        if (Ze.loader == null)
            return !1;
        if (ce)
            return shouldLoadRouteOnHydration(Ze, X.loaderData, X.errors);
        if (isNewLoader(X.loaderData, X.matches[qe], ze))
            return !0;
        let et = X.matches[qe]
          , it = ze;
        return shouldRevalidateLoader(ze, {
            currentUrl: ve,
            currentParams: et.params,
            nextUrl: ke,
            nextParams: it.params,
            ...ne,
            actionResult: Ne,
            actionStatus: we,
            defaultShouldRevalidate: Fe ? !1 : me || ve.pathname + ve.search === ke.pathname + ke.search || ve.search !== ke.search || isNewRouteInstance(et, it)
        })
    }
    )
      , Xe = [];
    return _e.forEach( (ze, qe) => {
        if (ce || !J.some(rt => rt.route.id === ze.routeId) || Te.has(qe))
            return;
        let Ze = matchRoutes(Ie, ze.path, ye);
        if (!Ze) {
            Xe.push({
                key: qe,
                routeId: ze.routeId,
                path: ze.path,
                matches: null,
                match: null,
                controller: null
            });
            return
        }
        let et = X.fetchers.get(qe)
          , it = getTargetMatch(Ze, ze.path)
          , at = !1;
        Se.has(qe) ? at = !1 : ge.has(qe) ? (ge.delete(qe),
        at = !0) : et && et.state !== "idle" && et.data === void 0 ? at = me : at = shouldRevalidateLoader(it, {
            currentUrl: ve,
            currentParams: X.matches[X.matches.length - 1].params,
            nextUrl: ke,
            nextParams: J[J.length - 1].params,
            ...ne,
            actionResult: Ne,
            actionStatus: we,
            defaultShouldRevalidate: Fe ? !1 : me
        }),
        at && Xe.push({
            key: qe,
            routeId: ze.routeId,
            path: ze.path,
            matches: Ze,
            match: it,
            controller: new AbortController
        })
    }
    ),
    [je, Xe]
}
function shouldLoadRouteOnHydration(V, X, J) {
    if (V.lazy)
        return !0;
    if (!V.loader)
        return !1;
    let ne = X != null && X[V.id] !== void 0
      , ue = J != null && J[V.id] !== void 0;
    return !ne && ue ? !1 : typeof V.loader == "function" && V.loader.hydrate === !0 ? !0 : !ne && !ue
}
function isNewLoader(V, X, J) {
    let ne = !X || J.route.id !== X.route.id
      , ue = !V.hasOwnProperty(J.route.id);
    return ne || ue
}
function isNewRouteInstance(V, X) {
    let J = V.route.path;
    return V.pathname !== X.pathname || J != null && J.endsWith("*") && V.params["*"] !== X.params["*"]
}
function shouldRevalidateLoader(V, X) {
    if (V.route.shouldRevalidate) {
        let J = V.route.shouldRevalidate(X);
        if (typeof J == "boolean")
            return J
    }
    return X.defaultShouldRevalidate
}
function patchRoutesImpl(V, X, J, ne, ue) {
    let ce;
    if (V) {
        let Te = ne[V];
        invariant(Te, `No route found to patch children into: routeId = ${V}`),
        Te.children || (Te.children = []),
        ce = Te.children
    } else
        ce = J;
    let me = X.filter(Te => !ce.some(_e => isSameRoute(Te, _e)))
      , ge = convertRoutesToDataRoutes(me, ue, [V || "_", "patch", String((ce == null ? void 0 : ce.length) || "0")], ne);
    ce.push(...ge)
}
function isSameRoute(V, X) {
    return "id"in V && "id"in X && V.id === X.id ? !0 : V.index === X.index && V.path === X.path && V.caseSensitive === X.caseSensitive ? (!V.children || V.children.length === 0) && (!X.children || X.children.length === 0) ? !0 : V.children.every( (J, ne) => {
        var ue;
        return (ue = X.children) == null ? void 0 : ue.some(ce => isSameRoute(J, ce))
    }
    ) : !1
}
async function loadLazyRouteModule(V, X, J) {
    if (!V.lazy)
        return;
    let ne = await V.lazy();
    if (!V.lazy)
        return;
    let ue = J[V.id];
    invariant(ue, "No route found in manifest");
    let ce = {};
    for (let me in ne) {
        let Te = ue[me] !== void 0 && me !== "hasErrorBoundary";
        warning(!Te, `Route "${ue.id}" has a static property "${me}" defined but its lazy function is also returning a value for this property. The lazy route property "${me}" will be ignored.`),
        !Te && !immutableRouteKeys.has(me) && (ce[me] = ne[me])
    }
    Object.assign(ue, ce),
    Object.assign(ue, {
        ...X(ue),
        lazy: void 0
    })
}
async function defaultDataStrategy(V) {
    let X = V.matches.filter(ue => ue.shouldLoad)
      , J = {};
    return (await Promise.all(X.map(ue => ue.resolve()))).forEach( (ue, ce) => {
        J[X[ce].route.id] = ue
    }
    ),
    J
}
async function defaultDataStrategyWithMiddleware(V) {
    return V.matches.some(X => X.route.unstable_middleware) ? runMiddlewarePipeline(V, !1, () => defaultDataStrategy(V), X => ({
        [X.routeId]: {
            type: "error",
            result: X.error
        }
    })) : defaultDataStrategy(V)
}
async function runMiddlewarePipeline(V, X, J, ne) {
    let {matches: ue, request: ce, params: me, context: ge} = V
      , Te = {
        handlerResult: void 0,
        propagateResult: X
    };
    try {
        let _e = ue.flatMap(Ie => Ie.route.unstable_middleware ? Ie.route.unstable_middleware.map(ye => [Ie.route.id, ye]) : [])
          , Se = await callRouteMiddleware({
            request: ce,
            params: me,
            context: ge
        }, _e, Te, J);
        return Te.propagateResult ? Se : Te.handlerResult
    } catch (_e) {
        if (!(_e instanceof MiddlewareError))
            throw _e;
        let Se = await ne(_e);
        return Te.handlerResult ? Object.assign(Te.handlerResult, Se) : Se
    }
}
var MiddlewareError = class {
    constructor(V, X) {
        this.routeId = V,
        this.error = X
    }
}
;
async function callRouteMiddleware(V, X, J, ne, ue=0) {
    let {request: ce} = V;
    if (ce.signal.aborted)
        throw ce.signal.reason ? ce.signal.reason : new Error(`Request aborted without an \`AbortSignal.reason\`: ${ce.method} ${ce.url}`);
    let me = X[ue];
    if (!me)
        return J.handlerResult = await ne(),
        J.handlerResult;
    let[ge,Te] = me, _e = !1, Se, Ie = async () => {
        if (_e)
            throw new Error("You may only call `next()` once per middleware");
        _e = !0;
        let ye = await callRouteMiddleware(V, X, J, ne, ue + 1);
        if (J.propagateResult)
            return Se = ye,
            Se
    }
    ;
    try {
        let ye = await Te({
            request: V.request,
            params: V.params,
            context: V.context
        }, Ie);
        return _e ? ye === void 0 ? Se : ye : Ie()
    } catch (ye) {
        throw ye instanceof MiddlewareError ? ye : new MiddlewareError(ge,ye)
    }
}
async function callDataStrategyImpl(V, X, J, ne, ue, ce, me, ge, Te, _e) {
    let Se = ue.map($e => $e.route.lazy ? loadLazyRouteModule($e.route, ge, me) : void 0);
    _e && await Promise.all(Se);
    let Ie = ue.map( ($e, Ne) => {
        let ve = Se[Ne]
          , ke = ne.some(we => we.route.id === $e.route.id);
        return {
            ...$e,
            shouldLoad: ke,
            resolve: async we => (we && J.method === "GET" && ($e.route.lazy || $e.route.loader) && (ke = !0),
            ke ? callLoaderOrAction(X, J, $e, ve, we, Te) : Promise.resolve({
                type: "data",
                result: void 0
            }))
        }
    }
    )
      , ye = await V({
        matches: Ie,
        request: J,
        params: ue[0].params,
        fetcherKey: ce,
        context: Te
    });
    try {
        await Promise.all(Se)
    } catch {}
    return ye
}
async function callLoaderOrAction(V, X, J, ne, ue, ce) {
    let me, ge, Te = _e => {
        let Se, Ie = new Promise( (Ne, ve) => Se = ve);
        ge = () => Se(),
        X.signal.addEventListener("abort", ge);
        let ye = Ne => typeof _e != "function" ? Promise.reject(new Error(`You cannot call the handler for a route which defines a boolean "${V}" [routeId: ${J.route.id}]`)) : _e({
            request: X,
            params: J.params,
            context: ce
        }, ...Ne !== void 0 ? [Ne] : [])
          , $e = (async () => {
            try {
                return {
                    type: "data",
                    result: await (ue ? ue(ve => ye(ve)) : ye())
                }
            } catch (Ne) {
                return {
                    type: "error",
                    result: Ne
                }
            }
        }
        )();
        return Promise.race([$e, Ie])
    }
    ;
    try {
        let _e = J.route[V];
        if (ne)
            if (_e) {
                let Se, [Ie] = await Promise.all([Te(_e).catch(ye => {
                    Se = ye
                }
                ), ne]);
                if (Se !== void 0)
                    throw Se;
                me = Ie
            } else if (await ne,
            _e = J.route[V],
            _e)
                me = await Te(_e);
            else if (V === "action") {
                let Se = new URL(X.url)
                  , Ie = Se.pathname + Se.search;
                throw getInternalRouterError(405, {
                    method: X.method,
                    pathname: Ie,
                    routeId: J.route.id
                })
            } else
                return {
                    type: "data",
                    result: void 0
                };
        else if (_e)
            me = await Te(_e);
        else {
            let Se = new URL(X.url)
              , Ie = Se.pathname + Se.search;
            throw getInternalRouterError(404, {
                pathname: Ie
            })
        }
    } catch (_e) {
        return {
            type: "error",
            result: _e
        }
    } finally {
        ge && X.signal.removeEventListener("abort", ge)
    }
    return me
}
async function convertDataStrategyResultToDataResult(V) {
    var ne, ue, ce, me, ge, Te;
    let {result: X, type: J} = V;
    if (isResponse(X)) {
        let _e;
        try {
            let Se = X.headers.get("Content-Type");
            Se && /\bapplication\/json\b/.test(Se) ? X.body == null ? _e = null : _e = await X.json() : _e = await X.text()
        } catch (Se) {
            return {
                type: "error",
                error: Se
            }
        }
        return J === "error" ? {
            type: "error",
            error: new ErrorResponseImpl(X.status,X.statusText,_e),
            statusCode: X.status,
            headers: X.headers
        } : {
            type: "data",
            data: _e,
            statusCode: X.status,
            headers: X.headers
        }
    }
    return J === "error" ? isDataWithResponseInit(X) ? X.data instanceof Error ? {
        type: "error",
        error: X.data,
        statusCode: (ne = X.init) == null ? void 0 : ne.status,
        headers: (ue = X.init) != null && ue.headers ? new Headers(X.init.headers) : void 0
    } : {
        type: "error",
        error: new ErrorResponseImpl(((ce = X.init) == null ? void 0 : ce.status) || 500,void 0,X.data),
        statusCode: isRouteErrorResponse(X) ? X.status : void 0,
        headers: (me = X.init) != null && me.headers ? new Headers(X.init.headers) : void 0
    } : {
        type: "error",
        error: X,
        statusCode: isRouteErrorResponse(X) ? X.status : void 0
    } : isDataWithResponseInit(X) ? {
        type: "data",
        data: X.data,
        statusCode: (ge = X.init) == null ? void 0 : ge.status,
        headers: (Te = X.init) != null && Te.headers ? new Headers(X.init.headers) : void 0
    } : {
        type: "data",
        data: X
    }
}
function normalizeRelativeRoutingRedirectResponse(V, X, J, ne, ue) {
    let ce = V.headers.get("Location");
    if (invariant(ce, "Redirects returned/thrown from loaders/actions must have a Location header"),
    !ABSOLUTE_URL_REGEX.test(ce)) {
        let me = ne.slice(0, ne.findIndex(ge => ge.route.id === J) + 1);
        ce = normalizeTo(new URL(X.url), me, ue, ce),
        V.headers.set("Location", ce)
    }
    return V
}
function normalizeRedirectLocation(V, X, J) {
    if (ABSOLUTE_URL_REGEX.test(V)) {
        let ne = V
          , ue = ne.startsWith("//") ? new URL(X.protocol + ne) : new URL(ne)
          , ce = stripBasename(ue.pathname, J) != null;
        if (ue.origin === X.origin && ce)
            return ue.pathname + ue.search + ue.hash
    }
    return V
}
function createClientSideRequest(V, X, J, ne) {
    let ue = V.createURL(stripHashFromPath(X)).toString()
      , ce = {
        signal: J
    };
    if (ne && isMutationMethod(ne.formMethod)) {
        let {formMethod: me, formEncType: ge} = ne;
        ce.method = me.toUpperCase(),
        ge === "application/json" ? (ce.headers = new Headers({
            "Content-Type": ge
        }),
        ce.body = JSON.stringify(ne.json)) : ge === "text/plain" ? ce.body = ne.text : ge === "application/x-www-form-urlencoded" && ne.formData ? ce.body = convertFormDataToSearchParams(ne.formData) : ce.body = ne.formData
    }
    return new Request(ue,ce)
}
function convertFormDataToSearchParams(V) {
    let X = new URLSearchParams;
    for (let[J,ne] of V.entries())
        X.append(J, typeof ne == "string" ? ne : ne.name);
    return X
}
function convertSearchParamsToFormData(V) {
    let X = new FormData;
    for (let[J,ne] of V.entries())
        X.append(J, ne);
    return X
}
function processRouteLoaderData(V, X, J, ne=!1, ue=!1) {
    let ce = {}, me = null, ge, Te = !1, _e = {}, Se = J && isErrorResult(J[1]) ? J[1].error : void 0;
    return V.forEach(Ie => {
        if (!(Ie.route.id in X))
            return;
        let ye = Ie.route.id
          , $e = X[ye];
        if (invariant(!isRedirectResult($e), "Cannot handle redirect results in processLoaderData"),
        isErrorResult($e)) {
            let Ne = $e.error;
            if (Se !== void 0 && (Ne = Se,
            Se = void 0),
            me = me || {},
            ue)
                me[ye] = Ne;
            else {
                let ve = findNearestBoundary(V, ye);
                me[ve.route.id] == null && (me[ve.route.id] = Ne)
            }
            ne || (ce[ye] = ResetLoaderDataSymbol),
            Te || (Te = !0,
            ge = isRouteErrorResponse($e.error) ? $e.error.status : 500),
            $e.headers && (_e[ye] = $e.headers)
        } else
            ce[ye] = $e.data,
            $e.statusCode && $e.statusCode !== 200 && !Te && (ge = $e.statusCode),
            $e.headers && (_e[ye] = $e.headers)
    }
    ),
    Se !== void 0 && J && (me = {
        [J[0]]: Se
    },
    ce[J[0]] = void 0),
    {
        loaderData: ce,
        errors: me,
        statusCode: ge || 200,
        loaderHeaders: _e
    }
}
function processLoaderData(V, X, J, ne, ue, ce) {
    let {loaderData: me, errors: ge} = processRouteLoaderData(X, J, ne);
    return ue.forEach(Te => {
        let {key: _e, match: Se, controller: Ie} = Te
          , ye = ce[_e];
        if (invariant(ye, "Did not find corresponding fetcher result"),
        !(Ie && Ie.signal.aborted))
            if (isErrorResult(ye)) {
                let $e = findNearestBoundary(V.matches, Se == null ? void 0 : Se.route.id);
                ge && ge[$e.route.id] || (ge = {
                    ...ge,
                    [$e.route.id]: ye.error
                }),
                V.fetchers.delete(_e)
            } else if (isRedirectResult(ye))
                invariant(!1, "Unhandled fetcher revalidation redirect");
            else {
                let $e = getDoneFetcher(ye.data);
                V.fetchers.set(_e, $e)
            }
    }
    ),
    {
        loaderData: me,
        errors: ge
    }
}
function mergeLoaderData(V, X, J, ne) {
    let ue = Object.entries(X).filter( ([,ce]) => ce !== ResetLoaderDataSymbol).reduce( (ce, [me,ge]) => (ce[me] = ge,
    ce), {});
    for (let ce of J) {
        let me = ce.route.id;
        if (!X.hasOwnProperty(me) && V.hasOwnProperty(me) && ce.route.loader && (ue[me] = V[me]),
        ne && ne.hasOwnProperty(me))
            break
    }
    return ue
}
function getActionDataForCommit(V) {
    return V ? isErrorResult(V[1]) ? {
        actionData: {}
    } : {
        actionData: {
            [V[0]]: V[1].data
        }
    } : {}
}
function findNearestBoundary(V, X) {
    return (X ? V.slice(0, V.findIndex(ne => ne.route.id === X) + 1) : [...V]).reverse().find(ne => ne.route.hasErrorBoundary === !0) || V[0]
}
function getShortCircuitMatches(V) {
    let X = V.length === 1 ? V[0] : V.find(J => J.index || !J.path || J.path === "/") || {
        id: "__shim-error-route__"
    };
    return {
        matches: [{
            params: {},
            pathname: "",
            pathnameBase: "",
            route: X
        }],
        route: X
    }
}
function getInternalRouterError(V, {pathname: X, routeId: J, method: ne, type: ue, message: ce}={}) {
    let me = "Unknown Server Error"
      , ge = "Unknown @remix-run/router error";
    return V === 400 ? (me = "Bad Request",
    ne && X && J ? ge = `You made a ${ne} request to "${X}" but did not provide a \`loader\` for route "${J}", so there is no way to handle the request.` : ue === "invalid-body" && (ge = "Unable to encode submission body")) : V === 403 ? (me = "Forbidden",
    ge = `Route "${J}" does not match URL "${X}"`) : V === 404 ? (me = "Not Found",
    ge = `No route matches URL "${X}"`) : V === 405 && (me = "Method Not Allowed",
    ne && X && J ? ge = `You made a ${ne.toUpperCase()} request to "${X}" but did not provide an \`action\` for route "${J}", so there is no way to handle the request.` : ne && (ge = `Invalid request method "${ne.toUpperCase()}"`)),
    new ErrorResponseImpl(V || 500,me,new Error(ge),!0)
}
function findRedirect(V) {
    let X = Object.entries(V);
    for (let J = X.length - 1; J >= 0; J--) {
        let[ne,ue] = X[J];
        if (isRedirectResult(ue))
            return {
                key: ne,
                result: ue
            }
    }
}
function stripHashFromPath(V) {
    let X = typeof V == "string" ? parsePath(V) : V;
    return createPath({
        ...X,
        hash: ""
    })
}
function isHashChangeOnly(V, X) {
    return V.pathname !== X.pathname || V.search !== X.search ? !1 : V.hash === "" ? X.hash !== "" : V.hash === X.hash ? !0 : X.hash !== ""
}
function isRedirectDataStrategyResult(V) {
    return isResponse(V.result) && redirectStatusCodes.has(V.result.status)
}
function isErrorResult(V) {
    return V.type === "error"
}
function isRedirectResult(V) {
    return (V && V.type) === "redirect"
}
function isDataWithResponseInit(V) {
    return typeof V == "object" && V != null && "type"in V && "data"in V && "init"in V && V.type === "DataWithResponseInit"
}
function isResponse(V) {
    return V != null && typeof V.status == "number" && typeof V.statusText == "string" && typeof V.headers == "object" && typeof V.body < "u"
}
function isValidMethod(V) {
    return validRequestMethods.has(V.toUpperCase())
}
function isMutationMethod(V) {
    return validMutationMethods.has(V.toUpperCase())
}
function hasNakedIndexQuery(V) {
    return new URLSearchParams(V).getAll("index").some(X => X === "")
}
function getTargetMatch(V, X) {
    let J = typeof X == "string" ? parsePath(X).search : X.search;
    if (V[V.length - 1].route.index && hasNakedIndexQuery(J || ""))
        return V[V.length - 1];
    let ne = getPathContributingMatches(V);
    return ne[ne.length - 1]
}
function getSubmissionFromNavigation(V) {
    let {formMethod: X, formAction: J, formEncType: ne, text: ue, formData: ce, json: me} = V;
    if (!(!X || !J || !ne)) {
        if (ue != null)
            return {
                formMethod: X,
                formAction: J,
                formEncType: ne,
                formData: void 0,
                json: void 0,
                text: ue
            };
        if (ce != null)
            return {
                formMethod: X,
                formAction: J,
                formEncType: ne,
                formData: ce,
                json: void 0,
                text: void 0
            };
        if (me !== void 0)
            return {
                formMethod: X,
                formAction: J,
                formEncType: ne,
                formData: void 0,
                json: me,
                text: void 0
            }
    }
}
function getLoadingNavigation(V, X) {
    return X ? {
        state: "loading",
        location: V,
        formMethod: X.formMethod,
        formAction: X.formAction,
        formEncType: X.formEncType,
        formData: X.formData,
        json: X.json,
        text: X.text
    } : {
        state: "loading",
        location: V,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0
    }
}
function getSubmittingNavigation(V, X) {
    return {
        state: "submitting",
        location: V,
        formMethod: X.formMethod,
        formAction: X.formAction,
        formEncType: X.formEncType,
        formData: X.formData,
        json: X.json,
        text: X.text
    }
}
function getLoadingFetcher(V, X) {
    return V ? {
        state: "loading",
        formMethod: V.formMethod,
        formAction: V.formAction,
        formEncType: V.formEncType,
        formData: V.formData,
        json: V.json,
        text: V.text,
        data: X
    } : {
        state: "loading",
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0,
        data: X
    }
}
function getSubmittingFetcher(V, X) {
    return {
        state: "submitting",
        formMethod: V.formMethod,
        formAction: V.formAction,
        formEncType: V.formEncType,
        formData: V.formData,
        json: V.json,
        text: V.text,
        data: X ? X.data : void 0
    }
}
function getDoneFetcher(V) {
    return {
        state: "idle",
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0,
        data: V
    }
}
function restoreAppliedTransitions(V, X) {
    try {
        let J = V.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);
        if (J) {
            let ne = JSON.parse(J);
            for (let[ue,ce] of Object.entries(ne || {}))
                ce && Array.isArray(ce) && X.set(ue, new Set(ce || []))
        }
    } catch {}
}
function persistAppliedTransitions(V, X) {
    if (X.size > 0) {
        let J = {};
        for (let[ne,ue] of X)
            J[ne] = [...ue];
        try {
            V.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(J))
        } catch (ne) {
            warning(!1, `Failed to save applied view transitions in sessionStorage (${ne}).`)
        }
    }
}
function createDeferred() {
    let V, X, J = new Promise( (ne, ue) => {
        V = async ce => {
            ne(ce);
            try {
                await J
            } catch {}
        }
        ,
        X = async ce => {
            ue(ce);
            try {
                await J
            } catch {}
        }
    }
    );
    return {
        promise: J,
        resolve: V,
        reject: X
    }
}
var DataRouterContext = reactExports.createContext(null);
DataRouterContext.displayName = "DataRouter";
var DataRouterStateContext = reactExports.createContext(null);
DataRouterStateContext.displayName = "DataRouterState";
var ViewTransitionContext = reactExports.createContext({
    isTransitioning: !1
});
ViewTransitionContext.displayName = "ViewTransition";
var FetchersContext = reactExports.createContext(new Map);
FetchersContext.displayName = "Fetchers";
var AwaitContext = reactExports.createContext(null);
AwaitContext.displayName = "Await";
var NavigationContext = reactExports.createContext(null);
NavigationContext.displayName = "Navigation";
var LocationContext = reactExports.createContext(null);
LocationContext.displayName = "Location";
var RouteContext = reactExports.createContext({
    outlet: null,
    matches: [],
    isDataRoute: !1
});
RouteContext.displayName = "Route";
var RouteErrorContext = reactExports.createContext(null);
RouteErrorContext.displayName = "RouteError";
function useHref(V, {relative: X}={}) {
    invariant(useInRouterContext(), "useHref() may be used only in the context of a <Router> component.");
    let {basename: J, navigator: ne} = reactExports.useContext(NavigationContext)
      , {hash: ue, pathname: ce, search: me} = useResolvedPath(V, {
        relative: X
    })
      , ge = ce;
    return J !== "/" && (ge = ce === "/" ? J : joinPaths([J, ce])),
    ne.createHref({
        pathname: ge,
        search: me,
        hash: ue
    })
}
function useInRouterContext() {
    return reactExports.useContext(LocationContext) != null
}
function useLocation() {
    return invariant(useInRouterContext(), "useLocation() may be used only in the context of a <Router> component."),
    reactExports.useContext(LocationContext).location
}
var navigateEffectWarning = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function useIsomorphicLayoutEffect(V) {
    reactExports.useContext(NavigationContext).static || reactExports.useLayoutEffect(V)
}
function useNavigate() {
    let {isDataRoute: V} = reactExports.useContext(RouteContext);
    return V ? useNavigateStable() : useNavigateUnstable()
}
function useNavigateUnstable() {
    invariant(useInRouterContext(), "useNavigate() may be used only in the context of a <Router> component.");
    let V = reactExports.useContext(DataRouterContext)
      , {basename: X, navigator: J} = reactExports.useContext(NavigationContext)
      , {matches: ne} = reactExports.useContext(RouteContext)
      , {pathname: ue} = useLocation()
      , ce = JSON.stringify(getResolveToMatches(ne))
      , me = reactExports.useRef(!1);
    return useIsomorphicLayoutEffect( () => {
        me.current = !0
    }
    ),
    reactExports.useCallback( (Te, _e={}) => {
        if (warning(me.current, navigateEffectWarning),
        !me.current)
            return;
        if (typeof Te == "number") {
            J.go(Te);
            return
        }
        let Se = resolveTo(Te, JSON.parse(ce), ue, _e.relative === "path");
        V == null && X !== "/" && (Se.pathname = Se.pathname === "/" ? X : joinPaths([X, Se.pathname])),
        (_e.replace ? J.replace : J.push)(Se, _e.state, _e)
    }
    , [X, J, ce, ue, V])
}
var OutletContext = reactExports.createContext(null);
function useOutlet(V) {
    let X = reactExports.useContext(RouteContext).outlet;
    return X && reactExports.createElement(OutletContext.Provider, {
        value: V
    }, X)
}
function useParams() {
    let {matches: V} = reactExports.useContext(RouteContext)
      , X = V[V.length - 1];
    return X ? X.params : {}
}
function useResolvedPath(V, {relative: X}={}) {
    let {matches: J} = reactExports.useContext(RouteContext)
      , {pathname: ne} = useLocation()
      , ue = JSON.stringify(getResolveToMatches(J));
    return reactExports.useMemo( () => resolveTo(V, JSON.parse(ue), ne, X === "path"), [V, ue, ne, X])
}
function useRoutesImpl(V, X, J, ne) {
    invariant(useInRouterContext(), "useRoutes() may be used only in the context of a <Router> component.");
    let {navigator: ue, static: ce} = reactExports.useContext(NavigationContext)
      , {matches: me} = reactExports.useContext(RouteContext)
      , ge = me[me.length - 1]
      , Te = ge ? ge.params : {}
      , _e = ge ? ge.pathname : "/"
      , Se = ge ? ge.pathnameBase : "/"
      , Ie = ge && ge.route;
    {
        let we = Ie && Ie.path || "";
        warningOnce(_e, !Ie || we.endsWith("*") || we.endsWith("*?"), `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${_e}" (under <Route path="${we}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${we}"> to <Route path="${we === "/" ? "*" : `${we}/*`}">.`)
    }
    let ye = useLocation(), $e;
    $e = ye;
    let Ne = $e.pathname || "/"
      , ve = Ne;
    if (Se !== "/") {
        let we = Se.replace(/^\//, "").split("/");
        ve = "/" + Ne.replace(/^\//, "").split("/").slice(we.length).join("/")
    }
    let ke = !ce && J && J.matches && J.matches.length > 0 ? J.matches : matchRoutes(V, {
        pathname: ve
    });
    return warning(Ie || ke != null, `No routes matched location "${$e.pathname}${$e.search}${$e.hash}" `),
    warning(ke == null || ke[ke.length - 1].route.element !== void 0 || ke[ke.length - 1].route.Component !== void 0 || ke[ke.length - 1].route.lazy !== void 0, `Matched leaf route at location "${$e.pathname}${$e.search}${$e.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`),
    _renderMatches(ke && ke.map(we => Object.assign({}, we, {
        params: Object.assign({}, Te, we.params),
        pathname: joinPaths([Se, ue.encodeLocation ? ue.encodeLocation(we.pathname).pathname : we.pathname]),
        pathnameBase: we.pathnameBase === "/" ? Se : joinPaths([Se, ue.encodeLocation ? ue.encodeLocation(we.pathnameBase).pathname : we.pathnameBase])
    })), me, J, ne)
}
function DefaultErrorComponent() {
    let V = useRouteError()
      , X = isRouteErrorResponse(V) ? `${V.status} ${V.statusText}` : V instanceof Error ? V.message : JSON.stringify(V)
      , J = V instanceof Error ? V.stack : null
      , ne = "rgba(200,200,200, 0.5)"
      , ue = {
        padding: "0.5rem",
        backgroundColor: ne
    }
      , ce = {
        padding: "2px 4px",
        backgroundColor: ne
    }
      , me = null;
    return console.error("Error handled by React Router default ErrorBoundary:", V),
    me = reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("p", null, "💿 Hey developer 👋"), reactExports.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", reactExports.createElement("code", {
        style: ce
    }, "ErrorBoundary"), " or", " ", reactExports.createElement("code", {
        style: ce
    }, "errorElement"), " prop on your route.")),
    reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("h2", null, "Unexpected Application Error!"), reactExports.createElement("h3", {
        style: {
            fontStyle: "italic"
        }
    }, X), J ? reactExports.createElement("pre", {
        style: ue
    }, J) : null, me)
}
var defaultErrorElement = reactExports.createElement(DefaultErrorComponent, null)
  , RenderErrorBoundary = class extends reactExports.Component {
    constructor(V) {
        super(V),
        this.state = {
            location: V.location,
            revalidation: V.revalidation,
            error: V.error
        }
    }
    static getDerivedStateFromError(V) {
        return {
            error: V
        }
    }
    static getDerivedStateFromProps(V, X) {
        return X.location !== V.location || X.revalidation !== "idle" && V.revalidation === "idle" ? {
            error: V.error,
            location: V.location,
            revalidation: V.revalidation
        } : {
            error: V.error !== void 0 ? V.error : X.error,
            location: X.location,
            revalidation: V.revalidation || X.revalidation
        }
    }
    componentDidCatch(V, X) {
        console.error("React Router caught the following error during render", V, X)
    }
    render() {
        return this.state.error !== void 0 ? reactExports.createElement(RouteContext.Provider, {
            value: this.props.routeContext
        }, reactExports.createElement(RouteErrorContext.Provider, {
            value: this.state.error,
            children: this.props.component
        })) : this.props.children
    }
}
;
function RenderedRoute({routeContext: V, match: X, children: J}) {
    let ne = reactExports.useContext(DataRouterContext);
    return ne && ne.static && ne.staticContext && (X.route.errorElement || X.route.ErrorBoundary) && (ne.staticContext._deepestRenderedBoundaryId = X.route.id),
    reactExports.createElement(RouteContext.Provider, {
        value: V
    }, J)
}
function _renderMatches(V, X=[], J=null, ne=null) {
    if (V == null) {
        if (!J)
            return null;
        if (J.errors)
            V = J.matches;
        else if (X.length === 0 && !J.initialized && J.matches.length > 0)
            V = J.matches;
        else
            return null
    }
    let ue = V
      , ce = J == null ? void 0 : J.errors;
    if (ce != null) {
        let Te = ue.findIndex(_e => _e.route.id && (ce == null ? void 0 : ce[_e.route.id]) !== void 0);
        invariant(Te >= 0, `Could not find a matching route for errors on route IDs: ${Object.keys(ce).join(",")}`),
        ue = ue.slice(0, Math.min(ue.length, Te + 1))
    }
    let me = !1
      , ge = -1;
    if (J)
        for (let Te = 0; Te < ue.length; Te++) {
            let _e = ue[Te];
            if ((_e.route.HydrateFallback || _e.route.hydrateFallbackElement) && (ge = Te),
            _e.route.id) {
                let {loaderData: Se, errors: Ie} = J
                  , ye = _e.route.loader && !Se.hasOwnProperty(_e.route.id) && (!Ie || Ie[_e.route.id] === void 0);
                if (_e.route.lazy || ye) {
                    me = !0,
                    ge >= 0 ? ue = ue.slice(0, ge + 1) : ue = [ue[0]];
                    break
                }
            }
        }
    return ue.reduceRight( (Te, _e, Se) => {
        let Ie, ye = !1, $e = null, Ne = null;
        J && (Ie = ce && _e.route.id ? ce[_e.route.id] : void 0,
        $e = _e.route.errorElement || defaultErrorElement,
        me && (ge < 0 && Se === 0 ? (warningOnce("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"),
        ye = !0,
        Ne = null) : ge === Se && (ye = !0,
        Ne = _e.route.hydrateFallbackElement || null)));
        let ve = X.concat(ue.slice(0, Se + 1))
          , ke = () => {
            let xe;
            return Ie ? xe = $e : ye ? xe = Ne : _e.route.Component ? xe = reactExports.createElement(_e.route.Component, null) : _e.route.element ? xe = _e.route.element : xe = Te,
            reactExports.createElement(RenderedRoute, {
                match: _e,
                routeContext: {
                    outlet: Te,
                    matches: ve,
                    isDataRoute: J != null
                },
                children: xe
            })
        }
        ;
        return J && (_e.route.ErrorBoundary || _e.route.errorElement || Se === 0) ? reactExports.createElement(RenderErrorBoundary, {
            location: J.location,
            revalidation: J.revalidation,
            component: $e,
            error: Ie,
            children: ke(),
            routeContext: {
                outlet: null,
                matches: ve,
                isDataRoute: !0
            }
        }) : ke()
    }
    , null)
}
function getDataRouterConsoleError(V) {
    return `${V} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`
}
function useDataRouterContext(V) {
    let X = reactExports.useContext(DataRouterContext);
    return invariant(X, getDataRouterConsoleError(V)),
    X
}
function useDataRouterState(V) {
    let X = reactExports.useContext(DataRouterStateContext);
    return invariant(X, getDataRouterConsoleError(V)),
    X
}
function useRouteContext(V) {
    let X = reactExports.useContext(RouteContext);
    return invariant(X, getDataRouterConsoleError(V)),
    X
}
function useCurrentRouteId(V) {
    let X = useRouteContext(V)
      , J = X.matches[X.matches.length - 1];
    return invariant(J.route.id, `${V} can only be used on routes that contain a unique "id"`),
    J.route.id
}
function useRouteId() {
    return useCurrentRouteId("useRouteId")
}
function useNavigation() {
    return useDataRouterState("useNavigation").navigation
}
function useMatches() {
    let {matches: V, loaderData: X} = useDataRouterState("useMatches");
    return reactExports.useMemo( () => V.map(J => convertRouteMatchToUiMatch(J, X)), [V, X])
}
function useRouteError() {
    var ne;
    let V = reactExports.useContext(RouteErrorContext)
      , X = useDataRouterState("useRouteError")
      , J = useCurrentRouteId("useRouteError");
    return V !== void 0 ? V : (ne = X.errors) == null ? void 0 : ne[J]
}
function useNavigateStable() {
    let {router: V} = useDataRouterContext("useNavigate")
      , X = useCurrentRouteId("useNavigate")
      , J = reactExports.useRef(!1);
    return useIsomorphicLayoutEffect( () => {
        J.current = !0
    }
    ),
    reactExports.useCallback(async (ue, ce={}) => {
        warning(J.current, navigateEffectWarning),
        J.current && (typeof ue == "number" ? V.navigate(ue) : await V.navigate(ue, {
            fromRouteId: X,
            ...ce
        }))
    }
    , [V, X])
}
var alreadyWarned = {};
function warningOnce(V, X, J) {
    !X && !alreadyWarned[V] && (alreadyWarned[V] = !0,
    warning(!1, J))
}
var alreadyWarned2 = {};
function warnOnce(V, X) {
    !V && !alreadyWarned2[X] && (alreadyWarned2[X] = !0,
    console.warn(X))
}
function mapRouteProperties(V) {
    let X = {
        hasErrorBoundary: V.hasErrorBoundary || V.ErrorBoundary != null || V.errorElement != null
    };
    return V.Component && (V.element && warning(!1, "You should not include both `Component` and `element` on your route - `Component` will be used."),
    Object.assign(X, {
        element: reactExports.createElement(V.Component),
        Component: void 0
    })),
    V.HydrateFallback && (V.hydrateFallbackElement && warning(!1, "You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used."),
    Object.assign(X, {
        hydrateFallbackElement: reactExports.createElement(V.HydrateFallback),
        HydrateFallback: void 0
    })),
    V.ErrorBoundary && (V.errorElement && warning(!1, "You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used."),
    Object.assign(X, {
        errorElement: reactExports.createElement(V.ErrorBoundary),
        ErrorBoundary: void 0
    })),
    X
}
var Deferred = class {
    constructor() {
        this.status = "pending",
        this.promise = new Promise( (V, X) => {
            this.resolve = J => {
                this.status === "pending" && (this.status = "resolved",
                V(J))
            }
            ,
            this.reject = J => {
                this.status === "pending" && (this.status = "rejected",
                X(J))
            }
        }
        )
    }
}
;
function RouterProvider({router: V, flushSync: X}) {
    let[J,ne] = reactExports.useState(V.state)
      , [ue,ce] = reactExports.useState()
      , [me,ge] = reactExports.useState({
        isTransitioning: !1
    })
      , [Te,_e] = reactExports.useState()
      , [Se,Ie] = reactExports.useState()
      , [ye,$e] = reactExports.useState()
      , Ne = reactExports.useRef(new Map)
      , ve = reactExports.useCallback( (Fe, {deletedFetchers: je, flushSync: Xe, viewTransitionOpts: ze}) => {
        Fe.fetchers.forEach( (Ze, et) => {
            Ze.data !== void 0 && Ne.current.set(et, Ze.data)
        }
        ),
        je.forEach(Ze => Ne.current.delete(Ze)),
        warnOnce(Xe === !1 || X != null, 'You provided the `flushSync` option to a router update, but you are not using the `<RouterProvider>` from `react-router/dom` so `ReactDOM.flushSync()` is unavailable.  Please update your app to `import { RouterProvider } from "react-router/dom"` and ensure you have `react-dom` installed as a dependency to use the `flushSync` option.');
        let qe = V.window != null && V.window.document != null && typeof V.window.document.startViewTransition == "function";
        if (warnOnce(ze == null || qe, "You provided the `viewTransition` option to a router update, but you do not appear to be running in a DOM environment as `window.startViewTransition` is not available."),
        !ze || !qe) {
            X && Xe ? X( () => ne(Fe)) : reactExports.startTransition( () => ne(Fe));
            return
        }
        if (X && Xe) {
            X( () => {
                Se && (Te && Te.resolve(),
                Se.skipTransition()),
                ge({
                    isTransitioning: !0,
                    flushSync: !0,
                    currentLocation: ze.currentLocation,
                    nextLocation: ze.nextLocation
                })
            }
            );
            let Ze = V.window.document.startViewTransition( () => {
                X( () => ne(Fe))
            }
            );
            Ze.finished.finally( () => {
                X( () => {
                    _e(void 0),
                    Ie(void 0),
                    ce(void 0),
                    ge({
                        isTransitioning: !1
                    })
                }
                )
            }
            ),
            X( () => Ie(Ze));
            return
        }
        Se ? (Te && Te.resolve(),
        Se.skipTransition(),
        $e({
            state: Fe,
            currentLocation: ze.currentLocation,
            nextLocation: ze.nextLocation
        })) : (ce(Fe),
        ge({
            isTransitioning: !0,
            flushSync: !1,
            currentLocation: ze.currentLocation,
            nextLocation: ze.nextLocation
        }))
    }
    , [V.window, X, Se, Te]);
    reactExports.useLayoutEffect( () => V.subscribe(ve), [V, ve]),
    reactExports.useEffect( () => {
        me.isTransitioning && !me.flushSync && _e(new Deferred)
    }
    , [me]),
    reactExports.useEffect( () => {
        if (Te && ue && V.window) {
            let Fe = ue
              , je = Te.promise
              , Xe = V.window.document.startViewTransition(async () => {
                reactExports.startTransition( () => ne(Fe)),
                await je
            }
            );
            Xe.finished.finally( () => {
                _e(void 0),
                Ie(void 0),
                ce(void 0),
                ge({
                    isTransitioning: !1
                })
            }
            ),
            Ie(Xe)
        }
    }
    , [ue, Te, V.window]),
    reactExports.useEffect( () => {
        Te && ue && J.location.key === ue.location.key && Te.resolve()
    }
    , [Te, Se, J.location, ue]),
    reactExports.useEffect( () => {
        !me.isTransitioning && ye && (ce(ye.state),
        ge({
            isTransitioning: !0,
            flushSync: !1,
            currentLocation: ye.currentLocation,
            nextLocation: ye.nextLocation
        }),
        $e(void 0))
    }
    , [me.isTransitioning, ye]);
    let ke = reactExports.useMemo( () => ({
        createHref: V.createHref,
        encodeLocation: V.encodeLocation,
        go: Fe => V.navigate(Fe),
        push: (Fe, je, Xe) => V.navigate(Fe, {
            state: je,
            preventScrollReset: Xe == null ? void 0 : Xe.preventScrollReset
        }),
        replace: (Fe, je, Xe) => V.navigate(Fe, {
            replace: !0,
            state: je,
            preventScrollReset: Xe == null ? void 0 : Xe.preventScrollReset
        })
    }), [V])
      , xe = V.basename || "/"
      , we = reactExports.useMemo( () => ({
        router: V,
        navigator: ke,
        static: !1,
        basename: xe
    }), [V, ke, xe]);
    return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(DataRouterContext.Provider, {
        value: we
    }, reactExports.createElement(DataRouterStateContext.Provider, {
        value: J
    }, reactExports.createElement(FetchersContext.Provider, {
        value: Ne.current
    }, reactExports.createElement(ViewTransitionContext.Provider, {
        value: me
    }, reactExports.createElement(Router, {
        basename: xe,
        location: J.location,
        navigationType: J.historyAction,
        navigator: ke
    }, reactExports.createElement(MemoizedDataRoutes, {
        routes: V.routes,
        future: V.future,
        state: J
    })))))), null)
}
var MemoizedDataRoutes = reactExports.memo(DataRoutes);
function DataRoutes({routes: V, future: X, state: J}) {
    return useRoutesImpl(V, void 0, J, X)
}
function Navigate({to: V, replace: X, state: J, relative: ne}) {
    invariant(useInRouterContext(), "<Navigate> may be used only in the context of a <Router> component.");
    let {static: ue} = reactExports.useContext(NavigationContext);
    warning(!ue, "<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.");
    let {matches: ce} = reactExports.useContext(RouteContext)
      , {pathname: me} = useLocation()
      , ge = useNavigate()
      , Te = resolveTo(V, getResolveToMatches(ce), me, ne === "path")
      , _e = JSON.stringify(Te);
    return reactExports.useEffect( () => {
        ge(JSON.parse(_e), {
            replace: X,
            state: J,
            relative: ne
        })
    }
    , [ge, _e, ne, X, J]),
    null
}
function Outlet(V) {
    return useOutlet(V.context)
}
function Router({basename: V="/", children: X=null, location: J, navigationType: ne="POP", navigator: ue, static: ce=!1}) {
    invariant(!useInRouterContext(), "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");
    let me = V.replace(/^\/*/, "/")
      , ge = reactExports.useMemo( () => ({
        basename: me,
        navigator: ue,
        static: ce,
        future: {}
    }), [me, ue, ce]);
    typeof J == "string" && (J = parsePath(J));
    let {pathname: Te="/", search: _e="", hash: Se="", state: Ie=null, key: ye="default"} = J
      , $e = reactExports.useMemo( () => {
        let Ne = stripBasename(Te, me);
        return Ne == null ? null : {
            location: {
                pathname: Ne,
                search: _e,
                hash: Se,
                state: Ie,
                key: ye
            },
            navigationType: ne
        }
    }
    , [me, Te, _e, Se, Ie, ye, ne]);
    return warning($e != null, `<Router basename="${me}"> is not able to match the URL "${Te}${_e}${Se}" because it does not start with the basename, so the <Router> won't render anything.`),
    $e == null ? null : reactExports.createElement(NavigationContext.Provider, {
        value: ge
    }, reactExports.createElement(LocationContext.Provider, {
        children: X,
        value: $e
    }))
}
var defaultMethod = "get"
  , defaultEncType = "application/x-www-form-urlencoded";
function isHtmlElement(V) {
    return V != null && typeof V.tagName == "string"
}
function isButtonElement(V) {
    return isHtmlElement(V) && V.tagName.toLowerCase() === "button"
}
function isFormElement(V) {
    return isHtmlElement(V) && V.tagName.toLowerCase() === "form"
}
function isInputElement(V) {
    return isHtmlElement(V) && V.tagName.toLowerCase() === "input"
}
function isModifiedEvent(V) {
    return !!(V.metaKey || V.altKey || V.ctrlKey || V.shiftKey)
}
function shouldProcessLinkClick(V, X) {
    return V.button === 0 && (!X || X === "_self") && !isModifiedEvent(V)
}
function createSearchParams(V="") {
    return new URLSearchParams(typeof V == "string" || Array.isArray(V) || V instanceof URLSearchParams ? V : Object.keys(V).reduce( (X, J) => {
        let ne = V[J];
        return X.concat(Array.isArray(ne) ? ne.map(ue => [J, ue]) : [[J, ne]])
    }
    , []))
}
function getSearchParamsForLocation(V, X) {
    let J = createSearchParams(V);
    return X && X.forEach( (ne, ue) => {
        J.has(ue) || X.getAll(ue).forEach(ce => {
            J.append(ue, ce)
        }
        )
    }
    ),
    J
}
var _formDataSupportsSubmitter = null;
function isFormDataSubmitterSupported() {
    if (_formDataSupportsSubmitter === null)
        try {
            new FormData(document.createElement("form"),0),
            _formDataSupportsSubmitter = !1
        } catch {
            _formDataSupportsSubmitter = !0
        }
    return _formDataSupportsSubmitter
}
var supportedFormEncTypes = new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
function getFormEncType(V) {
    return V != null && !supportedFormEncTypes.has(V) ? (warning(!1, `"${V}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${defaultEncType}"`),
    null) : V
}
function getFormSubmissionInfo(V, X) {
    let J, ne, ue, ce, me;
    if (isFormElement(V)) {
        let ge = V.getAttribute("action");
        ne = ge ? stripBasename(ge, X) : null,
        J = V.getAttribute("method") || defaultMethod,
        ue = getFormEncType(V.getAttribute("enctype")) || defaultEncType,
        ce = new FormData(V)
    } else if (isButtonElement(V) || isInputElement(V) && (V.type === "submit" || V.type === "image")) {
        let ge = V.form;
        if (ge == null)
            throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
        let Te = V.getAttribute("formaction") || ge.getAttribute("action");
        if (ne = Te ? stripBasename(Te, X) : null,
        J = V.getAttribute("formmethod") || ge.getAttribute("method") || defaultMethod,
        ue = getFormEncType(V.getAttribute("formenctype")) || getFormEncType(ge.getAttribute("enctype")) || defaultEncType,
        ce = new FormData(ge,V),
        !isFormDataSubmitterSupported()) {
            let {name: _e, type: Se, value: Ie} = V;
            if (Se === "image") {
                let ye = _e ? `${_e}.` : "";
                ce.append(`${ye}x`, "0"),
                ce.append(`${ye}y`, "0")
            } else
                _e && ce.append(_e, Ie)
        }
    } else {
        if (isHtmlElement(V))
            throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
        J = defaultMethod,
        ne = null,
        ue = defaultEncType,
        me = V
    }
    return ce && ue === "text/plain" && (me = ce,
    ce = void 0),
    {
        action: ne,
        method: J.toLowerCase(),
        encType: ue,
        formData: ce,
        body: me
    }
}
function invariant2(V, X) {
    if (V === !1 || V === null || typeof V > "u")
        throw new Error(X)
}
async function loadRouteModule(V, X) {
    if (V.id in X)
        return X[V.id];
    try {
        let J = await import(V.module);
        return X[V.id] = J,
        J
    } catch (J) {
        return console.error(`Error loading route module \`${V.module}\`, reloading page...`),
        console.error(J),
        window.__reactRouterContext && window.__reactRouterContext.isSpaMode,
        window.location.reload(),
        new Promise( () => {}
        )
    }
}
function isHtmlLinkDescriptor(V) {
    return V == null ? !1 : V.href == null ? V.rel === "preload" && typeof V.imageSrcSet == "string" && typeof V.imageSizes == "string" : typeof V.rel == "string" && typeof V.href == "string"
}
async function getKeyedPrefetchLinks(V, X, J) {
    let ne = await Promise.all(V.map(async ue => {
        let ce = X.routes[ue.route.id];
        if (ce) {
            let me = await loadRouteModule(ce, J);
            return me.links ? me.links() : []
        }
        return []
    }
    ));
    return dedupeLinkDescriptors(ne.flat(1).filter(isHtmlLinkDescriptor).filter(ue => ue.rel === "stylesheet" || ue.rel === "preload").map(ue => ue.rel === "stylesheet" ? {
        ...ue,
        rel: "prefetch",
        as: "style"
    } : {
        ...ue,
        rel: "prefetch"
    }))
}
function getNewMatchesForLinks(V, X, J, ne, ue, ce) {
    let me = (Te, _e) => J[_e] ? Te.route.id !== J[_e].route.id : !0
      , ge = (Te, _e) => {
        var Se;
        return J[_e].pathname !== Te.pathname || ((Se = J[_e].route.path) == null ? void 0 : Se.endsWith("*")) && J[_e].params["*"] !== Te.params["*"]
    }
    ;
    return ce === "assets" ? X.filter( (Te, _e) => me(Te, _e) || ge(Te, _e)) : ce === "data" ? X.filter( (Te, _e) => {
        var Ie;
        let Se = ne.routes[Te.route.id];
        if (!Se || !Se.hasLoader)
            return !1;
        if (me(Te, _e) || ge(Te, _e))
            return !0;
        if (Te.route.shouldRevalidate) {
            let ye = Te.route.shouldRevalidate({
                currentUrl: new URL(ue.pathname + ue.search + ue.hash,window.origin),
                currentParams: ((Ie = J[0]) == null ? void 0 : Ie.params) || {},
                nextUrl: new URL(V,window.origin),
                nextParams: Te.params,
                defaultShouldRevalidate: !0
            });
            if (typeof ye == "boolean")
                return ye
        }
        return !0
    }
    ) : []
}
function getModuleLinkHrefs(V, X, {includeHydrateFallback: J}={}) {
    return dedupeHrefs(V.map(ne => {
        let ue = X.routes[ne.route.id];
        if (!ue)
            return [];
        let ce = [ue.module];
        return ue.clientActionModule && (ce = ce.concat(ue.clientActionModule)),
        ue.clientLoaderModule && (ce = ce.concat(ue.clientLoaderModule)),
        J && ue.hydrateFallbackModule && (ce = ce.concat(ue.hydrateFallbackModule)),
        ue.imports && (ce = ce.concat(ue.imports)),
        ce
    }
    ).flat(1))
}
function dedupeHrefs(V) {
    return [...new Set(V)]
}
function sortKeys(V) {
    let X = {}
      , J = Object.keys(V).sort();
    for (let ne of J)
        X[ne] = V[ne];
    return X
}
function dedupeLinkDescriptors(V, X) {
    let J = new Set;
    return new Set(X),
    V.reduce( (ne, ue) => {
        let ce = JSON.stringify(sortKeys(ue));
        return J.has(ce) || (J.add(ce),
        ne.push({
            key: ce,
            link: ue
        })),
        ne
    }
    , [])
}
function singleFetchUrl(V, X) {
    let J = typeof V == "string" ? new URL(V,typeof window > "u" ? "server://singlefetch/" : window.location.origin) : V;
    return J.pathname === "/" ? J.pathname = "_root.data" : X && stripBasename(J.pathname, X) === "/" ? J.pathname = `${X.replace(/\/$/, "")}/_root.data` : J.pathname = `${J.pathname.replace(/\/$/, "")}.data`,
    J
}
function useDataRouterContext2() {
    let V = reactExports.useContext(DataRouterContext);
    return invariant2(V, "You must render this element inside a <DataRouterContext.Provider> element"),
    V
}
function useDataRouterStateContext() {
    let V = reactExports.useContext(DataRouterStateContext);
    return invariant2(V, "You must render this element inside a <DataRouterStateContext.Provider> element"),
    V
}
var FrameworkContext = reactExports.createContext(void 0);
FrameworkContext.displayName = "FrameworkContext";
function useFrameworkContext() {
    let V = reactExports.useContext(FrameworkContext);
    return invariant2(V, "You must render this element inside a <HydratedRouter> element"),
    V
}
function usePrefetchBehavior(V, X) {
    let J = reactExports.useContext(FrameworkContext)
      , [ne,ue] = reactExports.useState(!1)
      , [ce,me] = reactExports.useState(!1)
      , {onFocus: ge, onBlur: Te, onMouseEnter: _e, onMouseLeave: Se, onTouchStart: Ie} = X
      , ye = reactExports.useRef(null);
    reactExports.useEffect( () => {
        if (V === "render" && me(!0),
        V === "viewport") {
            let ve = xe => {
                xe.forEach(we => {
                    me(we.isIntersecting)
                }
                )
            }
              , ke = new IntersectionObserver(ve,{
                threshold: .5
            });
            return ye.current && ke.observe(ye.current),
            () => {
                ke.disconnect()
            }
        }
    }
    , [V]),
    reactExports.useEffect( () => {
        if (ne) {
            let ve = setTimeout( () => {
                me(!0)
            }
            , 100);
            return () => {
                clearTimeout(ve)
            }
        }
    }
    , [ne]);
    let $e = () => {
        ue(!0)
    }
      , Ne = () => {
        ue(!1),
        me(!1)
    }
    ;
    return J ? V !== "intent" ? [ce, ye, {}] : [ce, ye, {
        onFocus: composeEventHandlers(ge, $e),
        onBlur: composeEventHandlers(Te, Ne),
        onMouseEnter: composeEventHandlers(_e, $e),
        onMouseLeave: composeEventHandlers(Se, Ne),
        onTouchStart: composeEventHandlers(Ie, $e)
    }] : [!1, ye, {}]
}
function composeEventHandlers(V, X) {
    return J => {
        V && V(J),
        J.defaultPrevented || X(J)
    }
}
function PrefetchPageLinks({page: V, ...X}) {
    let {router: J} = useDataRouterContext2()
      , ne = reactExports.useMemo( () => matchRoutes(J.routes, V, J.basename), [J.routes, V, J.basename]);
    return ne ? reactExports.createElement(PrefetchPageLinksImpl, {
        page: V,
        matches: ne,
        ...X
    }) : null
}
function useKeyedPrefetchLinks(V) {
    let {manifest: X, routeModules: J} = useFrameworkContext()
      , [ne,ue] = reactExports.useState([]);
    return reactExports.useEffect( () => {
        let ce = !1;
        return getKeyedPrefetchLinks(V, X, J).then(me => {
            ce || ue(me)
        }
        ),
        () => {
            ce = !0
        }
    }
    , [V, X, J]),
    ne
}
function PrefetchPageLinksImpl({page: V, matches: X, ...J}) {
    let ne = useLocation()
      , {manifest: ue, routeModules: ce} = useFrameworkContext()
      , {basename: me} = useDataRouterContext2()
      , {loaderData: ge, matches: Te} = useDataRouterStateContext()
      , _e = reactExports.useMemo( () => getNewMatchesForLinks(V, X, Te, ue, ne, "data"), [V, X, Te, ue, ne])
      , Se = reactExports.useMemo( () => getNewMatchesForLinks(V, X, Te, ue, ne, "assets"), [V, X, Te, ue, ne])
      , Ie = reactExports.useMemo( () => {
        if (V === ne.pathname + ne.search + ne.hash)
            return [];
        let Ne = new Set
          , ve = !1;
        if (X.forEach(xe => {
            var Fe;
            let we = ue.routes[xe.route.id];
            !we || !we.hasLoader || (!_e.some(je => je.route.id === xe.route.id) && xe.route.id in ge && ((Fe = ce[xe.route.id]) != null && Fe.shouldRevalidate) || we.hasClientLoader ? ve = !0 : Ne.add(xe.route.id))
        }
        ),
        Ne.size === 0)
            return [];
        let ke = singleFetchUrl(V, me);
        return ve && Ne.size > 0 && ke.searchParams.set("_routes", X.filter(xe => Ne.has(xe.route.id)).map(xe => xe.route.id).join(",")),
        [ke.pathname + ke.search]
    }
    , [me, ge, ne, ue, _e, X, V, ce])
      , ye = reactExports.useMemo( () => getModuleLinkHrefs(Se, ue), [Se, ue])
      , $e = useKeyedPrefetchLinks(Se);
    return reactExports.createElement(reactExports.Fragment, null, Ie.map(Ne => reactExports.createElement("link", {
        key: Ne,
        rel: "prefetch",
        as: "fetch",
        href: Ne,
        ...J
    })), ye.map(Ne => reactExports.createElement("link", {
        key: Ne,
        rel: "modulepreload",
        href: Ne,
        ...J
    })), $e.map( ({key: Ne, link: ve}) => reactExports.createElement("link", {
        key: Ne,
        ...ve
    })))
}
function mergeRefs(...V) {
    return X => {
        V.forEach(J => {
            typeof J == "function" ? J(X) : J != null && (J.current = X)
        }
        )
    }
}
var isBrowser = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
try {
    isBrowser && (window.__reactRouterVersion = "7.3.0")
} catch (V) {}
function createBrowserRouter(V, X) {
    return createRouter({
        basename: X == null ? void 0 : X.basename,
        unstable_getContext: X == null ? void 0 : X.unstable_getContext,
        future: X == null ? void 0 : X.future,
        history: createBrowserHistory({
            window: X == null ? void 0 : X.window
        }),
        hydrationData: parseHydrationData(),
        routes: V,
        mapRouteProperties,
        dataStrategy: X == null ? void 0 : X.dataStrategy,
        patchRoutesOnNavigation: X == null ? void 0 : X.patchRoutesOnNavigation,
        window: X == null ? void 0 : X.window
    }).initialize()
}
function parseHydrationData() {
    let V = window == null ? void 0 : window.__staticRouterHydrationData;
    return V && V.errors && (V = {
        ...V,
        errors: deserializeErrors(V.errors)
    }),
    V
}
function deserializeErrors(V) {
    if (!V)
        return null;
    let X = Object.entries(V)
      , J = {};
    for (let[ne,ue] of X)
        if (ue && ue.__type === "RouteErrorResponse")
            J[ne] = new ErrorResponseImpl(ue.status,ue.statusText,ue.data,ue.internal === !0);
        else if (ue && ue.__type === "Error") {
            if (ue.__subType) {
                let ce = window[ue.__subType];
                if (typeof ce == "function")
                    try {
                        let me = new ce(ue.message);
                        me.stack = "",
                        J[ne] = me
                    } catch {}
            }
            if (J[ne] == null) {
                let ce = new Error(ue.message);
                ce.stack = "",
                J[ne] = ce
            }
        } else
            J[ne] = ue;
    return J
}
var ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i
  , Link = reactExports.forwardRef(function V({onClick: X, discover: J="render", prefetch: ne="none", relative: ue, reloadDocument: ce, replace: me, state: ge, target: Te, to: _e, preventScrollReset: Se, viewTransition: Ie, ...ye}, $e) {
    let {basename: Ne} = reactExports.useContext(NavigationContext), ve = typeof _e == "string" && ABSOLUTE_URL_REGEX2.test(_e), ke, xe = !1;
    if (typeof _e == "string" && ve && (ke = _e,
    isBrowser))
        try {
            let et = new URL(window.location.href)
              , it = _e.startsWith("//") ? new URL(et.protocol + _e) : new URL(_e)
              , at = stripBasename(it.pathname, Ne);
            it.origin === et.origin && at != null ? _e = at + it.search + it.hash : xe = !0
        } catch {
            warning(!1, `<Link to="${_e}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`)
        }
    let we = useHref(_e, {
        relative: ue
    })
      , [Fe,je,Xe] = usePrefetchBehavior(ne, ye)
      , ze = useLinkClickHandler(_e, {
        replace: me,
        state: ge,
        target: Te,
        preventScrollReset: Se,
        relative: ue,
        viewTransition: Ie
    });
    function qe(et) {
        X && X(et),
        et.defaultPrevented || ze(et)
    }
    let Ze = reactExports.createElement("a", {
        ...ye,
        ...Xe,
        href: ke || we,
        onClick: xe || ce ? X : qe,
        ref: mergeRefs($e, je),
        target: Te,
        "data-discover": !ve && J === "render" ? "true" : void 0
    });
    return Fe && !ve ? reactExports.createElement(reactExports.Fragment, null, Ze, reactExports.createElement(PrefetchPageLinks, {
        page: we
    })) : Ze
});
Link.displayName = "Link";
var NavLink = reactExports.forwardRef(function V({"aria-current": X="page", caseSensitive: J=!1, className: ne="", end: ue=!1, style: ce, to: me, viewTransition: ge, children: Te, ..._e}, Se) {
    let Ie = useResolvedPath(me, {
        relative: _e.relative
    })
      , ye = useLocation()
      , $e = reactExports.useContext(DataRouterStateContext)
      , {navigator: Ne, basename: ve} = reactExports.useContext(NavigationContext)
      , ke = $e != null && useViewTransitionState(Ie) && ge === !0
      , xe = Ne.encodeLocation ? Ne.encodeLocation(Ie).pathname : Ie.pathname
      , we = ye.pathname
      , Fe = $e && $e.navigation && $e.navigation.location ? $e.navigation.location.pathname : null;
    J || (we = we.toLowerCase(),
    Fe = Fe ? Fe.toLowerCase() : null,
    xe = xe.toLowerCase()),
    Fe && ve && (Fe = stripBasename(Fe, ve) || Fe);
    const je = xe !== "/" && xe.endsWith("/") ? xe.length - 1 : xe.length;
    let Xe = we === xe || !ue && we.startsWith(xe) && we.charAt(je) === "/", ze = Fe != null && (Fe === xe || !ue && Fe.startsWith(xe) && Fe.charAt(xe.length) === "/"), qe = {
        isActive: Xe,
        isPending: ze,
        isTransitioning: ke
    }, Ze = Xe ? X : void 0, et;
    typeof ne == "function" ? et = ne(qe) : et = [ne, Xe ? "active" : null, ze ? "pending" : null, ke ? "transitioning" : null].filter(Boolean).join(" ");
    let it = typeof ce == "function" ? ce(qe) : ce;
    return reactExports.createElement(Link, {
        ..._e,
        "aria-current": Ze,
        className: et,
        ref: Se,
        style: it,
        to: me,
        viewTransition: ge
    }, typeof Te == "function" ? Te(qe) : Te)
});
NavLink.displayName = "NavLink";
var Form = reactExports.forwardRef( ({discover: V="render", fetcherKey: X, navigate: J, reloadDocument: ne, replace: ue, state: ce, method: me=defaultMethod, action: ge, onSubmit: Te, relative: _e, preventScrollReset: Se, viewTransition: Ie, ...ye}, $e) => {
    let Ne = useSubmit()
      , ve = useFormAction(ge, {
        relative: _e
    })
      , ke = me.toLowerCase() === "get" ? "get" : "post"
      , xe = typeof ge == "string" && ABSOLUTE_URL_REGEX2.test(ge)
      , we = Fe => {
        if (Te && Te(Fe),
        Fe.defaultPrevented)
            return;
        Fe.preventDefault();
        let je = Fe.nativeEvent.submitter
          , Xe = (je == null ? void 0 : je.getAttribute("formmethod")) || me;
        Ne(je || Fe.currentTarget, {
            fetcherKey: X,
            method: Xe,
            navigate: J,
            replace: ue,
            state: ce,
            relative: _e,
            preventScrollReset: Se,
            viewTransition: Ie
        })
    }
    ;
    return reactExports.createElement("form", {
        ref: $e,
        method: ke,
        action: ve,
        onSubmit: ne ? Te : we,
        ...ye,
        "data-discover": !xe && V === "render" ? "true" : void 0
    })
}
);
Form.displayName = "Form";
function ScrollRestoration({getKey: V, storageKey: X, ...J}) {
    let ne = reactExports.useContext(FrameworkContext)
      , {basename: ue} = reactExports.useContext(NavigationContext)
      , ce = useLocation()
      , me = useMatches();
    useScrollRestoration({
        getKey: V,
        storageKey: X
    });
    let ge = reactExports.useMemo( () => {
        if (!ne || !V)
            return null;
        let _e = getScrollRestorationKey(ce, me, ue, V);
        return _e !== ce.key ? _e : null
    }
    , []);
    if (!ne || ne.isSpaMode)
        return null;
    let Te = ( (_e, Se) => {
        if (!window.history.state || !window.history.state.key) {
            let Ie = Math.random().toString(32).slice(2);
            window.history.replaceState({
                key: Ie
            }, "")
        }
        try {
            let ye = JSON.parse(sessionStorage.getItem(_e) || "{}")[Se || window.history.state.key];
            typeof ye == "number" && window.scrollTo(0, ye)
        } catch (Ie) {
            console.error(Ie),
            sessionStorage.removeItem(_e)
        }
    }
    ).toString();
    return reactExports.createElement("script", {
        ...J,
        suppressHydrationWarning: !0,
        dangerouslySetInnerHTML: {
            __html: `(${Te})(${JSON.stringify(X || SCROLL_RESTORATION_STORAGE_KEY)}, ${JSON.stringify(ge)})`
        }
    })
}
ScrollRestoration.displayName = "ScrollRestoration";
function getDataRouterConsoleError2(V) {
    return `${V} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`
}
function useDataRouterContext3(V) {
    let X = reactExports.useContext(DataRouterContext);
    return invariant(X, getDataRouterConsoleError2(V)),
    X
}
function useDataRouterState2(V) {
    let X = reactExports.useContext(DataRouterStateContext);
    return invariant(X, getDataRouterConsoleError2(V)),
    X
}
function useLinkClickHandler(V, {target: X, replace: J, state: ne, preventScrollReset: ue, relative: ce, viewTransition: me}={}) {
    let ge = useNavigate()
      , Te = useLocation()
      , _e = useResolvedPath(V, {
        relative: ce
    });
    return reactExports.useCallback(Se => {
        if (shouldProcessLinkClick(Se, X)) {
            Se.preventDefault();
            let Ie = J !== void 0 ? J : createPath(Te) === createPath(_e);
            ge(V, {
                replace: Ie,
                state: ne,
                preventScrollReset: ue,
                relative: ce,
                viewTransition: me
            })
        }
    }
    , [Te, ge, _e, J, ne, X, V, ue, ce, me])
}
function useSearchParams(V) {
    warning(typeof URLSearchParams < "u", "You cannot use the `useSearchParams` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params.");
    let X = reactExports.useRef(createSearchParams(V))
      , J = reactExports.useRef(!1)
      , ne = useLocation()
      , ue = reactExports.useMemo( () => getSearchParamsForLocation(ne.search, J.current ? null : X.current), [ne.search])
      , ce = useNavigate()
      , me = reactExports.useCallback( (ge, Te) => {
        const _e = createSearchParams(typeof ge == "function" ? ge(ue) : ge);
        J.current = !0,
        ce("?" + _e, Te)
    }
    , [ce, ue]);
    return [ue, me]
}
var fetcherId = 0
  , getUniqueFetcherId = () => `__${String(++fetcherId)}__`;
function useSubmit() {
    let {router: V} = useDataRouterContext3("useSubmit")
      , {basename: X} = reactExports.useContext(NavigationContext)
      , J = useRouteId();
    return reactExports.useCallback(async (ne, ue={}) => {
        let {action: ce, method: me, encType: ge, formData: Te, body: _e} = getFormSubmissionInfo(ne, X);
        if (ue.navigate === !1) {
            let Se = ue.fetcherKey || getUniqueFetcherId();
            await V.fetch(Se, J, ue.action || ce, {
                preventScrollReset: ue.preventScrollReset,
                formData: Te,
                body: _e,
                formMethod: ue.method || me,
                formEncType: ue.encType || ge,
                flushSync: ue.flushSync
            })
        } else
            await V.navigate(ue.action || ce, {
                preventScrollReset: ue.preventScrollReset,
                formData: Te,
                body: _e,
                formMethod: ue.method || me,
                formEncType: ue.encType || ge,
                replace: ue.replace,
                state: ue.state,
                fromRouteId: J,
                flushSync: ue.flushSync,
                viewTransition: ue.viewTransition
            })
    }
    , [V, X, J])
}
function useFormAction(V, {relative: X}={}) {
    let {basename: J} = reactExports.useContext(NavigationContext)
      , ne = reactExports.useContext(RouteContext);
    invariant(ne, "useFormAction must be used inside a RouteContext");
    let[ue] = ne.matches.slice(-1)
      , ce = {
        ...useResolvedPath(V || ".", {
            relative: X
        })
    }
      , me = useLocation();
    if (V == null) {
        ce.search = me.search;
        let ge = new URLSearchParams(ce.search)
          , Te = ge.getAll("index");
        if (Te.some(Se => Se === "")) {
            ge.delete("index"),
            Te.filter(Ie => Ie).forEach(Ie => ge.append("index", Ie));
            let Se = ge.toString();
            ce.search = Se ? `?${Se}` : ""
        }
    }
    return (!V || V === ".") && ue.route.index && (ce.search = ce.search ? ce.search.replace(/^\?/, "?index&") : "?index"),
    J !== "/" && (ce.pathname = ce.pathname === "/" ? J : joinPaths([J, ce.pathname])),
    createPath(ce)
}
var SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions"
  , savedScrollPositions = {};
function getScrollRestorationKey(V, X, J, ne) {
    let ue = null;
    return ne && (J !== "/" ? ue = ne({
        ...V,
        pathname: stripBasename(V.pathname, J) || V.pathname
    }, X) : ue = ne(V, X)),
    ue == null && (ue = V.key),
    ue
}
function useScrollRestoration({getKey: V, storageKey: X}={}) {
    let {router: J} = useDataRouterContext3("useScrollRestoration")
      , {restoreScrollPosition: ne, preventScrollReset: ue} = useDataRouterState2("useScrollRestoration")
      , {basename: ce} = reactExports.useContext(NavigationContext)
      , me = useLocation()
      , ge = useMatches()
      , Te = useNavigation();
    reactExports.useEffect( () => (window.history.scrollRestoration = "manual",
    () => {
        window.history.scrollRestoration = "auto"
    }
    ), []),
    usePageHide(reactExports.useCallback( () => {
        if (Te.state === "idle") {
            let _e = getScrollRestorationKey(me, ge, ce, V);
            savedScrollPositions[_e] = window.scrollY
        }
        try {
            sessionStorage.setItem(X || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions))
        } catch (_e) {
            warning(!1, `Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (${_e}).`)
        }
        window.history.scrollRestoration = "auto"
    }
    , [Te.state, V, ce, me, ge, X])),
    typeof document < "u" && (reactExports.useLayoutEffect( () => {
        try {
            let _e = sessionStorage.getItem(X || SCROLL_RESTORATION_STORAGE_KEY);
            _e && (savedScrollPositions = JSON.parse(_e))
        } catch {}
    }
    , [X]),
    reactExports.useLayoutEffect( () => {
        let _e = J == null ? void 0 : J.enableScrollRestoration(savedScrollPositions, () => window.scrollY, V ? (Se, Ie) => getScrollRestorationKey(Se, Ie, ce, V) : void 0);
        return () => _e && _e()
    }
    , [J, ce, V]),
    reactExports.useLayoutEffect( () => {
        if (ne !== !1) {
            if (typeof ne == "number") {
                window.scrollTo(0, ne);
                return
            }
            if (me.hash) {
                let _e = document.getElementById(decodeURIComponent(me.hash.slice(1)));
                if (_e) {
                    _e.scrollIntoView();
                    return
                }
            }
            ue !== !0 && window.scrollTo(0, 0)
        }
    }
    , [me, ne, ue]))
}
function usePageHide(V, X) {
    let {capture: J} = {};
    reactExports.useEffect( () => {
        let ne = J != null ? {
            capture: J
        } : void 0;
        return window.addEventListener("pagehide", V, ne),
        () => {
            window.removeEventListener("pagehide", V, ne)
        }
    }
    , [V, J])
}
function useViewTransitionState(V, X={}) {
    let J = reactExports.useContext(ViewTransitionContext);
    invariant(J != null, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");
    let {basename: ne} = useDataRouterContext3("useViewTransitionState")
      , ue = useResolvedPath(V, {
        relative: X.relative
    });
    if (!J.isTransitioning)
        return !1;
    let ce = stripBasename(J.currentLocation.pathname, ne) || J.currentLocation.pathname
      , me = stripBasename(J.nextLocation.pathname, ne) || J.nextLocation.pathname;
    return matchPath(ue.pathname, me) != null || matchPath(ue.pathname, ce) != null
}
new TextEncoder;
/**
 * react-router v7.3.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function RouterProvider2(V) {
    return reactExports.createElement(RouterProvider, {
        flushSync: reactDomExports.flushSync,
        ...V
    })
}
const syncConfirmContent = "_syncConfirmContent_x00fc_1"
  , label$2 = "_label_x00fc_5"
  , syncShowAgainContent = "_syncShowAgainContent_x00fc_10"
  , styles$E = {
    syncConfirmContent,
    label: label$2,
    syncShowAgainContent
}
  , AppContext = reactExports.createContext({
    forceRemountApp: common_utils.noop,
    handleDeleteExperience: () => common_utils.noop
})
  , createExperienceFromFileAtom = atomWithReset(null)
  , maxDescriptionLengthAtom = atom(FALLBACK_EXPERIENCE_DESCRIPTION_MAX_LENGTH)
  , maxNameLengthAtom = atom(FALLBACK_EXPERIENCE_NAME_MAX_LENGTH)
  , maxNumberOfPlayersAtom = atom(DEFAULT_GAME_SIZE_MAX)
  , minNumberOfPlayersAtom = atom(DEFAULT_GAME_SIZE_MIN)
  , playElementIdAtom = atomWithReset("")
  , nameAtom = atomWithReset("")
  , thumbnailUrlAtom = atomWithReset("")
  , pendingUploadThumbnailAtom = atomWithReset(null)
  , designIdAtom = atomWithReset("")
  , descriptionAtom = atomWithReset("")
  , gameModeAtom = atomWithReset("")
  , lastUpdatedTimeAtom = atom()
  , workspaceAtom = atomWithReset(null)
  , mapRotationAtom = atomWithReset([])
  , isCustomGameModeAtom = atom(V => V(gameModeAtom) === CUSTOM_GAME_MODE_ID)
  , mutatorsAtom = atomWithReset({})
  , restrictedAssetTagsAtom = atomWithReset({})
  , tagsAtom = atomWithReset([])
  , rulesVersionAtom = atomWithReset(void 0)
  , isOwnerAtom = atom(!1)
  , createdAtAtom = atom(null)
  , publishStateAtom = atomWithReset(PublishStateType.PUBLISH_STATE_TYPE_DRAFT)
  , aiTypeAtom = atom(V => V(mutatorsAtom)[SPAWN_TYPE_MUTATOR_ID])
  , mutatorsNamesWithChildrenAtom = atom([])
  , shortCodeAtom = atomWithReset(void 0)
  , isSavableAtom = atom(V => !!(V(gameModeAtom) && V(mapRotationAtom).length && V(nameAtom) && V(descriptionAtom) && V(nameAtom).length <= V(maxNameLengthAtom) && V(descriptionAtom).length <= V(maxDescriptionLengthAtom)) && (V(gameSizeAtom) ?? 0) <= DEFAULT_GAME_SIZE_MAX && (V(numberOfTeamsAtom) ?? 0) <= (V(gameSizeAtom) ?? 0))
  , spatialDataAttachmentAtom = atomWithReset(null)
  , scriptAttachmentAtom = atomWithReset(null)
  , stringsAttachmentAtom = atomWithReset(null)
  , attachmentsAtom = atomWithReset([])
  , compressedCompiledModAtom = atom(null)
  , patchIdAtom = atomWithReset(null)
  , savedPlaygroundAtom = atom("")
  , isPristineAtom = atomWithReset(!0)
  , isMapRotationPristineAtom = atom(!0)
  , shouldShowMapEmptyErrorAtom = atom(V => !V(isMapRotationPristineAtom) && !V(mapRotationAtom).length)
  , currentTeamsBeingEditedAtom = atom(void 0)
  , isTeamsSyncedAtom = atomWithReset(!0)
  , moderationStateAtom = atom()
  , teamCompositionAtom = atomWithReset(new Map)
  , numberOfTeamsAtom = atom(V => {
    const X = V(teamCompositionAtom);
    return X !== void 0 ? X.size : void 0
}
)
  , gameSizeAtom = atom(V => V(teamCompositionAtom) === void 0 ? void 0 : Array.from(V(teamCompositionAtom) ?? []).reduce( (X, J) => {
    const {humanCapacity: ne, aiCapacity: ue, aiType: ce} = J[1];
    return X += ne ?? 0,
    ce === InternalCapacityType.AI_STATIC && (X += ue ?? 0),
    X
}
, 0))
  , modRulesErrorMessageAtom = atomWithReset("")
  , attachmentIdsPendingDeletionAtom = atomWithReset([])
  , migrationOrphanedSpatialAttachmentAtom = atomWithReset(null)
  , ownedLicensesAtom = atom([])
  , mapEntryRequirementsAtom = atom([])
  , isAllowingCopiesAtom = atom(!1)
  , importExperienceErrorsAtom = atom([])
  , experienceAtom = atom(V => ({
    assetRestrictions: V(restrictedAssetTagsAtom),
    description: V(descriptionAtom),
    designId: V(designIdAtom),
    gameMode: V(gameModeAtom),
    mapRotation: V(mapRotationAtom),
    mutators: V(mutatorsAtom),
    name: V(nameAtom),
    numberOfTeams: V(numberOfTeamsAtom),
    patchId: V(patchIdAtom),
    playElementId: V(playElementIdAtom),
    publishState: V(publishStateAtom),
    rulesVersion: V(rulesVersionAtom),
    script: V(scriptAttachmentAtom),
    modStrings: V(stringsAttachmentAtom),
    spatial: V(spatialDataAttachmentAtom),
    workspace: V(workspaceAtom),
    thumbnailUrl: V(thumbnailUrlAtom),
    teamComposition: V(teamCompositionAtom) ?? new Map
}), (V, X, J) => {
    switch (J) {
    case PLAYGROUND_ACTIONS.RESET:
        X(mapRotationAtom, RESET),
        X(descriptionAtom, RESET),
        X(nameAtom, RESET),
        X(restrictedAssetTagsAtom, RESET),
        X(spatialDataAttachmentAtom, RESET),
        X(stringsAttachmentAtom, RESET),
        X(patchIdAtom, RESET),
        X(scriptAttachmentAtom, RESET),
        X(workspaceAtom, RESET),
        X(publishStateAtom, RESET),
        X(stringsAttachmentAtom, RESET),
        X(mutatorsAtom, RESET),
        X(isPristineAtom, RESET),
        X(thumbnailUrlAtom, RESET),
        X(isTeamsSyncedAtom, RESET),
        X(teamCompositionAtom, RESET),
        X(modRulesErrorMessageAtom, RESET),
        X(attachmentIdsPendingDeletionAtom, RESET),
        X(attachmentsAtom, RESET),
        X(migrationOrphanedSpatialAttachmentAtom, RESET),
        X(shortCodeAtom, RESET);
        break;
    case PLAYGROUND_ACTIONS.RESET_ASSET_TAGS:
        X(restrictedAssetTagsAtom, RESET);
        break;
    case PLAYGROUND_ACTIONS.RESET_GAME_MODE:
        X(gameModeAtom, RESET);
        break
    }
}
)
  , activeMutatorsWithChildrenAtom = atom(V => {
    const X = V(mutatorsNamesWithChildrenAtom)
      , J = V(mutatorsAtom);
    return X.reduce( (ne, ue) => (J[ue] && ne.push(ue),
    ne), [])
}
)
  , activeMutatorWithChildrenCountAtom = atom(V => V(activeMutatorsWithChildrenAtom).length)
  , activeMutatorsWithChildrenHistoryAtom = atom([])
  , validationFailsAtom = atom(V => {
    const X = V(mapRotationAtom)
      , J = X.length
      , ne = V(maxNameLengthAtom)
      , ue = V(maxDescriptionLengthAtom)
      , ce = V(descriptionAtom)
      , me = V(nameAtom)
      , ge = V(maxNumberOfPlayersAtom)
      , Te = V(minNumberOfPlayersAtom)
      , _e = V(gameModeAtom)
      , Se = V(gameSizeAtom) ?? DEFAULT_GAME_SIZE_MAX
      , Ie = V(ownedLicensesAtom)
      , ye = V(mapEntryRequirementsAtom)
      , $e = Se !== void 0 && Se > ge
      , Ne = Se !== void 0 && Se < Te
      , ve = V(teamCompositionAtom)
      , ke = ce.length > ue
      , xe = me.length > ne
      , we = X.some(et => getUsersMapLicenseData({
        ownedLicenses: Ie,
        mapEntryRequirements: ye,
        levelName: et.levelName
    }).missingLicense)
      , Fe = ve ? Array.from(ve).some(et => {
        const it = et[1];
        return it.aiType === InternalCapacityType.AI_STATIC && !it.aiCapacity && !it.humanCapacity || it.aiType !== InternalCapacityType.AI_STATIC && !it.humanCapacity
    }
    ) : !1
      , je = _e === GAME_MODE.BR && Se > BR_GAME_SIZE_LICENSE_LIMIT
      , Xe = new Map
      , ze = new Map
      , qe = new Map
      , Ze = new Map;
    return $e && qe.set(VALIDATION_RULE_NAME.MAX, {
        translationId: "general.game-size-exceeding-player-limit",
        translationArgs: {
            limit: ge.toString()
        },
        severity: WARNING_VARIANTS.ERROR
    }),
    je && qe.set(VALIDATION_RULE_NAME.LICENSE, {
        translationId: "experience.players-need-to-own-premium",
        severity: WARNING_VARIANTS.WARNING
    }),
    Fe && qe.set(VALIDATION_RULE_NAME.REQUIRED, {
        translationId: "manage.one-or-more-teams-zero",
        severity: WARNING_VARIANTS.WARNING
    }),
    Ne && qe.set(VALIDATION_RULE_NAME.MIN, {
        translationId: "manage.game-size-below-min",
        severity: WARNING_VARIANTS.ERROR
    }),
    me || Xe.set(VALIDATION_RULE_NAME.REQUIRED, {
        translationId: "manage.name-required",
        severity: WARNING_VARIANTS.ERROR
    }),
    xe && Xe.set(VALIDATION_RULE_NAME.MAX, {
        translationId: "manage.name-length-error",
        severity: WARNING_VARIANTS.ERROR,
        value: ne
    }),
    ce || ze.set(VALIDATION_RULE_NAME.REQUIRED, {
        translationId: "manage.description-required",
        severity: WARNING_VARIANTS.ERROR
    }),
    ke && ze.set(VALIDATION_RULE_NAME.MAX, {
        translationId: "manage.description-length-error",
        severity: WARNING_VARIANTS.ERROR,
        value: ue
    }),
    J || Ze.set(VALIDATION_RULE_NAME.REQUIRED, {
        translationId: "manage.no-maps-chosen",
        severity: WARNING_VARIANTS.ERROR
    }),
    we && Ze.set(VALIDATION_RULE_NAME.LICENSE, {
        translationId: "experience.premium-content-warning",
        severity: WARNING_VARIANTS.WARNING,
        icon: ICON_NAMES.LOCKED
    }),
    {
        [VALIDATION_FIELD_KEY.NAME]: Xe,
        [VALIDATION_FIELD_KEY.DESCRIPTION]: ze,
        [VALIDATION_FIELD_KEY.GAME_SIZE]: qe,
        [VALIDATION_FIELD_KEY.MAP]: Ze
    }
}
)
  , AppProvider = ({children: V}) => {
    const [X,J] = reactExports.useState(!1)
      , {colors: ne} = reactExports.useContext(ThemeContext)
      , ue = useNavigate()
      , [ce,me] = reactExports.useState(!1)
      , {addToast: ge} = reactExports.useContext(ToastContext)
      , [Te,_e] = reactExports.useState("")
      , [Se,Ie] = reactExports.useState(!1)
      , {close: ye} = useDialog(DIALOG_ID.CONFIRM_SYNC_TEAMS)
      , {open: $e} = useDialog(DIALOG_ID.CONFIRM_DELETE)
      , Ne = useDeleteExperienceMutation(Te)
      , ve = () => {
        J(!0)
    }
      , ke = () => {
        ue({
            pathname: getAbsolutePathWithLocale(`/${ROUTE.HOME}`)
        })
    }
      , xe = () => {
        me(!0),
        Ne(Fe, je)
    }
      , we = ze => {
        _e(ze),
        $e()
    }
      , Fe = () => {
        me(!1),
        ue({
            pathname: getAbsolutePathWithLocale(`/${ROUTE.HOME}`)
        }, {
            replace: !0
        }),
        ge(t$1("general.successfully-deleted"))
    }
      , je = () => {
        me(!1),
        ge(t$1("experience.delete-failed"))
    }
      , Xe = ze => {
        ze ? api.set(COOKIE_KEY.ACCEPTED_CONFLICT_DIALOG, "true", {
            expires: S_ONE_YEAR
        }) : api.remove(COOKIE_KEY.ACCEPTED_CONFLICT_DIALOG),
        Ie(ze)
    }
    ;
    return reactExports.useEffect( () => {
        X && J(!1)
    }
    , [X]),
    X ? jsxRuntimeExports.jsx(LoadingSpinner, {
        statusText: t$1("general.loading")
    }) : jsxRuntimeExports.jsx(AppContext.Provider, {
        value: {
            forceRemountApp: ve,
            handleDeleteExperience: we
        },
        children: jsxRuntimeExports.jsxs(ScopeProvider, {
            atoms: [mapEntryRequirementsAtom, ownedLicensesAtom],
            children: [V, jsxRuntimeExports.jsx(DialogContent, {
                id: DIALOG_ID.CONFIRM_LEAVE_UNSAVED_CHANGES,
                header: jsxRuntimeExports.jsxs(Space, {
                    children: [jsxRuntimeExports.jsx(Icon, {
                        name: ICON_NAMES.WARNING
                    }), t$1("general.warning")]
                }),
                footer: jsxRuntimeExports.jsxs(ButtonGroup, {
                    fillWidth: !0,
                    children: [jsxRuntimeExports.jsx(Button, {
                        fillWidth: !0,
                        variant: BUTTON_VARIANTS.SECONDARY,
                        type: BUTTON_TYPES$1.SUBMIT,
                        children: t$1("general.cancel")
                    }), jsxRuntimeExports.jsx(Button, {
                        fillWidth: !0,
                        color: ne.primary,
                        type: BUTTON_TYPES$1.SUBMIT,
                        onClick: ke,
                        children: t$1("general.confirm")
                    })]
                }),
                children: t$1("general.changes-made-will-not-be-saved")
            }), jsxRuntimeExports.jsx(DialogContent, {
                id: DIALOG_ID.CONFIRM_DELETE,
                header: t$1("general.confirm"),
                footer: jsxRuntimeExports.jsxs(ButtonGroup, {
                    fillWidth: !0,
                    children: [jsxRuntimeExports.jsx(Button, {
                        fillWidth: !0,
                        variant: BUTTON_VARIANTS.SECONDARY,
                        type: BUTTON_TYPES$1.SUBMIT,
                        children: t$1("general.cancel")
                    }), jsxRuntimeExports.jsx(Button, {
                        fillWidth: !0,
                        color: ne.primary,
                        type: BUTTON_TYPES$1.SUBMIT,
                        onClick: xe,
                        children: t$1("general.confirm")
                    })]
                }),
                children: t$1("manage.delete-confirmation")
            }), jsxRuntimeExports.jsx(DialogContent, {
                id: DIALOG_ID.CONFIRM_SYNC_TEAMS,
                header: jsxRuntimeExports.jsxs(Space, {
                    children: [jsxRuntimeExports.jsx(Icon, {
                        name: ICON_NAMES.WARNING
                    }), t$1("general.warning")]
                }),
                footer: jsxRuntimeExports.jsxs(ButtonGroup, {
                    fillWidth: !0,
                    children: [jsxRuntimeExports.jsx(Button, {
                        fillWidth: !0,
                        color: ne.primary,
                        type: BUTTON_TYPES$1.SUBMIT,
                        children: t$1("general.continue")
                    }), jsxRuntimeExports.jsx(Button, {
                        fillWidth: !0,
                        variant: BUTTON_VARIANTS.SECONDARY,
                        onClick: ye,
                        children: t$1("general.cancel")
                    })]
                }),
                children: jsxRuntimeExports.jsxs("div", {
                    className: styles$E.syncConfirmContent,
                    children: [jsxRuntimeExports.jsx(Paragraph, {
                        children: t$1("experience.apply-to-all-team-dialog")
                    }), jsxRuntimeExports.jsx(Paragraph, {
                        children: t$1("experience.are-you-sure-to-continue")
                    }), jsxRuntimeExports.jsx(Section, {
                        trimBottom: !0,
                        children: jsxRuntimeExports.jsx("label", {
                            className: styles$E.label,
                            children: jsxRuntimeExports.jsxs(Space, {
                                align: SPACE_ALIGN.START,
                                className: styles$E.syncShowAgainContent,
                                children: [jsxRuntimeExports.jsx(Checkbox, {
                                    checked: Se,
                                    onChange: Xe
                                }), " ", t$1("experience.do-not-show-msg-again")]
                            })
                        })
                    })]
                })
            }), ce ? jsxRuntimeExports.jsx(LoadingSpinner, {
                statusText: t$1("general.deleting-experience")
            }) : null]
        })
    })
}
  , ImportExperienceErrorsDialog = ({id: V}) => {
    const X = useAtomValue(importExperienceErrorsAtom);
    return jsxRuntimeExports.jsxs(DialogContent, {
        id: V,
        header: "Error",
        footer: jsxRuntimeExports.jsx(ButtonGroup, {
            fillWidth: !0,
            children: jsxRuntimeExports.jsx(Button, {
                fillWidth: !0,
                type: BUTTON_TYPES$1.SUBMIT,
                children: t$1("general.dismiss")
            })
        }),
        children: [t$1("general.following-errors-occurred-while-importing-experience"), jsxRuntimeExports.jsx("ol", {
            children: X.map(J => jsxRuntimeExports.jsx("li", {
                children: t$1(J.translationId, J.args)
            }, J.translationId))
        })]
    })
}
  , exportedMutatorsToWebMutators = V => Object.entries(V).reduce( (X, [J,ne]) => (X[J] = Array.isArray(ne) ? new Map(ne) : ne,
X), {})
  , exportedAssetRestrictionsToWebAssetRestrictions = (V, X) => {
    const J = Object.entries(V).reduce( (ne, [ue,ce]) => {
        var ge;
        const me = (ge = Object.entries({
            ...X.tags,
            ...X.categories
        }).find(Te => Te[1].name === ue)) == null ? void 0 : ge[0];
        return me && (ne[me] = Array.isArray(ce) ? new Map(ce) : ce),
        ne
    }
    , {});
    return expandAssetRestrictionCategories(J, X)
}
  , webAssetRestrictionsToExportedAssetRestrictions = (V, X) => {
    const J = collapseAssetRestrictionCategories(V, X);
    return Object.entries(J).reduce( (ne, [ue,ce]) => {
        var ge, Te, _e, Se;
        const me = ((Te = (ge = X == null ? void 0 : X.tags) == null ? void 0 : ge[ue]) == null ? void 0 : Te.name) ?? ((Se = (_e = X == null ? void 0 : X.categories) == null ? void 0 : _e[ue]) == null ? void 0 : Se.name);
        return me && (ne[me] = ce instanceof Map ? [...ce] : ce),
        ne
    }
    , {})
}
  , webMutatorsToExportedMutators = V => Object.entries(V).reduce( (X, [J,ne]) => (X[J] = ne instanceof Map ? [...ne] : ne,
X), {})
  , webAttachmentsToExportedAttachments = V => V.map(X => {
    var J, ne;
    return {
        ...X,
        attachmentData: {
            original: (J = X.attachmentData) != null && J.original ? bytesToBase64(X.attachmentData.original) : "",
            compiled: (ne = X.attachmentData) != null && ne.compiled ? bytesToBase64(X.attachmentData.compiled) : ""
        }
    }
}
)
  , exportedAttachmentsToWebAttachments = V => V.map(X => {
    var J, ne;
    return {
        ...X,
        attachmentData: {
            original: (J = X.attachmentData) != null && J.original ? new TextEncoder().encode(atob(X.attachmentData.original)) : new Uint8Array([]),
            compiled: (ne = X.attachmentData) != null && ne.compiled ? new TextEncoder().encode(atob(X.attachmentData.compiled)) : void 0
        }
    }
}
)
  , webMapRotationToExportedMapRotation = V => V.map(X => {
    var J, ne, ue, ce;
    return {
        id: `${X.levelName}-${X.levelLocation}`,
        spatialAttachment: X.spatialAttachment ? {
            ...X.spatialAttachment,
            attachmentData: {
                original: (ne = (J = X.spatialAttachment) == null ? void 0 : J.attachmentData) != null && ne.original ? btoa(new TextDecoder().decode(X.spatialAttachment.attachmentData.original)) : "",
                compiled: (ce = (ue = X.spatialAttachment) == null ? void 0 : ue.attachmentData) != null && ce.compiled ? btoa(new TextDecoder().decode(X.spatialAttachment.attachmentData.compiled)) : ""
            }
        } : void 0
    }
}
)
  , exportedMapRotationToWebMapRotation = ({exportedMapRotation: V, blueprintMaps: X, gameMode: J}) => V.reduce( (ne, {id: ue, spatialAttachment: ce}) => {
    var _e, Se;
    const [me,ge] = (ue == null ? void 0 : ue.split("-")) ?? []
      , Te = X.find(Ie => Ie.gameMode === J && Ie.levelLocation === ge && Ie.levelName === me);
    return Te && ne.push({
        ...Te,
        spatialAttachment: ce ? {
            ...ce,
            attachmentData: {
                original: (_e = ce == null ? void 0 : ce.attachmentData) != null && _e.original ? new TextEncoder().encode(atob(ce.attachmentData.original)) : new Uint8Array([]),
                compiled: (Se = ce == null ? void 0 : ce.attachmentData) != null && Se.compiled ? new TextEncoder().encode(atob(ce.attachmentData.compiled)) : void 0
            }
        } : void 0
    }),
    ne
}
, []);
var IMPORT_EXPERIENCE_STATUS = (V => (V.SUCCESS = "success",
V.FAIL = "fail",
V))(IMPORT_EXPERIENCE_STATUS || {});
const useImportExperience = () => {
    const {blueprint: V} = reactExports.useContext(BlueprintContext)
      , X = useSetAtom(restrictedAssetTagsAtom)
      , J = useSetAtom(descriptionAtom)
      , ne = useSetAtom(gameModeAtom)
      , ue = useSetAtom(mapRotationAtom)
      , ce = useSetAtom(mutatorsAtom)
      , me = useSetAtom(nameAtom)
      , ge = useSetAtom(patchIdAtom)
      , Te = useSetAtom(scriptAttachmentAtom)
      , _e = useSetAtom(stringsAttachmentAtom)
      , Se = useSetAtom(spatialDataAttachmentAtom)
      , Ie = useSetAtom(workspaceAtom)
      , ye = useSetAtom(teamCompositionAtom)
      , $e = useSetAtom(attachmentsAtom);
    return ({assetRestrictions: ve, description: ke, mapRotation: xe, mutators: we, name: Fe, patchId: je, script: Xe, modStrings: ze, spatial: qe, workspace: Ze, teamComposition: et, gameMode: it, attachments: at}) => {
        var mt;
        const rt = [];
        it || rt.push({
            translationId: "general.no-game-mode-set"
        });
        const ft = (mt = V == null ? void 0 : V.maps.find(lt => lt.gameMode === it)) == null ? void 0 : mt.gameMode;
        !ft && it && rt.push({
            translationId: "general.not-valid-game-mode",
            args: {
                gameMode: it
            }
        });
        const St = xe ? exportedMapRotationToWebMapRotation({
            exportedMapRotation: xe,
            blueprintMaps: (V == null ? void 0 : V.maps) ?? [],
            gameMode: it
        }) : []
          , Ye = V != null && V.assetTags ? exportedAssetRestrictionsToWebAssetRestrictions(ve ?? {}, V == null ? void 0 : V.assetTags) : {}
          , We = {}
          , nt = we ? exportedMutatorsToWebMutators(we) : {}
          , ct = V == null ? void 0 : V.gameModes.find( ({id: lt}) => lt === it)
          , Et = new Map(et ?? []);
        We[MAX_TEAM_COUNT_MUTATOR_ID] = (ct == null ? void 0 : ct.teamRange.defaultValue) ?? DEFAULT_TEAM_COUNT,
        We[MAX_PLAYER_COUNT_MUTATOR_ID] = (ct == null ? void 0 : ct.playerSize.defaultValue) ?? DEFAULT_GAME_SIZE;
        const Ke = getMutatorBasedFromTeamComposition(Et);
        return rt.length ? {
            status: "fail",
            errors: rt
        } : (ne(ft),
        X(Ye),
        J(ke ?? ""),
        ue(St),
        ce({
            ...We,
            ...nt,
            ...Ke
        }),
        me(Fe ?? ""),
        ge(je ?? null),
        Te(Xe ? Uint8Array.from(Xe) : null),
        _e(ze ? Uint8Array.from(ze) : null),
        Se(qe ? Uint8Array.from(qe) : null),
        $e(at ? exportedAttachmentsToWebAttachments(at) : []),
        Ie(Ze),
        ye(Et),
        {
            status: "success",
            errors: rt
        })
    }
}
  , formatPlayElementDesignToAppState = ({playElementDesign: V, blueprint: X}) => {
    var we, Fe, je, Xe, ze, qe, Ze, et, it, at;
    const J = ((we = V == null ? void 0 : V.mapRotation) == null ? void 0 : we.maps[0].levelLocation) ?? ""
      , ne = getNumbersFromEndOfString(J) ?? ""
      , ue = J.substring(0, J.length - ne.length)
      , ce = X == null ? void 0 : X.gameModes.find( ({name: rt}) => rt === ue)
      , me = (ce == null ? void 0 : ce.teamRange.defaultValue) ?? DEFAULT_TEAM_COUNT
      , ge = (Fe = V == null ? void 0 : V.mutators.find(rt => rt.name === MAX_TEAM_COUNT_MUTATOR_ID)) == null ? void 0 : Fe.kind
      , Te = ge && Number(getRawKindData(ge).kindValue)
      , _e = V != null && V.attachments ? [...V.attachments] : []
      , Se = V != null && V.assetCategories ? expandAssetRestrictionCategories(V.assetCategories.reduce( (rt, {boolean: ft, tagId: St}) => {
        if (ft) {
            const {teamOverrides: Ye, defaultValue: We} = ft;
            Ye && Ye.length ? rt[St] = new Map(Ye.map( ({teamId: nt, value: ct}) => [nt - 1, ct])) : rt[St] = We
        }
        return rt
    }
    , {}), (X == null ? void 0 : X.assetTags) ?? {
        tags: {},
        categories: {}
    }) : {}
      , Ie = ((ze = (Xe = (je = V == null ? void 0 : V.mapRotation) == null ? void 0 : je.maps[0]) == null ? void 0 : Xe.teamComposition) == null ? void 0 : ze.teams.length) ?? Te ?? me
      , ye = getMutatorValues((V == null ? void 0 : V.mutators) ?? [], Ie)
      , $e = ((qe = V == null ? void 0 : V.mapRotation) == null ? void 0 : qe.maps.reduce( (rt, ft, St) => {
        const Ye = X == null ? void 0 : X.maps.find(We => We.levelLocation === ft.levelLocation && ft.levelName === We.levelName);
        if (Ye) {
            const We = {
                ...Ye
            }
              , nt = getSpatialAttachmentAtIndex(_e, St);
            nt && (We.spatialAttachment = {
                id: nt.id,
                filename: nt.filename,
                metadata: nt.metadata,
                version: nt.version,
                isProcessable: nt.isProcessable,
                processingStatus: nt.processingStatus,
                attachmentData: nt.attachmentData ?? {
                    original: new Uint8Array([])
                },
                attachmentType: nt.attachmentType,
                errors: nt.errors
            }),
            rt.push(We)
        }
        return rt
    }
    , [])) ?? []
      , Ne = new TextDecoder
      , ve = getModRules(V == null ? void 0 : V.modRules)
      , ke = (Ze = ve == null ? void 0 : ve.mod) != null && Ze.patch ? (et = JSON.parse(Ne.decode(base64ToBytes(ve.mod.patch)))) == null ? void 0 : et.id : null
      , xe = new Map((at = (it = V == null ? void 0 : V.mapRotation) == null ? void 0 : it.maps[0].teamComposition) == null ? void 0 : at.teams.map( ({teamId: rt, capacity: ft}) => {
        var We, nt;
        const {capacity: St, capacityType: Ye} = ((nt = (We = V == null ? void 0 : V.mapRotation) == null ? void 0 : We.maps[0].teamComposition) == null ? void 0 : nt.internalTeams.find(ct => ct.teamId === rt)) ?? {};
        return [rt, {
            humanCapacity: ft,
            aiCapacity: St,
            aiType: Ye
        }]
    }
    ));
    return {
        numberOfTeams: Ie,
        gameMode: ue,
        gameModeData: ce,
        assetTags: Se,
        mutators: ye,
        mapRotation: $e,
        patchId: ke,
        teamComposition: xe,
        attachments: _e,
        workspace: {
            ...ve
        }
    }
}
  , getPublishingStateMetadata = ({publishState: V, moderationState: X, publishAt: J}) => V === PublishStateType.PUBLISH_STATE_TYPE_PUBLISHED && !X && !J ? {
    label: `experience.publishState${PublishStateType.PUBLISH_STATE_TYPE_PUBLISHED}`,
    chipVariant: CHIP_VARIANT.POSITIVE,
    icon: ICON_NAMES.CHECK2,
    description: `experience.publishStateDescription${PublishStateType.PUBLISH_STATE_TYPE_PUBLISHED}`
} : V === PublishStateType.PUBLISH_STATE_TYPE_PUBLISHED && J ? {
    label: "general.pending",
    icon: ICON_NAMES.FLAG,
    chipVariant: CHIP_VARIANT.SECONDARY,
    description: "experience.pending-publish-description",
    tooltipTranslation: {
        id: "general.publishing-at",
        arg: {
            date: J.toLocaleString()
        }
    }
} : !X && V === PublishStateType.PUBLISH_STATE_TYPE_DRAFT ? {
    label: `experience.publishState${V}`,
    chipVariant: CHIP_VARIANT.PRIMARY,
    icon: ICON_NAMES.EYE,
    description: `experience.publishStateDescription${V}`
} : X === ModerationStateType.MODERATION_STATE_TYPE_APPROVED ? {
    label: MODERATION_STATUS_LABEL_MAP[X].label,
    chipVariant: CHIP_VARIANT.POSITIVE,
    icon: ICON_NAMES.CHECK2,
    description: MODERATION_STATUS_LABEL_MAP[X].description
} : X === ModerationStateType.MODERATION_STATE_TYPE_DENIED ? {
    label: MODERATION_STATUS_LABEL_MAP[X].label,
    description: MODERATION_STATUS_LABEL_MAP[X].description,
    icon: ICON_NAMES.WARNING,
    chipVariant: CHIP_VARIANT.DANGER
} : V === PublishStateType.PUBLISH_STATE_TYPE_ERROR || V === PublishStateType.PUBLISH_STATE_TYPE_INVALID ? {
    label: MODERATION_STATUS_LABEL_MAP[ModerationStateType.MODERATION_STATE_TYPE_DENIED].label,
    description: MODERATION_STATUS_LABEL_MAP[ModerationStateType.MODERATION_STATE_TYPE_DENIED].description,
    icon: ICON_NAMES.WARNING,
    chipVariant: CHIP_VARIANT.DANGER
} : X === ModerationStateType.MODERATION_STATE_TYPE_IN_REVIEW ? {
    label: MODERATION_STATUS_LABEL_MAP[X].label,
    description: MODERATION_STATUS_LABEL_MAP[X].description,
    chipVariant: CHIP_VARIANT.WARNING,
    icon: ICON_NAMES.CLOCK
} : {
    label: MODERATION_STATUS_LABEL_MAP[X].label,
    description: MODERATION_STATUS_LABEL_MAP[X].description,
    icon: ICON_NAMES.WARNING,
    chipVariant: CHIP_VARIANT.DANGER
}
  , getPublishingStateLegendData = () => [getPublishingStateMetadata({
    publishState: PublishStateType.PUBLISH_STATE_TYPE_PUBLISHED,
    moderationState: ModerationStateType.MODERATION_STATE_TYPE_UNDEFINED,
    publishAt: new Date
}), getPublishingStateMetadata({
    publishState: PublishStateType.PUBLISH_STATE_TYPE_DRAFT,
    moderationState: ModerationStateType.MODERATION_STATE_TYPE_IN_REVIEW
}), getPublishingStateMetadata({
    publishState: PublishStateType.PUBLISH_STATE_TYPE_ERROR,
    moderationState: ModerationStateType.MODERATION_STATE_TYPE_UNDEFINED
}), getPublishingStateMetadata({
    publishState: PublishStateType.PUBLISH_STATE_TYPE_PUBLISHED,
    moderationState: ModerationStateType.MODERATION_STATE_TYPE_UNDEFINED
})]
  , logger$e = Logger$1.get("HydrateExperienceDataAtoms");
var PLAYGROUND_ACTIONS = (V => (V.RESET = "reset",
V.RESET_ASSET_TAGS = "resetAssetTags",
V.RESET_GAME_MODE = "resetGameMode",
V))(PLAYGROUND_ACTIONS || {});
const HydrateExperienceDataAtoms = ({children: V, experienceData: X, licenseData: J}) => {
    var Ht, Kt, Ot, kt, Xt, vt, Jt, Ct, Mt, nn, tn, mn, dn, Qt, on, zt, $t, Ut, An, yt;
    const {blueprint: ne} = reactExports.useContext(BlueprintContext)
      , {player: ue} = reactExports.useContext(SessionContext)
      , [ce,me] = useSearchParams()
      , ge = useSetAtom(importExperienceErrorsAtom)
      , Te = convertPathTeamParamToTeamIdx(ce.get(QUERY_PARAM_KEY.SELECTED_TEAMS) ?? void 0)
      , _e = useStore()
      , Se = useImportExperience()
      , {ownedLicenses: Ie=[], mapEntryRequirements: ye=[]} = J ?? {}
      , [$e,Ne] = useAtom(createExperienceFromFileAtom)
      , {t: ve} = useTranslation()
      , ke = useNavigate()
      , xe = () => {
        ge([]),
        ke({
            pathname: getAbsolutePathWithLocale(`/${ROUTE.HOME}`)
        }, {
            replace: !0
        })
    }
      , {open: we} = useDialog(DIALOG_ID.IMPORT_EXPERIENCE_ERRORS_FROM_FILE, {
        onClose: xe,
        onSubmit: xe
    })
      , {addToast: Fe} = reactExports.useContext(ToastContext)
      , {id: je="", thumbnailUrl: Xe, moderationState: ze=null, shortCode: qe, playElementSettings: Ze} = (X == null ? void 0 : X.playElement) ?? {}
      , {modRules: et, attachments: it} = (X == null ? void 0 : X.playElementDesign) ?? {}
      , at = it ? [...it] : []
      , rt = getModRules(et)
      , {orphanedSpatialAttachment: ft, deletionIds: St} = migrateModeRules(rt, it);
    reactExports.useEffect( () => {
        if ($e) {
            const {status: Dt, errors: Bt} = Se($e);
            Dt === IMPORT_EXPERIENCE_STATUS.FAIL ? (ge(Bt),
            we()) : Fe(ve("general.experience-imported-successfully")),
            Ne(RESET)
        }
    }
    , [Fe, $e, Se, we, Ne, ge, ve]),
    reactExports.useEffect( () => {
        var ts;
        const Dt = _e.sub(gameModeAtom, () => {
            const yn = _e.get(gameModeAtom);
            if (_e.set(experienceAtom, "reset"),
            !yn)
                return;
            const xn = {}
              , En = ne == null ? void 0 : ne.gameModes.find( ({id: ot}) => ot === yn)
              , wn = (En == null ? void 0 : En.teamRange.defaultValue) ?? DEFAULT_TEAM_COUNT
              , Qn = (En == null ? void 0 : En.playerSize.defaultValue) ?? DEFAULT_GAME_SIZE
              , pr = Qn > ((En == null ? void 0 : En.playerSize.range.max) ?? DEFAULT_MAX_TEAM_COUNT)
              , ar = getNewTeamDistribution(Qn, wn)
              , _t = yn === CUSTOM_GAME_MODE_ID;
            pr && logger$e.warn(`Team Size of ${Qn} with ${wn} exceeds the limit of ${DEFAULT_MAX_TEAM_COUNT}. (${Qn * wn} total players received)`),
            xn[MAX_TEAM_COUNT_MUTATOR_ID] = wn,
            xn[MAX_PLAYER_COUNT_MUTATOR_ID] = new Map(distributeEvenly(Qn, wn).map( (ot, pt) => [pt, ot]));
            const Be = ne == null ? void 0 : ne.maps.find(ot => ot.gameMode === yn)
              , Je = Array.from(ar).map( (ot, pt) => pt);
            _e.set(mutatorsAtom, {
                ...xn
            }),
            _e.set(thumbnailUrlAtom, Object.keys((ne == null ? void 0 : ne.availableThumbnailUrls) ?? {})[0] ?? ""),
            _e.set(nameAtom, getDefaultExperienceTitle(yn)),
            _e.set(descriptionAtom, ve("experience.default-experience", {
                lng: "en-us"
            })),
            _e.set(teamCompositionAtom, ar),
            _e.set(currentTeamsBeingEditedAtom, _t ? Je : void 0),
            _t ? me(ot => (ot.set(QUERY_PARAM_KEY.SELECTED_TEAMS, Je.join(",")),
            ot), {
                replace: !0,
                preventScrollReset: !0
            }) : (ce.delete(QUERY_PARAM_KEY.SELECTED_TEAMS),
            me(ce, {
                replace: !0,
                preventScrollReset: !0
            })),
            Be && (_t && (Be.includeDefaultSpatialData = !0),
            _e.set(mapRotationAtom, [Be]))
        }
        )
          , Bt = _e.sub(mapRotationAtom, () => {
            _e.set(isMapRotationPristineAtom, !1)
        }
        )
          , Wt = _e.sub(isPristineAtom, () => {
            _e.get(isPristineAtom) && _e.set(isMapRotationPristineAtom, !0)
        }
        )
          , ut = _e.sub(teamCompositionAtom, () => {
            const yn = _e.get(teamCompositionAtom);
            if (!(yn != null && yn.size))
                return;
            const xn = _e.get(mutatorsAtom);
            _e.set(mutatorsAtom, {
                ...xn,
                ...getMutatorBasedFromTeamComposition(yn)
            })
        }
        )
          , Ge = _e.sub(experienceAtom, () => {
            _e.set(isPristineAtom, !1)
        }
        )
          , st = _e.sub(aiTypeAtom, () => {
            const yn = _e.get(aiTypeAtom)
              , xn = _e.get(teamCompositionAtom);
            yn === AI_SPAWN_TYPE_MUTATOR_NO_AI_VALUE || yn === void 0 ? _e.set(teamCompositionAtom, new Map(Array.from(xn ?? []).map( ([En,{humanCapacity: wn}]) => [En, {
                humanCapacity: wn
            }]))) : yn === AI_SPAWN_TYPE_MUTATOR_PVE_VALUE ? _e.set(teamCompositionAtom, new Map(Array.from(xn ?? []).map( ([En,{humanCapacity: wn, aiCapacity: Qn=0}]) => [En, {
                humanCapacity: wn,
                aiCapacity: Qn,
                aiType: InternalCapacityType.AI_STATIC
            }]))) : yn === AI_SPAWN_TYPE_MUTATOR_PVP_VALUE && _e.set(teamCompositionAtom, new Map(Array.from(xn ?? []).map( ([En,{humanCapacity: wn}]) => [En, {
                humanCapacity: wn,
                aiType: InternalCapacityType.AI_BACKFILL
            }])))
        }
        )
          , ht = _e.sub(currentTeamsBeingEditedAtom, () => {
            const yn = _e.get(currentTeamsBeingEditedAtom)
              , xn = _e.get(isCustomGameModeAtom);
            yn && xn ? me(En => (En.set(QUERY_PARAM_KEY.SELECTED_TEAMS, yn.join(",")),
            En), {
                replace: !0,
                preventScrollReset: !0
            }) : !xn && ce.has(QUERY_PARAM_KEY.SELECTED_TEAMS) ? (ce.delete(QUERY_PARAM_KEY.SELECTED_TEAMS),
            me(ce, {
                replace: !0,
                preventScrollReset: !0
            })) : xn && !yn && _e.set(currentTeamsBeingEditedAtom, [0])
        }
        )
          , At = _e.sub(activeMutatorWithChildrenCountAtom, () => {
            const yn = _e.get(activeMutatorsWithChildrenHistoryAtom)
              , xn = _e.get(activeMutatorsWithChildrenAtom)
              , En = _e.get(mutatorsAtom)
              , wn = xn.filter(ar => !yn.includes(ar))
              , Qn = yn.filter(ar => !xn.includes(ar));
            let pr = !1;
            wn.forEach(ar => {
                var Be;
                const _t = ne == null ? void 0 : ne.mutators[ar];
                (Be = _t == null ? void 0 : _t.childMutators) == null || Be.forEach( ({name: Je, lockToValue: ot}) => {
                    var Vt;
                    const pt = En[Je]
                      , xt = (Vt = ne == null ? void 0 : ne.mutators[Je]) == null ? void 0 : Vt.defaultValue;
                    pt !== (ot ?? xt) && (pr = !0,
                    En[Je] = ot ?? xt)
                }
                )
            }
            ),
            Qn.forEach(ar => {
                var Be;
                const _t = ne == null ? void 0 : ne.mutators[ar];
                (Be = _t == null ? void 0 : _t.childMutators) == null || Be.forEach( ({name: Je}) => {
                    var xt;
                    const ot = En[Je]
                      , pt = (xt = ne == null ? void 0 : ne.mutators[Je]) == null ? void 0 : xt.defaultValue;
                    ot !== pt && (pr = !0,
                    En[Je] = pt)
                }
                )
            }
            ),
            pr && _e.set(mutatorsAtom, {
                ...En
            }),
            _e.set(activeMutatorsWithChildrenHistoryAtom, xn)
        }
        )
          , Ft = _e.get(teamCompositionAtom)
          , an = _e.get(isCustomGameModeAtom)
          , Sn = Array.from(Ft ?? []).map( ([yn]) => yn - 1);
        if (ce.has(QUERY_PARAM_KEY.SELECTED_TEAMS)) {
            const yn = ((ts = ce.get(QUERY_PARAM_KEY.SELECTED_TEAMS)) == null ? void 0 : ts.split(",")) ?? [];
            if (an) {
                if (yn.filter(En => !Sn.includes(Number(En))).length) {
                    const En = yn.filter(wn => Sn.includes(Number(wn)));
                    _e.set(currentTeamsBeingEditedAtom, En.map(wn => Number(wn)))
                }
            } else
                _e.set(currentTeamsBeingEditedAtom, void 0)
        } else
            an && _e.set(currentTeamsBeingEditedAtom, [0]);
        return () => {
            Dt(),
            ut(),
            Ge(),
            Bt(),
            Wt(),
            st(),
            ht(),
            At()
        }
    }
    , []);
    const {assetTags: Ye, gameMode: We, gameModeData: nt, mutators: ct, mapRotation: Et, teamComposition: Ke} = formatPlayElementDesignToAppState({
        playElementDesign: X == null ? void 0 : X.playElementDesign,
        blueprint: ne
    })
      , mt = new TextDecoder
      , lt = (Ot = (Kt = (Ht = et == null ? void 0 : et.compatibleRules) == null ? void 0 : Ht.compiled) == null ? void 0 : Kt.compressed) == null ? void 0 : Ot.compiledModRules
      , Qe = (vt = (Xt = Object.values(((kt = X == null ? void 0 : X.playElement) == null ? void 0 : kt.creator) ?? {}).find(Dt => Dt !== void 0)) == null ? void 0 : Xt.player) == null ? void 0 : vt.nucleusId
      , gt = !checkForUnlinkedValues(ct)
      , Nt = !checkForUnlinkedValues(Ye);
    let Gt = gt && Nt ? void 0 : [0];
    return Te !== void 0 && (Gt = Te),
    useHydrateAtoms([[playElementIdAtom, je], [gameModeAtom, We ?? ""], [mapRotationAtom, Et], [mutatorsAtom, ct], [restrictedAssetTagsAtom, Ye], [nameAtom, ((Jt = X == null ? void 0 : X.playElement) == null ? void 0 : Jt.name) ?? ""], [descriptionAtom, ((Ct = X == null ? void 0 : X.playElement) == null ? void 0 : Ct.description) ?? ""], [designIdAtom, ((Mt = X == null ? void 0 : X.playElementDesign) == null ? void 0 : Mt.designId) ?? ""], [tagsAtom, []], [createdAtAtom, ((nn = X == null ? void 0 : X.playElement) == null ? void 0 : nn.created) ?? null], [workspaceAtom, {
        ...rt
    }], [rulesVersionAtom, ne == null ? void 0 : ne.rulesVersion], [scriptAttachmentAtom, (tn = rt == null ? void 0 : rt.mod) != null && tn.script ? base64ToBytes(rt.mod.script) : null], [spatialDataAttachmentAtom, (mn = rt == null ? void 0 : rt.mod) != null && mn.spatial ? base64ToBytes(rt.mod.spatial) : null], [stringsAttachmentAtom, (dn = rt == null ? void 0 : rt.mod) != null && dn.strings ? base64ToBytes(rt.mod.strings) : null], [attachmentsAtom, at && at.length ? [...at] : []], [attachmentIdsPendingDeletionAtom, St], [migrationOrphanedSpatialAttachmentAtom, ft || null], [compressedCompiledModAtom, lt ?? null], [patchIdAtom, (Qt = rt == null ? void 0 : rt.mod) != null && Qt.patch ? (on = JSON.parse(mt.decode(base64ToBytes(rt.mod.patch)))) == null ? void 0 : on.id : null], [publishStateAtom, ((zt = X == null ? void 0 : X.playElement) == null ? void 0 : zt.publishStateType) ?? PublishStateType.PUBLISH_STATE_TYPE_DRAFT], [isOwnerAtom, Qe && ue ? Qe === (ue == null ? void 0 : ue.nucleusId) : !0], [currentTeamsBeingEditedAtom, Gt], [thumbnailUrlAtom, (Xe || Object.keys((ne == null ? void 0 : ne.availableThumbnailUrls) ?? {})[0]) ?? ""], [lastUpdatedTimeAtom, ($t = X == null ? void 0 : X.playElement) == null ? void 0 : $t.updated], [moderationStateAtom, ze], [maxDescriptionLengthAtom, ((Ut = ne == null ? void 0 : ne.constraints) == null ? void 0 : Ut.maxDescriptionSize) ?? FALLBACK_EXPERIENCE_DESCRIPTION_MAX_LENGTH], [maxNameLengthAtom, ((An = ne == null ? void 0 : ne.constraints) == null ? void 0 : An.maxNameSize) ?? FALLBACK_EXPERIENCE_NAME_MAX_LENGTH], [teamCompositionAtom, Ke], [modRulesErrorMessageAtom, ((yt = et == null ? void 0 : et.errorRules) == null ? void 0 : yt.errorMessage) ?? ""], [maxNumberOfPlayersAtom, (nt == null ? void 0 : nt.playerSize.range.max) ?? DEFAULT_GAME_SIZE_MAX], [minNumberOfPlayersAtom, (nt == null ? void 0 : nt.playerSize.range.min) ?? DEFAULT_MIN_TEAM_COUNT], [mapEntryRequirementsAtom, ye], [ownedLicensesAtom, Ie], [shortCodeAtom, qe], [isAllowingCopiesAtom, (Ze == null ? void 0 : Ze.allowCopies) ?? !1], [mutatorsNamesWithChildrenAtom, Object.keys((ne == null ? void 0 : ne.mutators) ?? {}).filter(Dt => {
        var Bt, Wt;
        return (Wt = (Bt = ne == null ? void 0 : ne.mutators[Dt]) == null ? void 0 : Bt.childMutators) == null ? void 0 : Wt.length
    }
    )]]),
    jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [V, jsxRuntimeExports.jsx(ImportExperienceErrorsDialog, {
            id: DIALOG_ID.IMPORT_EXPERIENCE_ERRORS_FROM_FILE
        })]
    })
}
;
async function getLicenseRequirements(V) {
    if (!V) {
        const X = new Error("Missing session!");
        throw X.name = "Unauthenticated",
        X
    }
    return await clients.play.GetLicenseRequirements({}, new grpcWebClient_umdExports.grpc.Metadata({
        "x-gateway-session-id": V
    }))
}
const useGetLicenseRequirements = () => {
    const {sessionId: V, player: X} = reactExports.useContext(SessionContext)
      , {data: J, isLoading: ne} = useQuery({
        queryKey: [QUERY_KEY.LICENSE_REQUIREMENTS, X == null ? void 0 : X.nucleusId],
        queryFn: () => getLicenseRequirements(V),
        enabled: !!V,
        refetchOnWindowFocus: !1,
        staleTime: MS_1_HOUR
    });
    return {
        data: J,
        isLoading: ne
    }
}
  , logger$d = Logger$1.get("playElements");
async function getPlayElement(V, X) {
    if (!X) {
        const ce = new Error("Missing session!");
        throw ce.name = "Unauthenticated",
        ce
    }
    const {playElement: J, playElementDesign: ne, progressionMode: ue} = await clients.play.getPlayElement(V, new grpcWebClient_umdExports.grpc.Metadata({
        "x-gateway-session-id": X
    }));
    return {
        playElement: J,
        playElementDesign: ne,
        progressionMode: ue
    }
}
const useGetPlayElementQuery = (V="") => {
    const {sessionId: X} = reactExports.useContext(SessionContext)
      , {data: J, isLoading: ne, refetch: ue} = useQuery({
        queryKey: [QUERY_KEY.PLAY_ELEMENT, V],
        queryFn: () => getPlayElement({
            id: V,
            includeDenied: !0
        }, X),
        enabled: !!X && !!V,
        refetchOnWindowFocus: !1,
        staleTime: MS_1_HOUR,
        select: ({playElement: me, playElementDesign: ge, progressionMode: Te}) => (logger$d.log("Received playElement", me),
        logger$d.log("Received playElementDesign", ge),
        {
            playElement: me,
            playElementDesign: ge,
            progressionMode: Te
        })
    })
      , ce = !!J && J.playElement === void 0 && J.playElementDesign === void 0;
    return {
        data: J,
        isLoading: ne,
        isExperienceNotFound: ce,
        refetch: ue
    }
}
  , ExperienceDataProvider = ({children: V}) => {
    const X = useNavigate()
      , [J] = useSearchParams()
      , ne = J.get(QUERY_PARAM_KEY.EXPERIENCE_ID) ?? void 0
      , {data: ue, isLoading: ce, isExperienceNotFound: me} = useGetPlayElementQuery(ne)
      , {data: ge, isLoading: Te} = useGetLicenseRequirements();
    return reactExports.useEffect( () => {
        me && X({
            pathname: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE_NOT_FOUND}`)
        })
    }
    , [me, X]),
    jsxRuntimeExports.jsx(ScopeProvider, {
        atoms: [attachmentIdsPendingDeletionAtom, attachmentsAtom, compressedCompiledModAtom, createdAtAtom, currentTeamsBeingEditedAtom, descriptionAtom, designIdAtom, experienceAtom, gameModeAtom, gameSizeAtom, isAllowingCopiesAtom, isCustomGameModeAtom, isMapRotationPristineAtom, isOwnerAtom, isPristineAtom, isSavableAtom, isTeamsSyncedAtom, lastUpdatedTimeAtom, mapEntryRequirementsAtom, mapRotationAtom, maxNumberOfPlayersAtom, minNumberOfPlayersAtom, moderationStateAtom, modRulesErrorMessageAtom, mutatorsAtom, nameAtom, numberOfTeamsAtom, ownedLicensesAtom, patchIdAtom, pendingUploadThumbnailAtom, playElementIdAtom, publishStateAtom, restrictedAssetTagsAtom, rulesVersionAtom, savedPlaygroundAtom, scriptAttachmentAtom, shortCodeAtom, shouldShowMapEmptyErrorAtom, spatialDataAttachmentAtom, stringsAttachmentAtom, tagsAtom, teamCompositionAtom, thumbnailUrlAtom, workspaceAtom],
        children: ce || me || Te ? jsxRuntimeExports.jsx(LoadingSpinner, {
            statusText: "Loading Experience..."
        }) : (ue || !ne) && jsxRuntimeExports.jsx(HydrateExperienceDataAtoms, {
            experienceData: ue,
            licenseData: ge,
            children: V
        })
    })
}
  , AuthRequired = ({children: V}) => {
    const {sessionId: X} = reactExports.useContext(SessionContext);
    return X ? jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
        children: V
    }) : jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {})
}
  , content$7 = "_content_1tm3j_1"
  , container$5 = "_container_1tm3j_8"
  , styles$D = {
    content: content$7,
    container: container$5
}
  , ErrorPage = ({errorText: V, description: X, includeBack: J, includeReload: ne}) => {
    const {colors: ue} = reactExports.useContext(ThemeContext)
      , ce = useQueryClient()
      , me = useNavigate()
      , {t: ge} = useTranslation()
      , Te = () => {
        ce.invalidateQueries({
            queryKey: [QUERY_KEY.BLUEPRINT],
            exact: !1
        }),
        ce.invalidateQueries({
            queryKey: [QUERY_KEY.SCHEDULED_BLUEPRINTS],
            exact: !1
        }),
        me(0)
    }
    ;
    return jsxRuntimeExports.jsx(PageWrapper, {
        children: jsxRuntimeExports.jsx("div", {
            className: styles$D.content,
            children: jsxRuntimeExports.jsxs("div", {
                className: styles$D.container,
                children: [jsxRuntimeExports.jsx(Icon, {
                    name: ICON_NAMES.WARNING,
                    color: ue.warningVibrant,
                    size: ICON_SIZES.JUMBO
                }), jsxRuntimeExports.jsx(Heading, {
                    children: V
                }), X && X, ne && jsxRuntimeExports.jsx(Button, {
                    onClick: Te,
                    children: ge("general.reload-page")
                }), J && jsxRuntimeExports.jsxs(Link, {
                    to: {
                        pathname: getAbsolutePathWithLocale(`/${ROUTE.HOME}`)
                    },
                    children: ["< ", ge("app.back-to-portal-home")]
                })]
            })
        })
    })
}
  , isLocaleSupportedInParams = V => LOCALES_REPRESENTED_IN_PARAMS.find(X => X.toLowerCase() === V)
  , isLocaleSupported = V => SUPPORTED_LOCALES.some(X => X.toLowerCase() === V)
  , LocaleGate = () => {
    const V = instance.language
      , {t: X} = useTranslation()
      , J = V.toLowerCase()
      , ne = api.get(COOKIE_KEY.LOCALE)
      , {lang: ue} = useParams()
      , {pathname: ce} = useLocation()
      , me = useSearchParams()[0].get("setLocale");
    let ge = "";
    if (ue)
        if (isLocaleSupported(ue))
            isLocaleSupportedInParams(ue) || (ge = ce.split("/").filter(_e => _e !== ue).join("/"));
        else
            return jsxRuntimeExports.jsx(ErrorPage, {
                errorText: X("app.status-404")
            });
    else
        !ue && isLocaleSupportedInParams(J) && (ge = `/bf6/${J}${ce.split("/").filter(_e => _e !== "bf6").join("/")}`);
    me && isLocaleSupported(me) && me !== ne && (me === ue || !isLocaleSupportedInParams(me) && !ue) && api.set(COOKIE_KEY.LOCALE, me);
    const Te = RTL_LOCALES.some(_e => _e === V) ? "rtl" : "ltr";
    return document.documentElement.lang !== V && (document.documentElement.lang = V),
    (Te === "rtl" && document.documentElement.dir !== Te || Te === "ltr" && document.documentElement.dir === "rtr") && (document.documentElement.dir = Te),
    ge ? jsxRuntimeExports.jsx(Navigate, {
        to: ge,
        replace: !0
    }) : jsxRuntimeExports.jsx(Outlet, {})
}
  , PreservedSearchNavigate = ({pathname: V, replace: X}) => {
    const {search: J} = useLocation();
    return jsxRuntimeExports.jsx(Navigate, {
        to: {
            pathname: V,
            search: J
        },
        replace: X
    })
}
  , RuleEditorGate = ({children: V}) => {
    const X = useAtomValue(gameModeAtom)
      , {pathname: J} = useLocation();
    let ne = "";
    return X ? X !== CUSTOM_GAME_MODE_ID && (ne = getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.MAP_ROTATION}`, J)) : ne = getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.GAME_MODE}`, J),
    ne ? jsxRuntimeExports.jsx(PreservedSearchNavigate, {
        pathname: ne,
        replace: !0
    }) : V
}
  , VipGate = ({children: V}) => {
    const {pathname: X} = useLocation()
      , [J] = useSearchParams()
      , {data: ne, isLoading: ue} = useGetLicenseRequirements()
      , ce = ne == null ? void 0 : ne.ownedLicenses.includes(VIP_ACCESS_LICENSE);
    let me = "";
    return ue ? null : (ce || (J.has(QUERY_PARAM_KEY.EXPERIENCE_ID) ? me = getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}`, X) : me = getAbsolutePathWithLocale(`/${ROUTE.HOME}`, X)),
    me ? jsxRuntimeExports.jsx(PreservedSearchNavigate, {
        pathname: me,
        replace: !0
    }) : V)
}
  , PlayElementContext = reactExports.createContext({})
  , PlayElementProvider = ({children: V}) => {
    const [X] = useSearchParams()
      , J = X.get(QUERY_PARAM_KEY.EXPERIENCE_ID) ?? void 0
      , {data: ne, isLoading: ue} = useGetPlayElementQuery(J)
      , {t: ce} = useTranslation();
    return ue ? jsxRuntimeExports.jsx(LoadingSpinner, {
        statusText: ce("general.loading-experience")
    }) : jsxRuntimeExports.jsx(PlayElementContext.Provider, {
        value: {
            serverSavedExperienceData: ne
        },
        children: V
    })
}
;
var TEST_ID = (V => (V.CREATE_BUTTON = "create-button",
V.DELETE_ALL_SCRIPTS = "delete-all-scripts",
V.DELETE_ALL_SCRIPTS_CANCEL = "delete-all-scripts-cancel",
V.DELETE_ALL_SCRIPTS_CONFIRM = "delete-all-scripts-confirm",
V.DOWNLOAD_SDK_BUTTON = "downloadSdkButton",
V.DOWNLOAD_SPATIAL = "downloadOldSpatial",
V.EXPERIENCE_LAYOUT_EXPORT = "experience-layout-export",
V.EXPERIENCE_TILE_DELETE = "experience-tile-delete",
V.EXPERIENCE_TILE_DUPLICATE = "experience-tile-duplicate",
V.EXPERIENCE_TILE_EXPORT = "experience-tile-export",
V.EXPERIENCE_TILE_MODIFY_BUTTON = "experience-tile-modify-button",
V.EXPERIENCE_TILE_NO_EXPERIENCES_CREATE = "experience-tile-create-first",
V.EXPERIENCE_TILE_PUBLISH = "experience-tile-publish",
V.EXPERIENCE_TILE_SHARE = "experience-tile-share",
V.EXPERIENCE_TILE_SHOW_CODE_BUTTON = "experience-tile-show-button",
V.EXPERIENCE_TILE_SHOW_MENU = "experience-tile-show-menu",
V.EXPORT_BLOCKS_TO_SCRIPT = "export-blocks-to-script",
V.EXPORT_MOD = "export-mod",
V.EXPORT_SCRIPTS = "export-scripts",
V.GENERATE_SCRIPT_CANCEL = "generate-script-cancel",
V.GENERATE_SCRIPT_CONFIRM = "generate-script-confirm",
V.GENERATE_SCRIPT_FILENAME = "generate-script-filename",
V.LOGIN_BUTTON = "login-button",
V.MAIN_NAV_AI = "main-nav-ai",
V.MAIN_NAV_ATTACHMENTS = "main-nav-attachments",
V.MAIN_NAV_BLOCKS = "main-nav-blocks",
V.MAIN_NAV_CHARS = "main-nav-chars",
V.MAIN_NAV_CORE = "main-nav-core",
V.MAIN_NAV_DISTRIBUTION = "main-nav-distribution",
V.MAIN_NAV_ERA = "main-nav-era",
V.MAIN_NAV_GADGETS = "main-nav-gadgets",
V.MAIN_NAV_GAME_MODE = "main-nav-game-mode",
V.MAIN_NAV_GAME_MODE_DETAILS = "main-nav-game-mode-details",
V.MAIN_NAV_GAME_PLAY = "main-nav-game-play",
V.MAIN_NAV_GAMEPLAY = "main-nav-gameplay",
V.MAIN_NAV_MAP_ROTATION = "main-nav-map-rotation",
V.MAIN_NAV_MODE = "main-nav-mode",
V.MAIN_NAV_MODIFIERS = "main-nav-modifiers",
V.MAIN_NAV_PUBLISH = "main-nav-publish",
V.MAIN_NAV_PUBLISH_STEP_ONE = "main-nav-publish-1",
V.MAIN_NAV_PUBLISH_STEP_THREE = "main-nav-publish-3",
V.MAIN_NAV_PUBLISH_STEP_TWO = "main-nav-publish-2",
V.MAIN_NAV_RESTRICTIONS = "main-nav-restrictions",
V.MAIN_NAV_RULES = "main-nav-rules",
V.MAIN_NAV_SCRIPT = "main-nav-script",
V.MAIN_NAV_SETTINGS = "main-nav-settings",
V.MAIN_NAV_SOLDIER = "main-nav-soldier",
V.MAIN_NAV_TEAMS = "main-nav-teams",
V.MAIN_NAV_UI = "main-nav-ui",
V.MAIN_NAV_VEHICLE = "main-nav-vehicle",
V.MAIN_NAV_VEHICLES = "main-nav-vehicles",
V.MAIN_NAV_WEAPONS = "main-nav-weapons",
V.MANAGE_BUTTON = "manage-button",
V.MANAGE_CREATE_EXPERIENCE_BUTTON = "manage-create-experience-button",
V.MANAGE_SAVE_BUTTON = "manage-save-button",
V.MOD_EXPORT_BUTTON = "mod-export-button",
V.NEXT_BUTTON = "next-button",
V.PLAYGROUND_DESCRIPTION_INPUT = "playground-description-input",
V.PLAYGROUND_NAME_INPUT = "playground-name-input",
V.PUBLISH_BUTTON = "publish-button",
V.REPORT_EXPERIENCE_SUBJECT = "report-experience-subject",
V.RESET_EXPERIENCE = "reset-experience",
V.WORKSPACE_EXPORT_BUTTON = "workspace-export-button",
V.WORKSPACE_EXPORT_CONVERTED_SCRIPT_BUTTON = "workspace-export-converted-script",
V.WORKSPACE_IMPORT_BUTTON = "workspace-import-button",
V.WORKSPACE_RESET = "workspace-reset",
V))(TEST_ID || {});
const styles$C = {};
var FIELD_KEY$1 = (V => (V.NAME = "name",
V.DESCRIPTION = "description",
V))(FIELD_KEY$1 || {});
const ExperienceBasicDetails = () => {
    const V = useAtomValue(maxNameLengthAtom)
      , [X,J] = useAtom(nameAtom)
      , ne = useAtomValue(isOwnerAtom)
      , [ue,ce] = reactExports.useState(new Map(common_utils.enumToArray(FIELD_KEY$1).map(ye => [ye, new Set])))
      , [me,ge] = useAtom(descriptionAtom)
      , Te = useAtomValue(maxDescriptionLengthAtom)
      , _e = ye => {
        J(ye ?? "")
    }
      , Se = ye => $e => {
        ue.set(ye, new Set([...$e])),
        ce(new Map([...ue]))
    }
      , Ie = ye => {
        ge(ye ?? "")
    }
    ;
    return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsx(Field, {
            label: t$1("general.name"),
            tip: t$1("manage.name-tooltip"),
            validation: {
                maxLength: V,
                currentLength: X.length
            },
            children: jsxRuntimeExports.jsx(TextInput, {
                label: t$1("general.name"),
                variant: TEXT_INPUT_VARIANT.SECONDARY,
                fillWidth: !0,
                disabled: !ne,
                value: X,
                dir: "ltr",
                testId: TEST_ID.PLAYGROUND_NAME_INPUT,
                onChange: _e,
                onValidationChange: Se("name"),
                validation: {
                    required: !0,
                    maxLength: V
                }
            })
        }), jsxRuntimeExports.jsx(Field, {
            label: t$1("general.description"),
            tip: t$1("manage.description-tooltip"),
            validation: {
                maxLength: Te,
                currentLength: me.length
            },
            children: jsxRuntimeExports.jsx(TextInput, {
                className: styles$C.descriptionInput,
                variant: TEXT_INPUT_VARIANT.SECONDARY,
                disabled: !ne,
                label: t$1("general.description"),
                type: TEXT_INPUT_TYPES.MULTILINE,
                fillWidth: !0,
                value: me,
                testId: TEST_ID.PLAYGROUND_DESCRIPTION_INPUT,
                onChange: Ie,
                onValidationChange: Se("description"),
                validation: {
                    required: !0,
                    maxLength: Te
                },
                dir: "ltr"
            })
        })]
    })
}
  , ValidationFails = ({keyFilters: V=[]}) => {
    const X = useAtomValue(validationFailsAtom)
      , {t: J} = useTranslation();
    return Object.entries(X).some( ([ne,ue]) => ue.size && (!V.length || V.includes(ne))) ? jsxRuntimeExports.jsx(Section, {
        subsection: !0,
        children: jsxRuntimeExports.jsx(WarningList, {
            children: Object.entries(X).map( ([ne,ue]) => ue.size && (!V.length || V.includes(ne)) ? Array.from(ue).map( ([ce,{translationId: me, severity: ge, icon: Te, value: _e}]) => jsxRuntimeExports.jsx(Warning, {
                text: _e ? J(me, {
                    [ce]: _e
                }) : J(me),
                variant: ge,
                ...Te && {
                    icon: Te
                }
            }, `${ne}-${ce}`)) : null)
        })
    }) : null
}
  , ExperienceStatusTag = ({children: V, icon: X, toolTip: J, variant: ne, className: ue}) => {
    const ce = jsxRuntimeExports.jsx(Chip, {
        variant: ne,
        className: ue,
        children: jsxRuntimeExports.jsxs(Space, {
            gapSize: SPACE_GAP_SIZE.XXS,
            children: [jsxRuntimeExports.jsx(Icon, {
                name: X
            }), V]
        })
    });
    return J ? jsxRuntimeExports.jsx(Tooltip, {
        tip: J,
        children: ce
    }) : ce
}
  , MapRotationPreview = ({maps: V, licenseTooltip: X}) => {
    const {colors: J} = reactExports.useContext(ThemeContext);
    return jsxRuntimeExports.jsx(Space, {
        gapSize: SPACE_GAP_SIZE.XS,
        column: !0,
        children: V.map( ({image: ne, title: ue, licenseRequirements: ce, missingLicense: me}) => jsxRuntimeExports.jsx(ImageCard, {
            variant: IMAGE_CARD_VARIANT.COMPACT_LIST_ITEM,
            imageSrc: ne,
            caption: jsxRuntimeExports.jsxs(Space, {
                gapSize: SPACE_GAP_SIZE.XS,
                children: [!!(ce != null && ce.length) && jsxRuntimeExports.jsx(Tooltip, {
                    tip: X,
                    children: jsxRuntimeExports.jsx(Icon, {
                        name: ICON_NAMES.PRICE_TAG,
                        size: ICON_SIZES.SM,
                        color: me ? J.warningVibrant : J.gray600
                    })
                }), t$1(ue)]
            })
        }))
    })
}
  , ServerTags = ({serverTags: V}) => jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children: jsxRuntimeExports.jsx(ChipList, {
        children: V.map( ({tagId: X, name: J, description: ne}) => jsxRuntimeExports.jsx(Tooltip, {
            tip: ne,
            children: jsxRuntimeExports.jsx(Chip, {
                children: J
            })
        }, X))
    })
})
  , logger$c = Logger$1.get("deleteAttachments")
  , useDeleteAttachmentsMutation = V => {
    const {sessionId: X, player: J} = reactExports.useContext(SessionContext)
      , ne = useAtomValue(playElementIdAtom)
      , ue = useAtomValue(designIdAtom)
      , ce = useQueryClient()
      , me = useMutation({
        mutationFn: Te => X && (Te != null && Te.length) ? clients.play.DeleteAttachments({
            playElementDesignId: V ?? ue,
            attachmentIds: Te
        }, new grpcWebClient_umdExports.grpc.Metadata({
            "x-gateway-session-id": X
        })) : Promise.reject()
    });
    return async Te => {
        if (Te != null && Te.length)
            try {
                logger$c.debug("Deleting the following attachment IDs", Te),
                await me.mutateAsync(Te) && (logger$c.debug("Attachments deletion successful!"),
                await ce.invalidateQueries({
                    queryKey: [QUERY_KEY.PLAY_ELEMENT, ne]
                }),
                await ce.invalidateQueries({
                    queryKey: [QUERY_KEY.LIST_PLAY_ELEMENTS, J == null ? void 0 : J.nucleusId]
                }))
            } catch (_e) {
                Logger$1.error("Failed to delete specified attachments: ", _e)
            }
    }
}
;
async function fetchSpatials() {
    const X = await (await fetch(getAssetPath("/assets/templates/spatial/spatials.json"))).json() ?? {}
      , J = new TextEncoder;
    return Object.entries(X).reduce( (ue, [ce,me]) => (ue[ce] = new Uint8Array(J.encode(JSON.stringify(me))),
    ue), {})
}
const useSpatialDefaults = (V=!0) => {
    const {data: X={}, isFetching: J, error: ne, isLoading: ue, isSuccess: ce} = useQuery({
        queryKey: [QUERY_KEY.SPATIAL_DEFAULTS],
        queryFn: () => fetchSpatials(),
        enabled: V,
        refetchOnWindowFocus: !1,
        staleTime: MS_1_MINUTE
    });
    return {
        spatialDefaults: X,
        isFetching: J,
        error: ne,
        isLoading: ue,
        isSuccess: ce
    }
}
  , logger$b = Logger$1.get("save")
  , getTeamCompositionPayload = (V, X, J) => {
    const ne = Array.from(V)
      , ue = ne.map( ([me,{humanCapacity: ge}]) => ({
        capacity: ge ?? 0,
        teamId: me
    }))
      , ce = ne.filter(me => me[1].aiType !== void 0).map( ([me,{aiCapacity: ge}]) => ({
        teamId: me,
        capacity: ge ?? 0,
        capacityType: X ?? InternalCapacityType.AI_BACKFILL
    }));
    return {
        teams: ue,
        internalTeams: ce,
        balancingMethod: J ?? TeamBalancingMethod.UNSPECIFIED
    }
}
  , getNewlyAddedSpatialAttachments = (V, X, J) => V.reduce( (ue, ce, me) => {
    var ge;
    if (ce.spatialAttachment && !J.some(Te => {
        var _e;
        return Te.id === ((_e = ce == null ? void 0 : ce.spatialAttachment) == null ? void 0 : _e.id)
    }
    )) {
        const Te = {
            ...ce.spatialAttachment,
            attachmentData: {
                original: ce.spatialAttachment.attachmentData.original,
                compiled: void 0
            },
            filename: ce.spatialAttachment.filename,
            metadata: getMetadataForSpatialAttachment(me, (ge = ce.spatialAttachment) == null ? void 0 : ge.metadata),
            errors: []
        };
        ue.push(Te)
    } else if (ce.includeDefaultSpatialData) {
        const Te = getDefaultSpatialDataByMap(ce, X);
        if (Te) {
            const _e = {
                id: generateUUID(),
                version: SPATIAL_ATTACHMENT_TEMP_VERSION,
                isProcessable: !0,
                attachmentData: {
                    original: Te,
                    compiled: void 0
                },
                processingStatus: ProcessingStatus.PROCESSING_STATUS_PENDING,
                filename: `basic_start_${ce.levelName.toLowerCase()}.json`,
                metadata: getMetadataForSpatialAttachment(me),
                errors: [],
                attachmentType: AttachmentType.ATTACHMENT_TYPE_SPATIAL
            };
            ue.push(_e)
        } else
            logger$b.warn(`No default spatial data was found for ${ce.levelName}`)
    }
    return ue
}
, [])
  , useSaveExperienceMutation = () => {
    const {forceRemountApp: V} = reactExports.useContext(AppContext)
      , {rawBlueprint: X, blueprint: J} = reactExports.useContext(BlueprintContext)
      , {sessionId: ne, player: ue} = reactExports.useContext(SessionContext)
      , ce = useQueryClient()
      , me = useAtomValue(gameSizeAtom)
      , ge = useAtomValue(experienceAtom)
      , Te = useAtomValue(createdAtAtom)
      , _e = useAtomValue(designIdAtom)
      , Se = useAtomValue(attachmentIdsPendingDeletionAtom)
      , Ie = useAtomValue(isCustomGameModeAtom)
      , ye = useAtomValue(attachmentsAtom)
      , $e = useAtomValue(isAllowingCopiesAtom)
      , Ne = useAtomValue(shortCodeAtom)
      , ve = useAtomValue(moderationStateAtom)
      , {spatialDefaults: ke, isLoading: xe} = useSpatialDefaults(Ie)
      , {playElementId: we, name: Fe, description: je, mutators: Xe, mapRotation: ze, gameMode: qe, assetRestrictions: Ze, publishState: et, thumbnailUrl: it, teamComposition: at} = ge
      , rt = useAtomValue(aiTypeAtom)
      , ft = GAME_MODE_TO_MUTATOR_TAG_MAP[qe]
      , St = common_utils.enumToArray(MUTATOR_TAG_GAME_MODE).filter(Ot => Ot !== ft)
      , Ye = Object.entries((J == null ? void 0 : J.mutators) ?? {}).reduce( (Ot, [kt,{tags: Xt, defaultValue: vt}]) => (Xt.some(Ct => St.includes(Ct)) || (Ot[kt] = vt),
    Ot), {})
      , We = {
        ...Ye,
        ...Xe
    }
      , nt = Ie ? We : getSyncMutatorsOrAssetTags(We)
      , ct = Ie ? Ze : getSyncMutatorsOrAssetTags(Ze)
      , Et = at || getSyncTeamComposition(at)
      , Ke = constructModRules(ge)
      , mt = useDeleteAttachmentsMutation(_e)
      , lt = () => {
        const Ot = GAME_MOD_TEAM_BALANCING_MAP.get(qe)
          , kt = getTeamCompositionPayload(Et, MUTATOR_AI_SPAWN_TYPE_TO_CAPACITY_TYPE.get(Number(rt)), Ot)
          , Xt = DEFAULT_GAME_SIZE_MIN
          , vt = {
            maps: ze.map( ({levelName: Ut, levelLocation: An}) => {
                var Dt;
                const yt = getRawMapData(An, Ut, ((Dt = X == null ? void 0 : X.availableGameData) == null ? void 0 : Dt.maps) ?? []);
                return {
                    levelName: Ut,
                    levelLocation: An,
                    gameSize: me || Xt,
                    teamComposition: kt,
                    rounds: yt != null && yt.rounds ? yt.rounds.defaultValue : 0,
                    allowedSpectators: yt != null && yt.allowedSpectators ? yt.allowedSpectators.defaultValue : 0
                }
            }
            ),
            attributes: {
                rotationBehavior: RotationBehavior.ROTATION_BEHAVIOR_LOOP
            }
        };
        Object.entries(LINKED_MUTATORS).forEach( ([Ut,An]) => {
            if (J && Ut in J.mutators) {
                const yt = J.mutators[Ut].defaultValue
                  , Dt = nt[Ut];
                An.forEach(Bt => {
                    if (Bt in J.mutators) {
                        const Wt = J.mutators[Bt].defaultValue;
                        Dt !== void 0 ? nt[Bt] = Dt : Wt !== yt && (nt[Bt] = yt)
                    }
                }
                )
            }
        }
        );
        const Jt = common_utils.enumToArray(MUTATOR_TAG_GAME_MODE)
          , Ct = GAME_MODE_TO_MUTATOR_TAG_MAP[qe]
          , Mt = Object.entries({
            ...Ye,
            ...nt
        }).reduce( (Ut, [An,yt]) => {
            var Sn;
            const Dt = (Sn = X == null ? void 0 : X.availableGameData) == null ? void 0 : Sn.mutators.find(Rn => Rn.name === An)
              , Bt = J == null ? void 0 : J.mutators[An]
              , Wt = (Dt == null ? void 0 : Dt.kind) && getRawKindData(Dt.kind)
              , ut = (Bt == null ? void 0 : Bt.defaultValue) !== yt
              , Ge = Ie && An === CUSTOM_GAME_MODE_MUTATOR_ID ? 2 : yt
              , st = Bt == null ? void 0 : Bt.tags.filter(Rn => Jt.includes(Rn) && Rn !== Ct)
              , At = (Bt == null ? void 0 : Bt.tags.includes(Ct)) || !(st != null && st.length)
              , Ft = (Bt == null ? void 0 : Bt.isForceSave) && At
              , an = Ft && Bt.isInternal;
            if (Wt && Wt.kind !== void 0 && Bt && (Wt != null && Wt.kind) && (ut || Ft)) {
                const Rn = buildMutatorKindFromAvailableMutator({
                    mutatorKindName: Wt.kind,
                    value: an ? Bt.defaultValue : Ge,
                    rawMutator: Dt,
                    fallbackValue: Bt.defaultValue,
                    size: at.size + 1
                });
                Ut.push({
                    id: (Dt == null ? void 0 : Dt.id) ?? "",
                    category: (Dt == null ? void 0 : Dt.category) ?? "",
                    name: An,
                    kind: Rn
                })
            } else
                (ut || Ft) && logger$b.warn(`Failed to prep mutator "${An}" for payload mutatorKind "${Wt}"`);
            return Ut
        }
        , [])
          , nn = combineAssetTagValues(ct, at.size)
          , tn = collapseAssetRestrictionCategories(nn, (J == null ? void 0 : J.assetTags) ?? {
            tags: {},
            categories: {}
        })
          , mn = Object.entries(tn).reduce( (Ut, [An,yt]) => {
            const Dt = yt instanceof Map ? Array.from(yt).every(Ge => !Ge[1]) : !yt
              , Bt = yt instanceof Map ? Array.from(yt).some(Ge => !Ge[1]) : !yt
              , Wt = AssetCategory.fromPartial({
                tagId: An
            })
              , ut = Array.from({
                length: kt.teams.length
            });
            if (Bt) {
                const Ge = AssetCategoryBoolean.fromPartial({
                    defaultValue: !Dt
                });
                Wt.boolean = Ge,
                Dt || (Wt.boolean.teamOverrides = ut.map( (st, ht) => ({
                    assetCategoryTags: [An],
                    teamId: ht + 1,
                    value: !!(getAssetTagValue(yt, ht) ?? !0)
                }))),
                Ut.push(Wt)
            }
            return Ut
        }
        , [])
          , dn = getModRulesPayload(Ke)
          , Qt = ze.filter(Ut => Ut.spatialAttachment && Ut.spatialAttachment.id || Ut.includeDefaultSpatialData).length
          , on = getNewlyAddedSpatialAttachments(ze, ke, ye)
          , zt = PlayElementDesign.fromJSON({
            designName: Fe,
            created: Te === null ? void 0 : Te,
            mapRotation: vt,
            mutators: Mt,
            assetCategories: mn,
            licenseRequirements: []
        });
        zt.attachments = Qt > 0 ? [...on, ...ye] : [...ye.filter(Ut => Ut.attachmentType !== AttachmentType.ATTACHMENT_TYPE_SPATIAL)];
        const $t = PlayElementSettings.fromJSON({
            allowCopies: $e
        });
        return {
            playElementDesign: zt,
            playElement: PlayElement.fromJSON({
                id: we,
                creator: {
                    playerCreator: {
                        player: ue
                    }
                },
                name: Fe,
                thumbnailUrl: it || void 0,
                description: je,
                created: Te === null ? void 0 : Te,
                updated: new Date,
                publishStateType: et,
                playElementSettings: $t
            }),
            modRules: dn
        }
    }
      , Qe = (Ot, kt, Xt) => {
        const vt = {
            id: Ot.id,
            name: Ot.name,
            description: Ot.description,
            designMetadata: kt.designMetadata,
            mapRotation: kt.mapRotation,
            mutators: kt.mutators,
            assetCategories: kt.assetCategories,
            originalModRules: Xt || new Uint8Array,
            modLevelDataId: kt.modLevelDataId,
            playElementSettings: Ot.playElementSettings,
            publishState: Ot.publishStateType,
            thumbnailUrl: Ot.thumbnailUrl,
            attachments: kt.attachments
        };
        return Xt && (vt.originalModRules = Xt),
        vt
    }
      , gt = (Ot, kt, Xt) => ({
        name: Ot.name,
        description: Ot.description,
        playElementSettings: Ot.playElementSettings,
        publishState: Ot.publishStateType,
        thumbnailUrl: Ot.thumbnailUrl,
        designMetadata: kt.designMetadata,
        mapRotation: kt.mapRotation,
        mutators: kt.mutators,
        assetCategories: kt.assetCategories,
        modLevelDataId: kt.modLevelDataId,
        attachments: kt.attachments,
        originalModRules: Xt || new Uint8Array
    })
      , Nt = useMutation({
        mutationFn: Ot => ne ? clients.play.updatePlayElement(Ot, new grpcWebClient_umdExports.grpc.Metadata({
            "x-gateway-session-id": ne
        })) : Promise.reject()
    })
      , Gt = useMutation({
        mutationFn: Ot => ne ? clients.play.createPlayElement(Ot, new grpcWebClient_umdExports.grpc.Metadata({
            "x-gateway-session-id": ne
        })) : Promise.reject()
    });
    return {
        save: async ({onSave: Ot, onError: kt, publishStateOverride: Xt}={}) => {
            var nn, tn, mn, dn, Qt, on, zt, $t;
            const {playElement: vt, playElementDesign: Jt, modRules: Ct} = lt()
              , Mt = Qe(vt, Jt, Ct);
            if (Xt !== void 0 ? Mt.publishState = Xt : Mt.publishState === PublishStateType.PUBLISH_STATE_TYPE_ERROR && (Mt.publishState = PublishStateType.PUBLISH_STATE_TYPE_DRAFT),
            logger$b.log("Attempting save with payload: ", Mt),
            Mt)
                try {
                    const Ut = await Nt.mutateAsync(Mt);
                    Ut && (telemetryHelper.saveExperience({
                        id: Mt.id,
                        title: Mt.name,
                        description: Mt.description || "",
                        type: Ie ? TelemetrySaveType.CUSTOM : TelemetrySaveType.VERIFIED,
                        isModified: !0,
                        shortCode: Ne ?? "",
                        status: getTelemetrySaveStatusFromPublishAndModerationStates(Mt.publishState, ve),
                        isClone: !1,
                        thumbnail: Mt.thumbnailUrl,
                        tags: (tn = (nn = Ut == null ? void 0 : Ut.playElementDesign) == null ? void 0 : nn.tags) == null ? void 0 : tn.map(An => An.tagId),
                        scriptCount: ((dn = (mn = Ut == null ? void 0 : Ut.playElementDesign) == null ? void 0 : mn.attachments) == null ? void 0 : dn.filter(An => An.attachmentType === AttachmentType.ATTACHMENT_TYPE_SCRIPT).length) ?? 0,
                        spatialCount: ((on = (Qt = Ut == null ? void 0 : Ut.playElementDesign) == null ? void 0 : Qt.attachments) == null ? void 0 : on.filter(An => An.attachmentType === AttachmentType.ATTACHMENT_TYPE_SPATIAL).length) ?? 0,
                        maps: (($t = (zt = Mt.mapRotation) == null ? void 0 : zt.maps) == null ? void 0 : $t.map(An => An.levelName)) ?? [],
                        gameMode: qe
                    }),
                    logger$b.log("Save successful!", Ut),
                    await ce.invalidateQueries({
                        queryKey: [QUERY_KEY.PLAY_ELEMENT, vt.id]
                    }),
                    await ce.invalidateQueries({
                        queryKey: [QUERY_KEY.LIST_PLAY_ELEMENTS],
                        exact: !1
                    }),
                    await mt(Se),
                    V(),
                    Ot && Ot(Ut))
                } catch (Ut) {
                    kt && (typeof Ut == "string" ? kt(new Error(Ut)) : Ut instanceof Error ? kt(Ut) : kt()),
                    logger$b.error("Failed to save: ", Ut)
                }
        }
        ,
        create: async (Ot, kt, Xt, vt) => {
            var mn, dn, Qt, on, zt, $t, Ut, An, yt, Dt, Bt;
            const {playElement: Jt, playElementDesign: Ct, modRules: Mt} = vt || lt()
              , nn = ((mn = J == null ? void 0 : J.constraints) == null ? void 0 : mn.maxNameSize) ?? FALLBACK_EXPERIENCE_NAME_MAX_LENGTH;
            if (Xt) {
                const Wt = " copy";
                if (Jt.name.length + Wt.length > nn) {
                    const ut = "..."
                      , Ge = Jt.name.substring(0, nn - (Wt.length + ut.length));
                    Jt.name = Ge + ut + Wt
                } else
                    Jt.name += Wt;
                Jt.publishStateType = PublishStateType.PUBLISH_STATE_TYPE_DRAFT
            }
            logger$b.log("modRules currently available to us are", Mt);
            const tn = gt(Jt, Ct, Mt);
            if (logger$b.log("Attempting create with payload: ", tn),
            tn)
                try {
                    const Wt = await Gt.mutateAsync(tn);
                    Wt && (telemetryHelper.saveExperience({
                        id: ((dn = Wt == null ? void 0 : Wt.playElement) == null ? void 0 : dn.id) || "",
                        title: tn.name,
                        description: tn.description || "",
                        type: Ie ? TelemetrySaveType.CUSTOM : TelemetrySaveType.VERIFIED,
                        isModified: !1,
                        shortCode: Ne ?? "",
                        status: getTelemetrySaveStatusFromPublishAndModerationStates(tn.publishState, ve),
                        isClone: !!Xt,
                        cloneCoupeId: Xt ? (Qt = vt == null ? void 0 : vt.playElement) == null ? void 0 : Qt.id : void 0,
                        thumbnail: tn.thumbnailUrl,
                        tags: (zt = (on = Wt == null ? void 0 : Wt.playElementDesign) == null ? void 0 : on.tags) == null ? void 0 : zt.map(ut => ut.tagId),
                        scriptCount: ((Ut = ($t = Wt == null ? void 0 : Wt.playElementDesign) == null ? void 0 : $t.attachments) == null ? void 0 : Ut.filter(ut => ut.attachmentType === AttachmentType.ATTACHMENT_TYPE_SCRIPT).length) ?? 0,
                        spatialCount: ((yt = (An = Wt == null ? void 0 : Wt.playElementDesign) == null ? void 0 : An.attachments) == null ? void 0 : yt.filter(ut => ut.attachmentType === AttachmentType.ATTACHMENT_TYPE_SPATIAL).length) ?? 0,
                        maps: ((Bt = (Dt = tn.mapRotation) == null ? void 0 : Dt.maps) == null ? void 0 : Bt.map(ut => ut.levelName)) ?? [],
                        gameMode: qe
                    }),
                    logger$b.log("Create successful!", Wt),
                    await ce.invalidateQueries({
                        queryKey: [QUERY_KEY.PLAY_ELEMENT, Jt.id]
                    }),
                    await ce.invalidateQueries({
                        queryKey: [QUERY_KEY.LIST_PLAY_ELEMENTS],
                        exact: !1
                    }),
                    Ot && Ot(Wt))
                } catch (Wt) {
                    kt && (typeof Wt == "string" ? kt(new Error(Wt)) : Wt instanceof Error ? kt(Wt) : kt(),
                    logger$b.error("Failed to create experience: ", Wt))
                }
        }
        ,
        isLoading: xe
    }
}
  , wrapper$6 = "_wrapper_uv6u4_1"
  , details$2 = "_details_uv6u4_15"
  , nameDescription$1 = "_nameDescription_uv6u4_27"
  , startColumn = "_startColumn_uv6u4_38"
  , footer$1 = "_footer_uv6u4_43"
  , styles$B = {
    wrapper: wrapper$6,
    details: details$2,
    nameDescription: nameDescription$1,
    startColumn,
    footer: footer$1
}
  , SavePanel = () => {
    var St, Ye, We;
    const {serverSavedExperienceData: V} = reactExports.useContext(PlayElementContext)
      , X = useAtomValue(thumbnailUrlAtom)
      , J = useSetAtom(isPristineAtom)
      , ne = getBattleBinaryUrl(X)
      , ue = useAtomValue(lastUpdatedTimeAtom)
      , ce = useAtomValue(gameModeAtom)
      , [me,ge] = reactExports.useState(!1)
      , Te = useAtomValue(nameAtom)
      , {addToast: _e} = reactExports.useContext(ToastContext)
      , Se = useAtomValue(mapRotationAtom)
      , Ie = useAtomValue(isSavableAtom)
      , [ye] = useSearchParams()
      , $e = ye.get(QUERY_PARAM_KEY.EXPERIENCE_ID) ?? void 0
      , Ne = useSetAtom(playElementIdAtom)
      , {t: ve} = useTranslation()
      , ke = useAtomValue(isCustomGameModeAtom)
      , xe = V && V.playElement ? getPublishingStateMetadata({
        publishState: V.playElement.publishStateType,
        moderationState: V.playElement.moderationState,
        publishAt: V.playElement.publishAt
    }) : void 0
      , {data: we} = useGetLicenseRequirements()
      , {ownedLicenses: Fe, mapEntryRequirements: je} = we ?? {}
      , {save: Xe, create: ze} = useSaveExperienceMutation()
      , qe = formatServerTags(((St = V == null ? void 0 : V.playElementDesign) == null ? void 0 : St.tags) ?? [], ve)
      , Ze = () => {
        ge(!0),
        Xe({
            onSave: et,
            onError: it
        })
    }
      , et = nt => {
        var ct, Et, Ke, mt, lt, Qe, gt, Nt, Gt;
        ge(!1),
        J(!0),
        (Et = (ct = nt.playElementDesign) == null ? void 0 : ct.attachments) != null && Et.some(Ht => Ht.errors.length) ? _e(`${ve("experience.experience-saved-with-errors")}
                ${getFormattedErrorsFromAttachments((Ke = nt.playElementDesign) == null ? void 0 : Ke.attachments).join(`
`)}`) : (Qe = (lt = (mt = nt.playElementDesign) == null ? void 0 : mt.modRules) == null ? void 0 : lt.errorRules) != null && Qe.errorMessage ? _e(`${ve("experience.experience-saved-with-errors")} ${(Gt = (Nt = (gt = nt.playElementDesign) == null ? void 0 : gt.modRules) == null ? void 0 : Nt.errorRules) == null ? void 0 : Gt.errorMessage}`) : _e(ve("experience.experience-saved"))
    }
      , it = nt => {
        ge(!1),
        _e(`${ve("experience.save-failed")} ${nt == null ? void 0 : nt.message}`)
    }
      , at = () => {
        ge(!0),
        ze(ft, rt)
    }
      , rt = nt => {
        ge(!1),
        _e(`${ve("experience.create-failed")} ${nt == null ? void 0 : nt.message}`)
    }
      , ft = nt => {
        var Et;
        ge(!1);
        const ct = (Et = nt.playElement) == null ? void 0 : Et.id;
        !$e && ct && Ne(ct),
        _e(ve("experience.experience-saved"))
    }
    ;
    return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsx(OffCanvasContent, {
            id: DIALOG_ID.SAVE_PANEL,
            header: jsxRuntimeExports.jsxs(Space, {
                children: [jsxRuntimeExports.jsx(Icon, {
                    name: ICON_NAMES.SAVE
                }), ve("general.save-experience")]
            }),
            footer: jsxRuntimeExports.jsx("div", {
                className: styles$B.footer,
                children: jsxRuntimeExports.jsx(Button, {
                    onClick: $e ? Ze : at,
                    isDisabled: me || !Ie,
                    fillWidth: !0,
                    children: ve($e ? "general.save" : "general.create")
                })
            }),
            children: jsxRuntimeExports.jsxs("div", {
                className: styles$B.wrapper,
                children: [jsxRuntimeExports.jsx(ValidationFails, {}), jsxRuntimeExports.jsxs("div", {
                    className: styles$B.details,
                    children: [jsxRuntimeExports.jsx("div", {
                        className: styles$B.startColumn,
                        children: jsxRuntimeExports.jsx(Field, {
                            label: ve("general.select-image"),
                            children: jsxRuntimeExports.jsx(ExperienceTile, {
                                tag: xe && jsxRuntimeExports.jsx(ExperienceStatusTag, {
                                    variant: xe.chipVariant,
                                    icon: xe.icon,
                                    toolTip: ((Ye = xe.tooltipTranslation) == null ? void 0 : Ye.id) && ve((We = xe.tooltipTranslation) == null ? void 0 : We.id, {
                                        ...xe.tooltipTranslation.arg,
                                        interpolation: {
                                            escapeValue: !1
                                        }
                                    }),
                                    children: ve(xe.label)
                                }),
                                bgImage: ne,
                                heading: Te,
                                subheading: `${ve("general.modified")}: ${ue == null ? void 0 : ue.toLocaleString()}`
                            })
                        })
                    }), jsxRuntimeExports.jsx("div", {
                        className: styles$B.nameDescription,
                        children: jsxRuntimeExports.jsx(ExperienceBasicDetails, {})
                    })]
                }), jsxRuntimeExports.jsx(Field, {
                    label: `${ve("general.mode")} / ${ve(`gamemodes.${ce}.title`)}`
                }), jsxRuntimeExports.jsx(Field, {
                    label: ve("general.map-rotation"),
                    tip: ve("general.validation-tooltip"),
                    icon: ICON_NAMES.MAP_PIN,
                    children: jsxRuntimeExports.jsx(MapRotationPreview, {
                        licenseTooltip: ve("editor.premium-map-req-tooltip"),
                        maps: Se.map( ({image: nt, title: ct, levelName: Et}) => {
                            const {licenseRequirements: Ke, missingLicense: mt} = getUsersMapLicenseData({
                                mapEntryRequirements: je ?? [],
                                ownedLicenses: Fe ?? [],
                                levelName: Et
                            });
                            return {
                                title: ct,
                                image: nt,
                                licenseRequirements: Ke,
                                missingLicense: mt
                            }
                        }
                        )
                    })
                }), jsxRuntimeExports.jsx(Field, {
                    label: ve("general.progression"),
                    tip: ve(ke ? "general.xp-tooltip-custom" : "general.xp-tooltip"),
                    icon: ICON_NAMES.XP,
                    children: jsxRuntimeExports.jsxs(Space, {
                        gapSize: SPACE_GAP_SIZE.XS,
                        children: [jsxRuntimeExports.jsx(Icon, {
                            name: ICON_NAMES.WARNING_DIAMOND
                        }), ve(ke ? "general.custom-xp-description" : "general.verified-xp-description")]
                    })
                }), qe !== void 0 && qe.length ? jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
                    children: jsxRuntimeExports.jsx(Field, {
                        tip: ve("general.helps-users-to-find-experience"),
                        label: ve("general.tags"),
                        children: jsxRuntimeExports.jsx(ServerTags, {
                            serverTags: qe
                        })
                    })
                }) : null]
            })
        }), me ? jsxRuntimeExports.jsx(LoadingSpinner, {
            statusText: ve("experience.saving-experience")
        }) : null]
    })
}
  , footerButtons = "_footerButtons_1106y_1"
  , styles$A = {
    footerButtons
}
  , SharePanel = () => {
    const {colors: V} = reactExports.useContext(ThemeContext)
      , {addToast: X} = reactExports.useContext(ToastContext)
      , J = useAtomValue(shortCodeAtom)
      , [ne,ue] = useAtom(isAllowingCopiesAtom)
      , ce = () => {
        common_utils.copyToClipboard(window.location.href),
        X(`${t$1("experience.experience-url")} ${t$1("general.copied")}`)
    }
      , me = () => {
        J && (common_utils.copyToClipboard(J),
        X(`${t$1("experience.experience-code")} ${t$1("general.copied")}`))
    }
      , ge = () => {
        window.open(EA_HELP_SHARE_EXPERIENCE_URL, "_blank")
    }
      , Te = _e => {
        ue(_e)
    }
    ;
    return jsxRuntimeExports.jsx(OffCanvasContent, {
        id: DIALOG_ID.SHARE_PANEL,
        header: t$1("experience.share-experience"),
        footer: jsxRuntimeExports.jsx(ButtonGroup, {
            className: styles$A.footerButtons,
            fillWidth: !0,
            children: jsxRuntimeExports.jsx(Tooltip, {
                tip: t$1("general.help"),
                placement: PLACEMENT.LEFT,
                children: jsxRuntimeExports.jsx(IconButton, {
                    icon: ICON_NAMES.QUESTION_MARK,
                    onClick: ge
                })
            })
        }),
        children: jsxRuntimeExports.jsxs(Section, {
            children: [jsxRuntimeExports.jsxs(Section, {
                subsection: !0,
                split: !0,
                trimBottom: !0,
                children: [jsxRuntimeExports.jsx(Heading, {
                    variant: HEADING_VARIANT.FIELD_LABEL,
                    children: t$1("experience.experience-code")
                }), jsxRuntimeExports.jsx(Tooltip, {
                    tip: t$1("experience.experience-code-tooltip"),
                    placement: PLACEMENT.LEFT,
                    children: jsxRuntimeExports.jsx(Icon, {
                        name: ICON_NAMES.INFO,
                        color: V.gray500
                    })
                })]
            }), jsxRuntimeExports.jsx(Section, {
                subsection: !0,
                children: J ? jsxRuntimeExports.jsx(TextInput, {
                    label: t$1("experience.experience-code"),
                    value: J,
                    readOnly: !0,
                    action: {
                        icon: ICON_NAMES.COPY,
                        iconOnly: !0,
                        text: t$1("general.copy"),
                        onClick: me
                    }
                }) : null
            }), jsxRuntimeExports.jsxs(Section, {
                subsection: !0,
                split: !0,
                trimY: !0,
                children: [jsxRuntimeExports.jsx(Heading, {
                    variant: HEADING_VARIANT.FIELD_LABEL,
                    children: t$1("experience.experience-url")
                }), jsxRuntimeExports.jsx(Tooltip, {
                    tip: t$1("experience.experience-url-tooltip"),
                    placement: PLACEMENT.LEFT,
                    children: jsxRuntimeExports.jsx(Icon, {
                        name: ICON_NAMES.INFO,
                        color: V.gray500
                    })
                })]
            }), jsxRuntimeExports.jsx(Section, {
                subsection: !0,
                trimBottom: !0,
                children: jsxRuntimeExports.jsx(TextInput, {
                    label: "URL",
                    value: window.location.href,
                    readOnly: !0,
                    action: {
                        icon: ICON_NAMES.COPY,
                        iconOnly: !0,
                        text: t$1("general.copy"),
                        onClick: ce
                    }
                })
            }), jsxRuntimeExports.jsx(Section, {
                subsection: !0,
                trimY: !0,
                children: jsxRuntimeExports.jsx(Caption, {
                    children: t$1("experience.experience-url-caption")
                })
            }), jsxRuntimeExports.jsxs(Section, {
                subsection: !0,
                split: !0,
                trimBottom: !0,
                children: [jsxRuntimeExports.jsx(Checkbox, {
                    label: t$1("general.allow-copies"),
                    checked: ne,
                    onChange: Te,
                    children: t$1("general.allow-copies")
                }), jsxRuntimeExports.jsx(Tooltip, {
                    tip: t$1("experience.allow-copies-tooltip"),
                    placement: PLACEMENT.LEFT,
                    children: jsxRuntimeExports.jsx(Icon, {
                        name: ICON_NAMES.INFO,
                        color: V.gray500
                    })
                })]
            }), jsxRuntimeExports.jsx(Section, {
                subsection: !0,
                trimY: !0,
                children: jsxRuntimeExports.jsx(Caption, {
                    children: t$1("experience.allow-copies-caption")
                })
            })]
        })
    })
}
  , page = "_page_rxypy_1"
  , sidebar = "_sidebar_rxypy_5"
  , body$1 = "_body_rxypy_10"
  , asideCollapsed = "_asideCollapsed_rxypy_15"
  , backToProjectsLink = "_backToProjectsLink_rxypy_25"
  , styles$z = {
    page,
    sidebar,
    body: body$1,
    asideCollapsed,
    backToProjectsLink
}
  , primaryNavIsCollapsed = atom(!1)
  , ExperienceMainNavLayout = ({children: V}) => {
    const X = useNavigate()
      , J = reactExports.useContext(CurrentBreakpointContext)
      , {breakpoints: ne, colors: ue} = reactExports.useContext(ThemeContext)
      , {addToast: ce} = reactExports.useContext(ToastContext)
      , {setIsOpen: me} = reactExports.useContext(DialogContext)
      , {forceClose: ge} = reactExports.useContext(OffCanvasContext)
      , Te = common_utils.getMobileFirstOption({
        xxs: !0,
        md: !1
    }, J, ne) ?? !0
      , {save: _e} = useSaveExperienceMutation()
      , {pathname: Se, search: Ie} = useLocation()
      , [ye,$e] = useAtom(primaryNavIsCollapsed)
      , [Ne,ve] = reactExports.useState(!1)
      , ke = useAtomValue(gameModeAtom)
      , xe = useAtomValue(isOwnerAtom)
      , we = useAtomValue(isPristineAtom)
      , Fe = useAtomValue(createExperienceFromFileAtom)
      , je = useAtomValue(descriptionAtom)
      , [Xe,ze] = useAtom(publishStateAtom)
      , qe = useAtomValue(isSavableAtom)
      , Ze = useAtomValue(nameAtom)
      , et = useAtomValue(thumbnailUrlAtom)
      , it = useSetAtom(experienceAtom)
      , at = useOffCanvas(DIALOG_ID.MOBILE_NAV_OFF_CANVAS)
      , {open: rt} = useOffCanvas(DIALOG_ID.SAVE_PANEL)
      , {open: ft} = useDialog(DIALOG_ID.CONFIRM_LEAVE_UNSAVED_CHANGES)
      , {data: St, isLoading: Ye} = useGetLicenseRequirements()
      , {t: We} = useTranslation()
      , nt = reactExports.useCallback(Ot => {
        const kt = We("app.pending-changes-header") + We("app.pending-changes-body");
        return Ot.returnValue = kt,
        telemetryHelper.logout(),
        kt
    }
    , [We])
      , ct = () => {
        $e(!ye)
    }
      , Et = () => {
        rt()
    }
      , Ke = Ot => {
        var kt, Xt, vt, Jt, Ct, Mt, nn, tn, mn;
        ve(!1),
        (Xt = (kt = Ot.playElementDesign) == null ? void 0 : kt.attachments) != null && Xt.some(dn => dn.errors.length) ? ce(`${We("experience.experience-saved-with-errors")}
                ${getFormattedErrorsFromAttachments((vt = Ot.playElementDesign) == null ? void 0 : vt.attachments).join(`
`)}`) : (Mt = (Ct = (Jt = Ot.playElementDesign) == null ? void 0 : Jt.modRules) == null ? void 0 : Ct.errorRules) != null && Mt.errorMessage ? ce(`${We("experience.experience-saved-with-errors")} ${(mn = (tn = (nn = Ot.playElementDesign) == null ? void 0 : nn.modRules) == null ? void 0 : tn.errorRules) == null ? void 0 : mn.errorMessage}`) : ce(We("experience.experience-saved"))
    }
      , mt = Ot => {
        ve(!1),
        ce(`${We("experience.save-failed")} ${Ot == null ? void 0 : Ot.message}`)
    }
      , lt = Ot => {
        X({
            pathname: Ot,
            search: Ie
        })
    }
      , Qe = () => {
        const Ot = Xe === PublishStateType.PUBLISH_STATE_TYPE_DRAFT ? PublishStateType.PUBLISH_STATE_TYPE_PUBLISHED : PublishStateType.PUBLISH_STATE_TYPE_DRAFT;
        ze(Ot),
        _e({
            onSave: Ke,
            onError: mt,
            publishStateOverride: Ot
        })
    }
      , gt = () => {
        it(PLAYGROUND_ACTIONS.RESET_GAME_MODE),
        X({
            pathname: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.GAME_MODE}`, Se),
            search: Ie
        })
    }
      , Nt = () => {
        we ? X({
            pathname: getAbsolutePathWithLocale(`/${ROUTE.HOME}`, Se)
        }) : ft()
    }
    ;
    reactExports.useEffect( () => {
        !ke && !Fe && X({
            pathname: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.GAME_MODE}`, Se),
            search: Ie
        }, {
            replace: !0
        })
    }
    , []),
    reactExports.useEffect( () => {
        Te || at.close()
    }
    , [Te, at]),
    reactExports.useEffect( () => (!we && xe ? window.addEventListener("beforeunload", nt) : window.removeEventListener("beforeunload", nt),
    () => {
        window.removeEventListener("beforeunload", nt)
    }
    ), [xe, we, nt]);
    const Gt = ke === CUSTOM_GAME_MODE_ID;
    reactExports.useEffect( () => {
        me(!1, DIALOG_STATE.CLOSED),
        ge()
    }
    , [Se]);
    const Ht = !Ye && (St != null && St.ownedLicenses.includes(VIP_ACCESS_LICENSE)) ? [{
        icon: ICON_NAMES.WRENCH,
        label: We("experience.import-patches"),
        link: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.SUPER_USER}`, Se),
        onClick: lt,
        id: "super-user"
    }] : []
      , Kt = jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsx("button", {
            title: We("app.back-to-projects"),
            className: styles$z.backToProjectsLink,
            onClick: Nt,
            children: jsxRuntimeExports.jsxs(Space, {
                gapSize: SPACE_GAP_SIZE.LG,
                children: [jsxRuntimeExports.jsx(Icon, {
                    size: ICON_SIZES.SM,
                    name: ICON_NAMES.CHEVRON_LEFT
                }), We("app.back-to-projects")]
            })
        }), jsxRuntimeExports.jsx(MainNav, {
            pathname: Se,
            items: [...Ht, {
                icon: ICON_NAMES.COG,
                label: We("general.settings"),
                link: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.SETTINGS}/${ROUTE.MODE}`, Se),
                onClick: lt,
                id: TEST_ID.MAIN_NAV_SETTINGS,
                subItems: [{
                    label: We("general.mode"),
                    onClick: lt,
                    testId: TEST_ID.MAIN_NAV_MODE,
                    link: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.SETTINGS}/${ROUTE.MODE}`, Se),
                    isDisabled: !ke
                }]
            }, {
                icon: ICON_NAMES.MAP_PIN,
                label: We("general.map-rotation"),
                id: TEST_ID.MAIN_NAV_MAP_ROTATION,
                onClick: lt,
                link: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.MAP_ROTATION}`, Se)
            }, {
                icon: ICON_NAMES.PLAYERS,
                label: We("general.teams"),
                link: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.DISTRIBUTION}`, Se),
                onClick: lt,
                id: TEST_ID.MAIN_NAV_TEAMS
            }, {
                icon: ICON_NAMES.SETTINGS,
                label: We("general.modifiers"),
                id: TEST_ID.MAIN_NAV_MODIFIERS,
                onClick: lt,
                link: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.MODIFIERS}`, Se),
                subItems: [{
                    label: We("general.gameplay"),
                    onClick: lt,
                    link: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.MODIFIERS}/${ROUTE.GAMEPLAY}`, Se),
                    isDisabled: !ke,
                    testId: TEST_ID.MAIN_NAV_GAMEPLAY
                }, {
                    label: We("general.soldier"),
                    onClick: lt,
                    link: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.MODIFIERS}/${ROUTE.SOLDIER}`, Se),
                    isDisabled: !ke,
                    testId: TEST_ID.MAIN_NAV_SOLDIER
                }, {
                    label: We("general.vehicle"),
                    onClick: lt,
                    link: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.MODIFIERS}/${ROUTE.VEHICLE}`, Se),
                    isDisabled: !ke,
                    testId: TEST_ID.MAIN_NAV_VEHICLE
                }, {
                    label: We("general.ui"),
                    onClick: lt,
                    link: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.MODIFIERS}/${ROUTE.UI}`, Se),
                    isDisabled: !ke,
                    testId: TEST_ID.MAIN_NAV_UI
                }, {
                    label: We("general.bots"),
                    onClick: lt,
                    link: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.MODIFIERS}/${ROUTE.AI}`, Se),
                    isDisabled: !ke || GAME_MODES_THAT_DO_SUPPORT_BOTS.includes(ke),
                    testId: TEST_ID.MAIN_NAV_AI
                }]
            }, {
                icon: ICON_NAMES.WARNING_DIAMOND,
                id: TEST_ID.MAIN_NAV_RESTRICTIONS,
                link: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.RESTRICTIONS}`, Se),
                onClick: lt,
                label: We("general.restrictions"),
                subItems: [{
                    label: We("general.classes"),
                    onClick: lt,
                    link: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.RESTRICTIONS}/${ROUTE.CLASSES}`, Se),
                    isDisabled: !ke,
                    testId: TEST_ID.MAIN_NAV_CHARS
                }, {
                    label: We("general.weapons"),
                    onClick: lt,
                    link: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.RESTRICTIONS}/${ROUTE.WEAPONS}`, Se),
                    isDisabled: !ke,
                    testId: TEST_ID.MAIN_NAV_WEAPONS
                }, {
                    label: We("general.vehicles"),
                    onClick: lt,
                    link: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.RESTRICTIONS}/${ROUTE.VEHICLES}`, Se),
                    isDisabled: !ke,
                    testId: TEST_ID.MAIN_NAV_VEHICLES
                }, {
                    label: We("general.gadgets"),
                    onClick: lt,
                    link: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.RESTRICTIONS}/${ROUTE.GADGETS}`, Se),
                    isDisabled: !ke,
                    testId: TEST_ID.MAIN_NAV_GADGETS
                }]
            }, {
                icon: ICON_NAMES.MODE_CUSTOM,
                label: We("general.rules-editor"),
                id: TEST_ID.MAIN_NAV_RULES,
                onClick: lt,
                link: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.RULES_EDITOR}`, Se),
                isDisabled: !Gt,
                subItems: [{
                    label: We("general.blocks"),
                    onClick: lt,
                    link: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.RULES_EDITOR}/${ROUTE.BLOCKS}`, Se),
                    testId: TEST_ID.MAIN_NAV_BLOCKS,
                    isDisabled: !Gt
                }, {
                    label: We("general.script"),
                    onClick: lt,
                    link: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.RULES_EDITOR}/${ROUTE.SCRIPT_EDITOR}`, Se),
                    testId: TEST_ID.MAIN_NAV_SCRIPT,
                    isDisabled: !Gt
                }]
            }, {
                icon: ICON_NAMES.UPLOAD2,
                label: We("general.publish"),
                id: TEST_ID.MAIN_NAV_PUBLISH,
                onClick: lt,
                link: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.PUBLISH}/${ROUTE.PUBLISH_STEP_ONE}`, Se),
                spacing: MAIN_NAV_LIST_SPACING_SIZE.LG,
                subItems: [{
                    label: We("general.step-1"),
                    onClick: lt,
                    link: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.PUBLISH}/${ROUTE.PUBLISH_STEP_ONE}`, Se),
                    testId: TEST_ID.MAIN_NAV_PUBLISH_STEP_ONE,
                    description: We("general.define-experience-name-and-description"),
                    ...(!Ze || !je) && {
                        step: !0
                    },
                    ...Ze && je && {
                        icon: ICON_NAMES.CHECK
                    }
                }, {
                    label: We("general.step-2"),
                    onClick: lt,
                    link: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.PUBLISH}/${ROUTE.PUBLISH_STEP_TWO}`, Se),
                    testId: TEST_ID.MAIN_NAV_PUBLISH_STEP_TWO,
                    description: We("general.select-an-image-to-represent-your-experience"),
                    step: !0,
                    ...!et && {
                        step: !0
                    },
                    ...et && {
                        icon: ICON_NAMES.CHECK
                    }
                }, {
                    label: We("general.step-3"),
                    onClick: lt,
                    link: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.PUBLISH}/${ROUTE.PUBLISH_STEP_THREE}`, Se),
                    testId: TEST_ID.MAIN_NAV_PUBLISH_STEP_THREE,
                    description: We("general.review-and-confirm-your-submission"),
                    step: !0
                }]
            }]
        })]
    });
    return jsxRuntimeExports.jsxs("div", {
        className: styles$z.page,
        children: [jsxRuntimeExports.jsx(Sidebar, {
            className: styles$z.sidebar,
            collapseLabel: We("general.minimize"),
            label: "Sidebar",
            isCollapsed: ye,
            toggleCollapse: ct,
            content: Kt,
            hideOnMobile: !0,
            children: jsxRuntimeExports.jsxs("div", {
                className: common_utils.classNames(styles$z.body, ye && styles$z.asideCollapsed),
                children: [jsxRuntimeExports.jsx(OffCanvasContent, {
                    header: We("general.menu"),
                    footer: xe && jsxRuntimeExports.jsxs(ButtonGroup, {
                        children: [jsxRuntimeExports.jsx(Tooltip, {
                            tip: We("general.save"),
                            children: jsxRuntimeExports.jsx(IconButton, {
                                icon: ICON_NAMES.SAVE,
                                label: We("general.save"),
                                onClick: Et
                            })
                        }), jsxRuntimeExports.jsx(Tooltip, {
                            tip: We("general.publish"),
                            children: jsxRuntimeExports.jsx(IconButton, {
                                testId: TEST_ID.PUBLISH_BUTTON,
                                icon: ICON_NAMES.UPLOAD2,
                                className: styles$z.iconButton,
                                label: We("general.publish"),
                                onClick: Qe,
                                isDisabled: !qe,
                                ...!qe && {
                                    color: ue.gray300
                                }
                            })
                        })]
                    }),
                    id: DIALOG_ID.MOBILE_NAV_OFF_CANVAS,
                    children: Kt
                }), V]
            })
        }), jsxRuntimeExports.jsx(SharePanel, {}), jsxRuntimeExports.jsx(SavePanel, {}), jsxRuntimeExports.jsxs(DialogContent, {
            id: DIALOG_ID.RESET_EXPERIENCE,
            header: jsxRuntimeExports.jsxs(Space, {
                gapSize: SPACE_GAP_SIZE.SM,
                children: [jsxRuntimeExports.jsx(Icon, {
                    name: ICON_NAMES.WARNING
                }), " ", We("general.warning")]
            }),
            footer: jsxRuntimeExports.jsxs(ButtonGroup, {
                fillWidth: !0,
                children: [jsxRuntimeExports.jsx(Button, {
                    fillWidth: !0,
                    variant: BUTTON_VARIANTS.SECONDARY,
                    type: BUTTON_TYPES$1.SUBMIT,
                    children: We("general.cancel")
                }), jsxRuntimeExports.jsx(Button, {
                    fillWidth: !0,
                    color: ue.primary,
                    type: BUTTON_TYPES$1.SUBMIT,
                    onClick: gt,
                    children: We("general.confirm")
                })]
            }),
            children: [jsxRuntimeExports.jsx(Paragraph, {
                children: We("general.are-you-sure-you-want-to-reset-experience")
            }), jsxRuntimeExports.jsx(Paragraph, {
                children: We("general.all-progress-for-this-experience-will-be-lost")
            })]
        }), Ne ? jsxRuntimeExports.jsx(LoadingSpinner, {
            statusText: We("experience.saving-experience")
        }) : null]
    })
}
  , logger$a = Logger$1.get("reportExperienceMutation")
  , useReportExperienceMutation = () => {
    const {sessionId: V} = reactExports.useContext(SessionContext)
      , X = useQueryClient()
      , J = useMutation({
        mutationFn: ({experienceId: ue, subject: ce}) => V && ue ? clients.webReporting.ReportExperience({
            experienceId: ue,
            subject: ce
        }, new grpcWebClient_umdExports.grpc.Metadata({
            "x-gateway-session-id": V
        })) : Promise.reject()
    });
    return async ({experienceId: ue, subject: ce}, me, ge) => {
        var Te;
        if (ue)
            try {
                const _e = await J.mutateAsync({
                    experienceId: ue,
                    subject: ce
                });
                _e && (logger$a.log("Response", _e),
                _e.success && (await X.invalidateQueries({
                    queryKey: [QUERY_KEY.PLAY_ELEMENT, ue]
                }),
                await X.invalidateQueries({
                    queryKey: [QUERY_KEY.LIST_PLAY_ELEMENTS],
                    exact: !1
                }),
                me && me(_e)),
                _e.error && ge && ((Te = _e == null ? void 0 : _e.error) != null && Te.errorMessage ? ge(new Error(_e.error.errorMessage)) : ge()))
            } catch (_e) {
                Logger$1.error("Failed to report due to an exception: ", _e),
                ge && (typeof _e == "string" ? ge(new Error(_e)) : _e instanceof Error ? ge(_e) : ge())
            }
    }
}
  , details$1 = "_details_536iw_1"
  , img$1 = "_img_536iw_13"
  , nameDescription = "_nameDescription_536iw_23"
  , styles$y = {
    details: details$1,
    img: img$1,
    nameDescription
}
  , NonOwnerExperienceDetailsDialog = () => {
    const V = useNavigate()
      , {pathname: X} = useLocation()
      , {forceRemountApp: J} = reactExports.useContext(AppContext)
      , {serverSavedExperienceData: ne} = reactExports.useContext(PlayElementContext)
      , ue = useAtomValue(playElementIdAtom)
      , {t: ce} = useTranslation()
      , [me,ge] = reactExports.useState(!1)
      , Te = useAtomValue(thumbnailUrlAtom)
      , _e = useAtomValue(descriptionAtom)
      , Se = useAtomValue(gameModeAtom)
      , {create: Ie} = useSaveExperienceMutation()
      , ye = useAtomValue(nameAtom)
      , [$e,Ne] = reactExports.useState(!1)
      , ve = useReportExperienceMutation()
      , [ke,xe] = reactExports.useState(void 0)
      , {open: we} = useDialog(DIALOG_ID.REPORT_EXPERIENCE)
      , {addToast: Fe} = reactExports.useContext(ToastContext)
      , {tags: je=[]} = (ne == null ? void 0 : ne.playElementDesign) ?? {}
      , {shortCode: Xe} = (ne == null ? void 0 : ne.playElement) ?? {}
      , {colors: ze} = reactExports.useContext(ThemeContext)
      , qe = () => {
        ge(!1),
        Fe(ce("experience.duplicate-failed"))
    }
      , Ze = Ye => {
        var nt;
        ge(!1);
        const We = (nt = Ye.playElement) == null ? void 0 : nt.id;
        if (We) {
            const ct = `${createSearchParams({
                [QUERY_PARAM_KEY.EXPERIENCE_ID]: We
            })}`;
            V({
                pathname: X,
                search: ct
            }),
            J()
        }
        Fe(ce("experience.duplicate-success"))
    }
      , et = () => {
        ge(!0),
        Ie(Ze, qe, !0)
    }
      , it = Ye => {
        xe(Ye)
    }
      , at = () => {
        xe(void 0),
        we()
    }
      , rt = () => {
        Ne(!0),
        ve({
            experienceId: ue,
            subject: ke
        }, St, ft)
    }
      , ft = Ye => {
        Ne(!1),
        Fe(`${ce("experience.report-failed")}  ${Ye == null ? void 0 : Ye.message}`)
    }
      , St = () => {
        Ne(!1),
        Fe(ce("experience.report-success"))
    }
    ;
    return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsxs(OffCanvasContent, {
            id: DIALOG_ID.VIEW_NON_OWNER_EXPERIENCE_DETAILS_OFF_CANVAS,
            header: ce("general.experience-details"),
            footer: jsxRuntimeExports.jsxs(ButtonGroup, {
                fillWidth: !0,
                justifyCenter: !0,
                children: [jsxRuntimeExports.jsx(Button, {
                    prefixIcon: ICON_NAMES.FLAG,
                    onClick: at,
                    children: ce("general.report")
                }), jsxRuntimeExports.jsx(Button, {
                    prefixIcon: ICON_NAMES.COPY,
                    onClick: et,
                    children: ce("general.clone")
                })]
            }),
            children: [jsxRuntimeExports.jsx(Section, {
                children: jsxRuntimeExports.jsxs("div", {
                    className: styles$y.details,
                    children: [jsxRuntimeExports.jsxs("div", {
                        children: [jsxRuntimeExports.jsx(Section, {
                            subsection: !0,
                            trimY: !0,
                            children: jsxRuntimeExports.jsx(Heading, {
                                variant: HEADING_VARIANT.FIELD_LABEL,
                                children: ce("general.selected-image")
                            })
                        }), Te && jsxRuntimeExports.jsx("img", {
                            className: styles$y.img,
                            src: getBattleBinaryUrl(Te),
                            alt: ce("general.selected-image")
                        })]
                    }), jsxRuntimeExports.jsxs("div", {
                        className: styles$y.nameDescription,
                        children: [jsxRuntimeExports.jsxs(Section, {
                            subsection: !0,
                            children: [jsxRuntimeExports.jsx(Section, {
                                subsection: !0,
                                trimY: !0,
                                children: jsxRuntimeExports.jsx(Heading, {
                                    variant: HEADING_VARIANT.FIELD_LABEL,
                                    children: ce("general.name")
                                })
                            }), jsxRuntimeExports.jsx(Section, {
                                trimTop: !0,
                                subsection: !0,
                                children: ye
                            })]
                        }), jsxRuntimeExports.jsxs(Section, {
                            subsection: !0,
                            children: [jsxRuntimeExports.jsx(Section, {
                                subsection: !0,
                                trimY: !0,
                                children: jsxRuntimeExports.jsx(Heading, {
                                    variant: HEADING_VARIANT.FIELD_LABEL,
                                    children: ce("general.description")
                                })
                            }), jsxRuntimeExports.jsx(Section, {
                                trimTop: !0,
                                subsection: !0,
                                children: _e
                            })]
                        })]
                    })]
                })
            }), jsxRuntimeExports.jsxs(Section, {
                trimTop: !0,
                children: [jsxRuntimeExports.jsx(Section, {
                    subsection: !0,
                    trimY: !0,
                    children: jsxRuntimeExports.jsx(Heading, {
                        variant: HEADING_VARIANT.FIELD_LABEL,
                        children: ce("general.game-mode")
                    })
                }), jsxRuntimeExports.jsx(Section, {
                    trimTop: !0,
                    subsection: !0,
                    children: ce(`gamemodes.${Se}.title`)
                }), jsxRuntimeExports.jsx(Section, {
                    subsection: !0,
                    trimY: !0,
                    children: jsxRuntimeExports.jsx(Heading, {
                        variant: HEADING_VARIANT.FIELD_LABEL,
                        children: ce("general.tags")
                    })
                }), jsxRuntimeExports.jsx(Section, {
                    subsection: !0,
                    trimTop: !0,
                    children: jsxRuntimeExports.jsx(ChipList, {
                        children: je.map( ({tagId: Ye, metadata: We}) => {
                            var Ke, mt;
                            const nt = We == null ? void 0 : We.translations
                              , ct = ce(((Ke = nt == null ? void 0 : nt.find( ({kind: lt}) => lt === SERVER_TAG_TRANSLATION_KIND.NAME)) == null ? void 0 : Ke.translationId) ?? "")
                              , Et = ce(((mt = nt == null ? void 0 : nt.find( ({kind: lt}) => lt === SERVER_TAG_TRANSLATION_KIND.DESCRIPTION)) == null ? void 0 : mt.translationId) ?? "");
                            return jsxRuntimeExports.jsx(Tooltip, {
                                tip: Et,
                                children: jsxRuntimeExports.jsx(Chip, {
                                    children: ct
                                })
                            }, Ye)
                        }
                        )
                    })
                }), Xe && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                    children: [jsxRuntimeExports.jsx(Section, {
                        subsection: !0,
                        trimY: !0,
                        children: jsxRuntimeExports.jsx(Heading, {
                            variant: HEADING_VARIANT.FIELD_LABEL,
                            children: ce("experience.experience-code")
                        })
                    }), jsxRuntimeExports.jsx(Section, {
                        trimTop: !0,
                        subsection: !0,
                        children: Xe
                    })]
                })]
            })]
        }), jsxRuntimeExports.jsxs(DialogContent, {
            id: DIALOG_ID.REPORT_EXPERIENCE,
            header: jsxRuntimeExports.jsxs(Space, {
                children: [jsxRuntimeExports.jsx(Icon, {
                    name: ICON_NAMES.WARNING
                }), ce("experience.report-experience")]
            }),
            footer: jsxRuntimeExports.jsxs(ButtonGroup, {
                fillWidth: !0,
                children: [jsxRuntimeExports.jsx(Button, {
                    fillWidth: !0,
                    variant: BUTTON_VARIANTS.SECONDARY,
                    type: BUTTON_TYPES$1.SUBMIT,
                    children: ce("general.cancel")
                }), jsxRuntimeExports.jsx(Button, {
                    fillWidth: !0,
                    color: ze.primary,
                    type: BUTTON_TYPES$1.SUBMIT,
                    onClick: rt,
                    children: ce("general.report")
                })]
            }),
            children: [ce("experience.report-description"), jsxRuntimeExports.jsx(TextInput, {
                fillWidth: !0,
                label: "reason",
                type: TEXT_INPUT_TYPES.MULTILINE,
                value: ke,
                onChange: it,
                testId: TEST_ID.REPORT_EXPERIENCE_SUBJECT
            })]
        }), $e ? jsxRuntimeExports.jsx(LoadingSpinner, {
            statusText: "Reporting Experience..."
        }) : null, me ? jsxRuntimeExports.jsx(LoadingSpinner, {
            statusText: "Duplicating Experience..."
        }) : null]
    })
}
  , headingWrapper = "_headingWrapper_13kdl_1"
  , heading$3 = "_heading_13kdl_1"
  , actions = "_actions_13kdl_21"
  , iconButton = "_iconButton_13kdl_25"
  , saveButton = "_saveButton_13kdl_30"
  , moreInfo = "_moreInfo_13kdl_39"
  , styles$x = {
    headingWrapper,
    heading: heading$3,
    actions,
    iconButton,
    saveButton,
    moreInfo
}
  , ExperienceHeading = ({heading: V, showFinishButton: X, hidePublishIconButton: J, title: ne, subheading: ue}) => {
    var ut, Ge, st;
    const [ce,me] = reactExports.useState(!1)
      , [ge,Te] = reactExports.useState(!1)
      , [_e,Se] = useAtom(playElementIdAtom)
      , Ie = useAtomValue(isOwnerAtom)
      , ye = useAtomValue(gameModeAtom)
      , $e = useAtomValue(mutatorsAtom)
      , Ne = useAtomValue(isSavableAtom)
      , ve = useAtomValue(patchIdAtom)
      , ke = useAtomValue(workspaceAtom)
      , xe = useAtomValue(nameAtom)
      , we = useAtomValue(mapRotationAtom)
      , Fe = useAtomValue(teamCompositionAtom)
      , je = useAtomValue(restrictedAssetTagsAtom)
      , Xe = useAtomValue(descriptionAtom)
      , ze = useSetAtom(importExperienceErrorsAtom)
      , qe = useAtomValue(attachmentsAtom)
      , {colors: Ze, breakpoints: et} = reactExports.useContext(ThemeContext)
      , {addToast: it} = reactExports.useContext(ToastContext)
      , {serverSavedExperienceData: at} = reactExports.useContext(PlayElementContext)
      , {forceRemountApp: rt, handleDeleteExperience: ft} = reactExports.useContext(AppContext)
      , [St,Ye] = useSearchParams()
      , We = useImportExperience()
      , {create: nt} = useSaveExperienceMutation()
      , {search: ct, pathname: Et} = useLocation()
      , {open: Ke} = useDialog(DIALOG_ID.IMPORT_EXPERIENCE_ERRORS)
      , mt = useNavigate()
      , {blueprint: lt} = reactExports.useContext(BlueprintContext)
      , {t: Qe} = useTranslation()
      , {open: gt} = useOffCanvas(DIALOG_ID.SHARE_PANEL)
      , {open: Nt} = useDialog(DIALOG_ID.RESET_EXPERIENCE)
      , {open: Gt} = useOffCanvas(DIALOG_ID.VIEW_NON_OWNER_EXPERIENCE_DETAILS_OFF_CANVAS)
      , Ht = St.get(QUERY_PARAM_KEY.EXPERIENCE_ID) ?? void 0
      , Kt = reactExports.useContext(CurrentBreakpointContext)
      , Ot = common_utils.getMobileFirstOption({
        xxs: !0,
        md: !1
    }, Kt, et) ?? !0
      , kt = ((ut = at == null ? void 0 : at.playElement) == null ? void 0 : ut.name) ?? getDefaultExperienceTitle(ye)
      , Xt = reactExports.useRef(!_e)
      , {open: vt} = useOffCanvas(DIALOG_ID.MOBILE_NAV_OFF_CANVAS)
      , {open: Jt} = useOffCanvas(DIALOG_ID.SAVE_PANEL)
      , Ct = () => {
        vt()
    }
      , Mt = () => {
        mt({
            pathname: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.PUBLISH}/${ROUTE.PUBLISH_STEP_THREE}`),
            search: ct
        })
    }
      , nn = () => {
        const ht = {
            mutators: webMutatorsToExportedMutators($e),
            assetRestrictions: lt != null && lt.assetTags ? webAssetRestrictionsToExportedAssetRestrictions(je, lt == null ? void 0 : lt.assetTags) : {},
            name: xe,
            description: Xe,
            mapRotation: webMapRotationToExportedMapRotation(we),
            patchId: ve,
            workspace: ke,
            teamComposition: Array.from(Fe ?? []),
            gameMode: ye,
            attachments: webAttachmentsToExportedAttachments(qe)
        };
        Object.keys(ht).forEach(At => {
            At in ht && (ht[At] === void 0 || ht[At] === null) && delete ht[At]
        }
        ),
        downloadFile(`${sanitizeFilename(xe)}.json`, JSON.stringify(ht))
    }
      , tn = () => {
        Jt(!0)
    }
      , mn = ht => {
        me(ht)
    }
      , dn = () => {
        loadFile(ht => {
            var At, Ft;
            if (typeof ((At = ht.target) == null ? void 0 : At.result) == "string")
                try {
                    const an = JSON.parse((Ft = ht.target) == null ? void 0 : Ft.result)
                      , {status: Sn, errors: Rn} = We(an);
                    ze(Rn),
                    Sn === IMPORT_EXPERIENCE_STATUS.SUCCESS ? it(Qe("general.experience-imported-successfully")) : Ke()
                } catch (an) {
                    console.error("Failed to read file", an)
                }
        }
        , [".json", "application/json"])
    }
      , Qt = () => {
        Ht && ft(Ht)
    }
      , on = () => {
        gt()
    }
      , zt = () => {
        window.open(`https://download.portal.battlefield.com/PortalSDK.zip?${cacheBustSuffix()}`, "_blank")
    }
      , $t = reactExports.useCallback( () => {
        Te(!1),
        it(Qe("experience.duplicate-failed"))
    }
    , [it, Qe])
      , Ut = reactExports.useCallback(ht => {
        var Ft;
        Te(!1);
        const At = (Ft = ht.playElement) == null ? void 0 : Ft.id;
        if (At) {
            Se(At);
            const an = `${createSearchParams({
                [QUERY_PARAM_KEY.EXPERIENCE_ID]: At
            })}`;
            mt({
                pathname: Et,
                search: an
            }),
            rt()
        }
        it(Qe("experience.duplicate-success"))
    }
    , [it, rt, mt, Se, Qe])
      , An = reactExports.useCallback( () => {
        Te(!0),
        nt(Ut, $t, !0)
    }
    , [nt, $t, Ut])
      , yt = () => {
        Nt()
    }
      , Dt = () => {
        Gt()
    }
    ;
    reactExports.useEffect( () => {
        _e && Xt.current && (Xt.current = !1,
        Ye(ht => (ht.set(QUERY_PARAM_KEY.EXPERIENCE_ID, _e),
        ht), {
            replace: !0,
            preventScrollReset: !1
        }))
    }
    , [_e, Ye]);
    const Bt = [jsxRuntimeExports.jsxs(Space, {
        children: [jsxRuntimeExports.jsx(Icon, {
            name: GAME_MODE_SMALL_ICON_MAP.get(ye) ?? ICON_NAMES.MODE_CUSTOM,
            color: Ze.primary
        }), kt]
    }, "experience-name"), jsxRuntimeExports.jsx(reactExports.Fragment, {
        children: V
    }, "heading")];
    ue && Bt.push(jsxRuntimeExports.jsx(reactExports.Fragment, {
        children: ue
    }, "subheading"));
    const Wt = at && at.playElement ? getPublishingStateMetadata({
        publishState: at.playElement.publishStateType,
        moderationState: at.playElement.moderationState,
        publishAt: at.playElement.publishAt
    }) : void 0;
    return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsxs(PageWrapper, {
            trimY: !0,
            className: styles$x.headingWrapper,
            children: [!Ie && jsxRuntimeExports.jsx(WarningList, {
                children: jsxRuntimeExports.jsx(Warning, {
                    text: Qe("editor.non-owner-warning")
                })
            }), jsxRuntimeExports.jsxs("div", {
                className: styles$x.heading,
                children: [Ot && jsxRuntimeExports.jsx(IconButton, {
                    size: ICON_BUTTON_SIZE.SM,
                    icon: ICON_NAMES.HAMBURGER,
                    onClick: Ct
                }), jsxRuntimeExports.jsx(Breadcrumb, {
                    crumbs: Bt
                }), jsxRuntimeExports.jsxs(Space, {
                    children: [!Ie && jsxRuntimeExports.jsxs(Space, {
                        column: !0,
                        align: SPACE_ALIGN.END,
                        gapSize: SPACE_GAP_SIZE.XXS,
                        children: [jsxRuntimeExports.jsxs(Space, {
                            gapSize: SPACE_GAP_SIZE.XS,
                            children: [jsxRuntimeExports.jsx(Icon, {
                                name: ICON_NAMES.MINUS,
                                variant: ICON_VARIANTS.CIRCLE,
                                color: Ze.white
                            }), jsxRuntimeExports.jsx(Paragraph, {
                                children: kt
                            })]
                        }), jsxRuntimeExports.jsxs(Link$1, {
                            className: styles$x.moreInfo,
                            onClick: Dt,
                            children: [Qe("general.more-info"), " >"]
                        })]
                    }), jsxRuntimeExports.jsxs(Space, {
                        gapSize: SPACE_GAP_SIZE.SM,
                        className: styles$x.actions,
                        children: [Wt && jsxRuntimeExports.jsx(ExperienceStatusTag, {
                            variant: Wt.chipVariant,
                            icon: Wt.icon,
                            toolTip: ((Ge = Wt.tooltipTranslation) == null ? void 0 : Ge.id) && Qe((st = Wt.tooltipTranslation) == null ? void 0 : st.id, Wt.tooltipTranslation.arg),
                            children: Qe(Wt.label)
                        }), Ie && jsxRuntimeExports.jsx(Tooltip, {
                            tip: Qe("general.save"),
                            children: jsxRuntimeExports.jsx(IconButton, {
                                className: common_utils.classNames(styles$x.iconButton, styles$x.saveButton),
                                icon: ICON_NAMES.SAVE,
                                label: Qe("general.save"),
                                onClick: tn,
                                variant: ICON_BUTTON_VARIANT.SECONDARY,
                                size: ICON_BUTTON_SIZE.SM
                            })
                        }), !X && !J && Ie && jsxRuntimeExports.jsx(Tooltip, {
                            tip: Qe("general.publish"),
                            children: jsxRuntimeExports.jsx(IconButton, {
                                testId: TEST_ID.PUBLISH_BUTTON,
                                icon: ICON_NAMES.UPLOAD2,
                                variant: ICON_BUTTON_VARIANT.SECONDARY,
                                className: styles$x.iconButton,
                                label: Qe("general.publish"),
                                onClick: Mt,
                                isDisabled: !Ne,
                                size: ICON_BUTTON_SIZE.SM,
                                ...!Ne && {
                                    color: Ze.gray300
                                }
                            })
                        }), Ie ? jsxRuntimeExports.jsx(Menu, {
                            isOpen: ce,
                            label: jsxRuntimeExports.jsx(IconButton, {
                                className: styles$x.iconButton,
                                variant: ICON_BUTTON_VARIANT.SECONDARY,
                                icon: ICON_NAMES.VERTICAL_DOTS,
                                size: ICON_BUTTON_SIZE.SM
                            }),
                            onToggle: mn,
                            placement: PLACEMENT.BOTTOM_RIGHT,
                            ignoreContextClick: !0,
                            children: jsxRuntimeExports.jsx(MenuItemList, {
                                items: [Ht ? jsxRuntimeExports.jsx(MenuItem, {
                                    onClick: on,
                                    children: Qe("general.share")
                                }, "share") : void 0, Ht ? jsxRuntimeExports.jsx(MenuItem, {
                                    onClick: An,
                                    children: Qe("general.duplicate")
                                }, "duplicate") : void 0, jsxRuntimeExports.jsx(MenuItem, {
                                    onClick: dn,
                                    children: Qe("general.import")
                                }, "import"), jsxRuntimeExports.jsx(MenuItem, {
                                    onClick: nn,
                                    children: Qe("general.export")
                                }, "export"), jsxRuntimeExports.jsx(MenuItem, {
                                    onClick: yt,
                                    children: Qe("general.reset")
                                }, "reset"), Ht ? jsxRuntimeExports.jsx(MenuItem, {
                                    onClick: Qt,
                                    children: Qe("general.delete")
                                }, "delete") : void 0, jsxRuntimeExports.jsx(MenuItem, {
                                    onClick: zt,
                                    children: Qe("download-sdk")
                                }, "download")].filter(ht => ht !== void 0)
                            })
                        }) : null]
                    })]
                })]
            })]
        }), jsxRuntimeExports.jsx(PageWrapper, {
            children: ne && jsxRuntimeExports.jsx(Heading, {
                variant: HEADING_VARIANT.PAGE_TITLE,
                children: ne
            })
        }), jsxRuntimeExports.jsx(ImportExperienceErrorsDialog, {
            id: DIALOG_ID.IMPORT_EXPERIENCE_ERRORS
        }), jsxRuntimeExports.jsx(NonOwnerExperienceDetailsDialog, {}), ge ? jsxRuntimeExports.jsx(LoadingSpinner, {
            statusText: Qe("general.duplicating-experience")
        }) : null]
    })
}
  , content$6 = "_content_avk02_1"
  , prevNextBg = "_prevNextBg_avk02_13"
  , prevNextBar = "_prevNextBar_avk02_21"
  , styles$w = {
    content: content$6,
    prevNextBg,
    prevNextBar
}
  , ExperiencePageLayout = ({children: V, heading: X, subheading: J, title: ne, prev: ue, next: ce, showFinishButton: me, hidePublishIconButton: ge}) => {
    const [Te] = useSearchParams()
      , {save: _e, create: Se} = useSaveExperienceMutation()
      , Ie = useNavigate()
      , {search: ye, pathname: $e} = useLocation()
      , Ne = Te.get(QUERY_PARAM_KEY.EXPERIENCE_ID) ?? void 0
      , {t: ve} = useTranslation()
      , ke = document.documentElement.dir === "rtl"
      , xe = useSetAtom(isPristineAtom)
      , {addToast: we} = reactExports.useContext(ToastContext)
      , Fe = useAtomValue(isSavableAtom)
      , je = useAtomValue(isOwnerAtom)
      , Xe = useSetAtom(publishStateAtom)
      , ze = useSetAtom(playElementIdAtom)
      , qe = useAtomValue(isCustomGameModeAtom)
      , Ze = useAtomValue(gameModeAtom)
      , [et,it] = reactExports.useState(!1)
      , at = $e.includes(`/${ROUTE.EXPERIENCE}/${ROUTE.PUBLISH}/${ROUTE.PUBLISH_STEP_ONE}`)
      , rt = $e.includes(`/${ROUTE.EXPERIENCE}/${ROUTE.RESTRICTIONS}/${ROUTE.GADGETS}`)
      , ft = $e.includes(`/${ROUTE.EXPERIENCE}/${ROUTE.MODIFIERS}/${ROUTE.UI}`)
      , St = $e.includes(`/${ROUTE.EXPERIENCE}/${ROUTE.RESTRICTIONS}/${ROUTE.CLASSES}`)
      , Ye = $e.includes(`/${ROUTE.EXPERIENCE}/${ROUTE.MODIFIERS}/${ROUTE.AI}`)
      , We = GAME_MODES_THAT_DO_SUPPORT_BOTS.includes(Ze);
    St && We && (ue = {
        label: ve("general.ui"),
        route: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.MODIFIERS}/${ROUTE.UI}`)
    }),
    ft && We && (ce = {
        label: ve("general.restrictions"),
        route: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.RESTRICTIONS}/${ROUTE.CLASSES}`)
    }),
    at && !qe && (ue = {
        label: ve("general.gadgets"),
        route: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.RESTRICTIONS}/${ROUTE.GADGETS}`)
    }),
    rt && qe && (ce = {
        label: ve("general.rules-editor"),
        route: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.RULES_EDITOR}/${ROUTE.BLOCKS}`)
    }),
    reactExports.useEffect( () => {
        Ye && We && Ie({
            pathname: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.MODIFIERS}/${ROUTE.UI}`),
            search: ye
        })
    }
    , [We, Ye, Ie, ye]);
    const nt = () => {
        Xe(PublishStateType.PUBLISH_STATE_TYPE_PUBLISHED),
        it(!0),
        _e({
            onSave: Et,
            onError: Ke,
            publishStateOverride: PublishStateType.PUBLISH_STATE_TYPE_PUBLISHED
        })
    }
      , ct = (gt, Nt) => () => {
        Ie({
            pathname: gt,
            search: Nt
        })
    }
      , Et = gt => {
        var Nt, Gt, Ht, Kt, Ot, kt, Xt, vt, Jt;
        xe(!0),
        it(!1),
        (Gt = (Nt = gt.playElementDesign) == null ? void 0 : Nt.attachments) != null && Gt.some(Ct => Ct.errors.length) ? we(`${ve("experience.experience-saved-with-errors")}
                ${getFormattedErrorsFromAttachments((Ht = gt.playElementDesign) == null ? void 0 : Ht.attachments).join(`
`)}`) : (kt = (Ot = (Kt = gt.playElementDesign) == null ? void 0 : Kt.modRules) == null ? void 0 : Ot.errorRules) != null && kt.errorMessage ? we(`${ve("experience.experience-saved-with-errors")} ${(Jt = (vt = (Xt = gt.playElementDesign) == null ? void 0 : Xt.modRules) == null ? void 0 : vt.errorRules) == null ? void 0 : Jt.errorMessage}`) : we("Published Experience Successfully")
    }
      , Ke = gt => {
        it(!1),
        Xe(PublishStateType.PUBLISH_STATE_TYPE_DRAFT),
        we(`Failed to publish ${gt == null ? void 0 : gt.message}`)
    }
      , mt = () => {
        it(!0),
        Se(Qe, lt)
    }
      , lt = () => {
        it(!1),
        we(ve("experience.create-failed"))
    }
      , Qe = gt => {
        var Gt;
        const Nt = (Gt = gt.playElement) == null ? void 0 : Gt.id;
        it(!1),
        !Ne && Nt && ze(Nt),
        we(ve("experience.experience-saved"))
    }
    ;
    return jsxRuntimeExports.jsxs("div", {
        className: styles$w.content,
        children: [X && jsxRuntimeExports.jsx(ExperienceHeading, {
            heading: X,
            subheading: J,
            showFinishButton: me,
            hidePublishIconButton: ge,
            title: ne
        }), V, (ue || ce) && jsxRuntimeExports.jsx("div", {
            className: styles$w.prevNextBg,
            children: jsxRuntimeExports.jsxs(PageWrapper, {
                trimY: !0,
                children: [jsxRuntimeExports.jsx(Divider, {
                    trimY: !0
                }), jsxRuntimeExports.jsxs("div", {
                    className: styles$w.prevNextBar,
                    children: [jsxRuntimeExports.jsx("div", {
                        children: ue && jsxRuntimeExports.jsx(Button, {
                            prefixIcon: ke ? ICON_NAMES.CHEVRON_RIGHT : ICON_NAMES.CHEVRON_LEFT,
                            variant: BUTTON_VARIANTS.SECONDARY,
                            isDisabled: ue.isDisabled,
                            onClick: ct(`../${ue.route}`, ye),
                            children: ue.label
                        })
                    }), jsxRuntimeExports.jsx("div", {
                        children: jsxRuntimeExports.jsxs(ButtonGroup, {
                            children: [me && Ne && je && jsxRuntimeExports.jsx(Button, {
                                prefixIcon: ICON_NAMES.CHECK2,
                                isDisabled: !Fe || !Ne || et,
                                onClick: nt,
                                children: ve("general.submit-to-publishing")
                            }), ce && jsxRuntimeExports.jsx(Button, {
                                suffixIcon: ke ? ICON_NAMES.CHEVRON_LEFT : ICON_NAMES.CHEVRON_RIGHT,
                                onClick: ct(`../${ce.route}`, ye),
                                isDisabled: ce.isDisabled,
                                testId: TEST_ID.NEXT_BUTTON,
                                children: ce.label
                            }), me && !Ne && je && jsxRuntimeExports.jsx(Button, {
                                prefixIcon: ICON_NAMES.CHECK2,
                                isDisabled: !Fe || et,
                                onClick: mt,
                                children: ve("general.create")
                            })]
                        })
                    })]
                })]
            })
        })]
    })
}
  , container$4 = "_container_hi07m_1"
  , helpTrigger = "_helpTrigger_hi07m_8"
  , styles$v = {
    container: container$4,
    helpTrigger
}
  , PublishPageLayout = ({children: V}) => {
    const X = useAtomValue(nameAtom)
      , J = useAtomValue(descriptionAtom)
      , ne = useAtomValue(thumbnailUrlAtom)
      , {pathname: ue} = useLocation()
      , ce = getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.PUBLISH}/`)
      , me = `${ce}${ROUTE.PUBLISH_STEP_ONE}`
      , ge = `${ce}${ROUTE.PUBLISH_STEP_TWO}`
      , Te = `${ce}${ROUTE.PUBLISH_STEP_THREE}`
      , _e = useNavigate()
      , {search: Se} = useLocation();
    return reactExports.useEffect( () => {
        (!J || !X) && (ue === ge || ue === Te) ? _e({
            pathname: me,
            search: Se
        }) : !ne && ue === Te && _e({
            pathname: ge,
            search: Se
        })
    }
    , []),
    jsxRuntimeExports.jsx(PageWrapper, {
        className: styles$v.container,
        children: V
    })
}
  , assaultImg = "/bf6/11303125/assets/assault-BWtDdHh2.jpg"
  , engineerImg = "/bf6/11303125/assets/engineer-GbrovrkE.jpg"
  , reconImg = "/bf6/11303125/assets/recon-CzykniHD.jpg"
  , supportImg = "/bf6/11303125/assets/support-CKu6Usxq.jpg"
  , container$3 = "_container_1h4au_1"
  , cell$1 = "_cell_1h4au_1"
  , teamListContainer = "_teamListContainer_1h4au_19"
  , selectAll = "_selectAll_1h4au_24"
  , teamList = "_teamList_1h4au_19"
  , overlayText = "_overlayText_1h4au_41"
  , active = "_active_1h4au_47"
  , content$5 = "_content_1h4au_51"
  , noTeamsSelected = "_noTeamsSelected_1h4au_56"
  , stickyBox = "_stickyBox_1h4au_66"
  , styles$u = {
    container: container$3,
    cell: cell$1,
    teamListContainer,
    selectAll,
    teamList,
    overlayText,
    active,
    content: content$5,
    noTeamsSelected,
    stickyBox
}
  , TeamSelectList = ({children: V}) => {
    const [X=[],J] = useAtom(currentTeamsBeingEditedAtom)
      , ne = useAtomValue(teamCompositionAtom)
      , ue = (X == null ? void 0 : X.length) === (ne == null ? void 0 : ne.size)
      , {t: ce} = useTranslation()
      , me = () => {
        J(ue ? [] : Array.from(ne ?? []).map( ([_e]) => _e - 1))
    }
      , ge = _e => () => {
        const Se = X != null && X.includes(_e) ? [...(X ?? []).filter(Ie => Ie !== _e)] : [...X ?? [], _e];
        J(Se)
    }
      , Te = _e => () => {
        J([_e])
    }
    ;
    return jsxRuntimeExports.jsxs("div", {
        className: styles$u.container,
        children: [jsxRuntimeExports.jsx("aside", {
            className: styles$u.teamListContainer,
            children: jsxRuntimeExports.jsxs("div", {
                className: styles$u.teamList,
                children: [jsxRuntimeExports.jsx("div", {
                    className: styles$u.selectAll,
                    children: jsxRuntimeExports.jsxs(Space, {
                        align: SPACE_ALIGN.START,
                        gapSize: SPACE_GAP_SIZE.SM,
                        children: [jsxRuntimeExports.jsx(Checkbox, {
                            onChange: me,
                            checked: X !== void 0 && X.length === (ne == null ? void 0 : ne.size)
                        }), ce(ue ? "general.deselect-all-teams" : "general.select-all-teams")]
                    })
                }), jsxRuntimeExports.jsx(Table, {
                    children: Array.from(ne ?? []).map( ([_e,{aiType: Se, aiCapacity: Ie, humanCapacity: ye}]) => {
                        const $e = _e - 1;
                        return jsxRuntimeExports.jsxs(TableRow, {
                            onClick: Te($e),
                            children: [jsxRuntimeExports.jsx(TableCell, {
                                children: jsxRuntimeExports.jsxs(Space, {
                                    className: styles$u.cell,
                                    gapSize: SPACE_GAP_SIZE.SM,
                                    children: [jsxRuntimeExports.jsx(Checkbox, {
                                        onChange: ge($e),
                                        checked: X == null ? void 0 : X.includes($e)
                                    }), ce("general.team"), " ", _e]
                                })
                            }), jsxRuntimeExports.jsx(TableCell, {
                                children: jsxRuntimeExports.jsxs(Space, {
                                    className: styles$u.cell,
                                    gapSize: SPACE_GAP_SIZE.XXS,
                                    children: [jsxRuntimeExports.jsx(Tooltip, {
                                        tip: ce("general.human-players"),
                                        children: jsxRuntimeExports.jsx(Icon, {
                                            name: ICON_NAMES.PLAYER,
                                            size: ICON_SIZES.MD
                                        })
                                    }), ye ?? 0]
                                })
                            }), Se !== void 0 && jsxRuntimeExports.jsx(TableCell, {
                                children: jsxRuntimeExports.jsxs(Space, {
                                    className: styles$u.cell,
                                    gapSize: SPACE_GAP_SIZE.XXS,
                                    children: [jsxRuntimeExports.jsx(Tooltip, {
                                        tip: Se === InternalCapacityType.AI_STATIC ? ce("general.static-bots") : ce("general.backfill-bots"),
                                        children: jsxRuntimeExports.jsx(Icon, {
                                            size: ICON_SIZES.MD,
                                            name: Se === InternalCapacityType.AI_STATIC ? ICON_NAMES.BOT2 : ICON_NAMES.BOT
                                        })
                                    }), Se === InternalCapacityType.AI_BACKFILL ? jsxRuntimeExports.jsx(Icon, {
                                        name: ICON_NAMES.INFINITY
                                    }) : Ie ?? 0]
                                })
                            })]
                        }, _e)
                    }
                    )
                })]
            })
        }), jsxRuntimeExports.jsxs("div", {
            className: common_utils.classNames(styles$u.content, !X.length && styles$u.noTeamsSelected),
            children: [jsxRuntimeExports.jsx("div", {
                className: common_utils.classNames(styles$u.overlayText, !X.length && styles$u.active),
                children: jsxRuntimeExports.jsx("div", {
                    className: styles$u.stickyBox,
                    children: jsxRuntimeExports.jsx(PromptBox, {
                        children: jsxRuntimeExports.jsx(Well, {
                            children: ce("experience.select-team-before-editing")
                        })
                    })
                })
            }), V]
        })]
    })
}
  , TeamSelect = ({children: V}) => useAtomValue(isCustomGameModeAtom) ? jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children: jsxRuntimeExports.jsx(TeamSelectList, {
        children: V
    })
}) : V
  , factionContainer = "_factionContainer_1yfj4_1"
  , tile = "_tile_1yfj4_7"
  , name$1 = "_name_1yfj4_11"
  , grid$2 = "_grid_1yfj4_15"
  , styles$t = {
    factionContainer,
    tile,
    name: name$1,
    grid: grid$2
}
  , CLASS_NAME_TO_IMG_MAP = {
    AssaultClass: {
        bg: assaultImg,
        icon: ICON_NAMES.ASSAULT
    },
    SupportClass: {
        bg: supportImg,
        icon: ICON_NAMES.SUPPORT
    },
    ReconClass: {
        bg: reconImg,
        icon: ICON_NAMES.RECON
    },
    EngineerClass: {
        bg: engineerImg,
        icon: ICON_NAMES.ENGINEER
    }
}
  , ClassesPage = () => {
    var Se;
    const {t: V} = useTranslation()
      , X = useAtomValue(currentTeamsBeingEditedAtom)
      , {blueprint: J} = reactExports.useContext(BlueprintContext)
      , [ne,ue] = useAtom(restrictedAssetTagsAtom)
      , ce = useAtomValue(isOwnerAtom)
      , me = useAtomValue(numberOfTeamsAtom)
      , ge = J == null ? void 0 : J.assetTags.categories[RESTRICTION_PAGE_CATEGORY.CHARACTERS]
      , Te = Ie => ye => {
        ue(getPatchedAssetTagValue({
            newValue: ye,
            assetTagsState: ne,
            assetTagId: Ie,
            numberOfTeams: me,
            teamIndexes: X
        }))
    }
      , _e = ((Se = ge == null ? void 0 : ge.childrenTags) == null ? void 0 : Se.reduce( (Ie, ye) => {
        const $e = J == null ? void 0 : J.assetTags.categories[ye];
        return $e && $e.name !== ALL_CLASS_ASSET_TAG_NAME && (Ie[ye] = $e),
        Ie
    }
    , {})) ?? {};
    return jsxRuntimeExports.jsx(PageWrapper, {
        children: jsxRuntimeExports.jsx(TeamSelect, {
            children: jsxRuntimeExports.jsxs("div", {
                className: styles$t.container,
                children: [jsxRuntimeExports.jsx(Heading, {
                    variant: HEADING_VARIANT.SUBHEADING,
                    children: V("general.classes")
                }), jsxRuntimeExports.jsx(Divider, {}), jsxRuntimeExports.jsx("div", {
                    className: styles$t.grid,
                    children: Object.entries(_e).map( ([Ie,{webImageMedium: ye, translationIds: $e, name: Ne, image: ve}]) => {
                        var Xe;
                        const ke = getTeamsGroupedByMutatorOrAssetTagValue({
                            assetTag: ne[Ie],
                            teamIndexesToCheck: X ?? []
                        })
                          , xe = X !== void 0 && ke.length > 1
                          , we = $e.name ? V($e.name) : Ne
                          , {bg: Fe, icon: je} = CLASS_NAME_TO_IMG_MAP[Ne];
                        return jsxRuntimeExports.jsx("div", {
                            "data-tagid": Ie,
                            className: styles$t.tile,
                            children: jsxRuntimeExports.jsx(AssetTile, {
                                image: Fe ?? ye ?? ve,
                                disabled: !ce,
                                unavailable: xe,
                                name: jsxRuntimeExports.jsxs(Space, {
                                    className: styles$t.name,
                                    gapSize: SPACE_GAP_SIZE.SM,
                                    children: [jsxRuntimeExports.jsx(Icon, {
                                        name: je
                                    }), we]
                                }),
                                isSelected: !(Ie in ne && getAssetTagValue(ne[Ie], (Xe = ke == null ? void 0 : ke[0]) == null ? void 0 : Xe.teamsIndexes[0]) === !1),
                                orientation: ASSET_TILE_ORIENTATION.PORTRAIT,
                                onChange: Te(Ie)
                            })
                        }, Ie)
                    }
                    )
                })]
            })
        })
    })
}
  , communityImg$1 = "/bf6/11303125/assets/community-D4j3cRvM.jpg"
  , tipsImg = "/bf6/11303125/assets/tips-tricks-Bc8E5Jtt.jpg"
  , whatsNewImg = "/bf6/11303125/assets/whats-new-CxBq77Ni.jpg"
  , getExperienceExportFromPlayElement = ({playElement: V, playElementDesign: X, blueprint: J}) => {
    const {mapRotation: ne, mutators: ue, assetTags: ce, patchId: me, workspace: ge, teamComposition: Te, attachments: _e, gameMode: Se} = formatPlayElementDesignToAppState({
        playElementDesign: X,
        blueprint: J
    });
    return {
        mutators: webMutatorsToExportedMutators(ue),
        assetRestrictions: J != null && J.assetTags ? webAssetRestrictionsToExportedAssetRestrictions(ce, J.assetTags) : {},
        gameMode: Se,
        name: V == null ? void 0 : V.name,
        description: V == null ? void 0 : V.description,
        mapRotation: webMapRotationToExportedMapRotation(ne),
        patchId: me,
        workspace: ge,
        teamComposition: Array.from(Te ?? []),
        attachments: webAttachmentsToExportedAttachments(_e)
    }
}
  , grid$1 = "_grid_f6b9k_17"
  , experienceContainer = "_experienceContainer_f6b9k_24"
  , showCodeContainer = "_showCodeContainer_f6b9k_28"
  , codePanelOpen = "_codePanelOpen_f6b9k_38"
  , codePanelTag = "_codePanelTag_f6b9k_42"
  , menuPanel = "_menuPanel_f6b9k_49"
  , closeShowCode = "_closeShowCode_f6b9k_54"
  , loadingShimmer = "_loadingShimmer_f6b9k_60"
  , shimmer = "_shimmer_f6b9k_1"
  , styles$s = {
    grid: grid$1,
    experienceContainer,
    showCodeContainer,
    codePanelOpen,
    codePanelTag,
    menuPanel,
    closeShowCode,
    loadingShimmer,
    shimmer
}
  , ExperienceTileList = ({playElements: V, emptyContent: X}) => {
    var at, rt;
    const {blueprint: J} = reactExports.useContext(BlueprintContext)
      , [ne,ue] = reactExports.useState([])
      , {colors: ce} = reactExports.useContext(ThemeContext)
      , [me,ge] = reactExports.useState()
      , [Te,_e] = reactExports.useState(!1)
      , {create: Se} = useSaveExperienceMutation()
      , {data: Ie} = useGetPlayElementQuery(me)
      , ye = reactExports.useRef(new Map)
      , {handleDeleteExperience: $e} = reactExports.useContext(AppContext)
      , Ne = useNavigate()
      , {addToast: ve} = reactExports.useContext(ToastContext);
    if (me && !ye.current.has(me) && Ie && Ie.playElementDesign && Ie.playElement) {
        const ft = new TextDecoder
          , St = getModRules(Ie.playElementDesign.modRules);
        migrateModeRules(St, Ie.playElementDesign.attachments);
        const Ye = constructModRules({
            workspace: {
                ...St
            },
            rulesVersion: J == null ? void 0 : J.rulesVersion,
            patchId: (at = St == null ? void 0 : St.mod) != null && at.patch ? (rt = JSON.parse(ft.decode(base64ToBytes(St.mod.patch)))) == null ? void 0 : rt.id : null
        })
          , We = getModRulesPayload(Ye);
        ye.current.set(me, {
            playElementDesign: Ie.playElementDesign,
            playElement: Ie.playElement,
            modRules: We
        })
    }
    const ke = ft => () => {
        ge(ft)
    }
      , xe = ft => () => {
        Ne({
            pathname: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}`),
            search: `${createSearchParams({
                [QUERY_PARAM_KEY.EXPERIENCE_ID]: ft
            })}`
        })
    }
      , we = ft => () => {
        ne.includes(ft) || (ne.push(ft),
        ue([...ne]))
    }
      , Fe = ft => () => {
        ne.includes(ft) && ue([...ne.filter(St => St !== ft)])
    }
      , je = ft => async () => {
        const St = ye.current.get(ft)
          , Ye = getExperienceExportFromPlayElement({
            playElementDesign: St == null ? void 0 : St.playElementDesign,
            playElement: St == null ? void 0 : St.playElement,
            blueprint: J
        });
        downloadFile(`${sanitizeFilename((St == null ? void 0 : St.playElement.name) ?? FALLBACK_DEFAULT_EXPERIENCE_TITLE)}.json`, JSON.stringify(Ye))
    }
      , Xe = () => {
        _e(!1),
        ve(t$1("experience.duplicate-failed"))
    }
      , ze = () => {
        _e(!1),
        ve(t$1("experience.duplicate-success"))
    }
      , qe = ft => async () => {
        _e(!0),
        Se(ze, Xe, !0, ye.current.get(ft))
    }
      , Ze = ft => () => {
        Ne({
            pathname: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.PUBLISH}/${ROUTE.PUBLISH_STEP_ONE}`),
            search: `${createSearchParams({
                [QUERY_PARAM_KEY.EXPERIENCE_ID]: ft
            })}`
        })
    }
      , et = ft => () => {
        we(ft)()
    }
      , it = ft => () => {
        $e(ft)
    }
    ;
    return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsx("div", {
            className: styles$s.grid,
            children: V != null && V.length ? V.map( ({id: ft, name: St, description: Ye, moderationState: We, publishStateType: nt, designId: ct, publishAt: Et, thumbnailUrl: Ke, shortCode: mt, updated: lt}, Qe) => {
                var Gt, Ht;
                const gt = ne.includes(Qe)
                  , Nt = getPublishingStateMetadata({
                    publishState: nt,
                    moderationState: We,
                    publishAt: Et
                });
                return jsxRuntimeExports.jsxs("div", {
                    className: styles$s.experienceContainer,
                    children: [jsxRuntimeExports.jsx(ExperienceTile, {
                        onFlip: ke(ft),
                        backSide: jsxRuntimeExports.jsxs("div", {
                            className: common_utils.classNames(styles$s.menuPanel),
                            children: [!ye.current.has(ft) && jsxRuntimeExports.jsx("div", {
                                className: styles$s.loadingShimmer
                            }), ye.current.has(ft) && jsxRuntimeExports.jsxs(Space, {
                                column: !0,
                                gapSize: SPACE_GAP_SIZE.XXS,
                                children: [nt === PublishStateType.PUBLISH_STATE_TYPE_PUBLISHED ? jsxRuntimeExports.jsx(Button, {
                                    variant: BUTTON_VARIANTS.SECONDARY,
                                    onClick: et(Qe),
                                    testId: TEST_ID.EXPERIENCE_TILE_SHARE,
                                    prefixIcon: ICON_NAMES.SHARE,
                                    fillWidth: !0,
                                    children: t$1("general.share")
                                }) : null, jsxRuntimeExports.jsx(Button, {
                                    variant: BUTTON_VARIANTS.SECONDARY,
                                    onClick: je(ft),
                                    testId: TEST_ID.EXPERIENCE_TILE_EXPORT,
                                    prefixIcon: ICON_NAMES.LOGO,
                                    fillWidth: !0,
                                    children: t$1("general.export")
                                }), jsxRuntimeExports.jsx(Button, {
                                    variant: BUTTON_VARIANTS.SECONDARY,
                                    onClick: qe(ft),
                                    testId: TEST_ID.EXPERIENCE_TILE_DUPLICATE,
                                    prefixIcon: ICON_NAMES.COPY,
                                    fillWidth: !0,
                                    children: t$1("general.duplicate")
                                }), jsxRuntimeExports.jsx(Button, {
                                    variant: BUTTON_VARIANTS.SECONDARY,
                                    onClick: it(ft),
                                    testId: TEST_ID.EXPERIENCE_TILE_DELETE,
                                    prefixIcon: ICON_NAMES.TRASH,
                                    fillWidth: !0,
                                    children: t$1("general.delete")
                                }), nt !== PublishStateType.PUBLISH_STATE_TYPE_PUBLISHED && jsxRuntimeExports.jsx(Button, {
                                    variant: BUTTON_VARIANTS.SECONDARY,
                                    onClick: Ze(ft),
                                    testId: TEST_ID.EXPERIENCE_TILE_PUBLISH,
                                    prefixIcon: ICON_NAMES.UPLOAD2,
                                    fillWidth: !0,
                                    children: t$1("general.publish")
                                })]
                            })]
                        }),
                        heading: St,
                        subheading: `${t$1("general.modified")}: ${lt == null ? void 0 : lt.toLocaleString()}`,
                        tag: jsxRuntimeExports.jsx(ExperienceStatusTag, {
                            variant: Nt.chipVariant,
                            icon: Nt.icon,
                            toolTip: ((Gt = Nt.tooltipTranslation) == null ? void 0 : Gt.id) && t$1((Ht = Nt.tooltipTranslation) == null ? void 0 : Ht.id, {
                                ...Nt.tooltipTranslation.arg,
                                interpolation: {
                                    escapeValue: !1
                                }
                            }),
                            children: t$1(Nt.label)
                        }),
                        bgImage: Ke ? getBattleBinaryUrl(Ke) : void 0,
                        actions: jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                            children: [nt !== PublishStateType.PUBLISH_STATE_TYPE_PUBLISHED && jsxRuntimeExports.jsx(Tooltip, {
                                tip: t$1("general.publish"),
                                children: jsxRuntimeExports.jsx(IconButton, {
                                    variant: ICON_BUTTON_VARIANT.SECONDARY,
                                    size: ICON_BUTTON_SIZE.SM,
                                    label: t$1("general.publish"),
                                    icon: ICON_NAMES.UPLOAD2,
                                    onClick: Ze(ft)
                                })
                            }), jsxRuntimeExports.jsx(Tooltip, {
                                tip: t$1("general.modify"),
                                children: jsxRuntimeExports.jsx(IconButton, {
                                    icon: ICON_NAMES.PENCIL2,
                                    label: t$1("general.modify"),
                                    variant: ICON_BUTTON_VARIANT.SECONDARY,
                                    size: ICON_BUTTON_SIZE.SM,
                                    onClick: xe(ft),
                                    testId: TEST_ID.EXPERIENCE_TILE_MODIFY_BUTTON
                                })
                            }), jsxRuntimeExports.jsx(Tooltip, {
                                tip: Ye,
                                children: jsxRuntimeExports.jsx(IconButton, {
                                    icon: ICON_NAMES.INFO,
                                    label: t$1("general.description"),
                                    variant: ICON_BUTTON_VARIANT.SECONDARY,
                                    size: ICON_BUTTON_SIZE.SM
                                })
                            })]
                        })
                    }), ct && jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
                        children: jsxRuntimeExports.jsxs("div", {
                            className: common_utils.classNames(styles$s.showCodeContainer, gt && styles$s.codePanelOpen),
                            children: [jsxRuntimeExports.jsx(IconButton, {
                                icon: ICON_NAMES.CLOSE,
                                variant: ICON_BUTTON_VARIANT.SECONDARY,
                                size: ICON_BUTTON_SIZE.SM,
                                hoverColor: ce.white,
                                onClick: Fe(Qe),
                                testId: "close-code-panel",
                                label: t$1("general.close"),
                                className: styles$s.closeShowCode
                            }), jsxRuntimeExports.jsxs(Section, {
                                children: [jsxRuntimeExports.jsxs(Section, {
                                    subsection: !0,
                                    children: [jsxRuntimeExports.jsx(Heading, {
                                        variant: HEADING_VARIANT.FIELD_LABEL,
                                        children: t$1("experience.experience-code")
                                    }), jsxRuntimeExports.jsx(TextToClipboard, {
                                        text: mt ?? t$1("general.share-code-only-available-for-published"),
                                        label: t$1("general.share-code"),
                                        fillWidth: !0
                                    })]
                                }), t$1("experience.server-code-prompt")]
                            })]
                        })
                    })]
                }, ft)
            }
            ) : X
        }), Te ? jsxRuntimeExports.jsx(LoadingSpinner, {
            statusText: t$1("general.duplicating-experience")
        }) : null]
    })
}
  , fetchSdkVersion = async () => {
    const V = await fetch(`https://download.portal.battlefield.com/versions.json?${cacheBustSuffix()}`);
    if (V.type === "error")
        throw new Error("Failed to get SDK version manifest");
    return await V.json()
}
  , useLatestSdkVersion = (V=!0) => {
    var ce;
    const {data: X, isFetching: J, error: ne} = useQuery({
        queryKey: [QUERY_KEY.SDK_VERSION, "production"],
        queryFn: () => fetchSdkVersion(),
        enabled: V && !0,
        refetchOnWindowFocus: !1,
        staleTime: MS_5_MINUTES
    })
      , ue = (ce = X == null ? void 0 : X.versions) != null && ce.version ? X == null ? void 0 : X.versions : X == null ? void 0 : X.versions[0];
    return {
        data: X,
        latestVersion: ue == null ? void 0 : ue.version,
        fileSize: ue == null ? void 0 : ue.fileSize,
        isFetching: J,
        error: ne
    }
}
;
async function listPlayElements(V) {
    if (!V) {
        const J = new Error("Missing session!");
        throw J.name = "Unauthenticated",
        J
    }
    const {playElements: X} = await clients.play.getOwnedPlayElements({
        publishStates: [PublishStateType.PUBLISH_STATE_TYPE_DRAFT, PublishStateType.PUBLISH_STATE_TYPE_PUBLISHED, PublishStateType.PUBLISH_STATE_TYPE_ERROR],
        includeDenied: !0
    }, new grpcWebClient_umdExports.grpc.Metadata({
        "x-gateway-session-id": V
    }));
    return {
        playElements: X
    }
}
const useGetOwnedPlayElementsQuery = V => {
    var ne;
    const {isFetching: X, data: J} = useQuery({
        queryKey: [QUERY_KEY.LIST_PLAY_ELEMENTS, (ne = V == null ? void 0 : V.player) == null ? void 0 : ne.nucleusId],
        queryFn: () => listPlayElements(V == null ? void 0 : V.sessionId),
        enabled: !!(V != null && V.sessionId),
        refetchOnWindowFocus: !1,
        staleTime: MS_5_MINUTES,
        select: ({playElements: ue}) => ue.reduce( (ce, me) => (me && ce.push(me),
        ce), [])
    });
    return [J, X]
}
  , intro$1 = "_intro_qg9yx_1"
  , wrapper$5 = "_wrapper_qg9yx_8"
  , descriptionSection = "_descriptionSection_qg9yx_20"
  , description$3 = "_description_qg9yx_20"
  , community = "_community_qg9yx_42"
  , communityImg = "_communityImg_qg9yx_55"
  , communityPanels = "_communityPanels_qg9yx_59"
  , tabBarHeading = "_tabBarHeading_qg9yx_64"
  , body = "_body_qg9yx_77"
  , bodyContent = "_bodyContent_qg9yx_80"
  , communityLink$1 = "_communityLink_qg9yx_85"
  , communityLinkText = "_communityLinkText_qg9yx_89"
  , headingTag = "_headingTag_qg9yx_95"
  , createButtonContainer = "_createButtonContainer_qg9yx_106"
  , createButtonContent = "_createButtonContent_qg9yx_120"
  , createNew = "_createNew_qg9yx_127"
  , tabBarImportButton = "_tabBarImportButton_qg9yx_131"
  , tabContent = "_tabContent_qg9yx_137"
  , tabsBar = "_tabsBar_qg9yx_148"
  , tabs = "_tabs_qg9yx_148"
  , styles$r = {
    intro: intro$1,
    wrapper: wrapper$5,
    descriptionSection,
    description: description$3,
    community,
    communityImg,
    communityPanels,
    tabBarHeading,
    body,
    bodyContent,
    communityLink: communityLink$1,
    communityLinkText,
    headingTag,
    createButtonContainer,
    createButtonContent,
    createNew,
    tabBarImportButton,
    tabContent,
    tabsBar,
    tabs
}
  , ExperiencesPage = () => {
    const V = useNavigate()
      , X = reactExports.useId()
      , {t: J} = useTranslation()
      , ne = reactExports.useContext(SessionContext)
      , [ue,ce] = useGetOwnedPlayElementsQuery(ne)
      , {latestVersion: me, fileSize: ge} = useLatestSdkVersion()
      , Te = instance.language.toLowerCase()
      , _e = ue == null ? void 0 : ue.filter(qe => qe.publishStateType === PublishStateType.PUBLISH_STATE_TYPE_PUBLISHED && !qe.publishAt && (!qe.moderationState || qe.moderationState == ModerationStateType.MODERATION_STATE_TYPE_IN_REVIEW))
      , Se = ue == null ? void 0 : ue.filter(qe => qe.publishStateType !== PublishStateType.PUBLISH_STATE_TYPE_PUBLISHED || qe.publishStateType === PublishStateType.PUBLISH_STATE_TYPE_PUBLISHED && !!qe.publishAt || qe.publishStateType === PublishStateType.PUBLISH_STATE_TYPE_PUBLISHED && qe.moderationState && qe.moderationState !== ModerationStateType.MODERATION_STATE_TYPE_IN_REVIEW)
      , Ie = ((_e == null ? void 0 : _e.length) ?? 0) + ((Se == null ? void 0 : Se.length) ?? 0)
      , ye = Se != null && Se.length ? 0 : _e != null && _e.length ? 1 : 0
      , [$e,Ne] = reactExports.useState(ye)
      , {colors: ve} = reactExports.useContext(ThemeContext)
      , [ke,xe] = useAtom(createExperienceFromFileAtom);
    if (reactExports.useEffect( () => {
        ke && V(getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.SETTINGS}/${ROUTE.MODE}`))
    }
    , [ke, V]),
    ce)
        return jsxRuntimeExports.jsx(LoadingSpinner, {
            statusText: J("general.loading-experiences-list")
        });
    const we = () => {
        V(getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.GAME_MODE}`))
    }
      , Fe = () => {
        window.open(`https://download.portal.battlefield.com/PortalSDK.zip?${cacheBustSuffix()}`, "_blank")
    }
      , je = () => {
        loadFile(qe => {
            var Ze, et;
            if (typeof ((Ze = qe.target) == null ? void 0 : Ze.result) == "string")
                try {
                    xe(JSON.parse((et = qe.target) == null ? void 0 : et.result))
                } catch {
                    console.error("Failed to read file")
                }
        }
        , [".json", "application/json"])
    }
      , Xe = qe => {
        Ne(qe)
    }
      , ze = me && ge ? `${me} (${bytesToMbString(ge)})` : "";
    return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsxs("div", {
            className: styles$r.intro,
            children: [jsxRuntimeExports.jsxs(PageWrapper, {
                paddingSize: PAGE_WRAPPER_PADDING.LG,
                className: styles$r.wrapper,
                children: [jsxRuntimeExports.jsxs(Section, {
                    className: styles$r.descriptionSection,
                    children: [jsxRuntimeExports.jsxs("div", {
                        children: [jsxRuntimeExports.jsx(Heading, {
                            variant: HEADING_VARIANT.HERO,
                            children: J("experience.banner-header")
                        }), jsxRuntimeExports.jsx(Paragraph, {
                            className: styles$r.description,
                            size: PARAGRAPH_SIZE.LG,
                            children: J("experience.banner-description-one")
                        })]
                    }), jsxRuntimeExports.jsxs(ButtonGroup, {
                        stacked: {
                            xxs: !0,
                            sm: !1
                        },
                        children: [jsxRuntimeExports.jsx(Button, {
                            variant: BUTTON_VARIANTS.SECONDARY,
                            color: ve.primary,
                            suffixIcon: ICON_NAMES.PLUS,
                            onClick: we,
                            noMax: !0,
                            testId: "createButton",
                            children: J("general.create")
                        }), jsxRuntimeExports.jsx(Tooltip, {
                            tip: ze || J("general.download-portal-sdk"),
                            children: jsxRuntimeExports.jsx(Button, {
                                variant: BUTTON_VARIANTS.SECONDARY,
                                color: ve.primary,
                                suffixIcon: ICON_NAMES.DOWNLOAD,
                                onClick: Fe,
                                noMax: !0,
                                testId: "downloadSdkButton",
                                children: J("download-sdk")
                            })
                        })]
                    })]
                }), jsxRuntimeExports.jsxs(Section, {
                    className: styles$r.community,
                    children: [jsxRuntimeExports.jsx(Heading, {
                        variant: HEADING_VARIANT.SUBHEADING,
                        trimY: !0,
                        children: J("general.getting-started")
                    }), jsxRuntimeExports.jsx(Divider, {}), jsxRuntimeExports.jsxs("div", {
                        className: styles$r.communityPanels,
                        children: [jsxRuntimeExports.jsx("a", {
                            href: `https://www.ea.com/${Te}/games/battlefield/battlefield-6/news`,
                            target: "_blank",
                            className: styles$r.communityLink,
                            children: jsxRuntimeExports.jsx(ImageCard, {
                                caption: jsxRuntimeExports.jsxs("span", {
                                    className: styles$r.communityLinkText,
                                    children: [J("general.whats-new"), jsxRuntimeExports.jsx(Icon, {
                                        name: ICON_NAMES.LINK_OUT
                                    })]
                                }),
                                imageSrc: whatsNewImg,
                                variant: IMAGE_CARD_VARIANT.CUSTOM,
                                imageClassName: styles$r.communityImg
                            })
                        }), jsxRuntimeExports.jsx("a", {
                            href: `https://www.ea.com/${Te}/games/battlefield/battlefield-6/onboarding-hub/bf6-portal-hub`,
                            target: "_blank",
                            className: styles$r.communityLink,
                            children: jsxRuntimeExports.jsx(ImageCard, {
                                caption: jsxRuntimeExports.jsxs("span", {
                                    className: styles$r.communityLinkText,
                                    children: [J("general.tips-n-tricks"), jsxRuntimeExports.jsx(Icon, {
                                        name: ICON_NAMES.LINK_OUT
                                    })]
                                }),
                                variant: IMAGE_CARD_VARIANT.CUSTOM,
                                imageSrc: tipsImg,
                                imageClassName: styles$r.communityImg
                            })
                        }), jsxRuntimeExports.jsx("a", {
                            href: `https://www.ea.com/${Te}/games/battlefield/battlefield-6/portal/browse`,
                            target: "_blank",
                            className: styles$r.communityLink,
                            children: jsxRuntimeExports.jsx(ImageCard, {
                                caption: jsxRuntimeExports.jsxs("span", {
                                    className: styles$r.communityLinkText,
                                    children: [J("general.community"), jsxRuntimeExports.jsx(Icon, {
                                        name: ICON_NAMES.LINK_OUT
                                    })]
                                }),
                                imageSrc: communityImg$1,
                                variant: IMAGE_CARD_VARIANT.CUSTOM,
                                imageClassName: styles$r.communityImg
                            })
                        })]
                    })]
                })]
            }), jsxRuntimeExports.jsx(PageWrapper, {
                paddingSize: PAGE_WRAPPER_PADDING.LG,
                trimY: !0,
                children: jsxRuntimeExports.jsx(Section, {
                    trimY: !0,
                    children: jsxRuntimeExports.jsxs("div", {
                        className: styles$r.tabsBar,
                        children: [jsxRuntimeExports.jsxs(Heading, {
                            variant: HEADING_VARIANT.SUBHEADING,
                            className: styles$r.tabBarHeading,
                            children: [jsxRuntimeExports.jsx(Icon, {
                                name: ICON_NAMES.MODE_CUSTOM
                            }), `${J("general.my-experiences")} (${Ie}/${MAX_EXPERIENCE_COUNT})`]
                        }), jsxRuntimeExports.jsx("div", {
                            className: styles$r.tabs,
                            children: jsxRuntimeExports.jsx(TabList, {
                                ariaId: X,
                                onTabClick: Xe,
                                activeTabIndex: $e,
                                tabs: [jsxRuntimeExports.jsx(Tab, {
                                    active: $e === 0,
                                    children: `${J("general.unpublished")} (${(Se == null ? void 0 : Se.length) ?? 0})`
                                }, "unpublished-tab"), jsxRuntimeExports.jsx(Tab, {
                                    active: $e === 1,
                                    children: `${J("general.published")} (${(_e == null ? void 0 : _e.length) ?? 0})`
                                }, "published-tab")]
                            })
                        }), jsxRuntimeExports.jsx(Button, {
                            prefixIcon: ICON_NAMES.FOLDER,
                            className: styles$r.tabBarImportButton,
                            size: BUTTON_SIZE.SM,
                            onClick: je,
                            children: J("general.import-from-file")
                        })]
                    })
                })
            })]
        }), jsxRuntimeExports.jsx("div", {
            className: styles$r.body,
            children: jsxRuntimeExports.jsx(PageWrapper, {
                paddingSize: PAGE_WRAPPER_PADDING.LG,
                trimTop: !0,
                children: jsxRuntimeExports.jsx(Section, {
                    paddingSize: SECTION_PADDING_SIZE.MD,
                    trimTop: !0,
                    children: jsxRuntimeExports.jsx("div", {
                        className: styles$r.bodyContent,
                        children: jsxRuntimeExports.jsx(TabPanel, {
                            instanceId: X,
                            activeTabIndex: $e,
                            panels: [jsxRuntimeExports.jsx(ExperienceTileList, {
                                playElements: Se ?? [],
                                emptyContent: jsxRuntimeExports.jsxs("div", {
                                    className: styles$r.createButtonContainer,
                                    children: [jsxRuntimeExports.jsx("div", {
                                        className: styles$r.createButtonContent,
                                        children: jsxRuntimeExports.jsxs("span", {
                                            className: styles$r.createNew,
                                            children: ["+ ", J("general.create")]
                                        })
                                    }), jsxRuntimeExports.jsx(Button, {
                                        onClick: we,
                                        fillWidth: !0,
                                        children: J("general.start-editing")
                                    })]
                                })
                            }, "unpublished"), _e != null && _e.length ? jsxRuntimeExports.jsx(ExperienceTileList, {
                                playElements: _e ?? []
                            }, "published") : jsxRuntimeExports.jsx("div", {
                                children: J("general.no-published-experiences")
                            })]
                        })
                    })
                })
            })
        })]
    })
}
  , breakthroughImage = "/bf6/11303125/assets/GameMode_Breakthrough-DPkPyBEp.jpg"
  , conquestImage = "/bf6/11303125/assets/GameMode_Conquest-DbvlC8Zr.jpg"
  , customImage = "/bf6/11303125/assets/GameMode_Portal_Custom-BTg6BMh-.jpg"
  , rushImage = "/bf6/11303125/assets/GameMode_Rush-B4LLMoEh.jpg"
  , unselectedImage = "/bf6/11303125/assets/GameMode_Unselected-CLCZWRns.jpg";
var VULCANITE_ICON_NAME = (V => (V.MAP_SIZE_LARGE = "map-size-l",
V.MAP_SIZE_MEDIUM = "map-size-m",
V.MAP_SIZE_SMALL = "map-size-s",
V.BF_PORTAL_LOGO = "bf-portal-logo",
V))(VULCANITE_ICON_NAME || {});
const wrapper$4 = "_wrapper_uh1q0_1"
  , hero = "_hero_uh1q0_7"
  , tabBarFiller = "_tabBarFiller_uh1q0_11"
  , content$4 = "_content_uh1q0_17"
  , modeIcon = "_modeIcon_uh1q0_31"
  , bfIcon = "_bfIcon_uh1q0_41"
  , description$2 = "_description_uh1q0_48"
  , descriptionBlurb = "_descriptionBlurb_uh1q0_63"
  , modeOptions = "_modeOptions_uh1q0_69"
  , featureGrid = "_featureGrid_uh1q0_80"
  , backBtn = "_backBtn_uh1q0_94"
  , tabListContainer = "_tabListContainer_uh1q0_100"
  , tabPanelsContainer = "_tabPanelsContainer_uh1q0_106"
  , panelWrapper = "_panelWrapper_uh1q0_110"
  , continueWrapper = "_continueWrapper_uh1q0_119"
  , continueContainer = "_continueContainer_uh1q0_125"
  , styles$q = {
    wrapper: wrapper$4,
    hero,
    tabBarFiller,
    content: content$4,
    modeIcon,
    bfIcon,
    description: description$2,
    descriptionBlurb,
    modeOptions,
    featureGrid,
    backBtn,
    tabListContainer,
    tabPanelsContainer,
    panelWrapper,
    continueWrapper,
    continueContainer
}
  , GAME_MODE_BG_MAP = new Map([["Conquest", conquestImage], ["ConquestSmall", conquestImage], ["Rush", rushImage], ["Breakthrough", breakthroughImage], ["BreakthroughSmall", breakthroughImage], ["ModBuilderCustom", customImage]])
  , GameModePage = () => {
    const [V,X] = reactExports.useState(0)
      , [J,ne] = useAtom(gameModeAtom)
      , {blueprint: ue} = reactExports.useContext(BlueprintContext)
      , ce = ue == null ? void 0 : ue.gameModes
      , {t: me} = useTranslation()
      , ge = useAtomValue(isOwnerAtom)
      , Te = useNavigate()
      , {search: _e} = useLocation()
      , {open: Se} = useDialog(DIALOG_ID.CONFIRM_LEAVE_UNSAVED_CHANGES)
      , Ie = useAtomValue(isPristineAtom)
      , ye = useAtomValue(createExperienceFromFileAtom)
      , $e = reactExports.useId()
      , [Ne,ve] = reactExports.useState()
      , ke = Ne === CUSTOM_GAME_MODE_ID;
    reactExports.useEffect( () => {
        J && !ye && Te({
            pathname: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.SETTINGS}`),
            search: _e
        }, {
            replace: !0
        })
    }
    , [ye, J, Te, _e]);
    const xe = Ze => {
        const et = Ze.toString();
        ve(et)
    }
      , we = () => {
        Ne && (ne(Ne),
        Te({
            pathname: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.SETTINGS}`),
            search: _e
        }))
    }
      , Fe = () => {
        Ie ? Te({
            pathname: getAbsolutePathWithLocale(`/${ROUTE.HOME}`)
        }) : Se()
    }
      , je = Ze => {
        X(Ze)
    }
      , Xe = Ne ? GAME_MODE_BG_MAP.get(Ne) ?? unselectedImage : unselectedImage
      , ze = (ce == null ? void 0 : ce.filter(Ze => Ze.id !== CUSTOM_GAME_MODE_ID)) ?? []
      , qe = !Ne || Ne === CUSTOM_GAME_MODE_ID;
    return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsxs("div", {
            className: styles$q.wrapper,
            style: {
                "--bg-image": Xe ? `url(${Xe})` : ""
            },
            children: [jsxRuntimeExports.jsx(PageWrapper, {
                className: styles$q.content,
                children: jsxRuntimeExports.jsxs("div", {
                    className: styles$q.description,
                    children: [jsxRuntimeExports.jsx(Button, {
                        onClick: Fe,
                        className: styles$q.backBtn,
                        prefixIcon: ICON_NAMES.CHEVRON_LEFT,
                        variant: BUTTON_VARIANTS.SECONDARY,
                        children: me("general.back")
                    }), jsxRuntimeExports.jsx(Icon, {
                        className: common_utils.classNames(styles$q.modeIcon, qe && styles$q.bfIcon),
                        name: GAME_MODE_ICON_MAP.get(Ne) ?? VULCANITE_ICON_NAME.BF_PORTAL_LOGO,
                        size: ICON_SIZES.FILL
                    }), jsxRuntimeExports.jsx(Heading, {
                        variant: HEADING_VARIANT.HERO,
                        className: styles$q.hero,
                        children: me(Ne ? `gamemodes.${Ne}.title` : "game-mode.choose-game-mode")
                    }), Ne && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                        children: [jsxRuntimeExports.jsx(Paragraph, {
                            size: PARAGRAPH_SIZE.LG,
                            className: styles$q.descriptionBlurb,
                            children: me(`gamemodes.${Ne}.desc`)
                        }), jsxRuntimeExports.jsx("div", {
                            className: styles$q.featureGrid,
                            children: ke ? jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                                children: [jsxRuntimeExports.jsxs(Space, {
                                    gapSize: SPACE_GAP_SIZE.XS,
                                    children: [jsxRuntimeExports.jsx(Icon, {
                                        name: ICON_NAMES.CHECK3
                                    }), me("game-mode.features.maps")]
                                }), jsxRuntimeExports.jsxs(Space, {
                                    gapSize: SPACE_GAP_SIZE.XS,
                                    children: [jsxRuntimeExports.jsx(Icon, {
                                        name: ICON_NAMES.CHECK3
                                    }), me("game-mode.features.logic")]
                                }), jsxRuntimeExports.jsxs(Space, {
                                    gapSize: SPACE_GAP_SIZE.XS,
                                    children: [jsxRuntimeExports.jsx(Icon, {
                                        name: ICON_NAMES.CHECK3
                                    }), me("game-mode.features.ai")]
                                })]
                            }) : jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                                children: [jsxRuntimeExports.jsxs(Space, {
                                    gapSize: SPACE_GAP_SIZE.XS,
                                    children: [jsxRuntimeExports.jsx(Icon, {
                                        name: ICON_NAMES.CHECK3
                                    }), me("game-mode.features.mutators")]
                                }), jsxRuntimeExports.jsxs(Space, {
                                    gapSize: SPACE_GAP_SIZE.XS,
                                    children: [jsxRuntimeExports.jsx(Icon, {
                                        name: ICON_NAMES.CHECK3
                                    }), me("game-mode.features.full-progression")]
                                })]
                            })
                        })]
                    })]
                })
            }), jsxRuntimeExports.jsx("div", {
                className: styles$q.tabListContainer,
                children: jsxRuntimeExports.jsx(TabList, {
                    activeTabIndex: V,
                    ariaId: $e,
                    tabs: [jsxRuntimeExports.jsx(Tab, {
                        active: V === 0,
                        children: me("game-mode.tabs.custom")
                    }, "custom"), jsxRuntimeExports.jsx(Tab, {
                        active: V === 1,
                        children: me("game-mode.tabs.core")
                    }, "verified")],
                    onTabClick: je
                })
            })]
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$q.tabPanelsContainer,
            children: [jsxRuntimeExports.jsx("div", {
                className: styles$q.panelWrapper,
                children: jsxRuntimeExports.jsx(TabPanel, {
                    instanceId: $e,
                    activeTabIndex: V,
                    panels: [jsxRuntimeExports.jsx(MediaRadioGroup, {
                        variant: MEDIA_RADIO_GROUP_VARIANT.ICON,
                        name: me("game-mode.tabs.custom"),
                        onChange: xe,
                        activeValue: Ne !== void 0 && (ce != null && ce.some( ({name: Ze}) => Ze === Ne)) ? Ne : void 0,
                        radios: [{
                            icon: ICON_NAMES.MODE_CUSTOM,
                            label: me("general.default"),
                            value: CUSTOM_GAME_MODE_ID,
                            testId: `game-mode-${CUSTOM_GAME_MODE_ID}-template-empty`
                        }],
                        isDisabled: !ge
                    }, "custom"), jsxRuntimeExports.jsx("div", {
                        className: styles$q.modeOptions,
                        children: jsxRuntimeExports.jsx(MediaRadioGroup, {
                            variant: MEDIA_RADIO_GROUP_VARIANT.ICON,
                            name: me("game-mode.tabs.core"),
                            activeValue: Ne !== void 0 && (ce != null && ce.some( ({name: Ze}) => Ze === Ne)) ? Ne : void 0,
                            onChange: xe,
                            radios: ze.map(Ze => ({
                                icon: GAME_MODE_ICON_MAP.get(Ze.name) ?? ICON_NAMES.MODE_CUSTOM,
                                label: me(`gamemodes.${Ze.name}.title`),
                                value: Ze.name,
                                testId: `game-mode-${Ze.name}`
                            })).sort( (Ze, et) => Ze.label < et.label ? -1 : Ze.label > et.label ? 1 : 0),
                            isDisabled: !ge
                        })
                    }, "verified")]
                })
            }), jsxRuntimeExports.jsx("div", {
                className: styles$q.continueWrapper,
                children: jsxRuntimeExports.jsx("div", {
                    className: styles$q.continueContainer,
                    children: jsxRuntimeExports.jsx(Button, {
                        isDisabled: !Ne,
                        onClick: we,
                        fillWidth: !0,
                        children: me("general.start-editing")
                    })
                })
            })]
        })]
    })
}
  , portalLogo = "/bf6/11303125/assets/portal-logo-white-BT1Yii4u.png"
  , wrapper$3 = "_wrapper_1vwv4_1"
  , logo = "_logo_1vwv4_8"
  , pageWrapper$1 = "_pageWrapper_1vwv4_12"
  , headingSection = "_headingSection_1vwv4_19"
  , contentWrapper = "_contentWrapper_1vwv4_23"
  , content$3 = "_content_1vwv4_23"
  , description$1 = "_description_1vwv4_36"
  , actionsContainer = "_actionsContainer_1vwv4_43"
  , backLink = "_backLink_1vwv4_51"
  , styles$p = {
    wrapper: wrapper$3,
    logo,
    pageWrapper: pageWrapper$1,
    headingSection,
    contentWrapper,
    content: content$3,
    description: description$1,
    actionsContainer,
    backLink
}
  , getLoginRedirect = (V, X, J) => {
    const ne = instance.language;
    let ue;
    return V != null && V.pathname ? ue = ["https://portal.battlefield.com", V.pathname, V.search].join("") : ue = buildUrl(["https://portal.battlefield.com", X, J]),
    buildUrl(["https://accounts.ea.com", "/connect/auth"], {
        queryParams: {
            response_type: "code",
            client_id: "GLACIER_COMP_APP",
            redirect_uri: ue,
            locale: ne.replace("-", "_"),
            state: ue
        }
    })
}
  , LoginPage = () => {
    var Fe;
    const {t: V} = useTranslation()
      , {state: X, pathname: J, search: ne} = useLocation();
    useDialog(DIALOG_ID.MANAGE_PATCH_VERSIONS);
    const [ue,ce] = reactExports.useState()
      , me = getLoginRedirect(X, J, ne)
      , ge = api.get(COOKIE_KEY.PATCH_VERSIONS)
      , Te = JSON.parse(ge ?? "{}")
      , [_e,Se] = reactExports.useState(Te)
      , Ie = Object.entries(_e);
    (Fe = Ie.find(je => je[1])) == null || Fe[0];
    const {isError: ye} = reactExports.useContext(SessionContext)
      , $e = () => {
        window.location.assign(me)
    }
      , Ne = () => {
        if (ue) {
            const je = {
                ..._e,
                [ue]: !1
            };
            Se(je)
        }
    }
      , ve = je => {
        ce(je)
    }
      , ke = je => {
        const Xe = Ie.reduce( (ze, [qe]) => (ze[qe] = !1,
        ze), {});
        je !== "default" && je && (Xe[je] = !0),
        Se(Xe)
    }
      , xe = je => Xe => {
        ke(Xe ? je : "default")
    }
      , we = je => () => {
        delete _e[je],
        Se({
            ..._e
        })
    }
    ;
    return reactExports.useEffect( () => {
        api.set(COOKIE_KEY.PATCH_VERSIONS, JSON.stringify(_e), {
            expires: S_ONE_YEAR
        })
    }
    , [_e]),
    jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsx("div", {
            className: styles$p.wrapper,
            children: jsxRuntimeExports.jsxs(PageWrapper, {
                className: styles$p.pageWrapper,
                children: [jsxRuntimeExports.jsx("div", {
                    className: styles$p.headingSection,
                    children: jsxRuntimeExports.jsx("img", {
                        src: portalLogo,
                        alt: "Battlefield Portal",
                        className: styles$p.logo
                    })
                }), jsxRuntimeExports.jsx("div", {
                    className: styles$p.contentWrapper,
                    children: jsxRuntimeExports.jsx(PromptBox, {
                        children: jsxRuntimeExports.jsxs("div", {
                            className: styles$p.content,
                            children: [jsxRuntimeExports.jsx(Paragraph, {
                                size: PARAGRAPH_SIZE.LG,
                                className: styles$p.description,
                                children: V("app.please-sign-in")
                            }), ye && jsxRuntimeExports.jsx(Warning, {
                                variant: WARNING_VARIANTS.ERROR,
                                text: V("general.authentication-error")
                            }), jsxRuntimeExports.jsxs("div", {
                                className: styles$p.actionsContainer,
                                children: [jsxRuntimeExports.jsx(Button, {
                                    fillWidth: !0,
                                    onClick: $e,
                                    testId: TEST_ID.LOGIN_BUTTON,
                                    children: V("app.sign-in-to-continue")
                                }), VITE_ENVIRONMENT !== "production"]
                            })]
                        })
                    })
                })]
            })
        }), jsxRuntimeExports.jsxs(DialogContent, {
            header: "Add/Remove Preferred Patch Versions",
            id: DIALOG_ID.MANAGE_PATCH_VERSIONS,
            footer: jsxRuntimeExports.jsx(Button, {
                type: BUTTON_TYPES$1.SUBMIT,
                children: "Done"
            }),
            children: [jsxRuntimeExports.jsx(Section, {
                subsection: !0,
                children: jsxRuntimeExports.jsxs(Table, {
                    children: [jsxRuntimeExports.jsxs(TableRow, {
                        children: [jsxRuntimeExports.jsx(TableCell, {
                            children: "Version"
                        }), jsxRuntimeExports.jsx(TableCell, {
                            children: "Action"
                        })]
                    }), Ie.map( ([je,Xe], ze) => jsxRuntimeExports.jsxs(TableRow, {
                        children: [jsxRuntimeExports.jsx(TableCell, {
                            children: je
                        }), jsxRuntimeExports.jsx(TableCell, {
                            color: "transparent",
                            children: jsxRuntimeExports.jsxs(Space, {
                                align: SPACE_ALIGN.CENTER,
                                children: [jsxRuntimeExports.jsx(Checkbox, {
                                    checked: Xe,
                                    onChange: xe(je),
                                    positive: !0
                                }), jsxRuntimeExports.jsx(Tooltip, {
                                    tip: "Remove",
                                    children: jsxRuntimeExports.jsx(IconButton, {
                                        icon: ICON_NAMES.CLOSE,
                                        onClick: we(je),
                                        size: ICON_BUTTON_SIZE.XS
                                    })
                                })]
                            })
                        })]
                    }, ze))]
                })
            }), jsxRuntimeExports.jsx(TextInput, {
                onChange: ve,
                label: "New Patch",
                value: ue,
                action: {
                    icon: ICON_NAMES.PLUS2,
                    text: "Add",
                    iconOnly: !0,
                    onClick: Ne
                }
            })]
        })]
    })
}
  , wrapper$2 = "_wrapper_zukdi_1"
  , styles$o = {
    wrapper: wrapper$2
}
  , logger$9 = Logger$1.get("Logout");
function performLogoutRedirect() {
    const V = document.referrer ? new URL(document.referrer) : void 0
      , J = (V == null ? void 0 : V.origin) === "https://portal.battlefield.com" ? V.href : "https://portal.battlefield.com";
    logger$9.debug("redirectUri:", J);
    const ne = buildUrl(["https://accounts.ea.com", "/connect/logout"], {
        queryParams: {
            client_id: "GLACIER_COMP_APP",
            redirect_uri: buildUrl([J], {
                endWithSlash: !0
            })
        }
    });
    try {
        clients.authentication.logout({})
    } catch (ue) {
        throw logger$9.error("Failed to logout from gateway!", ue),
        ue
    }
    return ne
}
const LogoutPage = () => {
    const {t: V} = useTranslation()
      , {clearSession: X} = reactExports.useContext(SessionContext);
    telemetryHelper.logout().then(ne => logger$9.log(ne)),
    logger$9.log("Clearing session cookie..."),
    X();
    const J = performLogoutRedirect();
    return J && window.location.replace(J),
    jsxRuntimeExports.jsx("div", {
        className: styles$o.wrapper,
        children: jsxRuntimeExports.jsx(LoadingSpinner, {
            statusText: V("general.signing-out")
        })
    })
}
  , maps = "_maps_keyx3_1"
  , content$2 = "_content_keyx3_34"
  , column = "_column_keyx3_42"
  , card = "_card_keyx3_51"
  , selectedMapsList = "_selectedMapsList_keyx3_55"
  , selectionsList = "_selectionsList_keyx3_77"
  , missingLicense = "_missingLicense_keyx3_95"
  , includeDefaultSpatial = "_includeDefaultSpatial_keyx3_98"
  , rotationMax = "_rotationMax_keyx3_106"
  , heading$2 = "_heading_keyx3_110"
  , selectionsHeading = "_selectionsHeading_keyx3_113"
  , choicesHeading = "_choicesHeading_keyx3_116"
  , choiceLabel = "_choiceLabel_keyx3_120"
  , label$1 = "_label_keyx3_125"
  , placeholderContainer = "_placeholderContainer_keyx3_131"
  , placeholder = "_placeholder_keyx3_131"
  , mapDetailsWrapper = "_mapDetailsWrapper_keyx3_147"
  , mapDetailsContainer = "_mapDetailsContainer_keyx3_153"
  , imageCard = "_imageCard_keyx3_166"
  , intro = "_intro_keyx3_170"
  , downloadSdkCaption = "_downloadSdkCaption_keyx3_184"
  , downloadSdkButton = "_downloadSdkButton_keyx3_188"
  , tools = "_tools_keyx3_192"
  , attachment = "_attachment_keyx3_197"
  , attachmentName = "_attachmentName_keyx3_203"
  , errorCaption = "_errorCaption_keyx3_214"
  , withErrors = "_withErrors_keyx3_218"
  , defaultSpatialContainer = "_defaultSpatialContainer_keyx3_225"
  , styles$n = {
    maps,
    content: content$2,
    column,
    card,
    selectedMapsList,
    selectionsList,
    missingLicense,
    includeDefaultSpatial,
    rotationMax,
    heading: heading$2,
    selectionsHeading,
    choicesHeading,
    choiceLabel,
    label: label$1,
    placeholderContainer,
    placeholder,
    mapDetailsWrapper,
    mapDetailsContainer,
    imageCard,
    intro,
    downloadSdkCaption,
    downloadSdkButton,
    tools,
    attachment,
    attachmentName,
    errorCaption,
    withErrors,
    defaultSpatialContainer
}
  , MAP_SIZE_TO_ICON_MAP = new Map([["s", VULCANITE_ICON_NAME.MAP_SIZE_SMALL], ["m", VULCANITE_ICON_NAME.MAP_SIZE_MEDIUM], ["l", VULCANITE_ICON_NAME.MAP_SIZE_LARGE]])
  , MapRotationPage = () => {
    const [V] = useAtom(gameModeAtom)
      , {colors: X, breakpoints: J} = reactExports.useContext(ThemeContext)
      , ne = useAtomValue(isCustomGameModeAtom)
      , ue = useAtomValue(isOwnerAtom)
      , [ce,me] = useAtom(mapRotationAtom)
      , {blueprint: ge} = reactExports.useContext(BlueprintContext)
      , {t: Te} = useTranslation()
      , _e = ce.length >= MAP_ROTATION_MAX
      , Se = reactExports.useContext(CurrentBreakpointContext)
      , Ie = {
        lg: !1
    }
      , ye = common_utils.getMobileFirstOption({
        xxs: "mobile",
        md: "tablet",
        xxl: "desktop"
    }, Se, J) ?? "mobile"
      , $e = ye === "mobile"
      , Ne = ye === "desktop"
      , ve = reactExports.useRef(null)
      , [ke,xe] = reactExports.useState(null)
      , [we,Fe] = useAtom(attachmentIdsPendingDeletionAtom)
      , {spatialDefaults: je, isLoading: Xe} = useSpatialDefaults(ne)
      , [ze,qe] = useAtom(migrationOrphanedSpatialAttachmentAtom)
      , [Ze,et] = useAtom(attachmentsAtom)
      , {data: it, isLoading: at} = useGetLicenseRequirements()
      , [rt,ft] = reactExports.useState([])
      , St = useOffCanvas(DIALOG_ID.SHOW_ERROR_OFF_CANVAS)
      , {latestVersion: Ye, fileSize: We} = useLatestSdkVersion()
      , nt = reactExports.useMemo( () => (ge == null ? void 0 : ge.maps.filter(Ct => ne ? getGameModeFromLevelLocation(Ct.levelLocation) === CUSTOM_GAME_MODE_ID && Ct.gameMode === V : getGameModeFromLevelLocation(Ct.levelLocation) === V)) ?? [], [ge == null ? void 0 : ge.maps, V, ne]);
    if (reactExports.useEffect( () => {
        var Ct;
        ve.current && !((Ct = ve.current) != null && Ct.value) && ve.current.click()
    }
    , [ke]),
    Xe || at)
        return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
    const {ownedLicenses: ct, mapEntryRequirements: Et} = it ?? {}
      , Ke = Ct => () => {
        const Mt = {
            ...Ct
        };
        ne && getDefaultSpatialDataByMap(Ct, je) && (Mt.includeDefaultSpatialData = !0),
        me([...ce, Mt])
    }
      , mt = Ct => () => {
        me([...ce.filter( (Mt, nn) => Ct !== nn)])
    }
      , lt = Ct => () => {
        xe(Ct)
    }
      , Qe = () => {
        ve.current && (ve.current.files = null,
        ve.current.value = ""),
        xe(null)
    }
      , gt = (Ct, Mt) => () => {
        me(ce.toSpliced(Ct, 1, {
            ...ce[Ct],
            spatialAttachment: Mt
        })),
        xe(null)
    }
      , Nt = (Ct, Mt) => () => {
        Fe([...we, Mt.id]),
        Ct === 0 && ze && qe(null),
        me(ce.toSpliced(Ct, 1, {
            ...ce[Ct],
            spatialAttachment: void 0
        })),
        xe(null),
        et([...Ze.filter(nn => nn.id !== Mt.id)])
    }
      , Gt = Ct => () => {
        var nn;
        const Mt = ce[Ct].spatialAttachment;
        Mt && ((nn = Mt.attachmentData) != null && nn.original) && downloadFile((Mt == null ? void 0 : Mt.filename) ?? `spatialAttachment${Ct}.json`, new TextDecoder().decode(Mt.attachmentData.original))
    }
      , Ht = Ct => Mt => {
        var mn, dn;
        const nn = new FileReader
          , tn = (dn = (mn = Mt == null ? void 0 : Mt.target) == null ? void 0 : mn.files) == null ? void 0 : dn[0];
        nn.onload = () => {
            if (nn.readyState === 2 && nn.result) {
                const Qt = new Uint8Array(nn.result);
                Qt.byteLength > 0 ? gt(Ct, {
                    filename: (tn == null ? void 0 : tn.name) ?? "spatial-data.json",
                    metadata: getMetadataForSpatialAttachment(Ct),
                    attachmentData: {
                        original: Qt,
                        compiled: void 0
                    },
                    id: generateUUID(),
                    version: SPATIAL_ATTACHMENT_TEMP_VERSION,
                    isProcessable: !0,
                    processingStatus: ProcessingStatus.PROCESSING_STATUS_PENDING,
                    attachmentType: AttachmentType.ATTACHMENT_TYPE_SPATIAL
                })() : console.debug("ArrayBuffer for Map Spatial attachment was empty", Qt)
            }
        }
        ,
        tn && (console.debug(`Reading Map Spatial attachment ${tn.name}, ${(tn.size / 1024).toFixed(2)}kb`),
        nn.readAsArrayBuffer(tn))
    }
      , Kt = (Ct, {isNewItem: Mt, newPosition: nn}={}) => {
        const tn = Ct.map(mn => ({
            ...mn.props["data-map-data"]
        }));
        ne && Mt && nn !== void 0 && getDefaultSpatialDataByMap(tn[nn], je) && (tn[nn].includeDefaultSpatialData = !0),
        me(tn)
    }
      , Ot = () => {
        window.open(`https://download.portal.battlefield.com/PortalSDK.zip?${cacheBustSuffix()}`, "_blank")
    }
      , kt = Ct => () => {
        const Mt = !!ce[Ct].includeDefaultSpatialData;
        ce[Ct].includeDefaultSpatialData = !Mt,
        me([...ce])
    }
      , Xt = () => {
        var Ct, Mt;
        (Ct = ze == null ? void 0 : ze.attachmentData) != null && Ct.original && downloadFile("mapRotation0Attachment.json", new TextDecoder().decode((Mt = ze == null ? void 0 : ze.attachmentData) == null ? void 0 : Mt.original))
    }
      , vt = Ct => () => {
        ft([...Ct]),
        St.open()
    }
      , Jt = Ye && We ? `${Ye} (${bytesToMbString(We)})` : "";
    return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsxs(PageWrapper, {
            trimTop: !0,
            children: [ne ? jsxRuntimeExports.jsxs(Section, {
                className: styles$n.intro,
                paddingSize: SECTION_PADDING_SIZE.LG,
                trimX: !0,
                trimTop: !0,
                children: [jsxRuntimeExports.jsx(Paragraph, {
                    className: styles$n.downloadSdkCaption,
                    size: PARAGRAPH_SIZE.LG,
                    children: Te("general.download-sdk-to-edit-maps")
                }), jsxRuntimeExports.jsx(Tooltip, {
                    tip: Jt || Te("general.download-portal-sdk"),
                    children: jsxRuntimeExports.jsx(Button, {
                        variant: BUTTON_VARIANTS.SECONDARY,
                        color: X.primary,
                        suffixIcon: ICON_NAMES.DOWNLOAD,
                        onClick: Ot,
                        testId: TEST_ID.DOWNLOAD_SDK_BUTTON,
                        className: styles$n.downloadSdkButton,
                        children: Te("download-sdk")
                    })
                })]
            }) : null, jsxRuntimeExports.jsx(ChoiceSorter, {
                dropPlaceholder: jsxRuntimeExports.jsx(ImageCardSkeleton, {
                    variant: IMAGE_CARD_VARIANT.LIST_ITEM
                }),
                emptyPlaceholder: jsxRuntimeExports.jsx("div", {
                    className: styles$n.placeholderContainer,
                    children: jsxRuntimeExports.jsxs(Space, {
                        className: styles$n.placeholder,
                        gapSize: SPACE_GAP_SIZE.XS,
                        children: ["+ ", Te("editor.drag-and-drop-empty")]
                    })
                }),
                isDisabled: !ue,
                mobileView: Ie,
                onChange: Kt,
                containerClassName: styles$n.content,
                columnClassName: styles$n.column,
                choicesClassName: styles$n.maps,
                selectionsListClassName: styles$n.selectionsList,
                activeListClassName: styles$n.selectedMapsList,
                max: MAP_ROTATION_MAX,
                showEmptyPlaceholderBelowDropArea: !$e,
                choicesTitle: jsxRuntimeExports.jsxs("div", {
                    className: common_utils.classNames(styles$n.heading, styles$n.choicesHeading),
                    children: [jsxRuntimeExports.jsx(Heading, {
                        variant: HEADING_VARIANT.SECONDARY_SUBHEADING,
                        children: Te("editor.available-maps")
                    }), jsxRuntimeExports.jsx(Divider, {})]
                }),
                activeItemsTitle: jsxRuntimeExports.jsxs("div", {
                    className: common_utils.classNames(styles$n.heading, styles$n.selectionsHeading),
                    children: [jsxRuntimeExports.jsxs(Heading, {
                        variant: HEADING_VARIANT.SECONDARY_SUBHEADING,
                        children: [Te("general.map-rotation"), jsxRuntimeExports.jsx(Divider, {
                            vertical: !0
                        }), jsxRuntimeExports.jsxs("span", {
                            children: [ce.length, jsxRuntimeExports.jsxs("span", {
                                className: styles$n.rotationMax,
                                children: ["/", MAP_ROTATION_MAX]
                            })]
                        })]
                    }), jsxRuntimeExports.jsx(Divider, {})]
                }),
                choices: nt.map( (Ct, Mt) => {
                    const {licenseRequirements: nn, missingLicense: tn} = getUsersMapLicenseData({
                        mapEntryRequirements: Et ?? [],
                        ownedLicenses: ct ?? [],
                        levelName: Ct.levelName
                    });
                    return jsxRuntimeExports.jsx(ImageCard, {
                        "data-map-data": Ct,
                        icon: MAP_SIZE_TO_ICON_MAP.get(Ct.mapSize),
                        className: common_utils.classNames(styles$n.card, !!tn && styles$n.missingLicense),
                        iconColor: X.black,
                        variant: $e ? IMAGE_CARD_VARIANT.LIST_ITEM : IMAGE_CARD_VARIANT.TILE,
                        caption: jsxRuntimeExports.jsxs("div", {
                            className: styles$n.choiceLabel,
                            "data-levellocation": Ct.levelLocation,
                            children: [jsxRuntimeExports.jsxs(Space, {
                                gapSize: SPACE_GAP_SIZE.XS,
                                children: [!!(nn != null && nn.length) && jsxRuntimeExports.jsx(Tooltip, {
                                    tip: Te("editor.premium-map-req-tooltip"),
                                    children: jsxRuntimeExports.jsx(Icon, {
                                        name: ICON_NAMES.PRICE_TAG,
                                        size: ICON_SIZES.SM,
                                        color: tn ? X.warningVibrant : X.gray600
                                    })
                                }), Te(Ct.title)]
                            }), jsxRuntimeExports.jsx(IconButton, {
                                size: ICON_BUTTON_SIZE.XS,
                                isDisabled: _e,
                                label: Te("general.add"),
                                icon: ICON_NAMES.PLUS,
                                hoverColor: X.white,
                                color: _e ? X.gray500 : X.gray300,
                                transparent: !0,
                                testId: `add-${Ct.levelName}:${Ct.mapSize}`,
                                onClick: Ke(Ct)
                            })]
                        }),
                        imageSrc: Ct.image
                    }, Mt)
                }
                ),
                activeItems: ce == null ? void 0 : ce.map( (Ct, Mt) => {
                    var Qt, on, zt, $t, Ut, An, yt;
                    const {licenseRequirements: nn, missingLicense: tn} = getUsersMapLicenseData({
                        mapEntryRequirements: Et ?? [],
                        ownedLicenses: ct ?? [],
                        levelName: Ct.levelName
                    })
                      , mn = (Qt = Ct == null ? void 0 : Ct.spatialAttachment) == null ? void 0 : Qt.errors
                      , dn = mn == null ? void 0 : mn.length;
                    return jsxRuntimeExports.jsx(ImageCard, {
                        "data-map-data": Ct,
                        icon: MAP_SIZE_TO_ICON_MAP.get(Ct.mapSize),
                        iconColor: X.black,
                        themeVariant: (zt = (on = Ct.spatialAttachment) == null ? void 0 : on.errors) != null && zt.length ? IMAGE_CARD_THEME_VARIANT.DANGER : IMAGE_CARD_THEME_VARIANT.BASIC,
                        className: styles$n.imageCard,
                        caption: jsxRuntimeExports.jsxs("div", {
                            className: styles$n.mapDetailsWrapper,
                            children: [jsxRuntimeExports.jsxs("div", {
                                className: styles$n.mapDetailsContainer,
                                children: [jsxRuntimeExports.jsx("div", {
                                    className: styles$n.label,
                                    "data-levellocation": Ct.levelLocation,
                                    children: jsxRuntimeExports.jsxs(Space, {
                                        gapSize: SPACE_GAP_SIZE.XXS,
                                        children: [!!(nn != null && nn.length) && jsxRuntimeExports.jsx(Tooltip, {
                                            tip: Te("general.experience-requires-full-game"),
                                            children: jsxRuntimeExports.jsx(Icon, {
                                                name: ICON_NAMES.PRICE_TAG,
                                                size: ICON_SIZES.SM,
                                                color: tn ? X.warningVibrant : X.gray600
                                            })
                                        }), Te(Ct.title)]
                                    })
                                }), ne && jsxRuntimeExports.jsx("div", {
                                    className: styles$n.tools,
                                    children: Ct.spatialAttachment ? jsxRuntimeExports.jsxs("div", {
                                        className: styles$n.attachment,
                                        children: [Mt === 0 && ze ? jsxRuntimeExports.jsx(Tooltip, {
                                            tip: Te("general.map-attachment-override-warning", {
                                                fileSize: `${((Ut = ($t = ze == null ? void 0 : ze.attachmentData) == null ? void 0 : $t.original) == null ? void 0 : Ut.length) && (((yt = (An = ze == null ? void 0 : ze.attachmentData) == null ? void 0 : An.original) == null ? void 0 : yt.length) / 1024).toFixed(2)}`
                                            }),
                                            children: jsxRuntimeExports.jsx(IconButton, {
                                                label: Te("general.download-old-spatial-attachment"),
                                                testId: TEST_ID.DOWNLOAD_SPATIAL,
                                                icon: ICON_NAMES.WARNING,
                                                onClick: Xt,
                                                size: ICON_BUTTON_SIZE.MD
                                            })
                                        }) : null, dn ? jsxRuntimeExports.jsx("button", {
                                            title: Ct.spatialAttachment.filename,
                                            "aria-label": Te("general.file-error"),
                                            className: common_utils.classNames(styles$n.attachmentName, styles$n.withErrors),
                                            type: "button",
                                            onClick: vt(mn),
                                            children: jsxRuntimeExports.jsxs(Space, {
                                                gapSize: SPACE_GAP_SIZE.XS,
                                                children: [jsxRuntimeExports.jsx(Icon, {
                                                    name: ICON_NAMES.ERROR
                                                }), Ne && jsxRuntimeExports.jsxs("span", {
                                                    className: styles$n.errorCaption,
                                                    children: [dn === 1 ? Te("general.one-error") : null, dn > 1 ? Te("general.count-errors", {
                                                        count: dn
                                                    }) : null]
                                                }), getTruncatedFilename(Ct.spatialAttachment.filename ?? "", $e ? 1 : 3)]
                                            })
                                        }) : jsxRuntimeExports.jsx("div", {
                                            title: Ct.spatialAttachment.filename,
                                            className: styles$n.attachmentName,
                                            children: getTruncatedFilename(Ct.spatialAttachment.filename ?? "", 11)
                                        }), jsxRuntimeExports.jsx(Tooltip, {
                                            tip: Te("general.download-spatial"),
                                            children: jsxRuntimeExports.jsx(IconButton, {
                                                label: Te("general.download-spatial"),
                                                testId: `downloadSpatial-${Ct.levelName}:${Ct.mapSize}:${Mt}`,
                                                icon: ICON_NAMES.DOWNLOAD,
                                                size: ICON_BUTTON_SIZE.SM,
                                                color: X.neutral200,
                                                transparent: !0,
                                                onClick: Gt(Mt)
                                            })
                                        }), jsxRuntimeExports.jsx(Tooltip, {
                                            tip: Te("general.remove-spatial"),
                                            children: jsxRuntimeExports.jsx(IconButton, {
                                                size: ICON_BUTTON_SIZE.SM,
                                                label: Te("general.remove-spatial"),
                                                testId: `attach-${Ct.levelName}:${Ct.mapSize}:${Mt}`,
                                                icon: ICON_NAMES.TRASH,
                                                color: X.neutral200,
                                                transparent: !0,
                                                onClick: Nt(Mt, Ct.spatialAttachment)
                                            })
                                        })]
                                    }) : ke === Mt ? jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                                        children: [jsxRuntimeExports.jsx(Tooltip, {
                                            tip: Te("general.cancel-attaching"),
                                            placement: PLACEMENT.TOP_LEFT,
                                            children: jsxRuntimeExports.jsx(IconButton, {
                                                label: Te("general.cancel"),
                                                testId: `cancelAttach-${Ct.levelName}:${Ct.mapSize}:${Mt}`,
                                                icon: ICON_NAMES.CHEVRON_LEFT,
                                                hoverColor: X.white,
                                                color: X.gray300,
                                                transparent: !0,
                                                onClick: Qe
                                            })
                                        }), jsxRuntimeExports.jsx("input", {
                                            name: "spatialData",
                                            disabled: !ue,
                                            ref: ve,
                                            type: "file",
                                            accept: ".json",
                                            onChange: Ht(Mt)
                                        })]
                                    }) : jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                                        children: [getDefaultSpatialDataByMap(Ct, je) && jsxRuntimeExports.jsx("div", {
                                            className: styles$n.defaultSpatialContainer,
                                            children: jsxRuntimeExports.jsx(Checkbox, {
                                                labelClassName: styles$n.includeDefaultSpatial,
                                                checked: Ct.includeDefaultSpatialData,
                                                onChange: kt(Mt),
                                                children: Te("general.include-default-spatial-data")
                                            })
                                        }), jsxRuntimeExports.jsx(Tooltip, {
                                            tip: Te("general.attach-spatial-json-to-map"),
                                            placement: PLACEMENT.TOP,
                                            children: jsxRuntimeExports.jsx(IconButton, {
                                                label: Te("general.attach"),
                                                testId: `attach-${Ct.levelName}:${Ct.mapSize}:${Mt}`,
                                                icon: ICON_NAMES.UPLOAD2,
                                                color: X.neutral200,
                                                size: ICON_BUTTON_SIZE.SM,
                                                transparent: !0,
                                                onClick: lt(Mt)
                                            })
                                        })]
                                    })
                                })]
                            }), jsxRuntimeExports.jsx(IconButton, {
                                label: Te("general.remove"),
                                testId: `remove-${Ct.levelName}:${Ct.mapSize}:${Mt}`,
                                icon: ICON_NAMES.MINUS,
                                hoverColor: X.white,
                                color: X.neutralT300,
                                size: ICON_BUTTON_SIZE.XS,
                                transparent: !0,
                                onClick: mt(Mt)
                            })]
                        }),
                        imageSrc: Ct.image,
                        variant: IMAGE_CARD_VARIANT.LIST_ITEM
                    }, `${Ct.levelName}:${Ct.mapSize}:${Mt}`)
                }
                )
            })]
        }), jsxRuntimeExports.jsx(OffCanvasContent, {
            header: "errors here",
            id: DIALOG_ID.SHOW_ERROR_OFF_CANVAS,
            children: rt
        })]
    })
}
  , legend = "_legend_lq4xz_1"
  , description = "_description_lq4xz_7"
  , styles$m = {
    legend,
    description
}
  , PublishingStatesLegend = ({states: V}) => jsxRuntimeExports.jsx("div", {
    className: styles$m.legend,
    children: V.map( ({chipVariant: X, description: J, label: ne, icon: ue}) => jsxRuntimeExports.jsxs(Space, {
        align: SPACE_ALIGN.START,
        gapSize: SPACE_GAP_SIZE.XS,
        children: [jsxRuntimeExports.jsx(ExperienceStatusTag, {
            variant: X,
            icon: ue,
            children: ne
        }), jsxRuntimeExports.jsx("span", {
            className: styles$m.description,
            children: J
        })]
    }))
})
  , container$2 = "_container_1msnc_1"
  , helpLabel = "_helpLabel_1msnc_5"
  , testHelpText = "_testHelpText_1msnc_8"
  , communityLink = "_communityLink_1msnc_16"
  , publishingHelpContainer = "_publishingHelpContainer_1msnc_19"
  , publishingHelpSection = "_publishingHelpSection_1msnc_33"
  , styles$l = {
    container: container$2,
    helpLabel,
    testHelpText,
    communityLink,
    publishingHelpContainer,
    publishingHelpSection
}
  , PublishStepOnePage = () => {
    var ue;
    const {serverSavedExperienceData: V} = reactExports.useContext(PlayElementContext)
      , {t: X} = useTranslation()
      , J = formatServerTags(((ue = V == null ? void 0 : V.playElementDesign) == null ? void 0 : ue.tags) ?? [], X)
      , ne = getPublishingStateLegendData().map(ce => ({
        ...ce,
        label: X(ce.label),
        description: X(ce.description)
    }));
    return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsxs("div", {
            className: styles$l.container,
            children: [jsxRuntimeExports.jsx(ExperienceBasicDetails, {}), jsxRuntimeExports.jsx(Field, {
                label: X("general.tags"),
                tip: X("general.help-users-find-experience"),
                children: jsxRuntimeExports.jsx(ServerTags, {
                    serverTags: J
                })
            })]
        }), jsxRuntimeExports.jsx("div", {
            children: jsxRuntimeExports.jsx(Field, {
                label: X("general.moderation-steps"),
                children: jsxRuntimeExports.jsxs(Section, {
                    subsection: !0,
                    trimY: !0,
                    className: styles$l.publishingHelpContainer,
                    children: [jsxRuntimeExports.jsxs(Section, {
                        subsection: !0,
                        className: styles$l.publishingHelpSection,
                        children: [jsxRuntimeExports.jsx(Section, {
                            subsection: !0,
                            paddingSize: SECTION_PADDING_SIZE.SM,
                            children: jsxRuntimeExports.jsxs(Space, {
                                children: [jsxRuntimeExports.jsx(Icon, {
                                    name: ICON_NAMES.WARNING
                                }), jsxRuntimeExports.jsx(Paragraph, {
                                    size: PARAGRAPH_SIZE.LG,
                                    className: styles$l.helpLabel,
                                    children: X("general.test-your-experience-before-publishing")
                                })]
                            })
                        }), jsxRuntimeExports.jsx(Paragraph, {
                            size: PARAGRAPH_SIZE.LG,
                            className: styles$l.testHelpText,
                            children: jsxRuntimeExports.jsxs(Trans, {
                                children: ["Make sure to test your experience prior publishing, any changes will require re-submission. The content submitted will be reviewed and verified and it should adhere to the", " ", jsxRuntimeExports.jsx(Link$1, {
                                    className: styles$l.communityLink,
                                    to: EA_COMMUNITY_GUIDELINES_URL,
                                    outsideLink: !0,
                                    children: "Battlefield Community Guidelines"
                                }), ". This process can ", jsxRuntimeExports.jsx("span", {
                                    children: "take a few hours to finalize."
                                })]
                            }, "general.make-sure-to-test-experience-help")
                        })]
                    }), jsxRuntimeExports.jsx(Section, {
                        subsection: !0,
                        className: styles$l.publishingHelpSection,
                        children: jsxRuntimeExports.jsx(PublishingStatesLegend, {
                            states: ne
                        })
                    })]
                })
            })
        })]
    })
}
  , details = "_details_1t812_1"
  , startSide = "_startSide_1t812_13"
  , summary = "_summary_1t812_18"
  , maxLengthInfo = "_maxLengthInfo_1t812_22"
  , progressionHeading = "_progressionHeading_1t812_27"
  , styles$k = {
    details,
    startSide,
    summary,
    maxLengthInfo,
    progressionHeading
}
  , PublishStepThreePage = () => {
    var we, Fe, je;
    const {serverSavedExperienceData: V} = reactExports.useContext(PlayElementContext)
      , [X] = useSearchParams()
      , J = X.get(QUERY_PARAM_KEY.EXPERIENCE_ID) ?? void 0
      , {blueprint: ne} = reactExports.useContext(BlueprintContext)
      , ue = useAtomValue(thumbnailUrlAtom)
      , ce = getBattleBinaryUrl(ue)
      , {t: me} = useTranslation()
      , ge = useAtomValue(isCustomGameModeAtom)
      , Te = useAtomValue(shortCodeAtom)
      , _e = useAtomValue(lastUpdatedTimeAtom)
      , Se = useAtomValue(mapRotationAtom)
      , Ie = useAtomValue(nameAtom)
      , ye = formatServerTags(((we = V == null ? void 0 : V.playElementDesign) == null ? void 0 : we.tags) ?? [], me)
      , {data: $e, isLoading: Ne} = useGetLicenseRequirements()
      , {ownedLicenses: ve, mapEntryRequirements: ke} = $e ?? {};
    if (!ne || Ne)
        return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
    const xe = V && V.playElement ? getPublishingStateMetadata({
        publishState: V.playElement.publishStateType,
        moderationState: V.playElement.moderationState,
        publishAt: V.playElement.publishAt
    }) : void 0;
    return jsxRuntimeExports.jsx("div", {
        children: jsxRuntimeExports.jsxs(Section, {
            subsection: !0,
            className: styles$k.details,
            children: [jsxRuntimeExports.jsxs("div", {
                className: styles$k.startSide,
                children: [jsxRuntimeExports.jsx(Field, {
                    label: me("general.select-image"),
                    children: jsxRuntimeExports.jsx(ExperienceTile, {
                        tag: xe && jsxRuntimeExports.jsx(ExperienceStatusTag, {
                            variant: xe.chipVariant,
                            icon: xe.icon,
                            toolTip: ((Fe = xe.tooltipTranslation) == null ? void 0 : Fe.id) && me((je = xe.tooltipTranslation) == null ? void 0 : je.id, {
                                ...xe.tooltipTranslation.arg,
                                interpolation: {
                                    escapeValue: !1
                                }
                            }),
                            children: me(xe.label)
                        }),
                        bgImage: ce,
                        heading: Ie,
                        subheading: `${me("general.modified")}: ${_e == null ? void 0 : _e.toLocaleString()}`
                    })
                }), jsxRuntimeExports.jsx(Field, {
                    label: me("general.progression"),
                    tip: me(ge ? "general.xp-tooltip-custom" : "general.xp-tooltip"),
                    icon: ICON_NAMES.XP,
                    children: jsxRuntimeExports.jsxs(Space, {
                        gapSize: SPACE_GAP_SIZE.XS,
                        children: [jsxRuntimeExports.jsx(Icon, {
                            name: ICON_NAMES.WARNING_DIAMOND
                        }), me(ge ? "general.custom-xp-description" : "general.verified-xp-description")]
                    })
                }), ye !== void 0 && ye.length ? jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
                    children: jsxRuntimeExports.jsx(Field, {
                        tip: me("general.helps-users-to-find-experience"),
                        label: me("general.tags"),
                        children: jsxRuntimeExports.jsx(ServerTags, {
                            serverTags: ye
                        })
                    })
                }) : null]
            }), jsxRuntimeExports.jsxs("div", {
                className: styles$k.summary,
                children: [jsxRuntimeExports.jsx(ExperienceBasicDetails, {}), J && Te && jsxRuntimeExports.jsx(Field, {
                    label: me("experience.experience-code"),
                    children: jsxRuntimeExports.jsx(Paragraph, {
                        children: Te
                    })
                }), jsxRuntimeExports.jsx(Field, {
                    label: me("general.map-rotation"),
                    tip: me("general.validation-tooltip"),
                    icon: ICON_NAMES.MAP_PIN,
                    children: jsxRuntimeExports.jsx(MapRotationPreview, {
                        licenseTooltip: me("editor.premium-map-req-tooltip"),
                        maps: Se.map( ({image: Xe, title: ze, levelName: qe}) => {
                            const {licenseRequirements: Ze, missingLicense: et} = getUsersMapLicenseData({
                                mapEntryRequirements: ke ?? [],
                                ownedLicenses: ve ?? [],
                                levelName: qe
                            });
                            return {
                                title: ze,
                                image: Xe,
                                licenseRequirements: Ze,
                                missingLicense: et
                            }
                        }
                        )
                    })
                }), jsxRuntimeExports.jsx(Field, {
                    label: me("general.experience-validation"),
                    tip: me("general.validation-tooltip"),
                    icon: ICON_NAMES.WARNING,
                    children: jsxRuntimeExports.jsx(ValidationFails, {})
                })]
            })]
        })
    })
}
  , useUploadExperienceThumbnailMutation = () => {
    const {sessionId: V} = reactExports.useContext(SessionContext)
      , X = useMutation({
        mutationFn: ne => V ? clients.play.UploadExperienceThumbnail(ne, new grpcWebClient_umdExports.grpc.Metadata({
            "x-gateway-session-id": V
        })) : Promise.reject()
    });
    return {
        uploadThumbnail: async ({imageData: ne, mimeType: ue, onSave: ce, onError: me}) => {
            const ge = {
                image: ne,
                mimeType: ue
            };
            console.debug("Uploading thumbnail image with payload:", ge);
            try {
                const Te = await X.mutateAsync(ge);
                Te && ce && ce(Te)
            } catch (Te) {
                me && (typeof Te == "string" ? me(new Error(Te)) : Te instanceof Error ? me(Te) : me()),
                console.error("Failed to upload thumbnail: ", Te)
            }
        }
    }
}
;
var ProfanityStatus = (V => (V[V.PROFANITY_UNDEFINED = 0] = "PROFANITY_UNDEFINED",
V[V.PROFANITY_PASS = 1] = "PROFANITY_PASS",
V[V.PROFANITY_FAIL_CSAM_DETECTED = 2] = "PROFANITY_FAIL_CSAM_DETECTED",
V[V.PROFANITY_FAIL_TOXICITY_DETECTED = 3] = "PROFANITY_FAIL_TOXICITY_DETECTED",
V[V.PROFANITY_DETECTION_UNAVAILABLE = 4] = "PROFANITY_DETECTION_UNAVAILABLE",
V[V.PROFANITY_PENDING = 5] = "PROFANITY_PENDING",
V[V.PROFANITY_STATUS_INTEGRITY_FAILED = 6] = "PROFANITY_STATUS_INTEGRITY_FAILED",
V[V.UNRECOGNIZED = -1] = "UNRECOGNIZED",
V))(ProfanityStatus || {});
function profanityStatusFromJSON(V) {
    switch (V) {
    case 0:
    case "PROFANITY_UNDEFINED":
        return 0;
    case 1:
    case "PROFANITY_PASS":
        return 1;
    case 2:
    case "PROFANITY_FAIL_CSAM_DETECTED":
        return 2;
    case 3:
    case "PROFANITY_FAIL_TOXICITY_DETECTED":
        return 3;
    case 4:
    case "PROFANITY_DETECTION_UNAVAILABLE":
        return 4;
    case 5:
    case "PROFANITY_PENDING":
        return 5;
    case 6:
    case "PROFANITY_STATUS_INTEGRITY_FAILED":
        return 6;
    case -1:
    case "UNRECOGNIZED":
    default:
        return -1
    }
}
function profanityStatusToJSON(V) {
    switch (V) {
    case 0:
        return "PROFANITY_UNDEFINED";
    case 1:
        return "PROFANITY_PASS";
    case 2:
        return "PROFANITY_FAIL_CSAM_DETECTED";
    case 3:
        return "PROFANITY_FAIL_TOXICITY_DETECTED";
    case 4:
        return "PROFANITY_DETECTION_UNAVAILABLE";
    case 5:
        return "PROFANITY_PENDING";
    case 6:
        return "PROFANITY_STATUS_INTEGRITY_FAILED";
    case -1:
    default:
        return "UNRECOGNIZED"
    }
}
function createBaseSubAssetProfanityStatus() {
    return {
        externalDataSourceId: 0,
        assetId: "",
        nonce: "",
        profanityStatus: 0,
        profanityReason: ""
    }
}
const SubAssetProfanityStatus = {
    encode(V, X=new BinaryWriter) {
        return V.externalDataSourceId !== 0 && X.uint32(8).int32(V.externalDataSourceId),
        V.assetId !== "" && X.uint32(18).string(V.assetId),
        V.nonce !== "" && X.uint32(26).string(V.nonce),
        V.profanityStatus !== 0 && X.uint32(32).int32(V.profanityStatus),
        V.profanityReason !== "" && X.uint32(42).string(V.profanityReason),
        X
    },
    decode(V, X) {
        const J = V instanceof BinaryReader ? V : new BinaryReader(V);
        let ne = X === void 0 ? J.len : J.pos + X;
        const ue = createBaseSubAssetProfanityStatus();
        for (; J.pos < ne; ) {
            const ce = J.uint32();
            switch (ce >>> 3) {
            case 1:
                {
                    if (ce !== 8)
                        break;
                    ue.externalDataSourceId = J.int32();
                    continue
                }
            case 2:
                {
                    if (ce !== 18)
                        break;
                    ue.assetId = J.string();
                    continue
                }
            case 3:
                {
                    if (ce !== 26)
                        break;
                    ue.nonce = J.string();
                    continue
                }
            case 4:
                {
                    if (ce !== 32)
                        break;
                    ue.profanityStatus = J.int32();
                    continue
                }
            case 5:
                {
                    if (ce !== 42)
                        break;
                    ue.profanityReason = J.string();
                    continue
                }
            }
            if ((ce & 7) === 4 || ce === 0)
                break;
            J.skip(ce & 7)
        }
        return ue
    },
    fromJSON(V) {
        return {
            externalDataSourceId: isSet(V.externalDataSourceId) ? globalThis.Number(V.externalDataSourceId) : 0,
            assetId: isSet(V.assetId) ? globalThis.String(V.assetId) : "",
            nonce: isSet(V.nonce) ? globalThis.String(V.nonce) : "",
            profanityStatus: isSet(V.profanityStatus) ? profanityStatusFromJSON(V.profanityStatus) : 0,
            profanityReason: isSet(V.profanityReason) ? globalThis.String(V.profanityReason) : ""
        }
    },
    toJSON(V) {
        const X = {};
        return V.externalDataSourceId !== 0 && (X.externalDataSourceId = Math.round(V.externalDataSourceId)),
        V.assetId !== "" && (X.assetId = V.assetId),
        V.nonce !== "" && (X.nonce = V.nonce),
        V.profanityStatus !== 0 && (X.profanityStatus = profanityStatusToJSON(V.profanityStatus)),
        V.profanityReason !== "" && (X.profanityReason = V.profanityReason),
        X
    },
    create(V) {
        return SubAssetProfanityStatus.fromPartial(V ?? {})
    },
    fromPartial(V) {
        const X = createBaseSubAssetProfanityStatus();
        return X.externalDataSourceId = V.externalDataSourceId ?? 0,
        X.assetId = V.assetId ?? "",
        X.nonce = V.nonce ?? "",
        X.profanityStatus = V.profanityStatus ?? 0,
        X.profanityReason = V.profanityReason ?? "",
        X
    }
};
function isSet(V) {
    return V != null
}
async function checkImageValidationUrl(V) {
    if (V) {
        const J = await (await fetch(V)).json();
        return J ? SubAssetProfanityStatus.fromJSON(J) : {}
    }
    return null
}
const useImageValidationStatus = (V, X) => {
    const {data: J} = useQuery({
        queryKey: [QUERY_KEY.SPATIAL_DEFAULTS, V],
        queryFn: () => checkImageValidationUrl(V),
        enabled: X && !!V,
        refetchInterval: 3e3,
        refetchOnWindowFocus: !1,
        staleTime: 1e3
    })
      , {profanityStatus: ne, profanityReason: ue} = J ?? {}
      , ce = profanityStatusFromJSON(ne)
      , me = ce === ProfanityStatus.PROFANITY_STATUS_INTEGRITY_FAILED || ce === ProfanityStatus.PROFANITY_FAIL_CSAM_DETECTED || ce === ProfanityStatus.PROFANITY_FAIL_TOXICITY_DETECTED || ce === ProfanityStatus.PROFANITY_DETECTION_UNAVAILABLE;
    return {
        isImageValidated: ne && profanityStatusFromJSON(ne) === ProfanityStatus.PROFANITY_PASS,
        isImageRejected: me,
        rejectionReason: ce !== ProfanityStatus.PROFANITY_PASS && ue ? ue : ""
    }
}
  , useImageUpload = (V, X) => {
    const {uploadThumbnail: J} = useUploadExperienceThumbnailMutation()
      , [ne,ue] = reactExports.useState(null)
      , [ce,me] = reactExports.useState(!1)
      , [ge,Te] = reactExports.useState(!1)
      , [_e,Se] = reactExports.useState([])
      , {isImageValidated: Ie, isImageRejected: ye, rejectionReason: $e} = useImageValidationStatus(ne, ce)
      , Ne = async (ke, xe, we, Fe) => {
        Te(!0),
        await J({
            imageData: ke,
            mimeType: xe,
            onSave: ze => {
                Te(!1),
                console.debug("Image successfully uploaded! API response:", ze),
                ue(ze.verificationUrl),
                we && we(ze),
                me(!0)
            }
            ,
            onError: ze => {
                Te(!1),
                Se(ze != null && ze.message ? [ze.message] : []),
                Fe && Fe()
            }
        })
    }
      , ve = () => {
        ue(null),
        Te(!1),
        me(!1),
        Se([])
    }
    ;
    return reactExports.useEffect( () => {
        ce && (Ie || ye) && (Ie && V && V(),
        ye && X && X(),
        me(!1))
    }
    , [Ie, ye, ce, V, X, me]),
    {
        initiateUpload: Ne,
        isImageValidationPending: ce,
        isImageValidated: Ie,
        isImageRejected: ye,
        isUploadingImage: ge,
        errors: _e,
        validationErrors: $e ? $e.replace("[", "").replace("]", "").split(",") : [],
        reset: ve
    }
}
  , container$1 = "_container_1ozfb_1"
  , introTitle = "_introTitle_1ozfb_5"
  , galleryContainer = "_galleryContainer_1ozfb_9"
  , tiles = "_tiles_1ozfb_13"
  , styles$j = {
    container: container$1,
    introTitle,
    galleryContainer,
    tiles
}
  , IS_IMAGE_UPLOAD_ENABLED = !1
  , PublishStepTwoPage = () => {
    const {blueprint: V} = reactExports.useContext(BlueprintContext)
      , {colors: X} = reactExports.useContext(ThemeContext)
      , [J,ne] = useAtom(thumbnailUrlAtom)
      , [ue,ce] = useAtom(pendingUploadThumbnailAtom)
      , {open: me} = useDialog(DIALOG_ID.UPLOAD_EXPERIENCE_IMAGE_INTRO)
      , {open: ge} = useDialog(DIALOG_ID.UPLOAD_EXPERIENCE_IMAGE_ERROR)
      , Te = () => {
        ge()
    }
      , _e = () => {
        ue && ue.url && ne(ue.url)
    }
      , {initiateUpload: Se, isUploadingImage: Ie, isImageValidationPending: ye, isImageValidated: $e, errors: Ne, reset: ve, validationErrors: ke} = useImageUpload(_e, Te)
      , xe = !Object.entries((V == null ? void 0 : V.availableThumbnailUrls) ?? {}).some( ([et]) => et === J)
      , we = et => {
        et !== (ue == null ? void 0 : ue.url) && ce(null),
        J !== et && ne(et)
    }
      , Fe = () => {
        me()
    }
      , je = et => {
        ce({
            src: et.url,
            url: et.url
        })
    }
      , Xe = () => {
        we(""),
        ge()
    }
      , ze = () => {
        V && (ve(),
        we(Object.entries(V.availableThumbnailUrls)[0][0]),
        ce(null))
    }
      , qe = () => {
        loadFile(async (et, it, at, rt) => {
            var ft, St, Ye, We;
            if (typeof ((ft = et.target) == null ? void 0 : ft.result) == "object" && ((Ye = (St = et.target) == null ? void 0 : St.result) == null ? void 0 : Ye.byteLength) !== void 0)
                try {
                    const nt = (We = et.target) == null ? void 0 : We.result
                      , ct = new Uint8Array(nt);
                    ct && rt && await Se(ct, rt, je, Xe)
                } catch (nt) {
                    console.error("Failed to read file", nt)
                }
        }
        , [".png", ".jpg"], !0)
    }
      , Ze = () => {
        const et = Object.entries((V == null ? void 0 : V.availableThumbnailUrls) ?? {}).map( ([it,at]) => ({
            src: at,
            id: it
        }));
        return et.some(it => it.id === J) ? ue && (ue != null && ue.url) && $e ? [...et, {
            id: ue.url,
            src: ue.url
        }] : et : [...et, {
            id: J,
            src: J
        }]
    }
    ;
    return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsxs(Section, {
            subsection: !0,
            split: !0,
            trimY: !0,
            children: [jsxRuntimeExports.jsx(Heading, {
                variant: HEADING_VARIANT.FIELD_LABEL,
                children: t$1("general.experience-images")
            }), jsxRuntimeExports.jsx(Tooltip, {
                tip: t$1("general.select-image-for-experience"),
                placement: PLACEMENT.LEFT,
                children: jsxRuntimeExports.jsx(Icon, {
                    name: ICON_NAMES.INFO,
                    color: X.gray500
                })
            })]
        }), jsxRuntimeExports.jsx(Section, {
            subsection: !0,
            className: styles$j.galleryContainer,
            children: jsxRuntimeExports.jsx(ImageGallery, {
                picks: J ? [J] : [],
                onChange: we,
                images: Ze(),
                onAddNew: ue || xe || !IS_IMAGE_UPLOAD_ENABLED ? void 0 : Fe
            })
        }), jsxRuntimeExports.jsxs(DialogContent, {
            id: DIALOG_ID.UPLOAD_EXPERIENCE_IMAGE_INTRO,
            header: jsxRuntimeExports.jsxs(Space, {
                children: [jsxRuntimeExports.jsx(Icon, {
                    name: ICON_NAMES.UPLOAD
                }), t$1("general.community-guidelines")]
            }),
            variant: DIALOG_VARIANT.OVERLAY,
            footer: jsxRuntimeExports.jsxs(ButtonGroup, {
                fillWidth: !0,
                children: [jsxRuntimeExports.jsx(Button, {
                    fillWidth: !0,
                    variant: BUTTON_VARIANTS.SECONDARY,
                    type: BUTTON_TYPES$1.SUBMIT,
                    children: t$1("general.cancel")
                }), jsxRuntimeExports.jsx(Button, {
                    fillWidth: !0,
                    color: X.primary,
                    type: BUTTON_TYPES$1.SUBMIT,
                    onClick: qe,
                    children: t$1("general.ok")
                })]
            }),
            children: [jsxRuntimeExports.jsx(Heading, {
                variant: HEADING_VARIANT.SECONDARY_SUBHEADING,
                className: styles$j.introTitle,
                children: t$1("general.help-create-safe-environment")
            }), jsxRuntimeExports.jsxs("ul", {
                className: styles$j.tiles,
                children: [jsxRuntimeExports.jsxs("li", {
                    children: [jsxRuntimeExports.jsx(Icon, {
                        name: ICON_NAMES.PLAYERS
                    }), jsxRuntimeExports.jsxs(Trans, {
                        i18nKey: "general.make-sure-image-does-not-breach-our-guidelines",
                        children: ["Make sure your image does not breach our", jsxRuntimeExports.jsx("a", {
                            href: EA_COMMUNITY_GUIDELINES_URL,
                            target: "_blank",
                            children: "Community Guidelines"
                        })]
                    })]
                }), jsxRuntimeExports.jsxs("li", {
                    children: [jsxRuntimeExports.jsx(Icon, {
                        name: ICON_NAMES.SETTINGS
                    }), t$1("general.image-guidelines-size", {
                        fileSize: "78kb",
                        dimensions: "352x248"
                    }), "."]
                }), jsxRuntimeExports.jsxs("li", {
                    children: [jsxRuntimeExports.jsx(Icon, {
                        name: ICON_NAMES.SAVE
                    }), t$1("general.image-guidelines-format")]
                })]
            })]
        }), jsxRuntimeExports.jsx(DialogContent, {
            id: DIALOG_ID.UPLOAD_EXPERIENCE_IMAGE_ERROR,
            header: jsxRuntimeExports.jsxs(Space, {
                children: [jsxRuntimeExports.jsx(Icon, {
                    name: ICON_NAMES.WARNING
                }), t$1("general.warning")]
            }),
            footer: jsxRuntimeExports.jsx(ButtonGroup, {
                fillWidth: !0,
                children: jsxRuntimeExports.jsx(Button, {
                    fillWidth: !0,
                    color: X.primary,
                    type: BUTTON_TYPES$1.SUBMIT,
                    onClick: ze,
                    children: t$1("general.ok")
                })
            }),
            onClose: ze,
            children: jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                children: [Ne.length ? jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                    children: [jsxRuntimeExports.jsxs("p", {
                        children: [t$1("general.file-cannot-upload"), ":"]
                    }), jsxRuntimeExports.jsx("ul", {
                        children: Ne.map(et => jsxRuntimeExports.jsx("li", {
                            children: et
                        }, et))
                    }), jsxRuntimeExports.jsx("p", {
                        children: t$1("general.thumbnail-failed-try-again")
                    })]
                }) : null, ke.length ? jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                    children: [jsxRuntimeExports.jsx("p", {
                        children: jsxRuntimeExports.jsxs(Trans, {
                            i18nKey: "general.file-uploaded-does-not-follow-our-guidelines",
                            children: ["The file you uploaded does not follow our", " ", jsxRuntimeExports.jsx("a", {
                                href: EA_COMMUNITY_GUIDELINES_URL,
                                target: "_blank",
                                children: "Community Guidelines"
                            }), "."]
                        })
                    }), jsxRuntimeExports.jsx("p", {
                        children: t$1("general.try-again-or-use-pre-made-thumbnails")
                    })]
                }) : null, jsxRuntimeExports.jsx("ul", {
                    children: ke.length ? jsxRuntimeExports.jsxs("li", {
                        children: [jsxRuntimeExports.jsx("strong", {
                            children: "(DEV-ONLY)"
                        }), " Rejection Reason(s):", jsxRuntimeExports.jsx("ul", {
                            children: ke.map(et => jsxRuntimeExports.jsx("li", {
                                children: et
                            }, et))
                        })]
                    }) : null
                })]
            })
        }), Ie ? jsxRuntimeExports.jsx(LoadingSpinner, {
            statusText: t$1("experience.uploading-image")
        }) : null, ye ? jsxRuntimeExports.jsx(LoadingSpinner, {
            statusText: t$1("experience.validating-image")
        }) : null]
    })
}
  , imageFrame = "_imageFrame_128j6_1"
  , img = "_img_128j6_12"
  , gameLabel = "_gameLabel_128j6_17"
  , iconGroup$1 = "_iconGroup_128j6_23"
  , icons = "_icons_128j6_28"
  , image$1 = "_image_128j6_1"
  , container = "_container_128j6_44"
  , section = "_section_128j6_44"
  , countContainer = "_countContainer_128j6_49"
  , styles$i = {
    imageFrame,
    img,
    gameLabel,
    iconGroup: iconGroup$1,
    icons,
    image: image$1,
    container,
    section,
    countContainer
}
  , AssetTagDetails = ({teamIndexes: V, tagId: X, itemType: J, isDisabled: ne, category: ue, countData: ce}) => {
    var mt;
    const {t: me} = useTranslation()
      , {blueprint: ge} = reactExports.useContext(BlueprintContext)
      , {colors: Te} = reactExports.useContext(ThemeContext)
      , [_e,Se] = useAtom(mutatorsAtom)
      , [Ie,ye] = useAtom(restrictedAssetTagsAtom)
      , $e = useAtomValue(numberOfTeamsAtom)
      , Ne = Te.tertiary
      , ve = useAtomValue(currentTeamsBeingEditedAtom);
    if (!ge)
        return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
    const {webImageMedium: ke, translationIds: xe, isProgressionLocked: we, parentCategories: Fe, name: je} = ge.assetTags.tags[X] ?? {}
      , Xe = X in Ie ? getAssetTagValue(Ie[X], V == null ? void 0 : V[0]) : !0
      , ze = ((mt = ge.assetTags.categories[RESTRICTION_PAGE_CATEGORY.CHARACTERS]) == null ? void 0 : mt.childrenTags) ?? []
      , qe = Fe == null ? void 0 : Fe.find(lt => {
        var Qe;
        return (Qe = ge.assetTags.categories.Classes.childrenTags) == null ? void 0 : Qe.includes(lt)
    }
    )
      , Ze = qe && ge.assetTags.categories[qe]
      , et = Ze && Ze.name === ALL_CLASS_ASSET_TAG_NAME
      , it = Fe && getSubCategory({
        mainCategory: ue,
        allCategories: ge.assetTags.categories,
        itemCategoryIds: Fe
    })
      , at = it ? ge.assetTags.categories[it] : void 0
      , rt = ASSET_CATEGORY_FALLBACK_IMG_MAP.get((at == null ? void 0 : at.name) ?? "") ?? supplyCrateImg
      , ft = new Set;
    ze.forEach(lt => {
        var Gt;
        const Qe = ge.assetTags.tags[lt]
          , gt = Qe == null ? void 0 : Qe.icon
          , Nt = Qe && qe && ((Gt = Qe.parentCategories) == null ? void 0 : Gt.includes(qe));
        return gt && (et || Nt) && ft.add(gt),
        Nt
    }
    );
    const St = common_utils.concatOptionalName(me(xe == null ? void 0 : xe.name), xe.model && me(xe.model))
      , Ye = ce && tagNameToMutatorName(je)
      , We = Ye ? Number(getMutatorValue(_e[Ye], ge.mutators[Ye].defaultValue, V == null ? void 0 : V[0])) : 0
      , nt = ce ? ce.max - ce.budgetUsed.reduce( (lt, Qe) => Qe + lt) : 0
      , ct = lt => {
        ye(getPatchedAssetTagValue({
            newValue: lt,
            assetTagsState: Ie,
            assetTagId: X,
            numberOfTeams: $e,
            teamIndexes: V
        }))
    }
      , Et = lt => {
        Ye && Se(getPatchedMutatorValue({
            newValue: lt,
            mutatorsState: _e,
            mutatorId: Ye,
            mutatorMeta: ge.mutators[Ye],
            numberOfTeams: $e,
            teamIndexes: ve
        }))
    }
      , Ke = lt => {
        "src"in lt.target && (lt.target.src = rt)
    }
    ;
    return jsxRuntimeExports.jsxs("div", {
        "data-testid": X,
        className: styles$i.container,
        style: {
            "--color": Ne
        },
        children: [jsxRuntimeExports.jsxs("div", {
            className: styles$i.imageFrame,
            children: [jsxRuntimeExports.jsx("img", {
                className: styles$i.img,
                src: ke || rt,
                alt: St,
                onError: Ke
            }), jsxRuntimeExports.jsxs("div", {
                className: common_utils.classNames(styles$i.icons, styles$i.iconGroup),
                children: [we && jsxRuntimeExports.jsx(Icon, {
                    name: ICON_NAMES.LOCKED,
                    variant: ICON_VARIANTS.CIRCLE
                }), [...ft].map(lt => jsxRuntimeExports.jsx(Icon, {
                    src: lt,
                    variant: ICON_VARIANTS.CIRCLE
                }, lt))]
            })]
        }), jsxRuntimeExports.jsxs(Section, {
            split: !0,
            className: styles$i.section,
            children: [jsxRuntimeExports.jsxs("div", {
                children: [jsxRuntimeExports.jsx(Heading, {
                    children: St
                }), at && jsxRuntimeExports.jsx(Heading, {
                    variant: HEADING_VARIANT.SUBHEADING,
                    children: me(at == null ? void 0 : at.translationIds.name)
                })]
            }), jsxRuntimeExports.jsx("div", {
                className: common_utils.classNames(ce && styles$i.countContainer),
                children: ce ? jsxRuntimeExports.jsx(Incrementor, {
                    count: We,
                    labels: {
                        increment: "Increment",
                        decrement: "Decrement",
                        count: "Count"
                    },
                    min: 0,
                    max: nt + We,
                    onChange: Et
                }) : jsxRuntimeExports.jsx(Checkbox, {
                    checked: Xe,
                    onChange: ct,
                    disabled: ne
                })
            })]
        }), we && jsxRuntimeExports.jsxs(Section, {
            className: styles$i.section,
            children: [jsxRuntimeExports.jsxs(Heading, {
                variant: HEADING_VARIANT.SUBHEADING,
                children: [jsxRuntimeExports.jsx(Icon, {
                    name: ICON_NAMES.LOCKED,
                    variant: ICON_VARIANTS.CIRCLE
                }), me("general.requires-progress")]
            }), jsxRuntimeExports.jsx(Paragraph, {
                children: me("editor.item-details.descriptions.locked", {
                    itemType: me(`editor.item-types.${J}`)
                })
            })]
        }), Ze && jsxRuntimeExports.jsxs(Section, {
            className: styles$i.section,
            children: [jsxRuntimeExports.jsxs(Heading, {
                variant: HEADING_VARIANT.SUBHEADING,
                children: [jsxRuntimeExports.jsx("div", {
                    className: styles$i.iconGroup,
                    children: [...ft].map(lt => jsxRuntimeExports.jsx(Icon, {
                        variant: ICON_VARIANTS.CIRCLE,
                        src: lt
                    }, lt))
                }), me(Ze.translationIds.name)]
            }), jsxRuntimeExports.jsx(Paragraph, {
                children: me(`editor.item-details.descriptions.${Ze.name}`, {
                    itemType: me(`editor.item-types.${J}`)
                })
            })]
        }), xe.description && jsxRuntimeExports.jsxs(Section, {
            className: styles$i.section,
            children: [jsxRuntimeExports.jsx(Heading, {
                variant: HEADING_VARIANT.SUBHEADING,
                children: me("general.description")
            }), jsxRuntimeExports.jsx(Paragraph, {
                children: me(xe.description)
            })]
        })]
    })
}
  , itemTallyBar = "_itemTallyBar_1l8iu_1"
  , teamItemTally = "_teamItemTally_1l8iu_12"
  , teamOne = "_teamOne_1l8iu_17"
  , teamTwo = "_teamTwo_1l8iu_20"
  , budgetContainer = "_budgetContainer_1l8iu_24"
  , budgetUsed = "_budgetUsed_1l8iu_37"
  , overBudget = "_overBudget_1l8iu_42"
  , styles$h = {
    itemTallyBar,
    teamItemTally,
    teamOne,
    teamTwo,
    budgetContainer,
    budgetUsed,
    overBudget
}
  , TeamBudgetBar = ({teamBudget: V, overBudgetTip: X, max: J, remainingBudget: ne}) => {
    const {colors: ue} = reactExports.useContext(ThemeContext)
      , me = J - ne > J;
    return jsxRuntimeExports.jsxs("div", {
        className: styles$h.itemTallyBar,
        children: [jsxRuntimeExports.jsx("span", {
            className: styles$h.tallyTeamLabel,
            children: V[0].label
        }), jsxRuntimeExports.jsx("span", {
            className: common_utils.classNames(styles$h.teamItemTally, styles$h.teamOne),
            children: V[0].budget
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$h.budgetContainer,
            children: [jsxRuntimeExports.jsxs("span", {
                children: [jsxRuntimeExports.jsx("span", {
                    className: common_utils.classNames(styles$h.budgetUsed, me && styles$h.overBudget),
                    children: J - ne
                }), "/", J]
            }), me && jsxRuntimeExports.jsx(Tooltip, {
                tip: X,
                placement: PLACEMENT.BOTTOM,
                children: jsxRuntimeExports.jsx(Icon, {
                    name: ICON_NAMES.INFO,
                    color: ue.white
                })
            })]
        }), jsxRuntimeExports.jsx("span", {
            className: common_utils.classNames(styles$h.teamItemTally, styles$h.teamTwo),
            children: V[1].budget
        }), jsxRuntimeExports.jsx("span", {
            className: styles$h.tallyTeamLabel,
            children: V[1].label
        })]
    })
}
  , divider = "_divider_1m7i7_1"
  , team1Only = "_team1Only_1m7i7_15"
  , team2Only = "_team2Only_1m7i7_21"
  , singleTeam = "_singleTeam_1m7i7_27"
  , linkToggle = "_linkToggle_1m7i7_35"
  , filterContainer = "_filterContainer_1m7i7_49"
  , filterContent = "_filterContent_1m7i7_53"
  , filterHeading = "_filterHeading_1m7i7_62"
  , filterList = "_filterList_1m7i7_72"
  , filterGrid = "_filterGrid_1m7i7_79"
  , filterItem = "_filterItem_1m7i7_85"
  , selected$1 = "_selected_1m7i7_91"
  , listItem$2 = "_listItem_1m7i7_95"
  , filterLabel = "_filterLabel_1m7i7_108"
  , teams = "_teams_1m7i7_113"
  , team = "_team_1m7i7_15"
  , iconGroup = "_iconGroup_1m7i7_124"
  , styles$g = {
    divider,
    team1Only,
    team2Only,
    singleTeam,
    linkToggle,
    filterContainer,
    filterContent,
    filterHeading,
    filterList,
    filterGrid,
    filterItem,
    selected: selected$1,
    listItem: listItem$2,
    filterLabel,
    teams,
    team,
    iconGroup
}
  , RestrictionPage = ({category: V, itemType: X, countData: J}) => {
    var Ht, Kt;
    const {t: ne} = useTranslation()
      , ue = reactExports.useRef(null)
      , ce = useAtomValue(isOwnerAtom)
      , me = useAtomValue(currentTeamsBeingEditedAtom)
      , {blueprint: ge} = reactExports.useContext(BlueprintContext)
      , [Te,_e] = useAtom(mutatorsAtom)
      , [Se,Ie] = useAtom(restrictedAssetTagsAtom)
      , ye = useAtomValue(numberOfTeamsAtom)
      , [$e,Ne] = reactExports.useState(!1)
      , ve = ((Ht = ge == null ? void 0 : ge.assetTags.categories[V]) == null ? void 0 : Ht.leafTags) ?? []
      , [ke,xe] = reactExports.useState()
      , [we,Fe] = reactExports.useState(new Set)
      , [je,Xe] = reactExports.useState()
      , [ze,qe] = reactExports.useState()
      , {open: Ze} = useDialog(DIALOG_ID.UNLOCKED_ITEM_DISABLE_WARNING)
      , {open: et} = useDialog(DIALOG_ID.LOCKED_ITEM_DISABLE_WARNING)
      , {open: it} = useOffCanvas(DIALOG_ID.ASSET_TAG_INFO)
      , at = J ? J.max - J.budgetUsed.reduce( (Ot, kt) => kt + Ot, 0) : 0
      , rt = ve.flat().reduce( (Ot, kt) => {
        const Xt = ge == null ? void 0 : ge.assetTags.tags[kt]
          , vt = ge == null ? void 0 : ge.assetTags.categories.Classes;
        if (!Xt || !vt)
            return Ot;
        if (Xt.parentCategories) {
            const Jt = getSubCategory({
                mainCategory: V,
                allCategories: ge.assetTags.categories,
                itemCategoryIds: Xt.parentCategories
            });
            Jt && Ot.category.add(Jt)
        }
        return Xt.isProgressionLocked && (Ot.progression = !0),
        Ot
    }
    , {
        category: new Set,
        classification: new Set,
        progression: !1
    })
      , ft = ve.reduce( (Ot, kt) => {
        var Jt;
        const {parentCategories: Xt} = ((Jt = ge == null ? void 0 : ge.assetTags) == null ? void 0 : Jt.tags[kt]) ?? {};
        if (!Xt)
            return Ot;
        const vt = getSubCategory({
            mainCategory: V,
            allCategories: (ge == null ? void 0 : ge.assetTags.categories) ?? {},
            itemCategoryIds: Xt
        });
        return vt && (vt in Ot ? Ot[vt].includes(kt) || Ot[vt].push(kt) : Ot[vt] = [kt]),
        Ot
    }
    , {})
      , St = J && ve.reduce( (Ot, kt) => {
        const Xt = J.assetTagToCountMutatorMap.get(kt);
        if (Xt && Xt in Te) {
            const vt = Te[Xt];
            (me == null ? void 0 : me[0]) !== void 0 && vt !== void 0 && vt instanceof Map && vt.get(me == null ? void 0 : me[0]) !== void 0 ? Ot.set(kt, Number(vt.get(me == null ? void 0 : me[0]))) : vt !== void 0 && Ot.set(kt, +vt)
        } else
            Ot.set(kt, 0);
        return Ot
    }
    , new Map)
      , {selectedIds: Ye, totalSelectedAndUnlocked: We} = getSelectionTabulations(ve, Se, ((Kt = ge == null ? void 0 : ge.assetTags) == null ? void 0 : Kt.tags) ?? {}, me == null ? void 0 : me[0], J && St)
      , nt = Ot => () => {
        if (!ge)
            return;
        const {isProgressionLocked: kt} = ge.assetTags.tags[Ot];
        ce && (kt ? et() : Ze())
    }
      , ct = Ot => () => {
        if (!ge)
            return;
        const {selectedIds: kt, totalSelectedAndUnlocked: Xt} = getSelectionTabulations(ve, Se, ge.assetTags.tags, me == null ? void 0 : me[0])
          , {isLastUnlocked: vt, isAllUnselected: Jt} = getTagDisabledState(Ot, Xt, ge.assetTags.tags[Ot].isProgressionLocked, kt);
        qe({
            tagId: Ot,
            teamIndexes: me,
            isDisabled: vt || Jt && J === void 0 || !ce,
            itemType: X,
            category: V
        }),
        it()
    }
      , Et = Ot => kt => {
        Ie(getPatchedAssetTagValue({
            newValue: kt,
            assetTagsState: Se,
            assetTagId: Ot,
            numberOfTeams: ye,
            teamIndexes: me
        }))
    }
      , Ke = Ot => kt => {
        "src"in kt.target && (kt.target.src = ASSET_CATEGORY_FALLBACK_IMG_MAP.get(Ot ?? "") ?? supplyCrateImg)
    }
      , mt = Object.entries(ft).reduce( (Ot, [kt,Xt]) => {
        const vt = ge == null ? void 0 : ge.assetTags.categories[kt];
        if ((we.has(kt) || !we.size) && ge) {
            const Jt = Xt.reduce( (nn, tn) => {
                const mn = getTeamsGroupedByMutatorOrAssetTagValue({
                    assetTag: Se[tn],
                    teamIndexesToCheck: me ?? []
                })
                  , dn = me !== void 0 && mn.length > 1
                  , {webImageMedium: Qt, translationIds: on, isProgressionLocked: zt, image: $t, name: Ut} = ge.assetTags.tags[tn]
                  , {isLastUnlocked: An, isAllUnselected: yt} = getTagDisabledState(tn, We, zt, Ye);
                if (je === void 0 || je === !1 && !zt || je && zt) {
                    const Dt = An || yt && J === void 0 || !ce
                      , Bt = common_utils.concatOptionalName(ne(on.name), on.model && ne(on.model)) ?? ""
                      , Wt = Bt.trim() ? Bt : Ut
                      , ut = Qt || $t || (ASSET_CATEGORY_FALLBACK_IMG_MAP.get((vt == null ? void 0 : vt.name) ?? "") ?? supplyCrateImg);
                    nn.push({
                        id: tn,
                        isDisabled: Dt,
                        isConflicted: dn,
                        assetTile: jsxRuntimeExports.jsx("div", {
                            "data-id": tn,
                            "data-name": Ut,
                            "data-category": vt == null ? void 0 : vt.name,
                            children: jsxRuntimeExports.jsx(AssetTile, {
                                image: ut,
                                disabled: Dt,
                                name: Wt,
                                unavailable: dn,
                                onImageLoadFailed: Ke(vt == null ? void 0 : vt.name),
                                isSelected: getAssetTagValue(Se[tn], me == null ? void 0 : me[0]) ?? !0,
                                onDisabledClick: nt(tn),
                                onInfoClick: ct(tn),
                                onChange: Et(tn),
                                ...zt && {
                                    icons: [{
                                        name: ICON_NAMES.LOCKED,
                                        tooltip: ne("general.requires-progress")
                                    }]
                                }
                            })
                        })
                    })
                }
                return nn
            }
            , [])
              , Ct = vt == null ? void 0 : vt.translationIds.name
              , Mt = Ct ? ne(Ct) : vt == null ? void 0 : vt.name;
            Jt.length && Ot.push({
                header: Mt,
                id: kt,
                items: Jt
            })
        }
        return Ot
    }
    , []).sort( ({header: Ot}, {header: kt}) => {
        const Xt = Ot == null ? void 0 : Ot.toString()
          , vt = kt == null ? void 0 : kt.toString();
        if (vt) {
            if (!Xt)
                return -1
        } else
            return 1;
        return Xt.localeCompare(vt)
    }
    )
      , lt = Ot => (kt, Xt, vt) => {
        const Jt = Xt.reduce( (Ct, Mt) => getPatchedAssetTagValue({
            newValue: vt,
            assetTagsState: Ct,
            assetTagId: Mt,
            numberOfTeams: ye,
            teamIndexes: Ot
        }), Se);
        Ie({
            ...Jt
        })
    }
      , Qe = () => {
        var Ot;
        Ne(!$e),
        xe((Ot = ue.current) == null ? void 0 : Ot.offsetWidth)
    }
      , gt = Ot => () => {
        we.has(Ot) ? we.delete(Ot) : we.add(Ot),
        Fe(new Set(Array.from(we)))
    }
      , Nt = Ot => () => {
        Xe(Ot)
    }
      , Gt = Ot => kt => {
        const Xt = Object.entries(kt).reduce( (vt, [Jt,Ct]) => {
            var nn;
            const Mt = (nn = J == null ? void 0 : J.assetTagToCountMutatorMap) == null ? void 0 : nn.get(Jt);
            return Mt && Ct !== void 0 && (ge == null ? void 0 : ge.mutators[Mt]) !== void 0 ? getPatchedMutatorValue({
                newValue: Ct,
                mutatorsState: vt,
                mutatorId: Mt,
                mutatorMeta: ge.mutators[Mt],
                numberOfTeams: ye,
                teamIndexes: Ot
            }) : vt
        }
        , Te);
        _e({
            ...Xt
        })
    }
    ;
    return jsxRuntimeExports.jsxs(PageWrapper, {
        children: [jsxRuntimeExports.jsxs(TeamSelect, {
            children: [jsxRuntimeExports.jsx("div", {
                ref: ue,
                children: jsxRuntimeExports.jsx(Menu, {
                    isOpen: $e,
                    onToggle: Qe,
                    label: jsxRuntimeExports.jsx(Button, {
                        variant: $e ? BUTTON_VARIANTS.PRIMARY : BUTTON_VARIANTS.SECONDARY,
                        children: ne("general.filter")
                    }),
                    children: jsxRuntimeExports.jsx("div", {
                        className: common_utils.classNames(styles$g.filterContainer),
                        style: {
                            width: `${ke}px`
                        },
                        children: jsxRuntimeExports.jsxs("div", {
                            className: styles$g.filterContent,
                            children: [rt.category.size ? jsxRuntimeExports.jsxs("div", {
                                className: styles$g.filterList,
                                children: [jsxRuntimeExports.jsx("div", {
                                    className: styles$g.filterHeading,
                                    children: ne("editor.filter.by-type", {
                                        itemType: ne(`editor.item-types.${X}`)
                                    })
                                }), jsxRuntimeExports.jsx("div", {
                                    className: styles$g.filterGrid,
                                    children: Array.from(rt.category).map(Ot => {
                                        const kt = ge == null ? void 0 : ge.assetTags.categories[Ot];
                                        if (!kt)
                                            return;
                                        const Xt = common_utils.concatOptionalName(ne(kt.translationIds.name), kt.translationIds.model && ne(kt.translationIds.model)) ?? ""
                                          , vt = Xt.trim() ? Xt : kt.name;
                                        return jsxRuntimeExports.jsx("div", {
                                            className: common_utils.classNames(styles$g.filterItem, we.has(Ot) && styles$g.selected),
                                            children: jsxRuntimeExports.jsx(Checkbox, {
                                                tabIndex: -1,
                                                checked: we.has(Ot),
                                                labelClassName: styles$g.filterLabel,
                                                onClick: gt(Ot),
                                                children: jsxRuntimeExports.jsx("span", {
                                                    className: common_utils.classNames(styles$g.listItem),
                                                    children: vt
                                                })
                                            }, Ot)
                                        })
                                    }
                                    )
                                })]
                            }) : null, rt.progression && jsxRuntimeExports.jsxs("div", {
                                className: styles$g.filterList,
                                children: [jsxRuntimeExports.jsx("div", {
                                    className: styles$g.filterHeading,
                                    children: ne("editor.filter.by-progression")
                                }), jsxRuntimeExports.jsxs("div", {
                                    className: styles$g.filterGrid,
                                    children: [jsxRuntimeExports.jsx("div", {
                                        className: common_utils.classNames(styles$g.filterItem, je === void 0 && styles$g.selected),
                                        children: jsxRuntimeExports.jsx(Checkbox, {
                                            tabIndex: -1,
                                            checked: je === void 0,
                                            onChange: Nt(void 0),
                                            labelClassName: styles$g.filterLabel,
                                            children: jsxRuntimeExports.jsx("div", {
                                                className: common_utils.classNames(styles$g.listItem),
                                                children: ne("general.any")
                                            })
                                        })
                                    }), jsxRuntimeExports.jsx("div", {
                                        className: common_utils.classNames(styles$g.filterItem, je && styles$g.selected),
                                        children: jsxRuntimeExports.jsx(Checkbox, {
                                            tabIndex: -1,
                                            checked: je,
                                            onChange: Nt(!0),
                                            labelClassName: styles$g.filterLabel,
                                            children: jsxRuntimeExports.jsx("span", {
                                                className: common_utils.classNames(styles$g.listItem),
                                                children: ne("general.locked")
                                            })
                                        })
                                    }), jsxRuntimeExports.jsx("div", {
                                        className: common_utils.classNames(styles$g.filterItem, je === !1 && styles$g.selected),
                                        children: jsxRuntimeExports.jsx(Checkbox, {
                                            tabIndex: -1,
                                            checked: je === !1,
                                            onChange: Nt(!1),
                                            labelClassName: styles$g.filterLabel,
                                            children: jsxRuntimeExports.jsx("div", {
                                                className: common_utils.classNames(styles$g.listItem),
                                                children: ne("general.unlocked")
                                            })
                                        })
                                    })]
                                })]
                            })]
                        })
                    })
                })
            }), J && jsxRuntimeExports.jsx(TeamBudgetBar, {
                remainingBudget: at,
                max: J.max,
                teamBudget: [{
                    label: ne("general.team-1"),
                    budget: J.budgetUsed[0]
                }, {
                    label: ne("general.team-2"),
                    budget: J.budgetUsed[1]
                }],
                overBudgetTip: ne("editor.max-vehicles-exceeded")
            }), jsxRuntimeExports.jsx("div", {
                className: styles$g.teams,
                children: jsxRuntimeExports.jsx("div", {
                    className: common_utils.classNames(styles$g.team, styles$g.notPerTeam),
                    children: mt.length ? jsxRuntimeExports.jsx(AssetTileSections, {
                        onChange: lt(me),
                        disabled: !ce,
                        countData: J && St && {
                            labels: {
                                decrement: ne("general.decrement-count"),
                                increment: ne("general.increment-count"),
                                count: ne("general.count")
                            },
                            countMapping: St,
                            budget: at,
                            onCountsChange: Gt(me)
                        },
                        selectedIds: Ye,
                        sections: mt
                    }) : null
                })
            })]
        }), jsxRuntimeExports.jsx(DialogContent, {
            id: DIALOG_ID.LOCKED_ITEM_DISABLE_WARNING,
            header: ne("general.warning"),
            footer: jsxRuntimeExports.jsx(Button, {
                variant: BUTTON_VARIANTS.SECONDARY,
                type: BUTTON_TYPES.SUBMIT,
                fillWidth: !0,
                children: ne("general.ok")
            }),
            children: ne("editor.locked-item-disable-warning")
        }), jsxRuntimeExports.jsx(DialogContent, {
            id: DIALOG_ID.UNLOCKED_ITEM_DISABLE_WARNING,
            header: ne("general.warning"),
            footer: jsxRuntimeExports.jsx(Button, {
                variant: BUTTON_VARIANTS.SECONDARY,
                type: BUTTON_TYPES.SUBMIT,
                fillWidth: !0,
                children: ne("general.ok")
            }),
            children: ne("editor.unlocked-item-disable-warning")
        }), jsxRuntimeExports.jsx(OffCanvasContent, {
            id: DIALOG_ID.ASSET_TAG_INFO,
            header: ne("editor.item-details.header", {
                itemType: ne(`editor.item-types.${X}`)
            }),
            children: ze && jsxRuntimeExports.jsx(AssetTagDetails, {
                ...ze,
                countData: J
            })
        })]
    })
}
;
async function fetchHelpMarkdown(V) {
    if (!V)
        throw new Error("Missing block type!");
    const J = await (await fetch(getAssetPath(`/assets/blockly/help/${V}.md`))).text();
    if (J.startsWith("<"))
        throw new Error("Help content was not found for this block.");
    return J
}
const useHelpTextQuery = (V, X=!0) => {
    const {data: J, isFetching: ne, error: ue} = useQuery({
        queryKey: [QUERY_KEY.HELP_TEXT, V],
        queryFn: () => fetchHelpMarkdown(V),
        enabled: !!V && X,
        refetchOnWindowFocus: !1,
        staleTime: MS_30_MINUTES
    });
    return {
        helpText: J ?? "",
        isFetching: ne,
        error: ue
    }
}
;
function ok$1() {}
function unreachable() {}
function stringify$1(V, X) {
    const J = {};
    return (V[V.length - 1] === "" ? [...V, ""] : V).join((J.padRight ? " " : "") + "," + (J.padLeft === !1 ? "" : " ")).trim()
}
const nameRe = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u
  , nameReJsx = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u
  , emptyOptions$2 = {};
function name(V, X) {
    return (emptyOptions$2.jsx ? nameReJsx : nameRe).test(V)
}
const re = /[ \t\n\f\r]/g;
function whitespace(V) {
    return typeof V == "object" ? V.type === "text" ? empty$1(V.value) : !1 : empty$1(V)
}
function empty$1(V) {
    return V.replace(re, "") === ""
}
class Schema {
    constructor(X, J, ne) {
        this.property = X,
        this.normal = J,
        ne && (this.space = ne)
    }
}
Schema.prototype.property = {};
Schema.prototype.normal = {};
Schema.prototype.space = null;
function merge$1(V, X) {
    const J = {}
      , ne = {};
    let ue = -1;
    for (; ++ue < V.length; )
        Object.assign(J, V[ue].property),
        Object.assign(ne, V[ue].normal);
    return new Schema(J,ne,X)
}
function normalize$1(V) {
    return V.toLowerCase()
}
class Info {
    constructor(X, J) {
        this.property = X,
        this.attribute = J
    }
}
Info.prototype.space = null;
Info.prototype.boolean = !1;
Info.prototype.booleanish = !1;
Info.prototype.overloadedBoolean = !1;
Info.prototype.number = !1;
Info.prototype.commaSeparated = !1;
Info.prototype.spaceSeparated = !1;
Info.prototype.commaOrSpaceSeparated = !1;
Info.prototype.mustUseProperty = !1;
Info.prototype.defined = !1;
let powers = 0;
const boolean = increment()
  , booleanish = increment()
  , overloadedBoolean = increment()
  , number = increment()
  , spaceSeparated = increment()
  , commaSeparated = increment()
  , commaOrSpaceSeparated = increment();
function increment() {
    return 2 ** ++powers
}
const types = Object.freeze(Object.defineProperty({
    __proto__: null,
    boolean,
    booleanish,
    commaOrSpaceSeparated,
    commaSeparated,
    number,
    overloadedBoolean,
    spaceSeparated
}, Symbol.toStringTag, {
    value: "Module"
}))
  , checks = Object.keys(types);
class DefinedInfo extends Info {
    constructor(X, J, ne, ue) {
        let ce = -1;
        if (super(X, J),
        mark(this, "space", ue),
        typeof ne == "number")
            for (; ++ce < checks.length; ) {
                const me = checks[ce];
                mark(this, checks[ce], (ne & types[me]) === types[me])
            }
    }
}
DefinedInfo.prototype.defined = !0;
function mark(V, X, J) {
    J && (V[X] = J)
}
const own$4 = {}.hasOwnProperty;
function create$1(V) {
    const X = {}
      , J = {};
    let ne;
    for (ne in V.properties)
        if (own$4.call(V.properties, ne)) {
            const ue = V.properties[ne]
              , ce = new DefinedInfo(ne,V.transform(V.attributes || {}, ne),ue,V.space);
            V.mustUseProperty && V.mustUseProperty.includes(ne) && (ce.mustUseProperty = !0),
            X[ne] = ce,
            J[normalize$1(ne)] = ne,
            J[normalize$1(ce.attribute)] = ne
        }
    return new Schema(X,J,V.space)
}
const xlink = create$1({
    space: "xlink",
    transform(V, X) {
        return "xlink:" + X.slice(5).toLowerCase()
    },
    properties: {
        xLinkActuate: null,
        xLinkArcRole: null,
        xLinkHref: null,
        xLinkRole: null,
        xLinkShow: null,
        xLinkTitle: null,
        xLinkType: null
    }
})
  , xml = create$1({
    space: "xml",
    transform(V, X) {
        return "xml:" + X.slice(3).toLowerCase()
    },
    properties: {
        xmlLang: null,
        xmlBase: null,
        xmlSpace: null
    }
});
function caseSensitiveTransform(V, X) {
    return X in V ? V[X] : X
}
function caseInsensitiveTransform(V, X) {
    return caseSensitiveTransform(V, X.toLowerCase())
}
const xmlns = create$1({
    space: "xmlns",
    attributes: {
        xmlnsxlink: "xmlns:xlink"
    },
    transform: caseInsensitiveTransform,
    properties: {
        xmlns: null,
        xmlnsXLink: null
    }
})
  , aria = create$1({
    transform(V, X) {
        return X === "role" ? X : "aria-" + X.slice(4).toLowerCase()
    },
    properties: {
        ariaActiveDescendant: null,
        ariaAtomic: booleanish,
        ariaAutoComplete: null,
        ariaBusy: booleanish,
        ariaChecked: booleanish,
        ariaColCount: number,
        ariaColIndex: number,
        ariaColSpan: number,
        ariaControls: spaceSeparated,
        ariaCurrent: null,
        ariaDescribedBy: spaceSeparated,
        ariaDetails: null,
        ariaDisabled: booleanish,
        ariaDropEffect: spaceSeparated,
        ariaErrorMessage: null,
        ariaExpanded: booleanish,
        ariaFlowTo: spaceSeparated,
        ariaGrabbed: booleanish,
        ariaHasPopup: null,
        ariaHidden: booleanish,
        ariaInvalid: null,
        ariaKeyShortcuts: null,
        ariaLabel: null,
        ariaLabelledBy: spaceSeparated,
        ariaLevel: number,
        ariaLive: null,
        ariaModal: booleanish,
        ariaMultiLine: booleanish,
        ariaMultiSelectable: booleanish,
        ariaOrientation: null,
        ariaOwns: spaceSeparated,
        ariaPlaceholder: null,
        ariaPosInSet: number,
        ariaPressed: booleanish,
        ariaReadOnly: booleanish,
        ariaRelevant: null,
        ariaRequired: booleanish,
        ariaRoleDescription: spaceSeparated,
        ariaRowCount: number,
        ariaRowIndex: number,
        ariaRowSpan: number,
        ariaSelected: booleanish,
        ariaSetSize: number,
        ariaSort: null,
        ariaValueMax: number,
        ariaValueMin: number,
        ariaValueNow: number,
        ariaValueText: null,
        role: null
    }
})
  , html$2 = create$1({
    space: "html",
    attributes: {
        acceptcharset: "accept-charset",
        classname: "class",
        htmlfor: "for",
        httpequiv: "http-equiv"
    },
    transform: caseInsensitiveTransform,
    mustUseProperty: ["checked", "multiple", "muted", "selected"],
    properties: {
        abbr: null,
        accept: commaSeparated,
        acceptCharset: spaceSeparated,
        accessKey: spaceSeparated,
        action: null,
        allow: null,
        allowFullScreen: boolean,
        allowPaymentRequest: boolean,
        allowUserMedia: boolean,
        alt: null,
        as: null,
        async: boolean,
        autoCapitalize: null,
        autoComplete: spaceSeparated,
        autoFocus: boolean,
        autoPlay: boolean,
        blocking: spaceSeparated,
        capture: null,
        charSet: null,
        checked: boolean,
        cite: null,
        className: spaceSeparated,
        cols: number,
        colSpan: null,
        content: null,
        contentEditable: booleanish,
        controls: boolean,
        controlsList: spaceSeparated,
        coords: number | commaSeparated,
        crossOrigin: null,
        data: null,
        dateTime: null,
        decoding: null,
        default: boolean,
        defer: boolean,
        dir: null,
        dirName: null,
        disabled: boolean,
        download: overloadedBoolean,
        draggable: booleanish,
        encType: null,
        enterKeyHint: null,
        fetchPriority: null,
        form: null,
        formAction: null,
        formEncType: null,
        formMethod: null,
        formNoValidate: boolean,
        formTarget: null,
        headers: spaceSeparated,
        height: number,
        hidden: boolean,
        high: number,
        href: null,
        hrefLang: null,
        htmlFor: spaceSeparated,
        httpEquiv: spaceSeparated,
        id: null,
        imageSizes: null,
        imageSrcSet: null,
        inert: boolean,
        inputMode: null,
        integrity: null,
        is: null,
        isMap: boolean,
        itemId: null,
        itemProp: spaceSeparated,
        itemRef: spaceSeparated,
        itemScope: boolean,
        itemType: spaceSeparated,
        kind: null,
        label: null,
        lang: null,
        language: null,
        list: null,
        loading: null,
        loop: boolean,
        low: number,
        manifest: null,
        max: null,
        maxLength: number,
        media: null,
        method: null,
        min: null,
        minLength: number,
        multiple: boolean,
        muted: boolean,
        name: null,
        nonce: null,
        noModule: boolean,
        noValidate: boolean,
        onAbort: null,
        onAfterPrint: null,
        onAuxClick: null,
        onBeforeMatch: null,
        onBeforePrint: null,
        onBeforeToggle: null,
        onBeforeUnload: null,
        onBlur: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onContextLost: null,
        onContextMenu: null,
        onContextRestored: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFormData: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLanguageChange: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadEnd: null,
        onLoadStart: null,
        onMessage: null,
        onMessageError: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRejectionHandled: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onScrollEnd: null,
        onSecurityPolicyViolation: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onSlotChange: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnhandledRejection: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onWheel: null,
        open: boolean,
        optimum: number,
        pattern: null,
        ping: spaceSeparated,
        placeholder: null,
        playsInline: boolean,
        popover: null,
        popoverTarget: null,
        popoverTargetAction: null,
        poster: null,
        preload: null,
        readOnly: boolean,
        referrerPolicy: null,
        rel: spaceSeparated,
        required: boolean,
        reversed: boolean,
        rows: number,
        rowSpan: number,
        sandbox: spaceSeparated,
        scope: null,
        scoped: boolean,
        seamless: boolean,
        selected: boolean,
        shadowRootClonable: boolean,
        shadowRootDelegatesFocus: boolean,
        shadowRootMode: null,
        shape: null,
        size: number,
        sizes: null,
        slot: null,
        span: number,
        spellCheck: booleanish,
        src: null,
        srcDoc: null,
        srcLang: null,
        srcSet: null,
        start: number,
        step: null,
        style: null,
        tabIndex: number,
        target: null,
        title: null,
        translate: null,
        type: null,
        typeMustMatch: boolean,
        useMap: null,
        value: booleanish,
        width: number,
        wrap: null,
        writingSuggestions: null,
        align: null,
        aLink: null,
        archive: spaceSeparated,
        axis: null,
        background: null,
        bgColor: null,
        border: number,
        borderColor: null,
        bottomMargin: number,
        cellPadding: null,
        cellSpacing: null,
        char: null,
        charOff: null,
        classId: null,
        clear: null,
        code: null,
        codeBase: null,
        codeType: null,
        color: null,
        compact: boolean,
        declare: boolean,
        event: null,
        face: null,
        frame: null,
        frameBorder: null,
        hSpace: number,
        leftMargin: number,
        link: null,
        longDesc: null,
        lowSrc: null,
        marginHeight: number,
        marginWidth: number,
        noResize: boolean,
        noHref: boolean,
        noShade: boolean,
        noWrap: boolean,
        object: null,
        profile: null,
        prompt: null,
        rev: null,
        rightMargin: number,
        rules: null,
        scheme: null,
        scrolling: booleanish,
        standby: null,
        summary: null,
        text: null,
        topMargin: number,
        valueType: null,
        version: null,
        vAlign: null,
        vLink: null,
        vSpace: number,
        allowTransparency: null,
        autoCorrect: null,
        autoSave: null,
        disablePictureInPicture: boolean,
        disableRemotePlayback: boolean,
        prefix: null,
        property: null,
        results: number,
        security: null,
        unselectable: null
    }
})
  , svg$1 = create$1({
    space: "svg",
    attributes: {
        accentHeight: "accent-height",
        alignmentBaseline: "alignment-baseline",
        arabicForm: "arabic-form",
        baselineShift: "baseline-shift",
        capHeight: "cap-height",
        className: "class",
        clipPath: "clip-path",
        clipRule: "clip-rule",
        colorInterpolation: "color-interpolation",
        colorInterpolationFilters: "color-interpolation-filters",
        colorProfile: "color-profile",
        colorRendering: "color-rendering",
        crossOrigin: "crossorigin",
        dataType: "datatype",
        dominantBaseline: "dominant-baseline",
        enableBackground: "enable-background",
        fillOpacity: "fill-opacity",
        fillRule: "fill-rule",
        floodColor: "flood-color",
        floodOpacity: "flood-opacity",
        fontFamily: "font-family",
        fontSize: "font-size",
        fontSizeAdjust: "font-size-adjust",
        fontStretch: "font-stretch",
        fontStyle: "font-style",
        fontVariant: "font-variant",
        fontWeight: "font-weight",
        glyphName: "glyph-name",
        glyphOrientationHorizontal: "glyph-orientation-horizontal",
        glyphOrientationVertical: "glyph-orientation-vertical",
        hrefLang: "hreflang",
        horizAdvX: "horiz-adv-x",
        horizOriginX: "horiz-origin-x",
        horizOriginY: "horiz-origin-y",
        imageRendering: "image-rendering",
        letterSpacing: "letter-spacing",
        lightingColor: "lighting-color",
        markerEnd: "marker-end",
        markerMid: "marker-mid",
        markerStart: "marker-start",
        navDown: "nav-down",
        navDownLeft: "nav-down-left",
        navDownRight: "nav-down-right",
        navLeft: "nav-left",
        navNext: "nav-next",
        navPrev: "nav-prev",
        navRight: "nav-right",
        navUp: "nav-up",
        navUpLeft: "nav-up-left",
        navUpRight: "nav-up-right",
        onAbort: "onabort",
        onActivate: "onactivate",
        onAfterPrint: "onafterprint",
        onBeforePrint: "onbeforeprint",
        onBegin: "onbegin",
        onCancel: "oncancel",
        onCanPlay: "oncanplay",
        onCanPlayThrough: "oncanplaythrough",
        onChange: "onchange",
        onClick: "onclick",
        onClose: "onclose",
        onCopy: "oncopy",
        onCueChange: "oncuechange",
        onCut: "oncut",
        onDblClick: "ondblclick",
        onDrag: "ondrag",
        onDragEnd: "ondragend",
        onDragEnter: "ondragenter",
        onDragExit: "ondragexit",
        onDragLeave: "ondragleave",
        onDragOver: "ondragover",
        onDragStart: "ondragstart",
        onDrop: "ondrop",
        onDurationChange: "ondurationchange",
        onEmptied: "onemptied",
        onEnd: "onend",
        onEnded: "onended",
        onError: "onerror",
        onFocus: "onfocus",
        onFocusIn: "onfocusin",
        onFocusOut: "onfocusout",
        onHashChange: "onhashchange",
        onInput: "oninput",
        onInvalid: "oninvalid",
        onKeyDown: "onkeydown",
        onKeyPress: "onkeypress",
        onKeyUp: "onkeyup",
        onLoad: "onload",
        onLoadedData: "onloadeddata",
        onLoadedMetadata: "onloadedmetadata",
        onLoadStart: "onloadstart",
        onMessage: "onmessage",
        onMouseDown: "onmousedown",
        onMouseEnter: "onmouseenter",
        onMouseLeave: "onmouseleave",
        onMouseMove: "onmousemove",
        onMouseOut: "onmouseout",
        onMouseOver: "onmouseover",
        onMouseUp: "onmouseup",
        onMouseWheel: "onmousewheel",
        onOffline: "onoffline",
        onOnline: "ononline",
        onPageHide: "onpagehide",
        onPageShow: "onpageshow",
        onPaste: "onpaste",
        onPause: "onpause",
        onPlay: "onplay",
        onPlaying: "onplaying",
        onPopState: "onpopstate",
        onProgress: "onprogress",
        onRateChange: "onratechange",
        onRepeat: "onrepeat",
        onReset: "onreset",
        onResize: "onresize",
        onScroll: "onscroll",
        onSeeked: "onseeked",
        onSeeking: "onseeking",
        onSelect: "onselect",
        onShow: "onshow",
        onStalled: "onstalled",
        onStorage: "onstorage",
        onSubmit: "onsubmit",
        onSuspend: "onsuspend",
        onTimeUpdate: "ontimeupdate",
        onToggle: "ontoggle",
        onUnload: "onunload",
        onVolumeChange: "onvolumechange",
        onWaiting: "onwaiting",
        onZoom: "onzoom",
        overlinePosition: "overline-position",
        overlineThickness: "overline-thickness",
        paintOrder: "paint-order",
        panose1: "panose-1",
        pointerEvents: "pointer-events",
        referrerPolicy: "referrerpolicy",
        renderingIntent: "rendering-intent",
        shapeRendering: "shape-rendering",
        stopColor: "stop-color",
        stopOpacity: "stop-opacity",
        strikethroughPosition: "strikethrough-position",
        strikethroughThickness: "strikethrough-thickness",
        strokeDashArray: "stroke-dasharray",
        strokeDashOffset: "stroke-dashoffset",
        strokeLineCap: "stroke-linecap",
        strokeLineJoin: "stroke-linejoin",
        strokeMiterLimit: "stroke-miterlimit",
        strokeOpacity: "stroke-opacity",
        strokeWidth: "stroke-width",
        tabIndex: "tabindex",
        textAnchor: "text-anchor",
        textDecoration: "text-decoration",
        textRendering: "text-rendering",
        transformOrigin: "transform-origin",
        typeOf: "typeof",
        underlinePosition: "underline-position",
        underlineThickness: "underline-thickness",
        unicodeBidi: "unicode-bidi",
        unicodeRange: "unicode-range",
        unitsPerEm: "units-per-em",
        vAlphabetic: "v-alphabetic",
        vHanging: "v-hanging",
        vIdeographic: "v-ideographic",
        vMathematical: "v-mathematical",
        vectorEffect: "vector-effect",
        vertAdvY: "vert-adv-y",
        vertOriginX: "vert-origin-x",
        vertOriginY: "vert-origin-y",
        wordSpacing: "word-spacing",
        writingMode: "writing-mode",
        xHeight: "x-height",
        playbackOrder: "playbackorder",
        timelineBegin: "timelinebegin"
    },
    transform: caseSensitiveTransform,
    properties: {
        about: commaOrSpaceSeparated,
        accentHeight: number,
        accumulate: null,
        additive: null,
        alignmentBaseline: null,
        alphabetic: number,
        amplitude: number,
        arabicForm: null,
        ascent: number,
        attributeName: null,
        attributeType: null,
        azimuth: number,
        bandwidth: null,
        baselineShift: null,
        baseFrequency: null,
        baseProfile: null,
        bbox: null,
        begin: null,
        bias: number,
        by: null,
        calcMode: null,
        capHeight: number,
        className: spaceSeparated,
        clip: null,
        clipPath: null,
        clipPathUnits: null,
        clipRule: null,
        color: null,
        colorInterpolation: null,
        colorInterpolationFilters: null,
        colorProfile: null,
        colorRendering: null,
        content: null,
        contentScriptType: null,
        contentStyleType: null,
        crossOrigin: null,
        cursor: null,
        cx: null,
        cy: null,
        d: null,
        dataType: null,
        defaultAction: null,
        descent: number,
        diffuseConstant: number,
        direction: null,
        display: null,
        dur: null,
        divisor: number,
        dominantBaseline: null,
        download: boolean,
        dx: null,
        dy: null,
        edgeMode: null,
        editable: null,
        elevation: number,
        enableBackground: null,
        end: null,
        event: null,
        exponent: number,
        externalResourcesRequired: null,
        fill: null,
        fillOpacity: number,
        fillRule: null,
        filter: null,
        filterRes: null,
        filterUnits: null,
        floodColor: null,
        floodOpacity: null,
        focusable: null,
        focusHighlight: null,
        fontFamily: null,
        fontSize: null,
        fontSizeAdjust: null,
        fontStretch: null,
        fontStyle: null,
        fontVariant: null,
        fontWeight: null,
        format: null,
        fr: null,
        from: null,
        fx: null,
        fy: null,
        g1: commaSeparated,
        g2: commaSeparated,
        glyphName: commaSeparated,
        glyphOrientationHorizontal: null,
        glyphOrientationVertical: null,
        glyphRef: null,
        gradientTransform: null,
        gradientUnits: null,
        handler: null,
        hanging: number,
        hatchContentUnits: null,
        hatchUnits: null,
        height: null,
        href: null,
        hrefLang: null,
        horizAdvX: number,
        horizOriginX: number,
        horizOriginY: number,
        id: null,
        ideographic: number,
        imageRendering: null,
        initialVisibility: null,
        in: null,
        in2: null,
        intercept: number,
        k: number,
        k1: number,
        k2: number,
        k3: number,
        k4: number,
        kernelMatrix: commaOrSpaceSeparated,
        kernelUnitLength: null,
        keyPoints: null,
        keySplines: null,
        keyTimes: null,
        kerning: null,
        lang: null,
        lengthAdjust: null,
        letterSpacing: null,
        lightingColor: null,
        limitingConeAngle: number,
        local: null,
        markerEnd: null,
        markerMid: null,
        markerStart: null,
        markerHeight: null,
        markerUnits: null,
        markerWidth: null,
        mask: null,
        maskContentUnits: null,
        maskUnits: null,
        mathematical: null,
        max: null,
        media: null,
        mediaCharacterEncoding: null,
        mediaContentEncodings: null,
        mediaSize: number,
        mediaTime: null,
        method: null,
        min: null,
        mode: null,
        name: null,
        navDown: null,
        navDownLeft: null,
        navDownRight: null,
        navLeft: null,
        navNext: null,
        navPrev: null,
        navRight: null,
        navUp: null,
        navUpLeft: null,
        navUpRight: null,
        numOctaves: null,
        observer: null,
        offset: null,
        onAbort: null,
        onActivate: null,
        onAfterPrint: null,
        onBeforePrint: null,
        onBegin: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnd: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFocusIn: null,
        onFocusOut: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadStart: null,
        onMessage: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onMouseWheel: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRepeat: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onShow: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onZoom: null,
        opacity: null,
        operator: null,
        order: null,
        orient: null,
        orientation: null,
        origin: null,
        overflow: null,
        overlay: null,
        overlinePosition: number,
        overlineThickness: number,
        paintOrder: null,
        panose1: null,
        path: null,
        pathLength: number,
        patternContentUnits: null,
        patternTransform: null,
        patternUnits: null,
        phase: null,
        ping: spaceSeparated,
        pitch: null,
        playbackOrder: null,
        pointerEvents: null,
        points: null,
        pointsAtX: number,
        pointsAtY: number,
        pointsAtZ: number,
        preserveAlpha: null,
        preserveAspectRatio: null,
        primitiveUnits: null,
        propagate: null,
        property: commaOrSpaceSeparated,
        r: null,
        radius: null,
        referrerPolicy: null,
        refX: null,
        refY: null,
        rel: commaOrSpaceSeparated,
        rev: commaOrSpaceSeparated,
        renderingIntent: null,
        repeatCount: null,
        repeatDur: null,
        requiredExtensions: commaOrSpaceSeparated,
        requiredFeatures: commaOrSpaceSeparated,
        requiredFonts: commaOrSpaceSeparated,
        requiredFormats: commaOrSpaceSeparated,
        resource: null,
        restart: null,
        result: null,
        rotate: null,
        rx: null,
        ry: null,
        scale: null,
        seed: null,
        shapeRendering: null,
        side: null,
        slope: null,
        snapshotTime: null,
        specularConstant: number,
        specularExponent: number,
        spreadMethod: null,
        spacing: null,
        startOffset: null,
        stdDeviation: null,
        stemh: null,
        stemv: null,
        stitchTiles: null,
        stopColor: null,
        stopOpacity: null,
        strikethroughPosition: number,
        strikethroughThickness: number,
        string: null,
        stroke: null,
        strokeDashArray: commaOrSpaceSeparated,
        strokeDashOffset: null,
        strokeLineCap: null,
        strokeLineJoin: null,
        strokeMiterLimit: number,
        strokeOpacity: number,
        strokeWidth: null,
        style: null,
        surfaceScale: number,
        syncBehavior: null,
        syncBehaviorDefault: null,
        syncMaster: null,
        syncTolerance: null,
        syncToleranceDefault: null,
        systemLanguage: commaOrSpaceSeparated,
        tabIndex: number,
        tableValues: null,
        target: null,
        targetX: number,
        targetY: number,
        textAnchor: null,
        textDecoration: null,
        textRendering: null,
        textLength: null,
        timelineBegin: null,
        title: null,
        transformBehavior: null,
        type: null,
        typeOf: commaOrSpaceSeparated,
        to: null,
        transform: null,
        transformOrigin: null,
        u1: null,
        u2: null,
        underlinePosition: number,
        underlineThickness: number,
        unicode: null,
        unicodeBidi: null,
        unicodeRange: null,
        unitsPerEm: number,
        values: null,
        vAlphabetic: number,
        vMathematical: number,
        vectorEffect: null,
        vHanging: number,
        vIdeographic: number,
        version: null,
        vertAdvY: number,
        vertOriginX: number,
        vertOriginY: number,
        viewBox: null,
        viewTarget: null,
        visibility: null,
        width: null,
        widths: null,
        wordSpacing: null,
        writingMode: null,
        x: null,
        x1: null,
        x2: null,
        xChannelSelector: null,
        xHeight: number,
        y: null,
        y1: null,
        y2: null,
        yChannelSelector: null,
        z: null,
        zoomAndPan: null
    }
})
  , valid = /^data[-\w.:]+$/i
  , dash = /-[a-z]/g
  , cap$1 = /[A-Z]/g;
function find(V, X) {
    const J = normalize$1(X);
    let ne = X
      , ue = Info;
    if (J in V.normal)
        return V.property[V.normal[J]];
    if (J.length > 4 && J.slice(0, 4) === "data" && valid.test(X)) {
        if (X.charAt(4) === "-") {
            const ce = X.slice(5).replace(dash, camelcase);
            ne = "data" + ce.charAt(0).toUpperCase() + ce.slice(1)
        } else {
            const ce = X.slice(4);
            if (!dash.test(ce)) {
                let me = ce.replace(cap$1, kebab);
                me.charAt(0) !== "-" && (me = "-" + me),
                X = "data" + me
            }
        }
        ue = DefinedInfo
    }
    return new ue(ne,X)
}
function kebab(V) {
    return "-" + V.toLowerCase()
}
function camelcase(V) {
    return V.charAt(1).toUpperCase()
}
const hastToReact = {
    classId: "classID",
    dataType: "datatype",
    itemId: "itemID",
    strokeDashArray: "strokeDasharray",
    strokeDashOffset: "strokeDashoffset",
    strokeLineCap: "strokeLinecap",
    strokeLineJoin: "strokeLinejoin",
    strokeMiterLimit: "strokeMiterlimit",
    typeOf: "typeof",
    xLinkActuate: "xlinkActuate",
    xLinkArcRole: "xlinkArcrole",
    xLinkHref: "xlinkHref",
    xLinkRole: "xlinkRole",
    xLinkShow: "xlinkShow",
    xLinkTitle: "xlinkTitle",
    xLinkType: "xlinkType",
    xmlnsXLink: "xmlnsXlink"
}
  , html$1 = merge$1([xml, xlink, xmlns, aria, html$2], "html")
  , svg = merge$1([xml, xlink, xmlns, aria, svg$1], "svg");
function stringify(V) {
    return V.join(" ").trim()
}
var cjs = {}
  , COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g
  , NEWLINE_REGEX = /\n/g
  , WHITESPACE_REGEX = /^\s*/
  , PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/
  , COLON_REGEX = /^:\s*/
  , VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/
  , SEMICOLON_REGEX = /^[;\s]*/
  , TRIM_REGEX = /^\s+|\s+$/g
  , NEWLINE = `
`
  , FORWARD_SLASH = "/"
  , ASTERISK = "*"
  , EMPTY_STRING = ""
  , TYPE_COMMENT = "comment"
  , TYPE_DECLARATION = "declaration"
  , inlineStyleParser = function(V, X) {
    if (typeof V != "string")
        throw new TypeError("First argument must be a string");
    if (!V)
        return [];
    X = X || {};
    var J = 1
      , ne = 1;
    function ue(Ne) {
        var ve = Ne.match(NEWLINE_REGEX);
        ve && (J += ve.length);
        var ke = Ne.lastIndexOf(NEWLINE);
        ne = ~ke ? Ne.length - ke : ne + Ne.length
    }
    function ce() {
        var Ne = {
            line: J,
            column: ne
        };
        return function(ve) {
            return ve.position = new me(Ne),
            _e(),
            ve
        }
    }
    function me(Ne) {
        this.start = Ne,
        this.end = {
            line: J,
            column: ne
        },
        this.source = X.source
    }
    me.prototype.content = V;
    function ge(Ne) {
        var ve = new Error(X.source + ":" + J + ":" + ne + ": " + Ne);
        if (ve.reason = Ne,
        ve.filename = X.source,
        ve.line = J,
        ve.column = ne,
        ve.source = V,
        !X.silent)
            throw ve
    }
    function Te(Ne) {
        var ve = Ne.exec(V);
        if (ve) {
            var ke = ve[0];
            return ue(ke),
            V = V.slice(ke.length),
            ve
        }
    }
    function _e() {
        Te(WHITESPACE_REGEX)
    }
    function Se(Ne) {
        var ve;
        for (Ne = Ne || []; ve = Ie(); )
            ve !== !1 && Ne.push(ve);
        return Ne
    }
    function Ie() {
        var Ne = ce();
        if (!(FORWARD_SLASH != V.charAt(0) || ASTERISK != V.charAt(1))) {
            for (var ve = 2; EMPTY_STRING != V.charAt(ve) && (ASTERISK != V.charAt(ve) || FORWARD_SLASH != V.charAt(ve + 1)); )
                ++ve;
            if (ve += 2,
            EMPTY_STRING === V.charAt(ve - 1))
                return ge("End of comment missing");
            var ke = V.slice(2, ve - 2);
            return ne += 2,
            ue(ke),
            V = V.slice(ve),
            ne += 2,
            Ne({
                type: TYPE_COMMENT,
                comment: ke
            })
        }
    }
    function ye() {
        var Ne = ce()
          , ve = Te(PROPERTY_REGEX);
        if (ve) {
            if (Ie(),
            !Te(COLON_REGEX))
                return ge("property missing ':'");
            var ke = Te(VALUE_REGEX)
              , xe = Ne({
                type: TYPE_DECLARATION,
                property: trim(ve[0].replace(COMMENT_REGEX, EMPTY_STRING)),
                value: ke ? trim(ke[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
            });
            return Te(SEMICOLON_REGEX),
            xe
        }
    }
    function $e() {
        var Ne = [];
        Se(Ne);
        for (var ve; ve = ye(); )
            ve !== !1 && (Ne.push(ve),
            Se(Ne));
        return Ne
    }
    return _e(),
    $e()
};
function trim(V) {
    return V ? V.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING
}
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(V) {
    return V && V.__esModule ? V : {
        default: V
    }
}
;
Object.defineProperty(cjs, "__esModule", {
    value: !0
});
var _default = cjs.default = StyleToObject
  , inline_style_parser_1 = __importDefault(inlineStyleParser);
function StyleToObject(V, X) {
    var J = null;
    if (!V || typeof V != "string")
        return J;
    var ne = (0,
    inline_style_parser_1.default)(V)
      , ue = typeof X == "function";
    return ne.forEach(function(ce) {
        if (ce.type === "declaration") {
            var me = ce.property
              , ge = ce.value;
            ue ? X(me, ge, ce) : ge && (J = J || {},
            J[me] = ge)
        }
    }),
    J
}
const styleToObject = _default.default || _default
  , pointEnd = point$2("end")
  , pointStart = point$2("start");
function point$2(V) {
    return X;
    function X(J) {
        const ne = J && J.position && J.position[V] || {};
        if (typeof ne.line == "number" && ne.line > 0 && typeof ne.column == "number" && ne.column > 0)
            return {
                line: ne.line,
                column: ne.column,
                offset: typeof ne.offset == "number" && ne.offset > -1 ? ne.offset : void 0
            }
    }
}
function position$1(V) {
    const X = pointStart(V)
      , J = pointEnd(V);
    if (X && J)
        return {
            start: X,
            end: J
        }
}
function stringifyPosition(V) {
    return !V || typeof V != "object" ? "" : "position"in V || "type"in V ? position(V.position) : "start"in V || "end"in V ? position(V) : "line"in V || "column"in V ? point$1(V) : ""
}
function point$1(V) {
    return index$1(V && V.line) + ":" + index$1(V && V.column)
}
function position(V) {
    return point$1(V && V.start) + "-" + point$1(V && V.end)
}
function index$1(V) {
    return V && typeof V == "number" ? V : 1
}
class VFileMessage extends Error {
    constructor(X, J, ne) {
        super(),
        typeof J == "string" && (ne = J,
        J = void 0);
        let ue = ""
          , ce = {}
          , me = !1;
        if (J && ("line"in J && "column"in J ? ce = {
            place: J
        } : "start"in J && "end"in J ? ce = {
            place: J
        } : "type"in J ? ce = {
            ancestors: [J],
            place: J.position
        } : ce = {
            ...J
        }),
        typeof X == "string" ? ue = X : !ce.cause && X && (me = !0,
        ue = X.message,
        ce.cause = X),
        !ce.ruleId && !ce.source && typeof ne == "string") {
            const Te = ne.indexOf(":");
            Te === -1 ? ce.ruleId = ne : (ce.source = ne.slice(0, Te),
            ce.ruleId = ne.slice(Te + 1))
        }
        if (!ce.place && ce.ancestors && ce.ancestors) {
            const Te = ce.ancestors[ce.ancestors.length - 1];
            Te && (ce.place = Te.position)
        }
        const ge = ce.place && "start"in ce.place ? ce.place.start : ce.place;
        this.ancestors = ce.ancestors || void 0,
        this.cause = ce.cause || void 0,
        this.column = ge ? ge.column : void 0,
        this.fatal = void 0,
        this.file,
        this.message = ue,
        this.line = ge ? ge.line : void 0,
        this.name = stringifyPosition(ce.place) || "1:1",
        this.place = ce.place || void 0,
        this.reason = this.message,
        this.ruleId = ce.ruleId || void 0,
        this.source = ce.source || void 0,
        this.stack = me && ce.cause && typeof ce.cause.stack == "string" ? ce.cause.stack : "",
        this.actual,
        this.expected,
        this.note,
        this.url
    }
}
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.column = void 0;
VFileMessage.prototype.line = void 0;
VFileMessage.prototype.ancestors = void 0;
VFileMessage.prototype.cause = void 0;
VFileMessage.prototype.fatal = void 0;
VFileMessage.prototype.place = void 0;
VFileMessage.prototype.ruleId = void 0;
VFileMessage.prototype.source = void 0;
const own$3 = {}.hasOwnProperty
  , emptyMap = new Map
  , cap = /[A-Z]/g
  , dashSomething = /-([a-z])/g
  , tableElements = new Set(["table", "tbody", "thead", "tfoot", "tr"])
  , tableCellElement = new Set(["td", "th"])
  , docs = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function toJsxRuntime(V, X) {
    if (!X || X.Fragment === void 0)
        throw new TypeError("Expected `Fragment` in options");
    const J = X.filePath || void 0;
    let ne;
    if (X.development) {
        if (typeof X.jsxDEV != "function")
            throw new TypeError("Expected `jsxDEV` in options when `development: true`");
        ne = developmentCreate(J, X.jsxDEV)
    } else {
        if (typeof X.jsx != "function")
            throw new TypeError("Expected `jsx` in production options");
        if (typeof X.jsxs != "function")
            throw new TypeError("Expected `jsxs` in production options");
        ne = productionCreate(J, X.jsx, X.jsxs)
    }
    const ue = {
        Fragment: X.Fragment,
        ancestors: [],
        components: X.components || {},
        create: ne,
        elementAttributeNameCase: X.elementAttributeNameCase || "react",
        evaluater: X.createEvaluater ? X.createEvaluater() : void 0,
        filePath: J,
        ignoreInvalidStyle: X.ignoreInvalidStyle || !1,
        passKeys: X.passKeys !== !1,
        passNode: X.passNode || !1,
        schema: X.space === "svg" ? svg : html$1,
        stylePropertyNameCase: X.stylePropertyNameCase || "dom",
        tableCellAlignToStyle: X.tableCellAlignToStyle !== !1
    }
      , ce = one$1(ue, V, void 0);
    return ce && typeof ce != "string" ? ce : ue.create(V, ue.Fragment, {
        children: ce || void 0
    }, void 0)
}
function one$1(V, X, J) {
    if (X.type === "element")
        return element$1(V, X, J);
    if (X.type === "mdxFlowExpression" || X.type === "mdxTextExpression")
        return mdxExpression(V, X);
    if (X.type === "mdxJsxFlowElement" || X.type === "mdxJsxTextElement")
        return mdxJsxElement(V, X, J);
    if (X.type === "mdxjsEsm")
        return mdxEsm(V, X);
    if (X.type === "root")
        return root$2(V, X, J);
    if (X.type === "text")
        return text$3(V, X)
}
function element$1(V, X, J) {
    const ne = V.schema;
    let ue = ne;
    X.tagName.toLowerCase() === "svg" && ne.space === "html" && (ue = svg,
    V.schema = ue),
    V.ancestors.push(X);
    const ce = findComponentFromName(V, X.tagName, !1)
      , me = createElementProps(V, X);
    let ge = createChildren(V, X);
    return tableElements.has(X.tagName) && (ge = ge.filter(function(Te) {
        return typeof Te == "string" ? !whitespace(Te) : !0
    })),
    addNode(V, me, ce, X),
    addChildren(me, ge),
    V.ancestors.pop(),
    V.schema = ne,
    V.create(X, ce, me, J)
}
function mdxExpression(V, X) {
    if (X.data && X.data.estree && V.evaluater) {
        const ne = X.data.estree.body[0];
        return ne.type,
        V.evaluater.evaluateExpression(ne.expression)
    }
    crashEstree(V, X.position)
}
function mdxEsm(V, X) {
    if (X.data && X.data.estree && V.evaluater)
        return V.evaluater.evaluateProgram(X.data.estree);
    crashEstree(V, X.position)
}
function mdxJsxElement(V, X, J) {
    const ne = V.schema;
    let ue = ne;
    X.name === "svg" && ne.space === "html" && (ue = svg,
    V.schema = ue),
    V.ancestors.push(X);
    const ce = X.name === null ? V.Fragment : findComponentFromName(V, X.name, !0)
      , me = createJsxElementProps(V, X)
      , ge = createChildren(V, X);
    return addNode(V, me, ce, X),
    addChildren(me, ge),
    V.ancestors.pop(),
    V.schema = ne,
    V.create(X, ce, me, J)
}
function root$2(V, X, J) {
    const ne = {};
    return addChildren(ne, createChildren(V, X)),
    V.create(X, V.Fragment, ne, J)
}
function text$3(V, X) {
    return X.value
}
function addNode(V, X, J, ne) {
    typeof J != "string" && J !== V.Fragment && V.passNode && (X.node = ne)
}
function addChildren(V, X) {
    if (X.length > 0) {
        const J = X.length > 1 ? X : X[0];
        J && (V.children = J)
    }
}
function productionCreate(V, X, J) {
    return ne;
    function ne(ue, ce, me, ge) {
        const _e = Array.isArray(me.children) ? J : X;
        return ge ? _e(ce, me, ge) : _e(ce, me)
    }
}
function developmentCreate(V, X) {
    return J;
    function J(ne, ue, ce, me) {
        const ge = Array.isArray(ce.children)
          , Te = pointStart(ne);
        return X(ue, ce, me, ge, {
            columnNumber: Te ? Te.column - 1 : void 0,
            fileName: V,
            lineNumber: Te ? Te.line : void 0
        }, void 0)
    }
}
function createElementProps(V, X) {
    const J = {};
    let ne, ue;
    for (ue in X.properties)
        if (ue !== "children" && own$3.call(X.properties, ue)) {
            const ce = createProperty(V, ue, X.properties[ue]);
            if (ce) {
                const [me,ge] = ce;
                V.tableCellAlignToStyle && me === "align" && typeof ge == "string" && tableCellElement.has(X.tagName) ? ne = ge : J[me] = ge
            }
        }
    if (ne) {
        const ce = J.style || (J.style = {});
        ce[V.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = ne
    }
    return J
}
function createJsxElementProps(V, X) {
    const J = {};
    for (const ne of X.attributes)
        if (ne.type === "mdxJsxExpressionAttribute")
            if (ne.data && ne.data.estree && V.evaluater) {
                const ce = ne.data.estree.body[0];
                ce.type;
                const me = ce.expression;
                me.type;
                const ge = me.properties[0];
                ge.type,
                Object.assign(J, V.evaluater.evaluateExpression(ge.argument))
            } else
                crashEstree(V, X.position);
        else {
            const ue = ne.name;
            let ce;
            if (ne.value && typeof ne.value == "object")
                if (ne.value.data && ne.value.data.estree && V.evaluater) {
                    const ge = ne.value.data.estree.body[0];
                    ge.type,
                    ce = V.evaluater.evaluateExpression(ge.expression)
                } else
                    crashEstree(V, X.position);
            else
                ce = ne.value === null ? !0 : ne.value;
            J[ue] = ce
        }
    return J
}
function createChildren(V, X) {
    const J = [];
    let ne = -1;
    const ue = V.passKeys ? new Map : emptyMap;
    for (; ++ne < X.children.length; ) {
        const ce = X.children[ne];
        let me;
        if (V.passKeys) {
            const Te = ce.type === "element" ? ce.tagName : ce.type === "mdxJsxFlowElement" || ce.type === "mdxJsxTextElement" ? ce.name : void 0;
            if (Te) {
                const _e = ue.get(Te) || 0;
                me = Te + "-" + _e,
                ue.set(Te, _e + 1)
            }
        }
        const ge = one$1(V, ce, me);
        ge !== void 0 && J.push(ge)
    }
    return J
}
function createProperty(V, X, J) {
    const ne = find(V.schema, X);
    if (!(J == null || typeof J == "number" && Number.isNaN(J))) {
        if (Array.isArray(J) && (J = ne.commaSeparated ? stringify$1(J) : stringify(J)),
        ne.property === "style") {
            let ue = typeof J == "object" ? J : parseStyle(V, String(J));
            return V.stylePropertyNameCase === "css" && (ue = transformStylesToCssCasing(ue)),
            ["style", ue]
        }
        return [V.elementAttributeNameCase === "react" && ne.space ? hastToReact[ne.property] || ne.property : ne.attribute, J]
    }
}
function parseStyle(V, X) {
    const J = {};
    try {
        styleToObject(X, ne)
    } catch (ue) {
        if (!V.ignoreInvalidStyle) {
            const ce = ue
              , me = new VFileMessage("Cannot parse `style` attribute",{
                ancestors: V.ancestors,
                cause: ce,
                ruleId: "style",
                source: "hast-util-to-jsx-runtime"
            });
            throw me.file = V.filePath || void 0,
            me.url = docs + "#cannot-parse-style-attribute",
            me
        }
    }
    return J;
    function ne(ue, ce) {
        let me = ue;
        me.slice(0, 2) !== "--" && (me.slice(0, 4) === "-ms-" && (me = "ms-" + me.slice(4)),
        me = me.replace(dashSomething, toCamel)),
        J[me] = ce
    }
}
function findComponentFromName(V, X, J) {
    let ne;
    if (!J)
        ne = {
            type: "Literal",
            value: X
        };
    else if (X.includes(".")) {
        const ue = X.split(".");
        let ce = -1, me;
        for (; ++ce < ue.length; ) {
            const ge = name(ue[ce]) ? {
                type: "Identifier",
                name: ue[ce]
            } : {
                type: "Literal",
                value: ue[ce]
            };
            me = me ? {
                type: "MemberExpression",
                object: me,
                property: ge,
                computed: !!(ce && ge.type === "Literal"),
                optional: !1
            } : ge
        }
        ne = me
    } else
        ne = name(X) && !/^[a-z]/.test(X) ? {
            type: "Identifier",
            name: X
        } : {
            type: "Literal",
            value: X
        };
    if (ne.type === "Literal") {
        const ue = ne.value;
        return own$3.call(V.components, ue) ? V.components[ue] : ue
    }
    if (V.evaluater)
        return V.evaluater.evaluateExpression(ne);
    crashEstree(V)
}
function crashEstree(V, X) {
    const J = new VFileMessage("Cannot handle MDX estrees without `createEvaluater`",{
        ancestors: V.ancestors,
        place: X,
        ruleId: "mdx-estree",
        source: "hast-util-to-jsx-runtime"
    });
    throw J.file = V.filePath || void 0,
    J.url = docs + "#cannot-handle-mdx-estrees-without-createevaluater",
    J
}
function transformStylesToCssCasing(V) {
    const X = {};
    let J;
    for (J in V)
        own$3.call(V, J) && (X[transformStyleToCssCasing(J)] = V[J]);
    return X
}
function transformStyleToCssCasing(V) {
    let X = V.replace(cap, toDash);
    return X.slice(0, 3) === "ms-" && (X = "-" + X),
    X
}
function toCamel(V, X) {
    return X.toUpperCase()
}
function toDash(V) {
    return "-" + V.toLowerCase()
}
const urlAttributes = {
    action: ["form"],
    cite: ["blockquote", "del", "ins", "q"],
    data: ["object"],
    formAction: ["button", "input"],
    href: ["a", "area", "base", "link"],
    icon: ["menuitem"],
    itemId: null,
    manifest: ["html"],
    ping: ["a", "area"],
    poster: ["video"],
    src: ["audio", "embed", "iframe", "img", "input", "script", "source", "track", "video"]
}
  , emptyOptions$1 = {};
function toString$1(V, X) {
    const J = emptyOptions$1
      , ne = typeof J.includeImageAlt == "boolean" ? J.includeImageAlt : !0
      , ue = typeof J.includeHtml == "boolean" ? J.includeHtml : !0;
    return one(V, ne, ue)
}
function one(V, X, J) {
    if (node(V)) {
        if ("value"in V)
            return V.type === "html" && !J ? "" : V.value;
        if (X && "alt"in V && V.alt)
            return V.alt;
        if ("children"in V)
            return all(V.children, X, J)
    }
    return Array.isArray(V) ? all(V, X, J) : ""
}
function all(V, X, J) {
    const ne = [];
    let ue = -1;
    for (; ++ue < V.length; )
        ne[ue] = one(V[ue], X, J);
    return ne.join("")
}
function node(V) {
    return !!(V && typeof V == "object")
}
const element = document.createElement("i");
function decodeNamedCharacterReference(V) {
    const X = "&" + V + ";";
    element.innerHTML = X;
    const J = element.textContent;
    return J.charCodeAt(J.length - 1) === 59 && V !== "semi" || J === X ? !1 : J
}
function splice(V, X, J, ne) {
    const ue = V.length;
    let ce = 0, me;
    if (X < 0 ? X = -X > ue ? 0 : ue + X : X = X > ue ? ue : X,
    J = J > 0 ? J : 0,
    ne.length < 1e4)
        me = Array.from(ne),
        me.unshift(X, J),
        V.splice(...me);
    else
        for (J && V.splice(X, J); ce < ne.length; )
            me = ne.slice(ce, ce + 1e4),
            me.unshift(X, 0),
            V.splice(...me),
            ce += 1e4,
            X += 1e4
}
function push(V, X) {
    return V.length > 0 ? (splice(V, V.length, 0, X),
    V) : X
}
const hasOwnProperty$1 = {}.hasOwnProperty;
function combineExtensions(V) {
    const X = {};
    let J = -1;
    for (; ++J < V.length; )
        syntaxExtension(X, V[J]);
    return X
}
function syntaxExtension(V, X) {
    let J;
    for (J in X) {
        const ue = (hasOwnProperty$1.call(V, J) ? V[J] : void 0) || (V[J] = {})
          , ce = X[J];
        let me;
        if (ce)
            for (me in ce) {
                hasOwnProperty$1.call(ue, me) || (ue[me] = []);
                const ge = ce[me];
                constructs(ue[me], Array.isArray(ge) ? ge : ge ? [ge] : [])
            }
    }
}
function constructs(V, X) {
    let J = -1;
    const ne = [];
    for (; ++J < X.length; )
        (X[J].add === "after" ? V : ne).push(X[J]);
    splice(V, 0, 0, ne)
}
function decodeNumericCharacterReference(V, X) {
    const J = Number.parseInt(V, X);
    return J < 9 || J === 11 || J > 13 && J < 32 || J > 126 && J < 160 || J > 55295 && J < 57344 || J > 64975 && J < 65008 || (J & 65535) === 65535 || (J & 65535) === 65534 || J > 1114111 ? "�" : String.fromCodePoint(J)
}
function normalizeIdentifier(V) {
    return V.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase()
}
const asciiAlpha = regexCheck(/[A-Za-z]/)
  , asciiAlphanumeric = regexCheck(/[\dA-Za-z]/)
  , asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(V) {
    return V !== null && (V < 32 || V === 127)
}
const asciiDigit = regexCheck(/\d/)
  , asciiHexDigit = regexCheck(/[\dA-Fa-f]/)
  , asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
function markdownLineEnding(V) {
    return V !== null && V < -2
}
function markdownLineEndingOrSpace(V) {
    return V !== null && (V < 0 || V === 32)
}
function markdownSpace(V) {
    return V === -2 || V === -1 || V === 32
}
const unicodePunctuation = regexCheck(new RegExp("\\p{P}|\\p{S}","u"))
  , unicodeWhitespace = regexCheck(/\s/);
function regexCheck(V) {
    return X;
    function X(J) {
        return J !== null && J > -1 && V.test(String.fromCharCode(J))
    }
}
function normalizeUri(V) {
    const X = [];
    let J = -1
      , ne = 0
      , ue = 0;
    for (; ++J < V.length; ) {
        const ce = V.charCodeAt(J);
        let me = "";
        if (ce === 37 && asciiAlphanumeric(V.charCodeAt(J + 1)) && asciiAlphanumeric(V.charCodeAt(J + 2)))
            ue = 2;
        else if (ce < 128)
            /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(ce)) || (me = String.fromCharCode(ce));
        else if (ce > 55295 && ce < 57344) {
            const ge = V.charCodeAt(J + 1);
            ce < 56320 && ge > 56319 && ge < 57344 ? (me = String.fromCharCode(ce, ge),
            ue = 1) : me = "�"
        } else
            me = String.fromCharCode(ce);
        me && (X.push(V.slice(ne, J), encodeURIComponent(me)),
        ne = J + ue + 1,
        me = ""),
        ue && (J += ue,
        ue = 0)
    }
    return X.join("") + V.slice(ne)
}
function factorySpace(V, X, J, ne) {
    const ue = ne ? ne - 1 : Number.POSITIVE_INFINITY;
    let ce = 0;
    return me;
    function me(Te) {
        return markdownSpace(Te) ? (V.enter(J),
        ge(Te)) : X(Te)
    }
    function ge(Te) {
        return markdownSpace(Te) && ce++ < ue ? (V.consume(Te),
        ge) : (V.exit(J),
        X(Te))
    }
}
const content$1 = {
    tokenize: initializeContent
};
function initializeContent(V) {
    const X = V.attempt(this.parser.constructs.contentInitial, ne, ue);
    let J;
    return X;
    function ne(ge) {
        if (ge === null) {
            V.consume(ge);
            return
        }
        return V.enter("lineEnding"),
        V.consume(ge),
        V.exit("lineEnding"),
        factorySpace(V, X, "linePrefix")
    }
    function ue(ge) {
        return V.enter("paragraph"),
        ce(ge)
    }
    function ce(ge) {
        const Te = V.enter("chunkText", {
            contentType: "text",
            previous: J
        });
        return J && (J.next = Te),
        J = Te,
        me(ge)
    }
    function me(ge) {
        if (ge === null) {
            V.exit("chunkText"),
            V.exit("paragraph"),
            V.consume(ge);
            return
        }
        return markdownLineEnding(ge) ? (V.consume(ge),
        V.exit("chunkText"),
        ce) : (V.consume(ge),
        me)
    }
}
const document$2 = {
    tokenize: initializeDocument
}
  , containerConstruct = {
    tokenize: tokenizeContainer
};
function initializeDocument(V) {
    const X = this
      , J = [];
    let ne = 0, ue, ce, me;
    return ge;
    function ge(Fe) {
        if (ne < J.length) {
            const je = J[ne];
            return X.containerState = je[1],
            V.attempt(je[0].continuation, Te, _e)(Fe)
        }
        return _e(Fe)
    }
    function Te(Fe) {
        if (ne++,
        X.containerState._closeFlow) {
            X.containerState._closeFlow = void 0,
            ue && we();
            const je = X.events.length;
            let Xe = je, ze;
            for (; Xe--; )
                if (X.events[Xe][0] === "exit" && X.events[Xe][1].type === "chunkFlow") {
                    ze = X.events[Xe][1].end;
                    break
                }
            xe(ne);
            let qe = je;
            for (; qe < X.events.length; )
                X.events[qe][1].end = {
                    ...ze
                },
                qe++;
            return splice(X.events, Xe + 1, 0, X.events.slice(je)),
            X.events.length = qe,
            _e(Fe)
        }
        return ge(Fe)
    }
    function _e(Fe) {
        if (ne === J.length) {
            if (!ue)
                return ye(Fe);
            if (ue.currentConstruct && ue.currentConstruct.concrete)
                return Ne(Fe);
            X.interrupt = !!(ue.currentConstruct && !ue._gfmTableDynamicInterruptHack)
        }
        return X.containerState = {},
        V.check(containerConstruct, Se, Ie)(Fe)
    }
    function Se(Fe) {
        return ue && we(),
        xe(ne),
        ye(Fe)
    }
    function Ie(Fe) {
        return X.parser.lazy[X.now().line] = ne !== J.length,
        me = X.now().offset,
        Ne(Fe)
    }
    function ye(Fe) {
        return X.containerState = {},
        V.attempt(containerConstruct, $e, Ne)(Fe)
    }
    function $e(Fe) {
        return ne++,
        J.push([X.currentConstruct, X.containerState]),
        ye(Fe)
    }
    function Ne(Fe) {
        if (Fe === null) {
            ue && we(),
            xe(0),
            V.consume(Fe);
            return
        }
        return ue = ue || X.parser.flow(X.now()),
        V.enter("chunkFlow", {
            _tokenizer: ue,
            contentType: "flow",
            previous: ce
        }),
        ve(Fe)
    }
    function ve(Fe) {
        if (Fe === null) {
            ke(V.exit("chunkFlow"), !0),
            xe(0),
            V.consume(Fe);
            return
        }
        return markdownLineEnding(Fe) ? (V.consume(Fe),
        ke(V.exit("chunkFlow")),
        ne = 0,
        X.interrupt = void 0,
        ge) : (V.consume(Fe),
        ve)
    }
    function ke(Fe, je) {
        const Xe = X.sliceStream(Fe);
        if (je && Xe.push(null),
        Fe.previous = ce,
        ce && (ce.next = Fe),
        ce = Fe,
        ue.defineSkip(Fe.start),
        ue.write(Xe),
        X.parser.lazy[Fe.start.line]) {
            let ze = ue.events.length;
            for (; ze--; )
                if (ue.events[ze][1].start.offset < me && (!ue.events[ze][1].end || ue.events[ze][1].end.offset > me))
                    return;
            const qe = X.events.length;
            let Ze = qe, et, it;
            for (; Ze--; )
                if (X.events[Ze][0] === "exit" && X.events[Ze][1].type === "chunkFlow") {
                    if (et) {
                        it = X.events[Ze][1].end;
                        break
                    }
                    et = !0
                }
            for (xe(ne),
            ze = qe; ze < X.events.length; )
                X.events[ze][1].end = {
                    ...it
                },
                ze++;
            splice(X.events, Ze + 1, 0, X.events.slice(qe)),
            X.events.length = ze
        }
    }
    function xe(Fe) {
        let je = J.length;
        for (; je-- > Fe; ) {
            const Xe = J[je];
            X.containerState = Xe[1],
            Xe[0].exit.call(X, V)
        }
        J.length = Fe
    }
    function we() {
        ue.write([null]),
        ce = void 0,
        ue = void 0,
        X.containerState._closeFlow = void 0
    }
}
function tokenizeContainer(V, X, J) {
    return factorySpace(V, V.attempt(this.parser.constructs.document, X, J), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)
}
function classifyCharacter(V) {
    if (V === null || markdownLineEndingOrSpace(V) || unicodeWhitespace(V))
        return 1;
    if (unicodePunctuation(V))
        return 2
}
function resolveAll(V, X, J) {
    const ne = [];
    let ue = -1;
    for (; ++ue < V.length; ) {
        const ce = V[ue].resolveAll;
        ce && !ne.includes(ce) && (X = ce(X, J),
        ne.push(ce))
    }
    return X
}
const attention = {
    name: "attention",
    resolveAll: resolveAllAttention,
    tokenize: tokenizeAttention
};
function resolveAllAttention(V, X) {
    let J = -1, ne, ue, ce, me, ge, Te, _e, Se;
    for (; ++J < V.length; )
        if (V[J][0] === "enter" && V[J][1].type === "attentionSequence" && V[J][1]._close) {
            for (ne = J; ne--; )
                if (V[ne][0] === "exit" && V[ne][1].type === "attentionSequence" && V[ne][1]._open && X.sliceSerialize(V[ne][1]).charCodeAt(0) === X.sliceSerialize(V[J][1]).charCodeAt(0)) {
                    if ((V[ne][1]._close || V[J][1]._open) && (V[J][1].end.offset - V[J][1].start.offset) % 3 && !((V[ne][1].end.offset - V[ne][1].start.offset + V[J][1].end.offset - V[J][1].start.offset) % 3))
                        continue;
                    Te = V[ne][1].end.offset - V[ne][1].start.offset > 1 && V[J][1].end.offset - V[J][1].start.offset > 1 ? 2 : 1;
                    const Ie = {
                        ...V[ne][1].end
                    }
                      , ye = {
                        ...V[J][1].start
                    };
                    movePoint(Ie, -Te),
                    movePoint(ye, Te),
                    me = {
                        type: Te > 1 ? "strongSequence" : "emphasisSequence",
                        start: Ie,
                        end: {
                            ...V[ne][1].end
                        }
                    },
                    ge = {
                        type: Te > 1 ? "strongSequence" : "emphasisSequence",
                        start: {
                            ...V[J][1].start
                        },
                        end: ye
                    },
                    ce = {
                        type: Te > 1 ? "strongText" : "emphasisText",
                        start: {
                            ...V[ne][1].end
                        },
                        end: {
                            ...V[J][1].start
                        }
                    },
                    ue = {
                        type: Te > 1 ? "strong" : "emphasis",
                        start: {
                            ...me.start
                        },
                        end: {
                            ...ge.end
                        }
                    },
                    V[ne][1].end = {
                        ...me.start
                    },
                    V[J][1].start = {
                        ...ge.end
                    },
                    _e = [],
                    V[ne][1].end.offset - V[ne][1].start.offset && (_e = push(_e, [["enter", V[ne][1], X], ["exit", V[ne][1], X]])),
                    _e = push(_e, [["enter", ue, X], ["enter", me, X], ["exit", me, X], ["enter", ce, X]]),
                    _e = push(_e, resolveAll(X.parser.constructs.insideSpan.null, V.slice(ne + 1, J), X)),
                    _e = push(_e, [["exit", ce, X], ["enter", ge, X], ["exit", ge, X], ["exit", ue, X]]),
                    V[J][1].end.offset - V[J][1].start.offset ? (Se = 2,
                    _e = push(_e, [["enter", V[J][1], X], ["exit", V[J][1], X]])) : Se = 0,
                    splice(V, ne - 1, J - ne + 3, _e),
                    J = ne + _e.length - Se - 2;
                    break
                }
        }
    for (J = -1; ++J < V.length; )
        V[J][1].type === "attentionSequence" && (V[J][1].type = "data");
    return V
}
function tokenizeAttention(V, X) {
    const J = this.parser.constructs.attentionMarkers.null
      , ne = this.previous
      , ue = classifyCharacter(ne);
    let ce;
    return me;
    function me(Te) {
        return ce = Te,
        V.enter("attentionSequence"),
        ge(Te)
    }
    function ge(Te) {
        if (Te === ce)
            return V.consume(Te),
            ge;
        const _e = V.exit("attentionSequence")
          , Se = classifyCharacter(Te)
          , Ie = !Se || Se === 2 && ue || J.includes(Te)
          , ye = !ue || ue === 2 && Se || J.includes(ne);
        return _e._open = !!(ce === 42 ? Ie : Ie && (ue || !ye)),
        _e._close = !!(ce === 42 ? ye : ye && (Se || !Ie)),
        X(Te)
    }
}
function movePoint(V, X) {
    V.column += X,
    V.offset += X,
    V._bufferIndex += X
}
const autolink = {
    name: "autolink",
    tokenize: tokenizeAutolink
};
function tokenizeAutolink(V, X, J) {
    let ne = 0;
    return ue;
    function ue($e) {
        return V.enter("autolink"),
        V.enter("autolinkMarker"),
        V.consume($e),
        V.exit("autolinkMarker"),
        V.enter("autolinkProtocol"),
        ce
    }
    function ce($e) {
        return asciiAlpha($e) ? (V.consume($e),
        me) : $e === 64 ? J($e) : _e($e)
    }
    function me($e) {
        return $e === 43 || $e === 45 || $e === 46 || asciiAlphanumeric($e) ? (ne = 1,
        ge($e)) : _e($e)
    }
    function ge($e) {
        return $e === 58 ? (V.consume($e),
        ne = 0,
        Te) : ($e === 43 || $e === 45 || $e === 46 || asciiAlphanumeric($e)) && ne++ < 32 ? (V.consume($e),
        ge) : (ne = 0,
        _e($e))
    }
    function Te($e) {
        return $e === 62 ? (V.exit("autolinkProtocol"),
        V.enter("autolinkMarker"),
        V.consume($e),
        V.exit("autolinkMarker"),
        V.exit("autolink"),
        X) : $e === null || $e === 32 || $e === 60 || asciiControl($e) ? J($e) : (V.consume($e),
        Te)
    }
    function _e($e) {
        return $e === 64 ? (V.consume($e),
        Se) : asciiAtext($e) ? (V.consume($e),
        _e) : J($e)
    }
    function Se($e) {
        return asciiAlphanumeric($e) ? Ie($e) : J($e)
    }
    function Ie($e) {
        return $e === 46 ? (V.consume($e),
        ne = 0,
        Se) : $e === 62 ? (V.exit("autolinkProtocol").type = "autolinkEmail",
        V.enter("autolinkMarker"),
        V.consume($e),
        V.exit("autolinkMarker"),
        V.exit("autolink"),
        X) : ye($e)
    }
    function ye($e) {
        if (($e === 45 || asciiAlphanumeric($e)) && ne++ < 63) {
            const Ne = $e === 45 ? ye : Ie;
            return V.consume($e),
            Ne
        }
        return J($e)
    }
}
const blankLine = {
    partial: !0,
    tokenize: tokenizeBlankLine
};
function tokenizeBlankLine(V, X, J) {
    return ne;
    function ne(ce) {
        return markdownSpace(ce) ? factorySpace(V, ue, "linePrefix")(ce) : ue(ce)
    }
    function ue(ce) {
        return ce === null || markdownLineEnding(ce) ? X(ce) : J(ce)
    }
}
const blockQuote = {
    continuation: {
        tokenize: tokenizeBlockQuoteContinuation
    },
    exit,
    name: "blockQuote",
    tokenize: tokenizeBlockQuoteStart
};
function tokenizeBlockQuoteStart(V, X, J) {
    const ne = this;
    return ue;
    function ue(me) {
        if (me === 62) {
            const ge = ne.containerState;
            return ge.open || (V.enter("blockQuote", {
                _container: !0
            }),
            ge.open = !0),
            V.enter("blockQuotePrefix"),
            V.enter("blockQuoteMarker"),
            V.consume(me),
            V.exit("blockQuoteMarker"),
            ce
        }
        return J(me)
    }
    function ce(me) {
        return markdownSpace(me) ? (V.enter("blockQuotePrefixWhitespace"),
        V.consume(me),
        V.exit("blockQuotePrefixWhitespace"),
        V.exit("blockQuotePrefix"),
        X) : (V.exit("blockQuotePrefix"),
        X(me))
    }
}
function tokenizeBlockQuoteContinuation(V, X, J) {
    const ne = this;
    return ue;
    function ue(me) {
        return markdownSpace(me) ? factorySpace(V, ce, "linePrefix", ne.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(me) : ce(me)
    }
    function ce(me) {
        return V.attempt(blockQuote, X, J)(me)
    }
}
function exit(V) {
    V.exit("blockQuote")
}
const characterEscape = {
    name: "characterEscape",
    tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(V, X, J) {
    return ne;
    function ne(ce) {
        return V.enter("characterEscape"),
        V.enter("escapeMarker"),
        V.consume(ce),
        V.exit("escapeMarker"),
        ue
    }
    function ue(ce) {
        return asciiPunctuation(ce) ? (V.enter("characterEscapeValue"),
        V.consume(ce),
        V.exit("characterEscapeValue"),
        V.exit("characterEscape"),
        X) : J(ce)
    }
}
const characterReference = {
    name: "characterReference",
    tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(V, X, J) {
    const ne = this;
    let ue = 0, ce, me;
    return ge;
    function ge(Ie) {
        return V.enter("characterReference"),
        V.enter("characterReferenceMarker"),
        V.consume(Ie),
        V.exit("characterReferenceMarker"),
        Te
    }
    function Te(Ie) {
        return Ie === 35 ? (V.enter("characterReferenceMarkerNumeric"),
        V.consume(Ie),
        V.exit("characterReferenceMarkerNumeric"),
        _e) : (V.enter("characterReferenceValue"),
        ce = 31,
        me = asciiAlphanumeric,
        Se(Ie))
    }
    function _e(Ie) {
        return Ie === 88 || Ie === 120 ? (V.enter("characterReferenceMarkerHexadecimal"),
        V.consume(Ie),
        V.exit("characterReferenceMarkerHexadecimal"),
        V.enter("characterReferenceValue"),
        ce = 6,
        me = asciiHexDigit,
        Se) : (V.enter("characterReferenceValue"),
        ce = 7,
        me = asciiDigit,
        Se(Ie))
    }
    function Se(Ie) {
        if (Ie === 59 && ue) {
            const ye = V.exit("characterReferenceValue");
            return me === asciiAlphanumeric && !decodeNamedCharacterReference(ne.sliceSerialize(ye)) ? J(Ie) : (V.enter("characterReferenceMarker"),
            V.consume(Ie),
            V.exit("characterReferenceMarker"),
            V.exit("characterReference"),
            X)
        }
        return me(Ie) && ue++ < ce ? (V.consume(Ie),
        Se) : J(Ie)
    }
}
const nonLazyContinuation = {
    partial: !0,
    tokenize: tokenizeNonLazyContinuation
}
  , codeFenced = {
    concrete: !0,
    name: "codeFenced",
    tokenize: tokenizeCodeFenced
};
function tokenizeCodeFenced(V, X, J) {
    const ne = this
      , ue = {
        partial: !0,
        tokenize: Xe
    };
    let ce = 0, me = 0, ge;
    return Te;
    function Te(ze) {
        return _e(ze)
    }
    function _e(ze) {
        const qe = ne.events[ne.events.length - 1];
        return ce = qe && qe[1].type === "linePrefix" ? qe[2].sliceSerialize(qe[1], !0).length : 0,
        ge = ze,
        V.enter("codeFenced"),
        V.enter("codeFencedFence"),
        V.enter("codeFencedFenceSequence"),
        Se(ze)
    }
    function Se(ze) {
        return ze === ge ? (me++,
        V.consume(ze),
        Se) : me < 3 ? J(ze) : (V.exit("codeFencedFenceSequence"),
        markdownSpace(ze) ? factorySpace(V, Ie, "whitespace")(ze) : Ie(ze))
    }
    function Ie(ze) {
        return ze === null || markdownLineEnding(ze) ? (V.exit("codeFencedFence"),
        ne.interrupt ? X(ze) : V.check(nonLazyContinuation, ve, je)(ze)) : (V.enter("codeFencedFenceInfo"),
        V.enter("chunkString", {
            contentType: "string"
        }),
        ye(ze))
    }
    function ye(ze) {
        return ze === null || markdownLineEnding(ze) ? (V.exit("chunkString"),
        V.exit("codeFencedFenceInfo"),
        Ie(ze)) : markdownSpace(ze) ? (V.exit("chunkString"),
        V.exit("codeFencedFenceInfo"),
        factorySpace(V, $e, "whitespace")(ze)) : ze === 96 && ze === ge ? J(ze) : (V.consume(ze),
        ye)
    }
    function $e(ze) {
        return ze === null || markdownLineEnding(ze) ? Ie(ze) : (V.enter("codeFencedFenceMeta"),
        V.enter("chunkString", {
            contentType: "string"
        }),
        Ne(ze))
    }
    function Ne(ze) {
        return ze === null || markdownLineEnding(ze) ? (V.exit("chunkString"),
        V.exit("codeFencedFenceMeta"),
        Ie(ze)) : ze === 96 && ze === ge ? J(ze) : (V.consume(ze),
        Ne)
    }
    function ve(ze) {
        return V.attempt(ue, je, ke)(ze)
    }
    function ke(ze) {
        return V.enter("lineEnding"),
        V.consume(ze),
        V.exit("lineEnding"),
        xe
    }
    function xe(ze) {
        return ce > 0 && markdownSpace(ze) ? factorySpace(V, we, "linePrefix", ce + 1)(ze) : we(ze)
    }
    function we(ze) {
        return ze === null || markdownLineEnding(ze) ? V.check(nonLazyContinuation, ve, je)(ze) : (V.enter("codeFlowValue"),
        Fe(ze))
    }
    function Fe(ze) {
        return ze === null || markdownLineEnding(ze) ? (V.exit("codeFlowValue"),
        we(ze)) : (V.consume(ze),
        Fe)
    }
    function je(ze) {
        return V.exit("codeFenced"),
        X(ze)
    }
    function Xe(ze, qe, Ze) {
        let et = 0;
        return it;
        function it(Ye) {
            return ze.enter("lineEnding"),
            ze.consume(Ye),
            ze.exit("lineEnding"),
            at
        }
        function at(Ye) {
            return ze.enter("codeFencedFence"),
            markdownSpace(Ye) ? factorySpace(ze, rt, "linePrefix", ne.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(Ye) : rt(Ye)
        }
        function rt(Ye) {
            return Ye === ge ? (ze.enter("codeFencedFenceSequence"),
            ft(Ye)) : Ze(Ye)
        }
        function ft(Ye) {
            return Ye === ge ? (et++,
            ze.consume(Ye),
            ft) : et >= me ? (ze.exit("codeFencedFenceSequence"),
            markdownSpace(Ye) ? factorySpace(ze, St, "whitespace")(Ye) : St(Ye)) : Ze(Ye)
        }
        function St(Ye) {
            return Ye === null || markdownLineEnding(Ye) ? (ze.exit("codeFencedFence"),
            qe(Ye)) : Ze(Ye)
        }
    }
}
function tokenizeNonLazyContinuation(V, X, J) {
    const ne = this;
    return ue;
    function ue(me) {
        return me === null ? J(me) : (V.enter("lineEnding"),
        V.consume(me),
        V.exit("lineEnding"),
        ce)
    }
    function ce(me) {
        return ne.parser.lazy[ne.now().line] ? J(me) : X(me)
    }
}
const codeIndented = {
    name: "codeIndented",
    tokenize: tokenizeCodeIndented
}
  , furtherStart = {
    partial: !0,
    tokenize: tokenizeFurtherStart
};
function tokenizeCodeIndented(V, X, J) {
    const ne = this;
    return ue;
    function ue(_e) {
        return V.enter("codeIndented"),
        factorySpace(V, ce, "linePrefix", 5)(_e)
    }
    function ce(_e) {
        const Se = ne.events[ne.events.length - 1];
        return Se && Se[1].type === "linePrefix" && Se[2].sliceSerialize(Se[1], !0).length >= 4 ? me(_e) : J(_e)
    }
    function me(_e) {
        return _e === null ? Te(_e) : markdownLineEnding(_e) ? V.attempt(furtherStart, me, Te)(_e) : (V.enter("codeFlowValue"),
        ge(_e))
    }
    function ge(_e) {
        return _e === null || markdownLineEnding(_e) ? (V.exit("codeFlowValue"),
        me(_e)) : (V.consume(_e),
        ge)
    }
    function Te(_e) {
        return V.exit("codeIndented"),
        X(_e)
    }
}
function tokenizeFurtherStart(V, X, J) {
    const ne = this;
    return ue;
    function ue(me) {
        return ne.parser.lazy[ne.now().line] ? J(me) : markdownLineEnding(me) ? (V.enter("lineEnding"),
        V.consume(me),
        V.exit("lineEnding"),
        ue) : factorySpace(V, ce, "linePrefix", 5)(me)
    }
    function ce(me) {
        const ge = ne.events[ne.events.length - 1];
        return ge && ge[1].type === "linePrefix" && ge[2].sliceSerialize(ge[1], !0).length >= 4 ? X(me) : markdownLineEnding(me) ? ue(me) : J(me)
    }
}
const codeText = {
    name: "codeText",
    previous,
    resolve: resolveCodeText,
    tokenize: tokenizeCodeText
};
function resolveCodeText(V) {
    let X = V.length - 4, J = 3, ne, ue;
    if ((V[J][1].type === "lineEnding" || V[J][1].type === "space") && (V[X][1].type === "lineEnding" || V[X][1].type === "space")) {
        for (ne = J; ++ne < X; )
            if (V[ne][1].type === "codeTextData") {
                V[J][1].type = "codeTextPadding",
                V[X][1].type = "codeTextPadding",
                J += 2,
                X -= 2;
                break
            }
    }
    for (ne = J - 1,
    X++; ++ne <= X; )
        ue === void 0 ? ne !== X && V[ne][1].type !== "lineEnding" && (ue = ne) : (ne === X || V[ne][1].type === "lineEnding") && (V[ue][1].type = "codeTextData",
        ne !== ue + 2 && (V[ue][1].end = V[ne - 1][1].end,
        V.splice(ue + 2, ne - ue - 2),
        X -= ne - ue - 2,
        ne = ue + 2),
        ue = void 0);
    return V
}
function previous(V) {
    return V !== 96 || this.events[this.events.length - 1][1].type === "characterEscape"
}
function tokenizeCodeText(V, X, J) {
    let ne = 0, ue, ce;
    return me;
    function me(Ie) {
        return V.enter("codeText"),
        V.enter("codeTextSequence"),
        ge(Ie)
    }
    function ge(Ie) {
        return Ie === 96 ? (V.consume(Ie),
        ne++,
        ge) : (V.exit("codeTextSequence"),
        Te(Ie))
    }
    function Te(Ie) {
        return Ie === null ? J(Ie) : Ie === 32 ? (V.enter("space"),
        V.consume(Ie),
        V.exit("space"),
        Te) : Ie === 96 ? (ce = V.enter("codeTextSequence"),
        ue = 0,
        Se(Ie)) : markdownLineEnding(Ie) ? (V.enter("lineEnding"),
        V.consume(Ie),
        V.exit("lineEnding"),
        Te) : (V.enter("codeTextData"),
        _e(Ie))
    }
    function _e(Ie) {
        return Ie === null || Ie === 32 || Ie === 96 || markdownLineEnding(Ie) ? (V.exit("codeTextData"),
        Te(Ie)) : (V.consume(Ie),
        _e)
    }
    function Se(Ie) {
        return Ie === 96 ? (V.consume(Ie),
        ue++,
        Se) : ue === ne ? (V.exit("codeTextSequence"),
        V.exit("codeText"),
        X(Ie)) : (ce.type = "codeTextData",
        _e(Ie))
    }
}
class SpliceBuffer {
    constructor(X) {
        this.left = X ? [...X] : [],
        this.right = []
    }
    get(X) {
        if (X < 0 || X >= this.left.length + this.right.length)
            throw new RangeError("Cannot access index `" + X + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
        return X < this.left.length ? this.left[X] : this.right[this.right.length - X + this.left.length - 1]
    }
    get length() {
        return this.left.length + this.right.length
    }
    shift() {
        return this.setCursor(0),
        this.right.pop()
    }
    slice(X, J) {
        const ne = J ?? Number.POSITIVE_INFINITY;
        if (ne < this.left.length)
            return this.left.slice(X, ne);
        if (X > this.left.length)
            return this.right.slice(this.right.length - ne + this.left.length, this.right.length - X + this.left.length).reverse();
        const ue = this.left.slice(X);
        return ue.push(...this.right.slice(this.right.length - ne + this.left.length).reverse()),
        ue
    }
    splice(X, J, ne) {
        const ue = J || 0;
        this.setCursor(Math.trunc(X));
        const ce = this.right.splice(this.right.length - ue, Number.POSITIVE_INFINITY);
        return ne && chunkedPush(this.left, ne),
        ce.reverse()
    }
    pop() {
        return this.setCursor(Number.POSITIVE_INFINITY),
        this.left.pop()
    }
    push(X) {
        this.setCursor(Number.POSITIVE_INFINITY),
        this.left.push(X)
    }
    pushMany(X) {
        this.setCursor(Number.POSITIVE_INFINITY),
        chunkedPush(this.left, X)
    }
    unshift(X) {
        this.setCursor(0),
        this.right.push(X)
    }
    unshiftMany(X) {
        this.setCursor(0),
        chunkedPush(this.right, X.reverse())
    }
    setCursor(X) {
        if (!(X === this.left.length || X > this.left.length && this.right.length === 0 || X < 0 && this.left.length === 0))
            if (X < this.left.length) {
                const J = this.left.splice(X, Number.POSITIVE_INFINITY);
                chunkedPush(this.right, J.reverse())
            } else {
                const J = this.right.splice(this.left.length + this.right.length - X, Number.POSITIVE_INFINITY);
                chunkedPush(this.left, J.reverse())
            }
    }
}
function chunkedPush(V, X) {
    let J = 0;
    if (X.length < 1e4)
        V.push(...X);
    else
        for (; J < X.length; )
            V.push(...X.slice(J, J + 1e4)),
            J += 1e4
}
function subtokenize(V) {
    const X = {};
    let J = -1, ne, ue, ce, me, ge, Te, _e;
    const Se = new SpliceBuffer(V);
    for (; ++J < Se.length; ) {
        for (; J in X; )
            J = X[J];
        if (ne = Se.get(J),
        J && ne[1].type === "chunkFlow" && Se.get(J - 1)[1].type === "listItemPrefix" && (Te = ne[1]._tokenizer.events,
        ce = 0,
        ce < Te.length && Te[ce][1].type === "lineEndingBlank" && (ce += 2),
        ce < Te.length && Te[ce][1].type === "content"))
            for (; ++ce < Te.length && Te[ce][1].type !== "content"; )
                Te[ce][1].type === "chunkText" && (Te[ce][1]._isInFirstContentOfListItem = !0,
                ce++);
        if (ne[0] === "enter")
            ne[1].contentType && (Object.assign(X, subcontent(Se, J)),
            J = X[J],
            _e = !0);
        else if (ne[1]._container) {
            for (ce = J,
            ue = void 0; ce-- && (me = Se.get(ce),
            me[1].type === "lineEnding" || me[1].type === "lineEndingBlank"); )
                me[0] === "enter" && (ue && (Se.get(ue)[1].type = "lineEndingBlank"),
                me[1].type = "lineEnding",
                ue = ce);
            ue && (ne[1].end = {
                ...Se.get(ue)[1].start
            },
            ge = Se.slice(ue, J),
            ge.unshift(ne),
            Se.splice(ue, J - ue + 1, ge))
        }
    }
    return splice(V, 0, Number.POSITIVE_INFINITY, Se.slice(0)),
    !_e
}
function subcontent(V, X) {
    const J = V.get(X)[1]
      , ne = V.get(X)[2];
    let ue = X - 1;
    const ce = []
      , me = J._tokenizer || ne.parser[J.contentType](J.start)
      , ge = me.events
      , Te = []
      , _e = {};
    let Se, Ie, ye = -1, $e = J, Ne = 0, ve = 0;
    const ke = [ve];
    for (; $e; ) {
        for (; V.get(++ue)[1] !== $e; )
            ;
        ce.push(ue),
        $e._tokenizer || (Se = ne.sliceStream($e),
        $e.next || Se.push(null),
        Ie && me.defineSkip($e.start),
        $e._isInFirstContentOfListItem && (me._gfmTasklistFirstContentOfListItem = !0),
        me.write(Se),
        $e._isInFirstContentOfListItem && (me._gfmTasklistFirstContentOfListItem = void 0)),
        Ie = $e,
        $e = $e.next
    }
    for ($e = J; ++ye < ge.length; )
        ge[ye][0] === "exit" && ge[ye - 1][0] === "enter" && ge[ye][1].type === ge[ye - 1][1].type && ge[ye][1].start.line !== ge[ye][1].end.line && (ve = ye + 1,
        ke.push(ve),
        $e._tokenizer = void 0,
        $e.previous = void 0,
        $e = $e.next);
    for (me.events = [],
    $e ? ($e._tokenizer = void 0,
    $e.previous = void 0) : ke.pop(),
    ye = ke.length; ye--; ) {
        const xe = ge.slice(ke[ye], ke[ye + 1])
          , we = ce.pop();
        Te.push([we, we + xe.length - 1]),
        V.splice(we, 2, xe)
    }
    for (Te.reverse(),
    ye = -1; ++ye < Te.length; )
        _e[Ne + Te[ye][0]] = Ne + Te[ye][1],
        Ne += Te[ye][1] - Te[ye][0] - 1;
    return _e
}
const content = {
    resolve: resolveContent,
    tokenize: tokenizeContent
}
  , continuationConstruct = {
    partial: !0,
    tokenize: tokenizeContinuation
};
function resolveContent(V) {
    return subtokenize(V),
    V
}
function tokenizeContent(V, X) {
    let J;
    return ne;
    function ne(ge) {
        return V.enter("content"),
        J = V.enter("chunkContent", {
            contentType: "content"
        }),
        ue(ge)
    }
    function ue(ge) {
        return ge === null ? ce(ge) : markdownLineEnding(ge) ? V.check(continuationConstruct, me, ce)(ge) : (V.consume(ge),
        ue)
    }
    function ce(ge) {
        return V.exit("chunkContent"),
        V.exit("content"),
        X(ge)
    }
    function me(ge) {
        return V.consume(ge),
        V.exit("chunkContent"),
        J.next = V.enter("chunkContent", {
            contentType: "content",
            previous: J
        }),
        J = J.next,
        ue
    }
}
function tokenizeContinuation(V, X, J) {
    const ne = this;
    return ue;
    function ue(me) {
        return V.exit("chunkContent"),
        V.enter("lineEnding"),
        V.consume(me),
        V.exit("lineEnding"),
        factorySpace(V, ce, "linePrefix")
    }
    function ce(me) {
        if (me === null || markdownLineEnding(me))
            return J(me);
        const ge = ne.events[ne.events.length - 1];
        return !ne.parser.constructs.disable.null.includes("codeIndented") && ge && ge[1].type === "linePrefix" && ge[2].sliceSerialize(ge[1], !0).length >= 4 ? X(me) : V.interrupt(ne.parser.constructs.flow, J, X)(me)
    }
}
function factoryDestination(V, X, J, ne, ue, ce, me, ge, Te) {
    const _e = Te || Number.POSITIVE_INFINITY;
    let Se = 0;
    return Ie;
    function Ie(xe) {
        return xe === 60 ? (V.enter(ne),
        V.enter(ue),
        V.enter(ce),
        V.consume(xe),
        V.exit(ce),
        ye) : xe === null || xe === 32 || xe === 41 || asciiControl(xe) ? J(xe) : (V.enter(ne),
        V.enter(me),
        V.enter(ge),
        V.enter("chunkString", {
            contentType: "string"
        }),
        ve(xe))
    }
    function ye(xe) {
        return xe === 62 ? (V.enter(ce),
        V.consume(xe),
        V.exit(ce),
        V.exit(ue),
        V.exit(ne),
        X) : (V.enter(ge),
        V.enter("chunkString", {
            contentType: "string"
        }),
        $e(xe))
    }
    function $e(xe) {
        return xe === 62 ? (V.exit("chunkString"),
        V.exit(ge),
        ye(xe)) : xe === null || xe === 60 || markdownLineEnding(xe) ? J(xe) : (V.consume(xe),
        xe === 92 ? Ne : $e)
    }
    function Ne(xe) {
        return xe === 60 || xe === 62 || xe === 92 ? (V.consume(xe),
        $e) : $e(xe)
    }
    function ve(xe) {
        return !Se && (xe === null || xe === 41 || markdownLineEndingOrSpace(xe)) ? (V.exit("chunkString"),
        V.exit(ge),
        V.exit(me),
        V.exit(ne),
        X(xe)) : Se < _e && xe === 40 ? (V.consume(xe),
        Se++,
        ve) : xe === 41 ? (V.consume(xe),
        Se--,
        ve) : xe === null || xe === 32 || xe === 40 || asciiControl(xe) ? J(xe) : (V.consume(xe),
        xe === 92 ? ke : ve)
    }
    function ke(xe) {
        return xe === 40 || xe === 41 || xe === 92 ? (V.consume(xe),
        ve) : ve(xe)
    }
}
function factoryLabel(V, X, J, ne, ue, ce) {
    const me = this;
    let ge = 0, Te;
    return _e;
    function _e($e) {
        return V.enter(ne),
        V.enter(ue),
        V.consume($e),
        V.exit(ue),
        V.enter(ce),
        Se
    }
    function Se($e) {
        return ge > 999 || $e === null || $e === 91 || $e === 93 && !Te || $e === 94 && !ge && "_hiddenFootnoteSupport"in me.parser.constructs ? J($e) : $e === 93 ? (V.exit(ce),
        V.enter(ue),
        V.consume($e),
        V.exit(ue),
        V.exit(ne),
        X) : markdownLineEnding($e) ? (V.enter("lineEnding"),
        V.consume($e),
        V.exit("lineEnding"),
        Se) : (V.enter("chunkString", {
            contentType: "string"
        }),
        Ie($e))
    }
    function Ie($e) {
        return $e === null || $e === 91 || $e === 93 || markdownLineEnding($e) || ge++ > 999 ? (V.exit("chunkString"),
        Se($e)) : (V.consume($e),
        Te || (Te = !markdownSpace($e)),
        $e === 92 ? ye : Ie)
    }
    function ye($e) {
        return $e === 91 || $e === 92 || $e === 93 ? (V.consume($e),
        ge++,
        Ie) : Ie($e)
    }
}
function factoryTitle(V, X, J, ne, ue, ce) {
    let me;
    return ge;
    function ge(ye) {
        return ye === 34 || ye === 39 || ye === 40 ? (V.enter(ne),
        V.enter(ue),
        V.consume(ye),
        V.exit(ue),
        me = ye === 40 ? 41 : ye,
        Te) : J(ye)
    }
    function Te(ye) {
        return ye === me ? (V.enter(ue),
        V.consume(ye),
        V.exit(ue),
        V.exit(ne),
        X) : (V.enter(ce),
        _e(ye))
    }
    function _e(ye) {
        return ye === me ? (V.exit(ce),
        Te(me)) : ye === null ? J(ye) : markdownLineEnding(ye) ? (V.enter("lineEnding"),
        V.consume(ye),
        V.exit("lineEnding"),
        factorySpace(V, _e, "linePrefix")) : (V.enter("chunkString", {
            contentType: "string"
        }),
        Se(ye))
    }
    function Se(ye) {
        return ye === me || ye === null || markdownLineEnding(ye) ? (V.exit("chunkString"),
        _e(ye)) : (V.consume(ye),
        ye === 92 ? Ie : Se)
    }
    function Ie(ye) {
        return ye === me || ye === 92 ? (V.consume(ye),
        Se) : Se(ye)
    }
}
function factoryWhitespace(V, X) {
    let J;
    return ne;
    function ne(ue) {
        return markdownLineEnding(ue) ? (V.enter("lineEnding"),
        V.consume(ue),
        V.exit("lineEnding"),
        J = !0,
        ne) : markdownSpace(ue) ? factorySpace(V, ne, J ? "linePrefix" : "lineSuffix")(ue) : X(ue)
    }
}
const definition = {
    name: "definition",
    tokenize: tokenizeDefinition
}
  , titleBefore = {
    partial: !0,
    tokenize: tokenizeTitleBefore
};
function tokenizeDefinition(V, X, J) {
    const ne = this;
    let ue;
    return ce;
    function ce($e) {
        return V.enter("definition"),
        me($e)
    }
    function me($e) {
        return factoryLabel.call(ne, V, ge, J, "definitionLabel", "definitionLabelMarker", "definitionLabelString")($e)
    }
    function ge($e) {
        return ue = normalizeIdentifier(ne.sliceSerialize(ne.events[ne.events.length - 1][1]).slice(1, -1)),
        $e === 58 ? (V.enter("definitionMarker"),
        V.consume($e),
        V.exit("definitionMarker"),
        Te) : J($e)
    }
    function Te($e) {
        return markdownLineEndingOrSpace($e) ? factoryWhitespace(V, _e)($e) : _e($e)
    }
    function _e($e) {
        return factoryDestination(V, Se, J, "definitionDestination", "definitionDestinationLiteral", "definitionDestinationLiteralMarker", "definitionDestinationRaw", "definitionDestinationString")($e)
    }
    function Se($e) {
        return V.attempt(titleBefore, Ie, Ie)($e)
    }
    function Ie($e) {
        return markdownSpace($e) ? factorySpace(V, ye, "whitespace")($e) : ye($e)
    }
    function ye($e) {
        return $e === null || markdownLineEnding($e) ? (V.exit("definition"),
        ne.parser.defined.push(ue),
        X($e)) : J($e)
    }
}
function tokenizeTitleBefore(V, X, J) {
    return ne;
    function ne(ge) {
        return markdownLineEndingOrSpace(ge) ? factoryWhitespace(V, ue)(ge) : J(ge)
    }
    function ue(ge) {
        return factoryTitle(V, ce, J, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(ge)
    }
    function ce(ge) {
        return markdownSpace(ge) ? factorySpace(V, me, "whitespace")(ge) : me(ge)
    }
    function me(ge) {
        return ge === null || markdownLineEnding(ge) ? X(ge) : J(ge)
    }
}
const hardBreakEscape = {
    name: "hardBreakEscape",
    tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(V, X, J) {
    return ne;
    function ne(ce) {
        return V.enter("hardBreakEscape"),
        V.consume(ce),
        ue
    }
    function ue(ce) {
        return markdownLineEnding(ce) ? (V.exit("hardBreakEscape"),
        X(ce)) : J(ce)
    }
}
const headingAtx = {
    name: "headingAtx",
    resolve: resolveHeadingAtx,
    tokenize: tokenizeHeadingAtx
};
function resolveHeadingAtx(V, X) {
    let J = V.length - 2, ne = 3, ue, ce;
    return V[ne][1].type === "whitespace" && (ne += 2),
    J - 2 > ne && V[J][1].type === "whitespace" && (J -= 2),
    V[J][1].type === "atxHeadingSequence" && (ne === J - 1 || J - 4 > ne && V[J - 2][1].type === "whitespace") && (J -= ne + 1 === J ? 2 : 4),
    J > ne && (ue = {
        type: "atxHeadingText",
        start: V[ne][1].start,
        end: V[J][1].end
    },
    ce = {
        type: "chunkText",
        start: V[ne][1].start,
        end: V[J][1].end,
        contentType: "text"
    },
    splice(V, ne, J - ne + 1, [["enter", ue, X], ["enter", ce, X], ["exit", ce, X], ["exit", ue, X]])),
    V
}
function tokenizeHeadingAtx(V, X, J) {
    let ne = 0;
    return ue;
    function ue(Se) {
        return V.enter("atxHeading"),
        ce(Se)
    }
    function ce(Se) {
        return V.enter("atxHeadingSequence"),
        me(Se)
    }
    function me(Se) {
        return Se === 35 && ne++ < 6 ? (V.consume(Se),
        me) : Se === null || markdownLineEndingOrSpace(Se) ? (V.exit("atxHeadingSequence"),
        ge(Se)) : J(Se)
    }
    function ge(Se) {
        return Se === 35 ? (V.enter("atxHeadingSequence"),
        Te(Se)) : Se === null || markdownLineEnding(Se) ? (V.exit("atxHeading"),
        X(Se)) : markdownSpace(Se) ? factorySpace(V, ge, "whitespace")(Se) : (V.enter("atxHeadingText"),
        _e(Se))
    }
    function Te(Se) {
        return Se === 35 ? (V.consume(Se),
        Te) : (V.exit("atxHeadingSequence"),
        ge(Se))
    }
    function _e(Se) {
        return Se === null || Se === 35 || markdownLineEndingOrSpace(Se) ? (V.exit("atxHeadingText"),
        ge(Se)) : (V.consume(Se),
        _e)
    }
}
const htmlBlockNames = ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "search", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"]
  , htmlRawNames = ["pre", "script", "style", "textarea"]
  , htmlFlow = {
    concrete: !0,
    name: "htmlFlow",
    resolveTo: resolveToHtmlFlow,
    tokenize: tokenizeHtmlFlow
}
  , blankLineBefore = {
    partial: !0,
    tokenize: tokenizeBlankLineBefore
}
  , nonLazyContinuationStart = {
    partial: !0,
    tokenize: tokenizeNonLazyContinuationStart
};
function resolveToHtmlFlow(V) {
    let X = V.length;
    for (; X-- && !(V[X][0] === "enter" && V[X][1].type === "htmlFlow"); )
        ;
    return X > 1 && V[X - 2][1].type === "linePrefix" && (V[X][1].start = V[X - 2][1].start,
    V[X + 1][1].start = V[X - 2][1].start,
    V.splice(X - 2, 2)),
    V
}
function tokenizeHtmlFlow(V, X, J) {
    const ne = this;
    let ue, ce, me, ge, Te;
    return _e;
    function _e(Qe) {
        return Se(Qe)
    }
    function Se(Qe) {
        return V.enter("htmlFlow"),
        V.enter("htmlFlowData"),
        V.consume(Qe),
        Ie
    }
    function Ie(Qe) {
        return Qe === 33 ? (V.consume(Qe),
        ye) : Qe === 47 ? (V.consume(Qe),
        ce = !0,
        ve) : Qe === 63 ? (V.consume(Qe),
        ue = 3,
        ne.interrupt ? X : Ke) : asciiAlpha(Qe) ? (V.consume(Qe),
        me = String.fromCharCode(Qe),
        ke) : J(Qe)
    }
    function ye(Qe) {
        return Qe === 45 ? (V.consume(Qe),
        ue = 2,
        $e) : Qe === 91 ? (V.consume(Qe),
        ue = 5,
        ge = 0,
        Ne) : asciiAlpha(Qe) ? (V.consume(Qe),
        ue = 4,
        ne.interrupt ? X : Ke) : J(Qe)
    }
    function $e(Qe) {
        return Qe === 45 ? (V.consume(Qe),
        ne.interrupt ? X : Ke) : J(Qe)
    }
    function Ne(Qe) {
        const gt = "CDATA[";
        return Qe === gt.charCodeAt(ge++) ? (V.consume(Qe),
        ge === gt.length ? ne.interrupt ? X : rt : Ne) : J(Qe)
    }
    function ve(Qe) {
        return asciiAlpha(Qe) ? (V.consume(Qe),
        me = String.fromCharCode(Qe),
        ke) : J(Qe)
    }
    function ke(Qe) {
        if (Qe === null || Qe === 47 || Qe === 62 || markdownLineEndingOrSpace(Qe)) {
            const gt = Qe === 47
              , Nt = me.toLowerCase();
            return !gt && !ce && htmlRawNames.includes(Nt) ? (ue = 1,
            ne.interrupt ? X(Qe) : rt(Qe)) : htmlBlockNames.includes(me.toLowerCase()) ? (ue = 6,
            gt ? (V.consume(Qe),
            xe) : ne.interrupt ? X(Qe) : rt(Qe)) : (ue = 7,
            ne.interrupt && !ne.parser.lazy[ne.now().line] ? J(Qe) : ce ? we(Qe) : Fe(Qe))
        }
        return Qe === 45 || asciiAlphanumeric(Qe) ? (V.consume(Qe),
        me += String.fromCharCode(Qe),
        ke) : J(Qe)
    }
    function xe(Qe) {
        return Qe === 62 ? (V.consume(Qe),
        ne.interrupt ? X : rt) : J(Qe)
    }
    function we(Qe) {
        return markdownSpace(Qe) ? (V.consume(Qe),
        we) : it(Qe)
    }
    function Fe(Qe) {
        return Qe === 47 ? (V.consume(Qe),
        it) : Qe === 58 || Qe === 95 || asciiAlpha(Qe) ? (V.consume(Qe),
        je) : markdownSpace(Qe) ? (V.consume(Qe),
        Fe) : it(Qe)
    }
    function je(Qe) {
        return Qe === 45 || Qe === 46 || Qe === 58 || Qe === 95 || asciiAlphanumeric(Qe) ? (V.consume(Qe),
        je) : Xe(Qe)
    }
    function Xe(Qe) {
        return Qe === 61 ? (V.consume(Qe),
        ze) : markdownSpace(Qe) ? (V.consume(Qe),
        Xe) : Fe(Qe)
    }
    function ze(Qe) {
        return Qe === null || Qe === 60 || Qe === 61 || Qe === 62 || Qe === 96 ? J(Qe) : Qe === 34 || Qe === 39 ? (V.consume(Qe),
        Te = Qe,
        qe) : markdownSpace(Qe) ? (V.consume(Qe),
        ze) : Ze(Qe)
    }
    function qe(Qe) {
        return Qe === Te ? (V.consume(Qe),
        Te = null,
        et) : Qe === null || markdownLineEnding(Qe) ? J(Qe) : (V.consume(Qe),
        qe)
    }
    function Ze(Qe) {
        return Qe === null || Qe === 34 || Qe === 39 || Qe === 47 || Qe === 60 || Qe === 61 || Qe === 62 || Qe === 96 || markdownLineEndingOrSpace(Qe) ? Xe(Qe) : (V.consume(Qe),
        Ze)
    }
    function et(Qe) {
        return Qe === 47 || Qe === 62 || markdownSpace(Qe) ? Fe(Qe) : J(Qe)
    }
    function it(Qe) {
        return Qe === 62 ? (V.consume(Qe),
        at) : J(Qe)
    }
    function at(Qe) {
        return Qe === null || markdownLineEnding(Qe) ? rt(Qe) : markdownSpace(Qe) ? (V.consume(Qe),
        at) : J(Qe)
    }
    function rt(Qe) {
        return Qe === 45 && ue === 2 ? (V.consume(Qe),
        We) : Qe === 60 && ue === 1 ? (V.consume(Qe),
        nt) : Qe === 62 && ue === 4 ? (V.consume(Qe),
        mt) : Qe === 63 && ue === 3 ? (V.consume(Qe),
        Ke) : Qe === 93 && ue === 5 ? (V.consume(Qe),
        Et) : markdownLineEnding(Qe) && (ue === 6 || ue === 7) ? (V.exit("htmlFlowData"),
        V.check(blankLineBefore, lt, ft)(Qe)) : Qe === null || markdownLineEnding(Qe) ? (V.exit("htmlFlowData"),
        ft(Qe)) : (V.consume(Qe),
        rt)
    }
    function ft(Qe) {
        return V.check(nonLazyContinuationStart, St, lt)(Qe)
    }
    function St(Qe) {
        return V.enter("lineEnding"),
        V.consume(Qe),
        V.exit("lineEnding"),
        Ye
    }
    function Ye(Qe) {
        return Qe === null || markdownLineEnding(Qe) ? ft(Qe) : (V.enter("htmlFlowData"),
        rt(Qe))
    }
    function We(Qe) {
        return Qe === 45 ? (V.consume(Qe),
        Ke) : rt(Qe)
    }
    function nt(Qe) {
        return Qe === 47 ? (V.consume(Qe),
        me = "",
        ct) : rt(Qe)
    }
    function ct(Qe) {
        if (Qe === 62) {
            const gt = me.toLowerCase();
            return htmlRawNames.includes(gt) ? (V.consume(Qe),
            mt) : rt(Qe)
        }
        return asciiAlpha(Qe) && me.length < 8 ? (V.consume(Qe),
        me += String.fromCharCode(Qe),
        ct) : rt(Qe)
    }
    function Et(Qe) {
        return Qe === 93 ? (V.consume(Qe),
        Ke) : rt(Qe)
    }
    function Ke(Qe) {
        return Qe === 62 ? (V.consume(Qe),
        mt) : Qe === 45 && ue === 2 ? (V.consume(Qe),
        Ke) : rt(Qe)
    }
    function mt(Qe) {
        return Qe === null || markdownLineEnding(Qe) ? (V.exit("htmlFlowData"),
        lt(Qe)) : (V.consume(Qe),
        mt)
    }
    function lt(Qe) {
        return V.exit("htmlFlow"),
        X(Qe)
    }
}
function tokenizeNonLazyContinuationStart(V, X, J) {
    const ne = this;
    return ue;
    function ue(me) {
        return markdownLineEnding(me) ? (V.enter("lineEnding"),
        V.consume(me),
        V.exit("lineEnding"),
        ce) : J(me)
    }
    function ce(me) {
        return ne.parser.lazy[ne.now().line] ? J(me) : X(me)
    }
}
function tokenizeBlankLineBefore(V, X, J) {
    return ne;
    function ne(ue) {
        return V.enter("lineEnding"),
        V.consume(ue),
        V.exit("lineEnding"),
        V.attempt(blankLine, X, J)
    }
}
const htmlText = {
    name: "htmlText",
    tokenize: tokenizeHtmlText
};
function tokenizeHtmlText(V, X, J) {
    const ne = this;
    let ue, ce, me;
    return ge;
    function ge(Ke) {
        return V.enter("htmlText"),
        V.enter("htmlTextData"),
        V.consume(Ke),
        Te
    }
    function Te(Ke) {
        return Ke === 33 ? (V.consume(Ke),
        _e) : Ke === 47 ? (V.consume(Ke),
        Xe) : Ke === 63 ? (V.consume(Ke),
        Fe) : asciiAlpha(Ke) ? (V.consume(Ke),
        Ze) : J(Ke)
    }
    function _e(Ke) {
        return Ke === 45 ? (V.consume(Ke),
        Se) : Ke === 91 ? (V.consume(Ke),
        ce = 0,
        Ne) : asciiAlpha(Ke) ? (V.consume(Ke),
        we) : J(Ke)
    }
    function Se(Ke) {
        return Ke === 45 ? (V.consume(Ke),
        $e) : J(Ke)
    }
    function Ie(Ke) {
        return Ke === null ? J(Ke) : Ke === 45 ? (V.consume(Ke),
        ye) : markdownLineEnding(Ke) ? (me = Ie,
        nt(Ke)) : (V.consume(Ke),
        Ie)
    }
    function ye(Ke) {
        return Ke === 45 ? (V.consume(Ke),
        $e) : Ie(Ke)
    }
    function $e(Ke) {
        return Ke === 62 ? We(Ke) : Ke === 45 ? ye(Ke) : Ie(Ke)
    }
    function Ne(Ke) {
        const mt = "CDATA[";
        return Ke === mt.charCodeAt(ce++) ? (V.consume(Ke),
        ce === mt.length ? ve : Ne) : J(Ke)
    }
    function ve(Ke) {
        return Ke === null ? J(Ke) : Ke === 93 ? (V.consume(Ke),
        ke) : markdownLineEnding(Ke) ? (me = ve,
        nt(Ke)) : (V.consume(Ke),
        ve)
    }
    function ke(Ke) {
        return Ke === 93 ? (V.consume(Ke),
        xe) : ve(Ke)
    }
    function xe(Ke) {
        return Ke === 62 ? We(Ke) : Ke === 93 ? (V.consume(Ke),
        xe) : ve(Ke)
    }
    function we(Ke) {
        return Ke === null || Ke === 62 ? We(Ke) : markdownLineEnding(Ke) ? (me = we,
        nt(Ke)) : (V.consume(Ke),
        we)
    }
    function Fe(Ke) {
        return Ke === null ? J(Ke) : Ke === 63 ? (V.consume(Ke),
        je) : markdownLineEnding(Ke) ? (me = Fe,
        nt(Ke)) : (V.consume(Ke),
        Fe)
    }
    function je(Ke) {
        return Ke === 62 ? We(Ke) : Fe(Ke)
    }
    function Xe(Ke) {
        return asciiAlpha(Ke) ? (V.consume(Ke),
        ze) : J(Ke)
    }
    function ze(Ke) {
        return Ke === 45 || asciiAlphanumeric(Ke) ? (V.consume(Ke),
        ze) : qe(Ke)
    }
    function qe(Ke) {
        return markdownLineEnding(Ke) ? (me = qe,
        nt(Ke)) : markdownSpace(Ke) ? (V.consume(Ke),
        qe) : We(Ke)
    }
    function Ze(Ke) {
        return Ke === 45 || asciiAlphanumeric(Ke) ? (V.consume(Ke),
        Ze) : Ke === 47 || Ke === 62 || markdownLineEndingOrSpace(Ke) ? et(Ke) : J(Ke)
    }
    function et(Ke) {
        return Ke === 47 ? (V.consume(Ke),
        We) : Ke === 58 || Ke === 95 || asciiAlpha(Ke) ? (V.consume(Ke),
        it) : markdownLineEnding(Ke) ? (me = et,
        nt(Ke)) : markdownSpace(Ke) ? (V.consume(Ke),
        et) : We(Ke)
    }
    function it(Ke) {
        return Ke === 45 || Ke === 46 || Ke === 58 || Ke === 95 || asciiAlphanumeric(Ke) ? (V.consume(Ke),
        it) : at(Ke)
    }
    function at(Ke) {
        return Ke === 61 ? (V.consume(Ke),
        rt) : markdownLineEnding(Ke) ? (me = at,
        nt(Ke)) : markdownSpace(Ke) ? (V.consume(Ke),
        at) : et(Ke)
    }
    function rt(Ke) {
        return Ke === null || Ke === 60 || Ke === 61 || Ke === 62 || Ke === 96 ? J(Ke) : Ke === 34 || Ke === 39 ? (V.consume(Ke),
        ue = Ke,
        ft) : markdownLineEnding(Ke) ? (me = rt,
        nt(Ke)) : markdownSpace(Ke) ? (V.consume(Ke),
        rt) : (V.consume(Ke),
        St)
    }
    function ft(Ke) {
        return Ke === ue ? (V.consume(Ke),
        ue = void 0,
        Ye) : Ke === null ? J(Ke) : markdownLineEnding(Ke) ? (me = ft,
        nt(Ke)) : (V.consume(Ke),
        ft)
    }
    function St(Ke) {
        return Ke === null || Ke === 34 || Ke === 39 || Ke === 60 || Ke === 61 || Ke === 96 ? J(Ke) : Ke === 47 || Ke === 62 || markdownLineEndingOrSpace(Ke) ? et(Ke) : (V.consume(Ke),
        St)
    }
    function Ye(Ke) {
        return Ke === 47 || Ke === 62 || markdownLineEndingOrSpace(Ke) ? et(Ke) : J(Ke)
    }
    function We(Ke) {
        return Ke === 62 ? (V.consume(Ke),
        V.exit("htmlTextData"),
        V.exit("htmlText"),
        X) : J(Ke)
    }
    function nt(Ke) {
        return V.exit("htmlTextData"),
        V.enter("lineEnding"),
        V.consume(Ke),
        V.exit("lineEnding"),
        ct
    }
    function ct(Ke) {
        return markdownSpace(Ke) ? factorySpace(V, Et, "linePrefix", ne.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(Ke) : Et(Ke)
    }
    function Et(Ke) {
        return V.enter("htmlTextData"),
        me(Ke)
    }
}
const labelEnd = {
    name: "labelEnd",
    resolveAll: resolveAllLabelEnd,
    resolveTo: resolveToLabelEnd,
    tokenize: tokenizeLabelEnd
}
  , resourceConstruct = {
    tokenize: tokenizeResource
}
  , referenceFullConstruct = {
    tokenize: tokenizeReferenceFull
}
  , referenceCollapsedConstruct = {
    tokenize: tokenizeReferenceCollapsed
};
function resolveAllLabelEnd(V) {
    let X = -1;
    const J = [];
    for (; ++X < V.length; ) {
        const ne = V[X][1];
        if (J.push(V[X]),
        ne.type === "labelImage" || ne.type === "labelLink" || ne.type === "labelEnd") {
            const ue = ne.type === "labelImage" ? 4 : 2;
            ne.type = "data",
            X += ue
        }
    }
    return V.length !== J.length && splice(V, 0, V.length, J),
    V
}
function resolveToLabelEnd(V, X) {
    let J = V.length, ne = 0, ue, ce, me, ge;
    for (; J--; )
        if (ue = V[J][1],
        ce) {
            if (ue.type === "link" || ue.type === "labelLink" && ue._inactive)
                break;
            V[J][0] === "enter" && ue.type === "labelLink" && (ue._inactive = !0)
        } else if (me) {
            if (V[J][0] === "enter" && (ue.type === "labelImage" || ue.type === "labelLink") && !ue._balanced && (ce = J,
            ue.type !== "labelLink")) {
                ne = 2;
                break
            }
        } else
            ue.type === "labelEnd" && (me = J);
    const Te = {
        type: V[ce][1].type === "labelLink" ? "link" : "image",
        start: {
            ...V[ce][1].start
        },
        end: {
            ...V[V.length - 1][1].end
        }
    }
      , _e = {
        type: "label",
        start: {
            ...V[ce][1].start
        },
        end: {
            ...V[me][1].end
        }
    }
      , Se = {
        type: "labelText",
        start: {
            ...V[ce + ne + 2][1].end
        },
        end: {
            ...V[me - 2][1].start
        }
    };
    return ge = [["enter", Te, X], ["enter", _e, X]],
    ge = push(ge, V.slice(ce + 1, ce + ne + 3)),
    ge = push(ge, [["enter", Se, X]]),
    ge = push(ge, resolveAll(X.parser.constructs.insideSpan.null, V.slice(ce + ne + 4, me - 3), X)),
    ge = push(ge, [["exit", Se, X], V[me - 2], V[me - 1], ["exit", _e, X]]),
    ge = push(ge, V.slice(me + 1)),
    ge = push(ge, [["exit", Te, X]]),
    splice(V, ce, V.length, ge),
    V
}
function tokenizeLabelEnd(V, X, J) {
    const ne = this;
    let ue = ne.events.length, ce, me;
    for (; ue--; )
        if ((ne.events[ue][1].type === "labelImage" || ne.events[ue][1].type === "labelLink") && !ne.events[ue][1]._balanced) {
            ce = ne.events[ue][1];
            break
        }
    return ge;
    function ge(ye) {
        return ce ? ce._inactive ? Ie(ye) : (me = ne.parser.defined.includes(normalizeIdentifier(ne.sliceSerialize({
            start: ce.end,
            end: ne.now()
        }))),
        V.enter("labelEnd"),
        V.enter("labelMarker"),
        V.consume(ye),
        V.exit("labelMarker"),
        V.exit("labelEnd"),
        Te) : J(ye)
    }
    function Te(ye) {
        return ye === 40 ? V.attempt(resourceConstruct, Se, me ? Se : Ie)(ye) : ye === 91 ? V.attempt(referenceFullConstruct, Se, me ? _e : Ie)(ye) : me ? Se(ye) : Ie(ye)
    }
    function _e(ye) {
        return V.attempt(referenceCollapsedConstruct, Se, Ie)(ye)
    }
    function Se(ye) {
        return X(ye)
    }
    function Ie(ye) {
        return ce._balanced = !0,
        J(ye)
    }
}
function tokenizeResource(V, X, J) {
    return ne;
    function ne(Ie) {
        return V.enter("resource"),
        V.enter("resourceMarker"),
        V.consume(Ie),
        V.exit("resourceMarker"),
        ue
    }
    function ue(Ie) {
        return markdownLineEndingOrSpace(Ie) ? factoryWhitespace(V, ce)(Ie) : ce(Ie)
    }
    function ce(Ie) {
        return Ie === 41 ? Se(Ie) : factoryDestination(V, me, ge, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(Ie)
    }
    function me(Ie) {
        return markdownLineEndingOrSpace(Ie) ? factoryWhitespace(V, Te)(Ie) : Se(Ie)
    }
    function ge(Ie) {
        return J(Ie)
    }
    function Te(Ie) {
        return Ie === 34 || Ie === 39 || Ie === 40 ? factoryTitle(V, _e, J, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(Ie) : Se(Ie)
    }
    function _e(Ie) {
        return markdownLineEndingOrSpace(Ie) ? factoryWhitespace(V, Se)(Ie) : Se(Ie)
    }
    function Se(Ie) {
        return Ie === 41 ? (V.enter("resourceMarker"),
        V.consume(Ie),
        V.exit("resourceMarker"),
        V.exit("resource"),
        X) : J(Ie)
    }
}
function tokenizeReferenceFull(V, X, J) {
    const ne = this;
    return ue;
    function ue(ge) {
        return factoryLabel.call(ne, V, ce, me, "reference", "referenceMarker", "referenceString")(ge)
    }
    function ce(ge) {
        return ne.parser.defined.includes(normalizeIdentifier(ne.sliceSerialize(ne.events[ne.events.length - 1][1]).slice(1, -1))) ? X(ge) : J(ge)
    }
    function me(ge) {
        return J(ge)
    }
}
function tokenizeReferenceCollapsed(V, X, J) {
    return ne;
    function ne(ce) {
        return V.enter("reference"),
        V.enter("referenceMarker"),
        V.consume(ce),
        V.exit("referenceMarker"),
        ue
    }
    function ue(ce) {
        return ce === 93 ? (V.enter("referenceMarker"),
        V.consume(ce),
        V.exit("referenceMarker"),
        V.exit("reference"),
        X) : J(ce)
    }
}
const labelStartImage = {
    name: "labelStartImage",
    resolveAll: labelEnd.resolveAll,
    tokenize: tokenizeLabelStartImage
};
function tokenizeLabelStartImage(V, X, J) {
    const ne = this;
    return ue;
    function ue(ge) {
        return V.enter("labelImage"),
        V.enter("labelImageMarker"),
        V.consume(ge),
        V.exit("labelImageMarker"),
        ce
    }
    function ce(ge) {
        return ge === 91 ? (V.enter("labelMarker"),
        V.consume(ge),
        V.exit("labelMarker"),
        V.exit("labelImage"),
        me) : J(ge)
    }
    function me(ge) {
        return ge === 94 && "_hiddenFootnoteSupport"in ne.parser.constructs ? J(ge) : X(ge)
    }
}
const labelStartLink = {
    name: "labelStartLink",
    resolveAll: labelEnd.resolveAll,
    tokenize: tokenizeLabelStartLink
};
function tokenizeLabelStartLink(V, X, J) {
    const ne = this;
    return ue;
    function ue(me) {
        return V.enter("labelLink"),
        V.enter("labelMarker"),
        V.consume(me),
        V.exit("labelMarker"),
        V.exit("labelLink"),
        ce
    }
    function ce(me) {
        return me === 94 && "_hiddenFootnoteSupport"in ne.parser.constructs ? J(me) : X(me)
    }
}
const lineEnding = {
    name: "lineEnding",
    tokenize: tokenizeLineEnding
};
function tokenizeLineEnding(V, X) {
    return J;
    function J(ne) {
        return V.enter("lineEnding"),
        V.consume(ne),
        V.exit("lineEnding"),
        factorySpace(V, X, "linePrefix")
    }
}
const thematicBreak$1 = {
    name: "thematicBreak",
    tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(V, X, J) {
    let ne = 0, ue;
    return ce;
    function ce(_e) {
        return V.enter("thematicBreak"),
        me(_e)
    }
    function me(_e) {
        return ue = _e,
        ge(_e)
    }
    function ge(_e) {
        return _e === ue ? (V.enter("thematicBreakSequence"),
        Te(_e)) : ne >= 3 && (_e === null || markdownLineEnding(_e)) ? (V.exit("thematicBreak"),
        X(_e)) : J(_e)
    }
    function Te(_e) {
        return _e === ue ? (V.consume(_e),
        ne++,
        Te) : (V.exit("thematicBreakSequence"),
        markdownSpace(_e) ? factorySpace(V, ge, "whitespace")(_e) : ge(_e))
    }
}
const list$1 = {
    continuation: {
        tokenize: tokenizeListContinuation
    },
    exit: tokenizeListEnd,
    name: "list",
    tokenize: tokenizeListStart
}
  , listItemPrefixWhitespaceConstruct = {
    partial: !0,
    tokenize: tokenizeListItemPrefixWhitespace
}
  , indentConstruct = {
    partial: !0,
    tokenize: tokenizeIndent
};
function tokenizeListStart(V, X, J) {
    const ne = this
      , ue = ne.events[ne.events.length - 1];
    let ce = ue && ue[1].type === "linePrefix" ? ue[2].sliceSerialize(ue[1], !0).length : 0
      , me = 0;
    return ge;
    function ge($e) {
        const Ne = ne.containerState.type || ($e === 42 || $e === 43 || $e === 45 ? "listUnordered" : "listOrdered");
        if (Ne === "listUnordered" ? !ne.containerState.marker || $e === ne.containerState.marker : asciiDigit($e)) {
            if (ne.containerState.type || (ne.containerState.type = Ne,
            V.enter(Ne, {
                _container: !0
            })),
            Ne === "listUnordered")
                return V.enter("listItemPrefix"),
                $e === 42 || $e === 45 ? V.check(thematicBreak$1, J, _e)($e) : _e($e);
            if (!ne.interrupt || $e === 49)
                return V.enter("listItemPrefix"),
                V.enter("listItemValue"),
                Te($e)
        }
        return J($e)
    }
    function Te($e) {
        return asciiDigit($e) && ++me < 10 ? (V.consume($e),
        Te) : (!ne.interrupt || me < 2) && (ne.containerState.marker ? $e === ne.containerState.marker : $e === 41 || $e === 46) ? (V.exit("listItemValue"),
        _e($e)) : J($e)
    }
    function _e($e) {
        return V.enter("listItemMarker"),
        V.consume($e),
        V.exit("listItemMarker"),
        ne.containerState.marker = ne.containerState.marker || $e,
        V.check(blankLine, ne.interrupt ? J : Se, V.attempt(listItemPrefixWhitespaceConstruct, ye, Ie))
    }
    function Se($e) {
        return ne.containerState.initialBlankLine = !0,
        ce++,
        ye($e)
    }
    function Ie($e) {
        return markdownSpace($e) ? (V.enter("listItemPrefixWhitespace"),
        V.consume($e),
        V.exit("listItemPrefixWhitespace"),
        ye) : J($e)
    }
    function ye($e) {
        return ne.containerState.size = ce + ne.sliceSerialize(V.exit("listItemPrefix"), !0).length,
        X($e)
    }
}
function tokenizeListContinuation(V, X, J) {
    const ne = this;
    return ne.containerState._closeFlow = void 0,
    V.check(blankLine, ue, ce);
    function ue(ge) {
        return ne.containerState.furtherBlankLines = ne.containerState.furtherBlankLines || ne.containerState.initialBlankLine,
        factorySpace(V, X, "listItemIndent", ne.containerState.size + 1)(ge)
    }
    function ce(ge) {
        return ne.containerState.furtherBlankLines || !markdownSpace(ge) ? (ne.containerState.furtherBlankLines = void 0,
        ne.containerState.initialBlankLine = void 0,
        me(ge)) : (ne.containerState.furtherBlankLines = void 0,
        ne.containerState.initialBlankLine = void 0,
        V.attempt(indentConstruct, X, me)(ge))
    }
    function me(ge) {
        return ne.containerState._closeFlow = !0,
        ne.interrupt = void 0,
        factorySpace(V, V.attempt(list$1, X, J), "linePrefix", ne.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(ge)
    }
}
function tokenizeIndent(V, X, J) {
    const ne = this;
    return factorySpace(V, ue, "listItemIndent", ne.containerState.size + 1);
    function ue(ce) {
        const me = ne.events[ne.events.length - 1];
        return me && me[1].type === "listItemIndent" && me[2].sliceSerialize(me[1], !0).length === ne.containerState.size ? X(ce) : J(ce)
    }
}
function tokenizeListEnd(V) {
    V.exit(this.containerState.type)
}
function tokenizeListItemPrefixWhitespace(V, X, J) {
    const ne = this;
    return factorySpace(V, ue, "listItemPrefixWhitespace", ne.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
    function ue(ce) {
        const me = ne.events[ne.events.length - 1];
        return !markdownSpace(ce) && me && me[1].type === "listItemPrefixWhitespace" ? X(ce) : J(ce)
    }
}
const setextUnderline = {
    name: "setextUnderline",
    resolveTo: resolveToSetextUnderline,
    tokenize: tokenizeSetextUnderline
};
function resolveToSetextUnderline(V, X) {
    let J = V.length, ne, ue, ce;
    for (; J--; )
        if (V[J][0] === "enter") {
            if (V[J][1].type === "content") {
                ne = J;
                break
            }
            V[J][1].type === "paragraph" && (ue = J)
        } else
            V[J][1].type === "content" && V.splice(J, 1),
            !ce && V[J][1].type === "definition" && (ce = J);
    const me = {
        type: "setextHeading",
        start: {
            ...V[ue][1].start
        },
        end: {
            ...V[V.length - 1][1].end
        }
    };
    return V[ue][1].type = "setextHeadingText",
    ce ? (V.splice(ue, 0, ["enter", me, X]),
    V.splice(ce + 1, 0, ["exit", V[ne][1], X]),
    V[ne][1].end = {
        ...V[ce][1].end
    }) : V[ne][1] = me,
    V.push(["exit", me, X]),
    V
}
function tokenizeSetextUnderline(V, X, J) {
    const ne = this;
    let ue;
    return ce;
    function ce(_e) {
        let Se = ne.events.length, Ie;
        for (; Se--; )
            if (ne.events[Se][1].type !== "lineEnding" && ne.events[Se][1].type !== "linePrefix" && ne.events[Se][1].type !== "content") {
                Ie = ne.events[Se][1].type === "paragraph";
                break
            }
        return !ne.parser.lazy[ne.now().line] && (ne.interrupt || Ie) ? (V.enter("setextHeadingLine"),
        ue = _e,
        me(_e)) : J(_e)
    }
    function me(_e) {
        return V.enter("setextHeadingLineSequence"),
        ge(_e)
    }
    function ge(_e) {
        return _e === ue ? (V.consume(_e),
        ge) : (V.exit("setextHeadingLineSequence"),
        markdownSpace(_e) ? factorySpace(V, Te, "lineSuffix")(_e) : Te(_e))
    }
    function Te(_e) {
        return _e === null || markdownLineEnding(_e) ? (V.exit("setextHeadingLine"),
        X(_e)) : J(_e)
    }
}
const flow$1 = {
    tokenize: initializeFlow
};
function initializeFlow(V) {
    const X = this
      , J = V.attempt(blankLine, ne, V.attempt(this.parser.constructs.flowInitial, ue, factorySpace(V, V.attempt(this.parser.constructs.flow, ue, V.attempt(content, ue)), "linePrefix")));
    return J;
    function ne(ce) {
        if (ce === null) {
            V.consume(ce);
            return
        }
        return V.enter("lineEndingBlank"),
        V.consume(ce),
        V.exit("lineEndingBlank"),
        X.currentConstruct = void 0,
        J
    }
    function ue(ce) {
        if (ce === null) {
            V.consume(ce);
            return
        }
        return V.enter("lineEnding"),
        V.consume(ce),
        V.exit("lineEnding"),
        X.currentConstruct = void 0,
        J
    }
}
const resolver = {
    resolveAll: createResolver()
}
  , string$1 = initializeFactory("string")
  , text$2 = initializeFactory("text");
function initializeFactory(V) {
    return {
        resolveAll: createResolver(V === "text" ? resolveAllLineSuffixes : void 0),
        tokenize: X
    };
    function X(J) {
        const ne = this
          , ue = this.parser.constructs[V]
          , ce = J.attempt(ue, me, ge);
        return me;
        function me(Se) {
            return _e(Se) ? ce(Se) : ge(Se)
        }
        function ge(Se) {
            if (Se === null) {
                J.consume(Se);
                return
            }
            return J.enter("data"),
            J.consume(Se),
            Te
        }
        function Te(Se) {
            return _e(Se) ? (J.exit("data"),
            ce(Se)) : (J.consume(Se),
            Te)
        }
        function _e(Se) {
            if (Se === null)
                return !0;
            const Ie = ue[Se];
            let ye = -1;
            if (Ie)
                for (; ++ye < Ie.length; ) {
                    const $e = Ie[ye];
                    if (!$e.previous || $e.previous.call(ne, ne.previous))
                        return !0
                }
            return !1
        }
    }
}
function createResolver(V) {
    return X;
    function X(J, ne) {
        let ue = -1, ce;
        for (; ++ue <= J.length; )
            ce === void 0 ? J[ue] && J[ue][1].type === "data" && (ce = ue,
            ue++) : (!J[ue] || J[ue][1].type !== "data") && (ue !== ce + 2 && (J[ce][1].end = J[ue - 1][1].end,
            J.splice(ce + 2, ue - ce - 2),
            ue = ce + 2),
            ce = void 0);
        return V ? V(J, ne) : J
    }
}
function resolveAllLineSuffixes(V, X) {
    let J = 0;
    for (; ++J <= V.length; )
        if ((J === V.length || V[J][1].type === "lineEnding") && V[J - 1][1].type === "data") {
            const ne = V[J - 1][1]
              , ue = X.sliceStream(ne);
            let ce = ue.length, me = -1, ge = 0, Te;
            for (; ce--; ) {
                const _e = ue[ce];
                if (typeof _e == "string") {
                    for (me = _e.length; _e.charCodeAt(me - 1) === 32; )
                        ge++,
                        me--;
                    if (me)
                        break;
                    me = -1
                } else if (_e === -2)
                    Te = !0,
                    ge++;
                else if (_e !== -1) {
                    ce++;
                    break
                }
            }
            if (ge) {
                const _e = {
                    type: J === V.length || Te || ge < 2 ? "lineSuffix" : "hardBreakTrailing",
                    start: {
                        _bufferIndex: ce ? me : ne.start._bufferIndex + me,
                        _index: ne.start._index + ce,
                        line: ne.end.line,
                        column: ne.end.column - ge,
                        offset: ne.end.offset - ge
                    },
                    end: {
                        ...ne.end
                    }
                };
                ne.end = {
                    ..._e.start
                },
                ne.start.offset === ne.end.offset ? Object.assign(ne, _e) : (V.splice(J, 0, ["enter", _e, X], ["exit", _e, X]),
                J += 2)
            }
            J++
        }
    return V
}
const document$1 = {
    42: list$1,
    43: list$1,
    45: list$1,
    48: list$1,
    49: list$1,
    50: list$1,
    51: list$1,
    52: list$1,
    53: list$1,
    54: list$1,
    55: list$1,
    56: list$1,
    57: list$1,
    62: blockQuote
}
  , contentInitial = {
    91: definition
}
  , flowInitial = {
    [-2]: codeIndented,
    [-1]: codeIndented,
    32: codeIndented
}
  , flow = {
    35: headingAtx,
    42: thematicBreak$1,
    45: [setextUnderline, thematicBreak$1],
    60: htmlFlow,
    61: setextUnderline,
    95: thematicBreak$1,
    96: codeFenced,
    126: codeFenced
}
  , string = {
    38: characterReference,
    92: characterEscape
}
  , text$1 = {
    [-5]: lineEnding,
    [-4]: lineEnding,
    [-3]: lineEnding,
    33: labelStartImage,
    38: characterReference,
    42: attention,
    60: [autolink, htmlText],
    91: labelStartLink,
    92: [hardBreakEscape, characterEscape],
    93: labelEnd,
    95: attention,
    96: codeText
}
  , insideSpan = {
    null: [attention, resolver]
}
  , attentionMarkers = {
    null: [42, 95]
}
  , disable = {
    null: []
}
  , defaultConstructs = Object.freeze(Object.defineProperty({
    __proto__: null,
    attentionMarkers,
    contentInitial,
    disable,
    document: document$1,
    flow,
    flowInitial,
    insideSpan,
    string,
    text: text$1
}, Symbol.toStringTag, {
    value: "Module"
}));
function createTokenizer(V, X, J) {
    let ne = {
        _bufferIndex: -1,
        _index: 0,
        line: J && J.line || 1,
        column: J && J.column || 1,
        offset: J && J.offset || 0
    };
    const ue = {}
      , ce = [];
    let me = []
      , ge = [];
    const Te = {
        attempt: qe(Xe),
        check: qe(ze),
        consume: we,
        enter: Fe,
        exit: je,
        interrupt: qe(ze, {
            interrupt: !0
        })
    }
      , _e = {
        code: null,
        containerState: {},
        defineSkip: ve,
        events: [],
        now: Ne,
        parser: V,
        previous: null,
        sliceSerialize: ye,
        sliceStream: $e,
        write: Ie
    };
    let Se = X.tokenize.call(_e, Te);
    return X.resolveAll && ce.push(X),
    _e;
    function Ie(at) {
        return me = push(me, at),
        ke(),
        me[me.length - 1] !== null ? [] : (Ze(X, 0),
        _e.events = resolveAll(ce, _e.events, _e),
        _e.events)
    }
    function ye(at, rt) {
        return serializeChunks($e(at), rt)
    }
    function $e(at) {
        return sliceChunks(me, at)
    }
    function Ne() {
        const {_bufferIndex: at, _index: rt, line: ft, column: St, offset: Ye} = ne;
        return {
            _bufferIndex: at,
            _index: rt,
            line: ft,
            column: St,
            offset: Ye
        }
    }
    function ve(at) {
        ue[at.line] = at.column,
        it()
    }
    function ke() {
        let at;
        for (; ne._index < me.length; ) {
            const rt = me[ne._index];
            if (typeof rt == "string")
                for (at = ne._index,
                ne._bufferIndex < 0 && (ne._bufferIndex = 0); ne._index === at && ne._bufferIndex < rt.length; )
                    xe(rt.charCodeAt(ne._bufferIndex));
            else
                xe(rt)
        }
    }
    function xe(at) {
        Se = Se(at)
    }
    function we(at) {
        markdownLineEnding(at) ? (ne.line++,
        ne.column = 1,
        ne.offset += at === -3 ? 2 : 1,
        it()) : at !== -1 && (ne.column++,
        ne.offset++),
        ne._bufferIndex < 0 ? ne._index++ : (ne._bufferIndex++,
        ne._bufferIndex === me[ne._index].length && (ne._bufferIndex = -1,
        ne._index++)),
        _e.previous = at
    }
    function Fe(at, rt) {
        const ft = rt || {};
        return ft.type = at,
        ft.start = Ne(),
        _e.events.push(["enter", ft, _e]),
        ge.push(ft),
        ft
    }
    function je(at) {
        const rt = ge.pop();
        return rt.end = Ne(),
        _e.events.push(["exit", rt, _e]),
        rt
    }
    function Xe(at, rt) {
        Ze(at, rt.from)
    }
    function ze(at, rt) {
        rt.restore()
    }
    function qe(at, rt) {
        return ft;
        function ft(St, Ye, We) {
            let nt, ct, Et, Ke;
            return Array.isArray(St) ? lt(St) : "tokenize"in St ? lt([St]) : mt(St);
            function mt(Gt) {
                return Ht;
                function Ht(Kt) {
                    const Ot = Kt !== null && Gt[Kt]
                      , kt = Kt !== null && Gt.null
                      , Xt = [...Array.isArray(Ot) ? Ot : Ot ? [Ot] : [], ...Array.isArray(kt) ? kt : kt ? [kt] : []];
                    return lt(Xt)(Kt)
                }
            }
            function lt(Gt) {
                return nt = Gt,
                ct = 0,
                Gt.length === 0 ? We : Qe(Gt[ct])
            }
            function Qe(Gt) {
                return Ht;
                function Ht(Kt) {
                    return Ke = et(),
                    Et = Gt,
                    Gt.partial || (_e.currentConstruct = Gt),
                    Gt.name && _e.parser.constructs.disable.null.includes(Gt.name) ? Nt() : Gt.tokenize.call(rt ? Object.assign(Object.create(_e), rt) : _e, Te, gt, Nt)(Kt)
                }
            }
            function gt(Gt) {
                return at(Et, Ke),
                Ye
            }
            function Nt(Gt) {
                return Ke.restore(),
                ++ct < nt.length ? Qe(nt[ct]) : We
            }
        }
    }
    function Ze(at, rt) {
        at.resolveAll && !ce.includes(at) && ce.push(at),
        at.resolve && splice(_e.events, rt, _e.events.length - rt, at.resolve(_e.events.slice(rt), _e)),
        at.resolveTo && (_e.events = at.resolveTo(_e.events, _e))
    }
    function et() {
        const at = Ne()
          , rt = _e.previous
          , ft = _e.currentConstruct
          , St = _e.events.length
          , Ye = Array.from(ge);
        return {
            from: St,
            restore: We
        };
        function We() {
            ne = at,
            _e.previous = rt,
            _e.currentConstruct = ft,
            _e.events.length = St,
            ge = Ye,
            it()
        }
    }
    function it() {
        ne.line in ue && ne.column < 2 && (ne.column = ue[ne.line],
        ne.offset += ue[ne.line] - 1)
    }
}
function sliceChunks(V, X) {
    const J = X.start._index
      , ne = X.start._bufferIndex
      , ue = X.end._index
      , ce = X.end._bufferIndex;
    let me;
    if (J === ue)
        me = [V[J].slice(ne, ce)];
    else {
        if (me = V.slice(J, ue),
        ne > -1) {
            const ge = me[0];
            typeof ge == "string" ? me[0] = ge.slice(ne) : me.shift()
        }
        ce > 0 && me.push(V[ue].slice(0, ce))
    }
    return me
}
function serializeChunks(V, X) {
    let J = -1;
    const ne = [];
    let ue;
    for (; ++J < V.length; ) {
        const ce = V[J];
        let me;
        if (typeof ce == "string")
            me = ce;
        else
            switch (ce) {
            case -5:
                {
                    me = "\r";
                    break
                }
            case -4:
                {
                    me = `
`;
                    break
                }
            case -3:
                {
                    me = `\r
`;
                    break
                }
            case -2:
                {
                    me = X ? " " : "	";
                    break
                }
            case -1:
                {
                    if (!X && ue)
                        continue;
                    me = " ";
                    break
                }
            default:
                me = String.fromCharCode(ce)
            }
        ue = ce === -2,
        ne.push(me)
    }
    return ne.join("")
}
function parse(V) {
    const ne = {
        constructs: combineExtensions([defaultConstructs, ...(V || {}).extensions || []]),
        content: ue(content$1),
        defined: [],
        document: ue(document$2),
        flow: ue(flow$1),
        lazy: {},
        string: ue(string$1),
        text: ue(text$2)
    };
    return ne;
    function ue(ce) {
        return me;
        function me(ge) {
            return createTokenizer(ne, ce, ge)
        }
    }
}
function postprocess(V) {
    for (; !subtokenize(V); )
        ;
    return V
}
const search = /[\0\t\n\r]/g;
function preprocess() {
    let V = 1, X = "", J = !0, ne;
    return ue;
    function ue(ce, me, ge) {
        const Te = [];
        let _e, Se, Ie, ye, $e;
        for (ce = X + (typeof ce == "string" ? ce.toString() : new TextDecoder(me || void 0).decode(ce)),
        Ie = 0,
        X = "",
        J && (ce.charCodeAt(0) === 65279 && Ie++,
        J = void 0); Ie < ce.length; ) {
            if (search.lastIndex = Ie,
            _e = search.exec(ce),
            ye = _e && _e.index !== void 0 ? _e.index : ce.length,
            $e = ce.charCodeAt(ye),
            !_e) {
                X = ce.slice(Ie);
                break
            }
            if ($e === 10 && Ie === ye && ne)
                Te.push(-3),
                ne = void 0;
            else
                switch (ne && (Te.push(-5),
                ne = void 0),
                Ie < ye && (Te.push(ce.slice(Ie, ye)),
                V += ye - Ie),
                $e) {
                case 0:
                    {
                        Te.push(65533),
                        V++;
                        break
                    }
                case 9:
                    {
                        for (Se = Math.ceil(V / 4) * 4,
                        Te.push(-2); V++ < Se; )
                            Te.push(-1);
                        break
                    }
                case 10:
                    {
                        Te.push(-4),
                        V = 1;
                        break
                    }
                default:
                    ne = !0,
                    V = 1
                }
            Ie = ye + 1
        }
        return ge && (ne && Te.push(-5),
        X && Te.push(X),
        Te.push(null)),
        Te
    }
}
const characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(V) {
    return V.replace(characterEscapeOrReference, decode)
}
function decode(V, X, J) {
    if (X)
        return X;
    if (J.charCodeAt(0) === 35) {
        const ue = J.charCodeAt(1)
          , ce = ue === 120 || ue === 88;
        return decodeNumericCharacterReference(J.slice(ce ? 2 : 1), ce ? 16 : 10)
    }
    return decodeNamedCharacterReference(J) || V
}
const own$2 = {}.hasOwnProperty;
function fromMarkdown(V, X, J) {
    return typeof X != "string" && (J = X,
    X = void 0),
    compiler(J)(postprocess(parse(J).document().write(preprocess()(V, X, !0))))
}
function compiler(V) {
    const X = {
        transforms: [],
        canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
        enter: {
            autolink: ce(dn),
            autolinkProtocol: et,
            autolinkEmail: et,
            atxHeading: ce(Mt),
            blockQuote: ce(kt),
            characterEscape: et,
            characterReference: et,
            codeFenced: ce(Xt),
            codeFencedFenceInfo: me,
            codeFencedFenceMeta: me,
            codeIndented: ce(Xt, me),
            codeText: ce(vt, me),
            codeTextData: et,
            data: et,
            codeFlowValue: et,
            definition: ce(Jt),
            definitionDestinationString: me,
            definitionLabelString: me,
            definitionTitleString: me,
            emphasis: ce(Ct),
            hardBreakEscape: ce(nn),
            hardBreakTrailing: ce(nn),
            htmlFlow: ce(tn, me),
            htmlFlowData: et,
            htmlText: ce(tn, me),
            htmlTextData: et,
            image: ce(mn),
            label: me,
            link: ce(dn),
            listItem: ce(on),
            listItemValue: ye,
            listOrdered: ce(Qt, Ie),
            listUnordered: ce(Qt),
            paragraph: ce(zt),
            reference: Qe,
            referenceString: me,
            resourceDestinationString: me,
            resourceTitleString: me,
            setextHeading: ce(Mt),
            strong: ce($t),
            thematicBreak: ce(An)
        },
        exit: {
            atxHeading: Te(),
            atxHeadingSequence: Xe,
            autolink: Te(),
            autolinkEmail: Ot,
            autolinkProtocol: Kt,
            blockQuote: Te(),
            characterEscapeValue: it,
            characterReferenceMarkerHexadecimal: Nt,
            characterReferenceMarkerNumeric: Nt,
            characterReferenceValue: Gt,
            characterReference: Ht,
            codeFenced: Te(ke),
            codeFencedFence: ve,
            codeFencedFenceInfo: $e,
            codeFencedFenceMeta: Ne,
            codeFlowValue: it,
            codeIndented: Te(xe),
            codeText: Te(Ye),
            codeTextData: it,
            data: it,
            definition: Te(),
            definitionDestinationString: je,
            definitionLabelString: we,
            definitionTitleString: Fe,
            emphasis: Te(),
            hardBreakEscape: Te(rt),
            hardBreakTrailing: Te(rt),
            htmlFlow: Te(ft),
            htmlFlowData: it,
            htmlText: Te(St),
            htmlTextData: it,
            image: Te(nt),
            label: Et,
            labelText: ct,
            lineEnding: at,
            link: Te(We),
            listItem: Te(),
            listOrdered: Te(),
            listUnordered: Te(),
            paragraph: Te(),
            referenceString: gt,
            resourceDestinationString: Ke,
            resourceTitleString: mt,
            resource: lt,
            setextHeading: Te(Ze),
            setextHeadingLineSequence: qe,
            setextHeadingText: ze,
            strong: Te(),
            thematicBreak: Te()
        }
    };
    configure(X, (V || {}).mdastExtensions || []);
    const J = {};
    return ne;
    function ne(yt) {
        let Dt = {
            type: "root",
            children: []
        };
        const Bt = {
            stack: [Dt],
            tokenStack: [],
            config: X,
            enter: ge,
            exit: _e,
            buffer: me,
            resume: Se,
            data: J
        }
          , Wt = [];
        let ut = -1;
        for (; ++ut < yt.length; )
            if (yt[ut][1].type === "listOrdered" || yt[ut][1].type === "listUnordered")
                if (yt[ut][0] === "enter")
                    Wt.push(ut);
                else {
                    const Ge = Wt.pop();
                    ut = ue(yt, Ge, ut)
                }
        for (ut = -1; ++ut < yt.length; ) {
            const Ge = X[yt[ut][0]];
            own$2.call(Ge, yt[ut][1].type) && Ge[yt[ut][1].type].call(Object.assign({
                sliceSerialize: yt[ut][2].sliceSerialize
            }, Bt), yt[ut][1])
        }
        if (Bt.tokenStack.length > 0) {
            const Ge = Bt.tokenStack[Bt.tokenStack.length - 1];
            (Ge[1] || defaultOnError).call(Bt, void 0, Ge[0])
        }
        for (Dt.position = {
            start: point(yt.length > 0 ? yt[0][1].start : {
                line: 1,
                column: 1,
                offset: 0
            }),
            end: point(yt.length > 0 ? yt[yt.length - 2][1].end : {
                line: 1,
                column: 1,
                offset: 0
            })
        },
        ut = -1; ++ut < X.transforms.length; )
            Dt = X.transforms[ut](Dt) || Dt;
        return Dt
    }
    function ue(yt, Dt, Bt) {
        let Wt = Dt - 1, ut = -1, Ge = !1, st, ht, At, Ft;
        for (; ++Wt <= Bt; ) {
            const an = yt[Wt];
            switch (an[1].type) {
            case "listUnordered":
            case "listOrdered":
            case "blockQuote":
                {
                    an[0] === "enter" ? ut++ : ut--,
                    Ft = void 0;
                    break
                }
            case "lineEndingBlank":
                {
                    an[0] === "enter" && (st && !Ft && !ut && !At && (At = Wt),
                    Ft = void 0);
                    break
                }
            case "linePrefix":
            case "listItemValue":
            case "listItemMarker":
            case "listItemPrefix":
            case "listItemPrefixWhitespace":
                break;
            default:
                Ft = void 0
            }
            if (!ut && an[0] === "enter" && an[1].type === "listItemPrefix" || ut === -1 && an[0] === "exit" && (an[1].type === "listUnordered" || an[1].type === "listOrdered")) {
                if (st) {
                    let Sn = Wt;
                    for (ht = void 0; Sn--; ) {
                        const Rn = yt[Sn];
                        if (Rn[1].type === "lineEnding" || Rn[1].type === "lineEndingBlank") {
                            if (Rn[0] === "exit")
                                continue;
                            ht && (yt[ht][1].type = "lineEndingBlank",
                            Ge = !0),
                            Rn[1].type = "lineEnding",
                            ht = Sn
                        } else if (!(Rn[1].type === "linePrefix" || Rn[1].type === "blockQuotePrefix" || Rn[1].type === "blockQuotePrefixWhitespace" || Rn[1].type === "blockQuoteMarker" || Rn[1].type === "listItemIndent"))
                            break
                    }
                    At && (!ht || At < ht) && (st._spread = !0),
                    st.end = Object.assign({}, ht ? yt[ht][1].start : an[1].end),
                    yt.splice(ht || Wt, 0, ["exit", st, an[2]]),
                    Wt++,
                    Bt++
                }
                if (an[1].type === "listItemPrefix") {
                    const Sn = {
                        type: "listItem",
                        _spread: !1,
                        start: Object.assign({}, an[1].start),
                        end: void 0
                    };
                    st = Sn,
                    yt.splice(Wt, 0, ["enter", Sn, an[2]]),
                    Wt++,
                    Bt++,
                    At = void 0,
                    Ft = !0
                }
            }
        }
        return yt[Dt][1]._spread = Ge,
        Bt
    }
    function ce(yt, Dt) {
        return Bt;
        function Bt(Wt) {
            ge.call(this, yt(Wt), Wt),
            Dt && Dt.call(this, Wt)
        }
    }
    function me() {
        this.stack.push({
            type: "fragment",
            children: []
        })
    }
    function ge(yt, Dt, Bt) {
        this.stack[this.stack.length - 1].children.push(yt),
        this.stack.push(yt),
        this.tokenStack.push([Dt, Bt || void 0]),
        yt.position = {
            start: point(Dt.start),
            end: void 0
        }
    }
    function Te(yt) {
        return Dt;
        function Dt(Bt) {
            yt && yt.call(this, Bt),
            _e.call(this, Bt)
        }
    }
    function _e(yt, Dt) {
        const Bt = this.stack.pop()
          , Wt = this.tokenStack.pop();
        if (Wt)
            Wt[0].type !== yt.type && (Dt ? Dt.call(this, yt, Wt[0]) : (Wt[1] || defaultOnError).call(this, yt, Wt[0]));
        else
            throw new Error("Cannot close `" + yt.type + "` (" + stringifyPosition({
                start: yt.start,
                end: yt.end
            }) + "): it’s not open");
        Bt.position.end = point(yt.end)
    }
    function Se() {
        return toString$1(this.stack.pop())
    }
    function Ie() {
        this.data.expectingFirstListItemValue = !0
    }
    function ye(yt) {
        if (this.data.expectingFirstListItemValue) {
            const Dt = this.stack[this.stack.length - 2];
            Dt.start = Number.parseInt(this.sliceSerialize(yt), 10),
            this.data.expectingFirstListItemValue = void 0
        }
    }
    function $e() {
        const yt = this.resume()
          , Dt = this.stack[this.stack.length - 1];
        Dt.lang = yt
    }
    function Ne() {
        const yt = this.resume()
          , Dt = this.stack[this.stack.length - 1];
        Dt.meta = yt
    }
    function ve() {
        this.data.flowCodeInside || (this.buffer(),
        this.data.flowCodeInside = !0)
    }
    function ke() {
        const yt = this.resume()
          , Dt = this.stack[this.stack.length - 1];
        Dt.value = yt.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""),
        this.data.flowCodeInside = void 0
    }
    function xe() {
        const yt = this.resume()
          , Dt = this.stack[this.stack.length - 1];
        Dt.value = yt.replace(/(\r?\n|\r)$/g, "")
    }
    function we(yt) {
        const Dt = this.resume()
          , Bt = this.stack[this.stack.length - 1];
        Bt.label = Dt,
        Bt.identifier = normalizeIdentifier(this.sliceSerialize(yt)).toLowerCase()
    }
    function Fe() {
        const yt = this.resume()
          , Dt = this.stack[this.stack.length - 1];
        Dt.title = yt
    }
    function je() {
        const yt = this.resume()
          , Dt = this.stack[this.stack.length - 1];
        Dt.url = yt
    }
    function Xe(yt) {
        const Dt = this.stack[this.stack.length - 1];
        if (!Dt.depth) {
            const Bt = this.sliceSerialize(yt).length;
            Dt.depth = Bt
        }
    }
    function ze() {
        this.data.setextHeadingSlurpLineEnding = !0
    }
    function qe(yt) {
        const Dt = this.stack[this.stack.length - 1];
        Dt.depth = this.sliceSerialize(yt).codePointAt(0) === 61 ? 1 : 2
    }
    function Ze() {
        this.data.setextHeadingSlurpLineEnding = void 0
    }
    function et(yt) {
        const Bt = this.stack[this.stack.length - 1].children;
        let Wt = Bt[Bt.length - 1];
        (!Wt || Wt.type !== "text") && (Wt = Ut(),
        Wt.position = {
            start: point(yt.start),
            end: void 0
        },
        Bt.push(Wt)),
        this.stack.push(Wt)
    }
    function it(yt) {
        const Dt = this.stack.pop();
        Dt.value += this.sliceSerialize(yt),
        Dt.position.end = point(yt.end)
    }
    function at(yt) {
        const Dt = this.stack[this.stack.length - 1];
        if (this.data.atHardBreak) {
            const Bt = Dt.children[Dt.children.length - 1];
            Bt.position.end = point(yt.end),
            this.data.atHardBreak = void 0;
            return
        }
        !this.data.setextHeadingSlurpLineEnding && X.canContainEols.includes(Dt.type) && (et.call(this, yt),
        it.call(this, yt))
    }
    function rt() {
        this.data.atHardBreak = !0
    }
    function ft() {
        const yt = this.resume()
          , Dt = this.stack[this.stack.length - 1];
        Dt.value = yt
    }
    function St() {
        const yt = this.resume()
          , Dt = this.stack[this.stack.length - 1];
        Dt.value = yt
    }
    function Ye() {
        const yt = this.resume()
          , Dt = this.stack[this.stack.length - 1];
        Dt.value = yt
    }
    function We() {
        const yt = this.stack[this.stack.length - 1];
        if (this.data.inReference) {
            const Dt = this.data.referenceType || "shortcut";
            yt.type += "Reference",
            yt.referenceType = Dt,
            delete yt.url,
            delete yt.title
        } else
            delete yt.identifier,
            delete yt.label;
        this.data.referenceType = void 0
    }
    function nt() {
        const yt = this.stack[this.stack.length - 1];
        if (this.data.inReference) {
            const Dt = this.data.referenceType || "shortcut";
            yt.type += "Reference",
            yt.referenceType = Dt,
            delete yt.url,
            delete yt.title
        } else
            delete yt.identifier,
            delete yt.label;
        this.data.referenceType = void 0
    }
    function ct(yt) {
        const Dt = this.sliceSerialize(yt)
          , Bt = this.stack[this.stack.length - 2];
        Bt.label = decodeString(Dt),
        Bt.identifier = normalizeIdentifier(Dt).toLowerCase()
    }
    function Et() {
        const yt = this.stack[this.stack.length - 1]
          , Dt = this.resume()
          , Bt = this.stack[this.stack.length - 1];
        if (this.data.inReference = !0,
        Bt.type === "link") {
            const Wt = yt.children;
            Bt.children = Wt
        } else
            Bt.alt = Dt
    }
    function Ke() {
        const yt = this.resume()
          , Dt = this.stack[this.stack.length - 1];
        Dt.url = yt
    }
    function mt() {
        const yt = this.resume()
          , Dt = this.stack[this.stack.length - 1];
        Dt.title = yt
    }
    function lt() {
        this.data.inReference = void 0
    }
    function Qe() {
        this.data.referenceType = "collapsed"
    }
    function gt(yt) {
        const Dt = this.resume()
          , Bt = this.stack[this.stack.length - 1];
        Bt.label = Dt,
        Bt.identifier = normalizeIdentifier(this.sliceSerialize(yt)).toLowerCase(),
        this.data.referenceType = "full"
    }
    function Nt(yt) {
        this.data.characterReferenceType = yt.type
    }
    function Gt(yt) {
        const Dt = this.sliceSerialize(yt)
          , Bt = this.data.characterReferenceType;
        let Wt;
        Bt ? (Wt = decodeNumericCharacterReference(Dt, Bt === "characterReferenceMarkerNumeric" ? 10 : 16),
        this.data.characterReferenceType = void 0) : Wt = decodeNamedCharacterReference(Dt);
        const ut = this.stack[this.stack.length - 1];
        ut.value += Wt
    }
    function Ht(yt) {
        const Dt = this.stack.pop();
        Dt.position.end = point(yt.end)
    }
    function Kt(yt) {
        it.call(this, yt);
        const Dt = this.stack[this.stack.length - 1];
        Dt.url = this.sliceSerialize(yt)
    }
    function Ot(yt) {
        it.call(this, yt);
        const Dt = this.stack[this.stack.length - 1];
        Dt.url = "mailto:" + this.sliceSerialize(yt)
    }
    function kt() {
        return {
            type: "blockquote",
            children: []
        }
    }
    function Xt() {
        return {
            type: "code",
            lang: null,
            meta: null,
            value: ""
        }
    }
    function vt() {
        return {
            type: "inlineCode",
            value: ""
        }
    }
    function Jt() {
        return {
            type: "definition",
            identifier: "",
            label: null,
            title: null,
            url: ""
        }
    }
    function Ct() {
        return {
            type: "emphasis",
            children: []
        }
    }
    function Mt() {
        return {
            type: "heading",
            depth: 0,
            children: []
        }
    }
    function nn() {
        return {
            type: "break"
        }
    }
    function tn() {
        return {
            type: "html",
            value: ""
        }
    }
    function mn() {
        return {
            type: "image",
            title: null,
            url: "",
            alt: null
        }
    }
    function dn() {
        return {
            type: "link",
            title: null,
            url: "",
            children: []
        }
    }
    function Qt(yt) {
        return {
            type: "list",
            ordered: yt.type === "listOrdered",
            start: null,
            spread: yt._spread,
            children: []
        }
    }
    function on(yt) {
        return {
            type: "listItem",
            spread: yt._spread,
            checked: null,
            children: []
        }
    }
    function zt() {
        return {
            type: "paragraph",
            children: []
        }
    }
    function $t() {
        return {
            type: "strong",
            children: []
        }
    }
    function Ut() {
        return {
            type: "text",
            value: ""
        }
    }
    function An() {
        return {
            type: "thematicBreak"
        }
    }
}
function point(V) {
    return {
        line: V.line,
        column: V.column,
        offset: V.offset
    }
}
function configure(V, X) {
    let J = -1;
    for (; ++J < X.length; ) {
        const ne = X[J];
        Array.isArray(ne) ? configure(V, ne) : extension(V, ne)
    }
}
function extension(V, X) {
    let J;
    for (J in X)
        if (own$2.call(X, J))
            switch (J) {
            case "canContainEols":
                {
                    const ne = X[J];
                    ne && V[J].push(...ne);
                    break
                }
            case "transforms":
                {
                    const ne = X[J];
                    ne && V[J].push(...ne);
                    break
                }
            case "enter":
            case "exit":
                {
                    const ne = X[J];
                    ne && Object.assign(V[J], ne);
                    break
                }
            }
}
function defaultOnError(V, X) {
    throw V ? new Error("Cannot close `" + V.type + "` (" + stringifyPosition({
        start: V.start,
        end: V.end
    }) + "): a different token (`" + X.type + "`, " + stringifyPosition({
        start: X.start,
        end: X.end
    }) + ") is open") : new Error("Cannot close document, a token (`" + X.type + "`, " + stringifyPosition({
        start: X.start,
        end: X.end
    }) + ") is still open")
}
function remarkParse(V) {
    const X = this;
    X.parser = J;
    function J(ne) {
        return fromMarkdown(ne, {
            ...X.data("settings"),
            ...V,
            extensions: X.data("micromarkExtensions") || [],
            mdastExtensions: X.data("fromMarkdownExtensions") || []
        })
    }
}
function blockquote(V, X) {
    const J = {
        type: "element",
        tagName: "blockquote",
        properties: {},
        children: V.wrap(V.all(X), !0)
    };
    return V.patch(X, J),
    V.applyData(X, J)
}
function hardBreak(V, X) {
    const J = {
        type: "element",
        tagName: "br",
        properties: {},
        children: []
    };
    return V.patch(X, J),
    [V.applyData(X, J), {
        type: "text",
        value: `
`
    }]
}
function code(V, X) {
    const J = X.value ? X.value + `
` : ""
      , ne = {};
    X.lang && (ne.className = ["language-" + X.lang]);
    let ue = {
        type: "element",
        tagName: "code",
        properties: ne,
        children: [{
            type: "text",
            value: J
        }]
    };
    return X.meta && (ue.data = {
        meta: X.meta
    }),
    V.patch(X, ue),
    ue = V.applyData(X, ue),
    ue = {
        type: "element",
        tagName: "pre",
        properties: {},
        children: [ue]
    },
    V.patch(X, ue),
    ue
}
function strikethrough(V, X) {
    const J = {
        type: "element",
        tagName: "del",
        properties: {},
        children: V.all(X)
    };
    return V.patch(X, J),
    V.applyData(X, J)
}
function emphasis(V, X) {
    const J = {
        type: "element",
        tagName: "em",
        properties: {},
        children: V.all(X)
    };
    return V.patch(X, J),
    V.applyData(X, J)
}
function footnoteReference(V, X) {
    const J = typeof V.options.clobberPrefix == "string" ? V.options.clobberPrefix : "user-content-"
      , ne = String(X.identifier).toUpperCase()
      , ue = normalizeUri(ne.toLowerCase())
      , ce = V.footnoteOrder.indexOf(ne);
    let me, ge = V.footnoteCounts.get(ne);
    ge === void 0 ? (ge = 0,
    V.footnoteOrder.push(ne),
    me = V.footnoteOrder.length) : me = ce + 1,
    ge += 1,
    V.footnoteCounts.set(ne, ge);
    const Te = {
        type: "element",
        tagName: "a",
        properties: {
            href: "#" + J + "fn-" + ue,
            id: J + "fnref-" + ue + (ge > 1 ? "-" + ge : ""),
            dataFootnoteRef: !0,
            ariaDescribedBy: ["footnote-label"]
        },
        children: [{
            type: "text",
            value: String(me)
        }]
    };
    V.patch(X, Te);
    const _e = {
        type: "element",
        tagName: "sup",
        properties: {},
        children: [Te]
    };
    return V.patch(X, _e),
    V.applyData(X, _e)
}
function heading$1(V, X) {
    const J = {
        type: "element",
        tagName: "h" + X.depth,
        properties: {},
        children: V.all(X)
    };
    return V.patch(X, J),
    V.applyData(X, J)
}
function html(V, X) {
    if (V.options.allowDangerousHtml) {
        const J = {
            type: "raw",
            value: X.value
        };
        return V.patch(X, J),
        V.applyData(X, J)
    }
}
function revert(V, X) {
    const J = X.referenceType;
    let ne = "]";
    if (J === "collapsed" ? ne += "[]" : J === "full" && (ne += "[" + (X.label || X.identifier) + "]"),
    X.type === "imageReference")
        return [{
            type: "text",
            value: "![" + X.alt + ne
        }];
    const ue = V.all(X)
      , ce = ue[0];
    ce && ce.type === "text" ? ce.value = "[" + ce.value : ue.unshift({
        type: "text",
        value: "["
    });
    const me = ue[ue.length - 1];
    return me && me.type === "text" ? me.value += ne : ue.push({
        type: "text",
        value: ne
    }),
    ue
}
function imageReference(V, X) {
    const J = String(X.identifier).toUpperCase()
      , ne = V.definitionById.get(J);
    if (!ne)
        return revert(V, X);
    const ue = {
        src: normalizeUri(ne.url || ""),
        alt: X.alt
    };
    ne.title !== null && ne.title !== void 0 && (ue.title = ne.title);
    const ce = {
        type: "element",
        tagName: "img",
        properties: ue,
        children: []
    };
    return V.patch(X, ce),
    V.applyData(X, ce)
}
function image(V, X) {
    const J = {
        src: normalizeUri(X.url)
    };
    X.alt !== null && X.alt !== void 0 && (J.alt = X.alt),
    X.title !== null && X.title !== void 0 && (J.title = X.title);
    const ne = {
        type: "element",
        tagName: "img",
        properties: J,
        children: []
    };
    return V.patch(X, ne),
    V.applyData(X, ne)
}
function inlineCode(V, X) {
    const J = {
        type: "text",
        value: X.value.replace(/\r?\n|\r/g, " ")
    };
    V.patch(X, J);
    const ne = {
        type: "element",
        tagName: "code",
        properties: {},
        children: [J]
    };
    return V.patch(X, ne),
    V.applyData(X, ne)
}
function linkReference(V, X) {
    const J = String(X.identifier).toUpperCase()
      , ne = V.definitionById.get(J);
    if (!ne)
        return revert(V, X);
    const ue = {
        href: normalizeUri(ne.url || "")
    };
    ne.title !== null && ne.title !== void 0 && (ue.title = ne.title);
    const ce = {
        type: "element",
        tagName: "a",
        properties: ue,
        children: V.all(X)
    };
    return V.patch(X, ce),
    V.applyData(X, ce)
}
function link(V, X) {
    const J = {
        href: normalizeUri(X.url)
    };
    X.title !== null && X.title !== void 0 && (J.title = X.title);
    const ne = {
        type: "element",
        tagName: "a",
        properties: J,
        children: V.all(X)
    };
    return V.patch(X, ne),
    V.applyData(X, ne)
}
function listItem$1(V, X, J) {
    const ne = V.all(X)
      , ue = J ? listLoose(J) : listItemLoose(X)
      , ce = {}
      , me = [];
    if (typeof X.checked == "boolean") {
        const Se = ne[0];
        let Ie;
        Se && Se.type === "element" && Se.tagName === "p" ? Ie = Se : (Ie = {
            type: "element",
            tagName: "p",
            properties: {},
            children: []
        },
        ne.unshift(Ie)),
        Ie.children.length > 0 && Ie.children.unshift({
            type: "text",
            value: " "
        }),
        Ie.children.unshift({
            type: "element",
            tagName: "input",
            properties: {
                type: "checkbox",
                checked: X.checked,
                disabled: !0
            },
            children: []
        }),
        ce.className = ["task-list-item"]
    }
    let ge = -1;
    for (; ++ge < ne.length; ) {
        const Se = ne[ge];
        (ue || ge !== 0 || Se.type !== "element" || Se.tagName !== "p") && me.push({
            type: "text",
            value: `
`
        }),
        Se.type === "element" && Se.tagName === "p" && !ue ? me.push(...Se.children) : me.push(Se)
    }
    const Te = ne[ne.length - 1];
    Te && (ue || Te.type !== "element" || Te.tagName !== "p") && me.push({
        type: "text",
        value: `
`
    });
    const _e = {
        type: "element",
        tagName: "li",
        properties: ce,
        children: me
    };
    return V.patch(X, _e),
    V.applyData(X, _e)
}
function listLoose(V) {
    let X = !1;
    if (V.type === "list") {
        X = V.spread || !1;
        const J = V.children;
        let ne = -1;
        for (; !X && ++ne < J.length; )
            X = listItemLoose(J[ne])
    }
    return X
}
function listItemLoose(V) {
    const X = V.spread;
    return X ?? V.children.length > 1
}
function list(V, X) {
    const J = {}
      , ne = V.all(X);
    let ue = -1;
    for (typeof X.start == "number" && X.start !== 1 && (J.start = X.start); ++ue < ne.length; ) {
        const me = ne[ue];
        if (me.type === "element" && me.tagName === "li" && me.properties && Array.isArray(me.properties.className) && me.properties.className.includes("task-list-item")) {
            J.className = ["contains-task-list"];
            break
        }
    }
    const ce = {
        type: "element",
        tagName: X.ordered ? "ol" : "ul",
        properties: J,
        children: V.wrap(ne, !0)
    };
    return V.patch(X, ce),
    V.applyData(X, ce)
}
function paragraph(V, X) {
    const J = {
        type: "element",
        tagName: "p",
        properties: {},
        children: V.all(X)
    };
    return V.patch(X, J),
    V.applyData(X, J)
}
function root$1(V, X) {
    const J = {
        type: "root",
        children: V.wrap(V.all(X))
    };
    return V.patch(X, J),
    V.applyData(X, J)
}
function strong(V, X) {
    const J = {
        type: "element",
        tagName: "strong",
        properties: {},
        children: V.all(X)
    };
    return V.patch(X, J),
    V.applyData(X, J)
}
function table(V, X) {
    const J = V.all(X)
      , ne = J.shift()
      , ue = [];
    if (ne) {
        const me = {
            type: "element",
            tagName: "thead",
            properties: {},
            children: V.wrap([ne], !0)
        };
        V.patch(X.children[0], me),
        ue.push(me)
    }
    if (J.length > 0) {
        const me = {
            type: "element",
            tagName: "tbody",
            properties: {},
            children: V.wrap(J, !0)
        }
          , ge = pointStart(X.children[1])
          , Te = pointEnd(X.children[X.children.length - 1]);
        ge && Te && (me.position = {
            start: ge,
            end: Te
        }),
        ue.push(me)
    }
    const ce = {
        type: "element",
        tagName: "table",
        properties: {},
        children: V.wrap(ue, !0)
    };
    return V.patch(X, ce),
    V.applyData(X, ce)
}
function tableRow(V, X, J) {
    const ne = J ? J.children : void 0
      , ce = (ne ? ne.indexOf(X) : 1) === 0 ? "th" : "td"
      , me = J && J.type === "table" ? J.align : void 0
      , ge = me ? me.length : X.children.length;
    let Te = -1;
    const _e = [];
    for (; ++Te < ge; ) {
        const Ie = X.children[Te]
          , ye = {}
          , $e = me ? me[Te] : void 0;
        $e && (ye.align = $e);
        let Ne = {
            type: "element",
            tagName: ce,
            properties: ye,
            children: []
        };
        Ie && (Ne.children = V.all(Ie),
        V.patch(Ie, Ne),
        Ne = V.applyData(Ie, Ne)),
        _e.push(Ne)
    }
    const Se = {
        type: "element",
        tagName: "tr",
        properties: {},
        children: V.wrap(_e, !0)
    };
    return V.patch(X, Se),
    V.applyData(X, Se)
}
function tableCell(V, X) {
    const J = {
        type: "element",
        tagName: "td",
        properties: {},
        children: V.all(X)
    };
    return V.patch(X, J),
    V.applyData(X, J)
}
const tab = 9
  , space = 32;
function trimLines(V) {
    const X = String(V)
      , J = /\r?\n|\r/g;
    let ne = J.exec(X)
      , ue = 0;
    const ce = [];
    for (; ne; )
        ce.push(trimLine(X.slice(ue, ne.index), ue > 0, !0), ne[0]),
        ue = ne.index + ne[0].length,
        ne = J.exec(X);
    return ce.push(trimLine(X.slice(ue), ue > 0, !1)),
    ce.join("")
}
function trimLine(V, X, J) {
    let ne = 0
      , ue = V.length;
    if (X) {
        let ce = V.codePointAt(ne);
        for (; ce === tab || ce === space; )
            ne++,
            ce = V.codePointAt(ne)
    }
    if (J) {
        let ce = V.codePointAt(ue - 1);
        for (; ce === tab || ce === space; )
            ue--,
            ce = V.codePointAt(ue - 1)
    }
    return ue > ne ? V.slice(ne, ue) : ""
}
function text(V, X) {
    const J = {
        type: "text",
        value: trimLines(String(X.value))
    };
    return V.patch(X, J),
    V.applyData(X, J)
}
function thematicBreak(V, X) {
    const J = {
        type: "element",
        tagName: "hr",
        properties: {},
        children: []
    };
    return V.patch(X, J),
    V.applyData(X, J)
}
const handlers = {
    blockquote,
    break: hardBreak,
    code,
    delete: strikethrough,
    emphasis,
    footnoteReference,
    heading: heading$1,
    html,
    imageReference,
    image,
    inlineCode,
    linkReference,
    link,
    listItem: listItem$1,
    list,
    paragraph,
    root: root$1,
    strong,
    table,
    tableCell,
    tableRow,
    text,
    thematicBreak,
    toml: ignore,
    yaml: ignore,
    definition: ignore,
    footnoteDefinition: ignore
};
function ignore() {}
const VOID = -1
  , PRIMITIVE = 0
  , ARRAY = 1
  , OBJECT = 2
  , DATE = 3
  , REGEXP = 4
  , MAP = 5
  , SET = 6
  , ERROR = 7
  , BIGINT = 8
  , env = typeof self == "object" ? self : globalThis
  , deserializer = (V, X) => {
    const J = (ue, ce) => (V.set(ce, ue),
    ue)
      , ne = ue => {
        if (V.has(ue))
            return V.get(ue);
        const [ce,me] = X[ue];
        switch (ce) {
        case PRIMITIVE:
        case VOID:
            return J(me, ue);
        case ARRAY:
            {
                const ge = J([], ue);
                for (const Te of me)
                    ge.push(ne(Te));
                return ge
            }
        case OBJECT:
            {
                const ge = J({}, ue);
                for (const [Te,_e] of me)
                    ge[ne(Te)] = ne(_e);
                return ge
            }
        case DATE:
            return J(new Date(me), ue);
        case REGEXP:
            {
                const {source: ge, flags: Te} = me;
                return J(new RegExp(ge,Te), ue)
            }
        case MAP:
            {
                const ge = J(new Map, ue);
                for (const [Te,_e] of me)
                    ge.set(ne(Te), ne(_e));
                return ge
            }
        case SET:
            {
                const ge = J(new Set, ue);
                for (const Te of me)
                    ge.add(ne(Te));
                return ge
            }
        case ERROR:
            {
                const {name: ge, message: Te} = me;
                return J(new env[ge](Te), ue)
            }
        case BIGINT:
            return J(BigInt(me), ue);
        case "BigInt":
            return J(Object(BigInt(me)), ue)
        }
        return J(new env[ce](me), ue)
    }
    ;
    return ne
}
  , deserialize = V => deserializer(new Map, V)(0)
  , EMPTY = ""
  , {toString} = {}
  , {keys} = Object
  , typeOf = V => {
    const X = typeof V;
    if (X !== "object" || !V)
        return [PRIMITIVE, X];
    const J = toString.call(V).slice(8, -1);
    switch (J) {
    case "Array":
        return [ARRAY, EMPTY];
    case "Object":
        return [OBJECT, EMPTY];
    case "Date":
        return [DATE, EMPTY];
    case "RegExp":
        return [REGEXP, EMPTY];
    case "Map":
        return [MAP, EMPTY];
    case "Set":
        return [SET, EMPTY]
    }
    return J.includes("Array") ? [ARRAY, J] : J.includes("Error") ? [ERROR, J] : [OBJECT, J]
}
  , shouldSkip = ([V,X]) => V === PRIMITIVE && (X === "function" || X === "symbol")
  , serializer = (V, X, J, ne) => {
    const ue = (me, ge) => {
        const Te = ne.push(me) - 1;
        return J.set(ge, Te),
        Te
    }
      , ce = me => {
        if (J.has(me))
            return J.get(me);
        let[ge,Te] = typeOf(me);
        switch (ge) {
        case PRIMITIVE:
            {
                let Se = me;
                switch (Te) {
                case "bigint":
                    ge = BIGINT,
                    Se = me.toString();
                    break;
                case "function":
                case "symbol":
                    if (V)
                        throw new TypeError("unable to serialize " + Te);
                    Se = null;
                    break;
                case "undefined":
                    return ue([VOID], me)
                }
                return ue([ge, Se], me)
            }
        case ARRAY:
            {
                if (Te)
                    return ue([Te, [...me]], me);
                const Se = []
                  , Ie = ue([ge, Se], me);
                for (const ye of me)
                    Se.push(ce(ye));
                return Ie
            }
        case OBJECT:
            {
                if (Te)
                    switch (Te) {
                    case "BigInt":
                        return ue([Te, me.toString()], me);
                    case "Boolean":
                    case "Number":
                    case "String":
                        return ue([Te, me.valueOf()], me)
                    }
                if (X && "toJSON"in me)
                    return ce(me.toJSON());
                const Se = []
                  , Ie = ue([ge, Se], me);
                for (const ye of keys(me))
                    (V || !shouldSkip(typeOf(me[ye]))) && Se.push([ce(ye), ce(me[ye])]);
                return Ie
            }
        case DATE:
            return ue([ge, me.toISOString()], me);
        case REGEXP:
            {
                const {source: Se, flags: Ie} = me;
                return ue([ge, {
                    source: Se,
                    flags: Ie
                }], me)
            }
        case MAP:
            {
                const Se = []
                  , Ie = ue([ge, Se], me);
                for (const [ye,$e] of me)
                    (V || !(shouldSkip(typeOf(ye)) || shouldSkip(typeOf($e)))) && Se.push([ce(ye), ce($e)]);
                return Ie
            }
        case SET:
            {
                const Se = []
                  , Ie = ue([ge, Se], me);
                for (const ye of me)
                    (V || !shouldSkip(typeOf(ye))) && Se.push(ce(ye));
                return Ie
            }
        }
        const {message: _e} = me;
        return ue([ge, {
            name: Te,
            message: _e
        }], me)
    }
    ;
    return ce
}
  , serialize = (V, {json: X, lossy: J}={}) => {
    const ne = [];
    return serializer(!(X || J), !!X, new Map, ne)(V),
    ne
}
  , structuredClone$1 = typeof structuredClone == "function" ? (V, X) => X && ("json"in X || "lossy"in X) ? deserialize(serialize(V, X)) : structuredClone(V) : (V, X) => deserialize(serialize(V, X));
function defaultFootnoteBackContent(V, X) {
    const J = [{
        type: "text",
        value: "↩"
    }];
    return X > 1 && J.push({
        type: "element",
        tagName: "sup",
        properties: {},
        children: [{
            type: "text",
            value: String(X)
        }]
    }),
    J
}
function defaultFootnoteBackLabel(V, X) {
    return "Back to reference " + (V + 1) + (X > 1 ? "-" + X : "")
}
function footer(V) {
    const X = typeof V.options.clobberPrefix == "string" ? V.options.clobberPrefix : "user-content-"
      , J = V.options.footnoteBackContent || defaultFootnoteBackContent
      , ne = V.options.footnoteBackLabel || defaultFootnoteBackLabel
      , ue = V.options.footnoteLabel || "Footnotes"
      , ce = V.options.footnoteLabelTagName || "h2"
      , me = V.options.footnoteLabelProperties || {
        className: ["sr-only"]
    }
      , ge = [];
    let Te = -1;
    for (; ++Te < V.footnoteOrder.length; ) {
        const _e = V.footnoteById.get(V.footnoteOrder[Te]);
        if (!_e)
            continue;
        const Se = V.all(_e)
          , Ie = String(_e.identifier).toUpperCase()
          , ye = normalizeUri(Ie.toLowerCase());
        let $e = 0;
        const Ne = []
          , ve = V.footnoteCounts.get(Ie);
        for (; ve !== void 0 && ++$e <= ve; ) {
            Ne.length > 0 && Ne.push({
                type: "text",
                value: " "
            });
            let we = typeof J == "string" ? J : J(Te, $e);
            typeof we == "string" && (we = {
                type: "text",
                value: we
            }),
            Ne.push({
                type: "element",
                tagName: "a",
                properties: {
                    href: "#" + X + "fnref-" + ye + ($e > 1 ? "-" + $e : ""),
                    dataFootnoteBackref: "",
                    ariaLabel: typeof ne == "string" ? ne : ne(Te, $e),
                    className: ["data-footnote-backref"]
                },
                children: Array.isArray(we) ? we : [we]
            })
        }
        const ke = Se[Se.length - 1];
        if (ke && ke.type === "element" && ke.tagName === "p") {
            const we = ke.children[ke.children.length - 1];
            we && we.type === "text" ? we.value += " " : ke.children.push({
                type: "text",
                value: " "
            }),
            ke.children.push(...Ne)
        } else
            Se.push(...Ne);
        const xe = {
            type: "element",
            tagName: "li",
            properties: {
                id: X + "fn-" + ye
            },
            children: V.wrap(Se, !0)
        };
        V.patch(_e, xe),
        ge.push(xe)
    }
    if (ge.length !== 0)
        return {
            type: "element",
            tagName: "section",
            properties: {
                dataFootnotes: !0,
                className: ["footnotes"]
            },
            children: [{
                type: "element",
                tagName: ce,
                properties: {
                    ...structuredClone$1(me),
                    id: "footnote-label"
                },
                children: [{
                    type: "text",
                    value: ue
                }]
            }, {
                type: "text",
                value: `
`
            }, {
                type: "element",
                tagName: "ol",
                properties: {},
                children: V.wrap(ge, !0)
            }, {
                type: "text",
                value: `
`
            }]
        }
}
const convert = function(V) {
    if (V == null)
        return ok;
    if (typeof V == "function")
        return castFactory(V);
    if (typeof V == "object")
        return Array.isArray(V) ? anyFactory(V) : propsFactory(V);
    if (typeof V == "string")
        return typeFactory(V);
    throw new Error("Expected function, string, or object as test")
};
function anyFactory(V) {
    const X = [];
    let J = -1;
    for (; ++J < V.length; )
        X[J] = convert(V[J]);
    return castFactory(ne);
    function ne(...ue) {
        let ce = -1;
        for (; ++ce < X.length; )
            if (X[ce].apply(this, ue))
                return !0;
        return !1
    }
}
function propsFactory(V) {
    const X = V;
    return castFactory(J);
    function J(ne) {
        const ue = ne;
        let ce;
        for (ce in V)
            if (ue[ce] !== X[ce])
                return !1;
        return !0
    }
}
function typeFactory(V) {
    return castFactory(X);
    function X(J) {
        return J && J.type === V
    }
}
function castFactory(V) {
    return X;
    function X(J, ne, ue) {
        return !!(looksLikeANode(J) && V.call(this, J, typeof ne == "number" ? ne : void 0, ue || void 0))
    }
}
function ok() {
    return !0
}
function looksLikeANode(V) {
    return V !== null && typeof V == "object" && "type"in V
}
function color(V) {
    return V
}
const empty = []
  , CONTINUE = !0
  , EXIT = !1
  , SKIP = "skip";
function visitParents(V, X, J, ne) {
    let ue;
    typeof X == "function" && typeof J != "function" ? (ne = J,
    J = X) : ue = X;
    const ce = convert(ue)
      , me = ne ? -1 : 1;
    ge(V, void 0, [])();
    function ge(Te, _e, Se) {
        const Ie = Te && typeof Te == "object" ? Te : {};
        if (typeof Ie.type == "string") {
            const $e = typeof Ie.tagName == "string" ? Ie.tagName : typeof Ie.name == "string" ? Ie.name : void 0;
            Object.defineProperty(ye, "name", {
                value: "node (" + (Te.type + ($e ? "<" + $e + ">" : "")) + ")"
            })
        }
        return ye;
        function ye() {
            let $e = empty, Ne, ve, ke;
            if ((!X || ce(Te, _e, Se[Se.length - 1] || void 0)) && ($e = toResult(J(Te, Se)),
            $e[0] === EXIT))
                return $e;
            if ("children"in Te && Te.children) {
                const xe = Te;
                if (xe.children && $e[0] !== SKIP)
                    for (ve = (ne ? xe.children.length : -1) + me,
                    ke = Se.concat(xe); ve > -1 && ve < xe.children.length; ) {
                        const we = xe.children[ve];
                        if (Ne = ge(we, ve, ke)(),
                        Ne[0] === EXIT)
                            return Ne;
                        ve = typeof Ne[1] == "number" ? Ne[1] : ve + me
                    }
            }
            return $e
        }
    }
}
function toResult(V) {
    return Array.isArray(V) ? V : typeof V == "number" ? [CONTINUE, V] : V == null ? empty : [V]
}
function visit(V, X, J, ne) {
    let ue, ce, me;
    typeof X == "function" && typeof J != "function" ? (ce = void 0,
    me = X,
    ue = J) : (ce = X,
    me = J,
    ue = ne),
    visitParents(V, ce, ge, ue);
    function ge(Te, _e) {
        const Se = _e[_e.length - 1]
          , Ie = Se ? Se.children.indexOf(Te) : void 0;
        return me(Te, Ie, Se)
    }
}
const own$1 = {}.hasOwnProperty
  , emptyOptions = {};
function createState(V, X) {
    const J = X || emptyOptions
      , ne = new Map
      , ue = new Map
      , ce = new Map
      , me = {
        ...handlers,
        ...J.handlers
    }
      , ge = {
        all: _e,
        applyData,
        definitionById: ne,
        footnoteById: ue,
        footnoteCounts: ce,
        footnoteOrder: [],
        handlers: me,
        one: Te,
        options: J,
        patch,
        wrap: wrap$1
    };
    return visit(V, function(Se) {
        if (Se.type === "definition" || Se.type === "footnoteDefinition") {
            const Ie = Se.type === "definition" ? ne : ue
              , ye = String(Se.identifier).toUpperCase();
            Ie.has(ye) || Ie.set(ye, Se)
        }
    }),
    ge;
    function Te(Se, Ie) {
        const ye = Se.type
          , $e = ge.handlers[ye];
        if (own$1.call(ge.handlers, ye) && $e)
            return $e(ge, Se, Ie);
        if (ge.options.passThrough && ge.options.passThrough.includes(ye)) {
            if ("children"in Se) {
                const {children: ve, ...ke} = Se
                  , xe = structuredClone$1(ke);
                return xe.children = ge.all(Se),
                xe
            }
            return structuredClone$1(Se)
        }
        return (ge.options.unknownHandler || defaultUnknownHandler)(ge, Se, Ie)
    }
    function _e(Se) {
        const Ie = [];
        if ("children"in Se) {
            const ye = Se.children;
            let $e = -1;
            for (; ++$e < ye.length; ) {
                const Ne = ge.one(ye[$e], Se);
                if (Ne) {
                    if ($e && ye[$e - 1].type === "break" && (!Array.isArray(Ne) && Ne.type === "text" && (Ne.value = trimMarkdownSpaceStart(Ne.value)),
                    !Array.isArray(Ne) && Ne.type === "element")) {
                        const ve = Ne.children[0];
                        ve && ve.type === "text" && (ve.value = trimMarkdownSpaceStart(ve.value))
                    }
                    Array.isArray(Ne) ? Ie.push(...Ne) : Ie.push(Ne)
                }
            }
        }
        return Ie
    }
}
function patch(V, X) {
    V.position && (X.position = position$1(V))
}
function applyData(V, X) {
    let J = X;
    if (V && V.data) {
        const ne = V.data.hName
          , ue = V.data.hChildren
          , ce = V.data.hProperties;
        if (typeof ne == "string")
            if (J.type === "element")
                J.tagName = ne;
            else {
                const me = "children"in J ? J.children : [J];
                J = {
                    type: "element",
                    tagName: ne,
                    properties: {},
                    children: me
                }
            }
        J.type === "element" && ce && Object.assign(J.properties, structuredClone$1(ce)),
        "children"in J && J.children && ue !== null && ue !== void 0 && (J.children = ue)
    }
    return J
}
function defaultUnknownHandler(V, X) {
    const J = X.data || {}
      , ne = "value"in X && !(own$1.call(J, "hProperties") || own$1.call(J, "hChildren")) ? {
        type: "text",
        value: X.value
    } : {
        type: "element",
        tagName: "div",
        properties: {},
        children: V.all(X)
    };
    return V.patch(X, ne),
    V.applyData(X, ne)
}
function wrap$1(V, X) {
    const J = [];
    let ne = -1;
    for (X && J.push({
        type: "text",
        value: `
`
    }); ++ne < V.length; )
        ne && J.push({
            type: "text",
            value: `
`
        }),
        J.push(V[ne]);
    return X && V.length > 0 && J.push({
        type: "text",
        value: `
`
    }),
    J
}
function trimMarkdownSpaceStart(V) {
    let X = 0
      , J = V.charCodeAt(X);
    for (; J === 9 || J === 32; )
        X++,
        J = V.charCodeAt(X);
    return V.slice(X)
}
function toHast(V, X) {
    const J = createState(V, X)
      , ne = J.one(V, void 0)
      , ue = footer(J)
      , ce = Array.isArray(ne) ? {
        type: "root",
        children: ne
    } : ne || {
        type: "root",
        children: []
    };
    return ue && ce.children.push({
        type: "text",
        value: `
`
    }, ue),
    ce
}
function remarkRehype(V, X) {
    return V && "run"in V ? async function(J, ne) {
        const ue = toHast(J, {
            file: ne,
            ...X
        });
        await V.run(ue, ne)
    }
    : function(J, ne) {
        return toHast(J, {
            file: ne,
            ...V || X
        })
    }
}
function bail(V) {
    if (V)
        throw V
}
var hasOwn = Object.prototype.hasOwnProperty
  , toStr = Object.prototype.toString
  , defineProperty = Object.defineProperty
  , gOPD = Object.getOwnPropertyDescriptor
  , isArray = function V(X) {
    return typeof Array.isArray == "function" ? Array.isArray(X) : toStr.call(X) === "[object Array]"
}
  , isPlainObject$1 = function V(X) {
    if (!X || toStr.call(X) !== "[object Object]")
        return !1;
    var J = hasOwn.call(X, "constructor")
      , ne = X.constructor && X.constructor.prototype && hasOwn.call(X.constructor.prototype, "isPrototypeOf");
    if (X.constructor && !J && !ne)
        return !1;
    var ue;
    for (ue in X)
        ;
    return typeof ue > "u" || hasOwn.call(X, ue)
}
  , setProperty = function V(X, J) {
    defineProperty && J.name === "__proto__" ? defineProperty(X, J.name, {
        enumerable: !0,
        configurable: !0,
        value: J.newValue,
        writable: !0
    }) : X[J.name] = J.newValue
}
  , getProperty = function V(X, J) {
    if (J === "__proto__")
        if (hasOwn.call(X, J)) {
            if (gOPD)
                return gOPD(X, J).value
        } else
            return;
    return X[J]
}
  , extend = function V() {
    var X, J, ne, ue, ce, me, ge = arguments[0], Te = 1, _e = arguments.length, Se = !1;
    for (typeof ge == "boolean" && (Se = ge,
    ge = arguments[1] || {},
    Te = 2),
    (ge == null || typeof ge != "object" && typeof ge != "function") && (ge = {}); Te < _e; ++Te)
        if (X = arguments[Te],
        X != null)
            for (J in X)
                ne = getProperty(ge, J),
                ue = getProperty(X, J),
                ge !== ue && (Se && ue && (isPlainObject$1(ue) || (ce = isArray(ue))) ? (ce ? (ce = !1,
                me = ne && isArray(ne) ? ne : []) : me = ne && isPlainObject$1(ne) ? ne : {},
                setProperty(ge, {
                    name: J,
                    newValue: V(Se, me, ue)
                })) : typeof ue < "u" && setProperty(ge, {
                    name: J,
                    newValue: ue
                }));
    return ge
};
const extend$1 = getDefaultExportFromCjs(extend);
function isPlainObject(V) {
    if (typeof V != "object" || V === null)
        return !1;
    const X = Object.getPrototypeOf(V);
    return (X === null || X === Object.prototype || Object.getPrototypeOf(X) === null) && !(Symbol.toStringTag in V) && !(Symbol.iterator in V)
}
function trough() {
    const V = []
      , X = {
        run: J,
        use: ne
    };
    return X;
    function J(...ue) {
        let ce = -1;
        const me = ue.pop();
        if (typeof me != "function")
            throw new TypeError("Expected function as last argument, not " + me);
        ge(null, ...ue);
        function ge(Te, ..._e) {
            const Se = V[++ce];
            let Ie = -1;
            if (Te) {
                me(Te);
                return
            }
            for (; ++Ie < ue.length; )
                (_e[Ie] === null || _e[Ie] === void 0) && (_e[Ie] = ue[Ie]);
            ue = _e,
            Se ? wrap(Se, ge)(..._e) : me(null, ..._e)
        }
    }
    function ne(ue) {
        if (typeof ue != "function")
            throw new TypeError("Expected `middelware` to be a function, not " + ue);
        return V.push(ue),
        X
    }
}
function wrap(V, X) {
    let J;
    return ne;
    function ne(...me) {
        const ge = V.length > me.length;
        let Te;
        ge && me.push(ue);
        try {
            Te = V.apply(this, me)
        } catch (_e) {
            const Se = _e;
            if (ge && J)
                throw Se;
            return ue(Se)
        }
        ge || (Te && Te.then && typeof Te.then == "function" ? Te.then(ce, ue) : Te instanceof Error ? ue(Te) : ce(Te))
    }
    function ue(me, ...ge) {
        J || (J = !0,
        X(me, ...ge))
    }
    function ce(me) {
        ue(null, me)
    }
}
const minpath = {
    basename,
    dirname,
    extname,
    join,
    sep: "/"
};
function basename(V, X) {
    if (X !== void 0 && typeof X != "string")
        throw new TypeError('"ext" argument must be a string');
    assertPath$1(V);
    let J = 0, ne = -1, ue = V.length, ce;
    if (X === void 0 || X.length === 0 || X.length > V.length) {
        for (; ue--; )
            if (V.codePointAt(ue) === 47) {
                if (ce) {
                    J = ue + 1;
                    break
                }
            } else
                ne < 0 && (ce = !0,
                ne = ue + 1);
        return ne < 0 ? "" : V.slice(J, ne)
    }
    if (X === V)
        return "";
    let me = -1
      , ge = X.length - 1;
    for (; ue--; )
        if (V.codePointAt(ue) === 47) {
            if (ce) {
                J = ue + 1;
                break
            }
        } else
            me < 0 && (ce = !0,
            me = ue + 1),
            ge > -1 && (V.codePointAt(ue) === X.codePointAt(ge--) ? ge < 0 && (ne = ue) : (ge = -1,
            ne = me));
    return J === ne ? ne = me : ne < 0 && (ne = V.length),
    V.slice(J, ne)
}
function dirname(V) {
    if (assertPath$1(V),
    V.length === 0)
        return ".";
    let X = -1, J = V.length, ne;
    for (; --J; )
        if (V.codePointAt(J) === 47) {
            if (ne) {
                X = J;
                break
            }
        } else
            ne || (ne = !0);
    return X < 0 ? V.codePointAt(0) === 47 ? "/" : "." : X === 1 && V.codePointAt(0) === 47 ? "//" : V.slice(0, X)
}
function extname(V) {
    assertPath$1(V);
    let X = V.length, J = -1, ne = 0, ue = -1, ce = 0, me;
    for (; X--; ) {
        const ge = V.codePointAt(X);
        if (ge === 47) {
            if (me) {
                ne = X + 1;
                break
            }
            continue
        }
        J < 0 && (me = !0,
        J = X + 1),
        ge === 46 ? ue < 0 ? ue = X : ce !== 1 && (ce = 1) : ue > -1 && (ce = -1)
    }
    return ue < 0 || J < 0 || ce === 0 || ce === 1 && ue === J - 1 && ue === ne + 1 ? "" : V.slice(ue, J)
}
function join(...V) {
    let X = -1, J;
    for (; ++X < V.length; )
        assertPath$1(V[X]),
        V[X] && (J = J === void 0 ? V[X] : J + "/" + V[X]);
    return J === void 0 ? "." : normalize(J)
}
function normalize(V) {
    assertPath$1(V);
    const X = V.codePointAt(0) === 47;
    let J = normalizeString(V, !X);
    return J.length === 0 && !X && (J = "."),
    J.length > 0 && V.codePointAt(V.length - 1) === 47 && (J += "/"),
    X ? "/" + J : J
}
function normalizeString(V, X) {
    let J = "", ne = 0, ue = -1, ce = 0, me = -1, ge, Te;
    for (; ++me <= V.length; ) {
        if (me < V.length)
            ge = V.codePointAt(me);
        else {
            if (ge === 47)
                break;
            ge = 47
        }
        if (ge === 47) {
            if (!(ue === me - 1 || ce === 1))
                if (ue !== me - 1 && ce === 2) {
                    if (J.length < 2 || ne !== 2 || J.codePointAt(J.length - 1) !== 46 || J.codePointAt(J.length - 2) !== 46) {
                        if (J.length > 2) {
                            if (Te = J.lastIndexOf("/"),
                            Te !== J.length - 1) {
                                Te < 0 ? (J = "",
                                ne = 0) : (J = J.slice(0, Te),
                                ne = J.length - 1 - J.lastIndexOf("/")),
                                ue = me,
                                ce = 0;
                                continue
                            }
                        } else if (J.length > 0) {
                            J = "",
                            ne = 0,
                            ue = me,
                            ce = 0;
                            continue
                        }
                    }
                    X && (J = J.length > 0 ? J + "/.." : "..",
                    ne = 2)
                } else
                    J.length > 0 ? J += "/" + V.slice(ue + 1, me) : J = V.slice(ue + 1, me),
                    ne = me - ue - 1;
            ue = me,
            ce = 0
        } else
            ge === 46 && ce > -1 ? ce++ : ce = -1
    }
    return J
}
function assertPath$1(V) {
    if (typeof V != "string")
        throw new TypeError("Path must be a string. Received " + JSON.stringify(V))
}
const minproc = {
    cwd
};
function cwd() {
    return "/"
}
function isUrl(V) {
    return !!(V !== null && typeof V == "object" && "href"in V && V.href && "protocol"in V && V.protocol && V.auth === void 0)
}
function urlToPath(V) {
    if (typeof V == "string")
        V = new URL(V);
    else if (!isUrl(V)) {
        const X = new TypeError('The "path" argument must be of type string or an instance of URL. Received `' + V + "`");
        throw X.code = "ERR_INVALID_ARG_TYPE",
        X
    }
    if (V.protocol !== "file:") {
        const X = new TypeError("The URL must be of scheme file");
        throw X.code = "ERR_INVALID_URL_SCHEME",
        X
    }
    return getPathFromURLPosix(V)
}
function getPathFromURLPosix(V) {
    if (V.hostname !== "") {
        const ne = new TypeError('File URL host must be "localhost" or empty on darwin');
        throw ne.code = "ERR_INVALID_FILE_URL_HOST",
        ne
    }
    const X = V.pathname;
    let J = -1;
    for (; ++J < X.length; )
        if (X.codePointAt(J) === 37 && X.codePointAt(J + 1) === 50) {
            const ne = X.codePointAt(J + 2);
            if (ne === 70 || ne === 102) {
                const ue = new TypeError("File URL path must not include encoded / characters");
                throw ue.code = "ERR_INVALID_FILE_URL_PATH",
                ue
            }
        }
    return decodeURIComponent(X)
}
const order = ["history", "path", "basename", "stem", "extname", "dirname"];
class VFile {
    constructor(X) {
        let J;
        X ? isUrl(X) ? J = {
            path: X
        } : typeof X == "string" || isUint8Array$1(X) ? J = {
            value: X
        } : J = X : J = {},
        this.cwd = "cwd"in J ? "" : minproc.cwd(),
        this.data = {},
        this.history = [],
        this.messages = [],
        this.value,
        this.map,
        this.result,
        this.stored;
        let ne = -1;
        for (; ++ne < order.length; ) {
            const ce = order[ne];
            ce in J && J[ce] !== void 0 && J[ce] !== null && (this[ce] = ce === "history" ? [...J[ce]] : J[ce])
        }
        let ue;
        for (ue in J)
            order.includes(ue) || (this[ue] = J[ue])
    }
    get basename() {
        return typeof this.path == "string" ? minpath.basename(this.path) : void 0
    }
    set basename(X) {
        assertNonEmpty(X, "basename"),
        assertPart(X, "basename"),
        this.path = minpath.join(this.dirname || "", X)
    }
    get dirname() {
        return typeof this.path == "string" ? minpath.dirname(this.path) : void 0
    }
    set dirname(X) {
        assertPath(this.basename, "dirname"),
        this.path = minpath.join(X || "", this.basename)
    }
    get extname() {
        return typeof this.path == "string" ? minpath.extname(this.path) : void 0
    }
    set extname(X) {
        if (assertPart(X, "extname"),
        assertPath(this.dirname, "extname"),
        X) {
            if (X.codePointAt(0) !== 46)
                throw new Error("`extname` must start with `.`");
            if (X.includes(".", 1))
                throw new Error("`extname` cannot contain multiple dots")
        }
        this.path = minpath.join(this.dirname, this.stem + (X || ""))
    }
    get path() {
        return this.history[this.history.length - 1]
    }
    set path(X) {
        isUrl(X) && (X = urlToPath(X)),
        assertNonEmpty(X, "path"),
        this.path !== X && this.history.push(X)
    }
    get stem() {
        return typeof this.path == "string" ? minpath.basename(this.path, this.extname) : void 0
    }
    set stem(X) {
        assertNonEmpty(X, "stem"),
        assertPart(X, "stem"),
        this.path = minpath.join(this.dirname || "", X + (this.extname || ""))
    }
    fail(X, J, ne) {
        const ue = this.message(X, J, ne);
        throw ue.fatal = !0,
        ue
    }
    info(X, J, ne) {
        const ue = this.message(X, J, ne);
        return ue.fatal = void 0,
        ue
    }
    message(X, J, ne) {
        const ue = new VFileMessage(X,J,ne);
        return this.path && (ue.name = this.path + ":" + ue.name,
        ue.file = this.path),
        ue.fatal = !1,
        this.messages.push(ue),
        ue
    }
    toString(X) {
        return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(X || void 0).decode(this.value)
    }
}
function assertPart(V, X) {
    if (V && V.includes(minpath.sep))
        throw new Error("`" + X + "` cannot be a path: did not expect `" + minpath.sep + "`")
}
function assertNonEmpty(V, X) {
    if (!V)
        throw new Error("`" + X + "` cannot be empty")
}
function assertPath(V, X) {
    if (!V)
        throw new Error("Setting `" + X + "` requires `path` to be set too")
}
function isUint8Array$1(V) {
    return !!(V && typeof V == "object" && "byteLength"in V && "byteOffset"in V)
}
const CallableInstance = function(V) {
    const ne = this.constructor.prototype
      , ue = ne[V]
      , ce = function() {
        return ue.apply(ce, arguments)
    };
    return Object.setPrototypeOf(ce, ne),
    ce
}
  , own = {}.hasOwnProperty;
class Processor extends CallableInstance {
    constructor() {
        super("copy"),
        this.Compiler = void 0,
        this.Parser = void 0,
        this.attachers = [],
        this.compiler = void 0,
        this.freezeIndex = -1,
        this.frozen = void 0,
        this.namespace = {},
        this.parser = void 0,
        this.transformers = trough()
    }
    copy() {
        const X = new Processor;
        let J = -1;
        for (; ++J < this.attachers.length; ) {
            const ne = this.attachers[J];
            X.use(...ne)
        }
        return X.data(extend$1(!0, {}, this.namespace)),
        X
    }
    data(X, J) {
        return typeof X == "string" ? arguments.length === 2 ? (assertUnfrozen("data", this.frozen),
        this.namespace[X] = J,
        this) : own.call(this.namespace, X) && this.namespace[X] || void 0 : X ? (assertUnfrozen("data", this.frozen),
        this.namespace = X,
        this) : this.namespace
    }
    freeze() {
        if (this.frozen)
            return this;
        const X = this;
        for (; ++this.freezeIndex < this.attachers.length; ) {
            const [J,...ne] = this.attachers[this.freezeIndex];
            if (ne[0] === !1)
                continue;
            ne[0] === !0 && (ne[0] = void 0);
            const ue = J.call(X, ...ne);
            typeof ue == "function" && this.transformers.use(ue)
        }
        return this.frozen = !0,
        this.freezeIndex = Number.POSITIVE_INFINITY,
        this
    }
    parse(X) {
        this.freeze();
        const J = vfile(X)
          , ne = this.parser || this.Parser;
        return assertParser("parse", ne),
        ne(String(J), J)
    }
    process(X, J) {
        const ne = this;
        return this.freeze(),
        assertParser("process", this.parser || this.Parser),
        assertCompiler("process", this.compiler || this.Compiler),
        J ? ue(void 0, J) : new Promise(ue);
        function ue(ce, me) {
            const ge = vfile(X)
              , Te = ne.parse(ge);
            ne.run(Te, ge, function(Se, Ie, ye) {
                if (Se || !Ie || !ye)
                    return _e(Se);
                const $e = Ie
                  , Ne = ne.stringify($e, ye);
                looksLikeAValue(Ne) ? ye.value = Ne : ye.result = Ne,
                _e(Se, ye)
            });
            function _e(Se, Ie) {
                Se || !Ie ? me(Se) : ce ? ce(Ie) : J(void 0, Ie)
            }
        }
    }
    processSync(X) {
        let J = !1, ne;
        return this.freeze(),
        assertParser("processSync", this.parser || this.Parser),
        assertCompiler("processSync", this.compiler || this.Compiler),
        this.process(X, ue),
        assertDone("processSync", "process", J),
        ne;
        function ue(ce, me) {
            J = !0,
            bail(ce),
            ne = me
        }
    }
    run(X, J, ne) {
        assertNode(X),
        this.freeze();
        const ue = this.transformers;
        return !ne && typeof J == "function" && (ne = J,
        J = void 0),
        ne ? ce(void 0, ne) : new Promise(ce);
        function ce(me, ge) {
            const Te = vfile(J);
            ue.run(X, Te, _e);
            function _e(Se, Ie, ye) {
                const $e = Ie || X;
                Se ? ge(Se) : me ? me($e) : ne(void 0, $e, ye)
            }
        }
    }
    runSync(X, J) {
        let ne = !1, ue;
        return this.run(X, J, ce),
        assertDone("runSync", "run", ne),
        ue;
        function ce(me, ge) {
            bail(me),
            ue = ge,
            ne = !0
        }
    }
    stringify(X, J) {
        this.freeze();
        const ne = vfile(J)
          , ue = this.compiler || this.Compiler;
        return assertCompiler("stringify", ue),
        assertNode(X),
        ue(X, ne)
    }
    use(X, ...J) {
        const ne = this.attachers
          , ue = this.namespace;
        if (assertUnfrozen("use", this.frozen),
        X != null)
            if (typeof X == "function")
                Te(X, J);
            else if (typeof X == "object")
                Array.isArray(X) ? ge(X) : me(X);
            else
                throw new TypeError("Expected usable value, not `" + X + "`");
        return this;
        function ce(_e) {
            if (typeof _e == "function")
                Te(_e, []);
            else if (typeof _e == "object")
                if (Array.isArray(_e)) {
                    const [Se,...Ie] = _e;
                    Te(Se, Ie)
                } else
                    me(_e);
            else
                throw new TypeError("Expected usable value, not `" + _e + "`")
        }
        function me(_e) {
            if (!("plugins"in _e) && !("settings"in _e))
                throw new Error("Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither");
            ge(_e.plugins),
            _e.settings && (ue.settings = extend$1(!0, ue.settings, _e.settings))
        }
        function ge(_e) {
            let Se = -1;
            if (_e != null)
                if (Array.isArray(_e))
                    for (; ++Se < _e.length; ) {
                        const Ie = _e[Se];
                        ce(Ie)
                    }
                else
                    throw new TypeError("Expected a list of plugins, not `" + _e + "`")
        }
        function Te(_e, Se) {
            let Ie = -1
              , ye = -1;
            for (; ++Ie < ne.length; )
                if (ne[Ie][0] === _e) {
                    ye = Ie;
                    break
                }
            if (ye === -1)
                ne.push([_e, ...Se]);
            else if (Se.length > 0) {
                let[$e,...Ne] = Se;
                const ve = ne[ye][1];
                isPlainObject(ve) && isPlainObject($e) && ($e = extend$1(!0, ve, $e)),
                ne[ye] = [_e, $e, ...Ne]
            }
        }
    }
}
const unified = new Processor().freeze();
function assertParser(V, X) {
    if (typeof X != "function")
        throw new TypeError("Cannot `" + V + "` without `parser`")
}
function assertCompiler(V, X) {
    if (typeof X != "function")
        throw new TypeError("Cannot `" + V + "` without `compiler`")
}
function assertUnfrozen(V, X) {
    if (X)
        throw new Error("Cannot call `" + V + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.")
}
function assertNode(V) {
    if (!isPlainObject(V) || typeof V.type != "string")
        throw new TypeError("Expected node, got `" + V + "`")
}
function assertDone(V, X, J) {
    if (!J)
        throw new Error("`" + V + "` finished async. Use `" + X + "` instead")
}
function vfile(V) {
    return looksLikeAVFile(V) ? V : new VFile(V)
}
function looksLikeAVFile(V) {
    return !!(V && typeof V == "object" && "message"in V && "messages"in V)
}
function looksLikeAValue(V) {
    return typeof V == "string" || isUint8Array(V)
}
function isUint8Array(V) {
    return !!(V && typeof V == "object" && "byteLength"in V && "byteOffset"in V)
}
const changelog = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md"
  , emptyPlugins = []
  , emptyRemarkRehypeOptions = {
    allowDangerousHtml: !0
}
  , safeProtocol = /^(https?|ircs?|mailto|xmpp)$/i
  , deprecations = [{
    from: "astPlugins",
    id: "remove-buggy-html-in-markdown-parser"
}, {
    from: "allowDangerousHtml",
    id: "remove-buggy-html-in-markdown-parser"
}, {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
}, {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
}, {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
}, {
    from: "escapeHtml",
    id: "remove-buggy-html-in-markdown-parser"
}, {
    from: "includeElementIndex",
    id: "#remove-includeelementindex"
}, {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
}, {
    from: "linkTarget",
    id: "remove-linktarget"
}, {
    from: "plugins",
    id: "change-plugins-to-remarkplugins",
    to: "remarkPlugins"
}, {
    from: "rawSourcePos",
    id: "#remove-rawsourcepos"
}, {
    from: "renderers",
    id: "change-renderers-to-components",
    to: "components"
}, {
    from: "source",
    id: "change-source-to-children",
    to: "children"
}, {
    from: "sourcePos",
    id: "#remove-sourcepos"
}, {
    from: "transformImageUri",
    id: "#add-urltransform",
    to: "urlTransform"
}, {
    from: "transformLinkUri",
    id: "#add-urltransform",
    to: "urlTransform"
}];
function Markdown(V) {
    const X = V.allowedElements
      , J = V.allowElement
      , ne = V.children || ""
      , ue = V.className
      , ce = V.components
      , me = V.disallowedElements
      , ge = V.rehypePlugins || emptyPlugins
      , Te = V.remarkPlugins || emptyPlugins
      , _e = V.remarkRehypeOptions ? {
        ...V.remarkRehypeOptions,
        ...emptyRemarkRehypeOptions
    } : emptyRemarkRehypeOptions
      , Se = V.skipHtml
      , Ie = V.unwrapDisallowed
      , ye = V.urlTransform || defaultUrlTransform
      , $e = unified().use(remarkParse).use(Te).use(remarkRehype, _e).use(ge)
      , Ne = new VFile;
    typeof ne == "string" && (Ne.value = ne);
    for (const we of deprecations)
        Object.hasOwn(V, we.from) && ("" + we.from + (we.to ? "use `" + we.to + "` instead" : "remove it") + changelog + we.id,
        void 0);
    const ve = $e.parse(Ne);
    let ke = $e.runSync(ve, Ne);
    return ue && (ke = {
        type: "element",
        tagName: "div",
        properties: {
            className: ue
        },
        children: ke.type === "root" ? ke.children : [ke]
    }),
    visit(ke, xe),
    toJsxRuntime(ke, {
        Fragment: jsxRuntimeExports.Fragment,
        components: ce,
        ignoreInvalidStyle: !0,
        jsx: jsxRuntimeExports.jsx,
        jsxs: jsxRuntimeExports.jsxs,
        passKeys: !0,
        passNode: !0
    });
    function xe(we, Fe, je) {
        if (we.type === "raw" && je && typeof Fe == "number")
            return Se ? je.children.splice(Fe, 1) : je.children[Fe] = {
                type: "text",
                value: we.value
            },
            Fe;
        if (we.type === "element") {
            let Xe;
            for (Xe in urlAttributes)
                if (Object.hasOwn(urlAttributes, Xe) && Object.hasOwn(we.properties, Xe)) {
                    const ze = we.properties[Xe]
                      , qe = urlAttributes[Xe];
                    (qe === null || qe.includes(we.tagName)) && (we.properties[Xe] = ye(String(ze || ""), Xe, we))
                }
        }
        if (we.type === "element") {
            let Xe = X ? !X.includes(we.tagName) : me ? me.includes(we.tagName) : !1;
            if (!Xe && J && typeof Fe == "number" && (Xe = !J(we, Fe, je)),
            Xe && je && typeof Fe == "number")
                return Ie && we.children ? je.children.splice(Fe, 1, ...we.children) : je.children.splice(Fe, 1),
                Fe
        }
    }
}
function defaultUrlTransform(V) {
    const X = V.indexOf(":")
      , J = V.indexOf("?")
      , ne = V.indexOf("#")
      , ue = V.indexOf("/");
    return X < 0 || ue > -1 && X > ue || J > -1 && X > J || ne > -1 && X > ne || safeProtocol.test(V.slice(0, X)) ? V : ""
}
const blocklyHelp = "_blocklyHelp_jss20_1"
  , injectionDiv = "_injectionDiv_jss20_7"
  , helpFlyoutContainer = "_helpFlyoutContainer_jss20_36"
  , helpFlyout = "_helpFlyout_jss20_36"
  , blocklyFlyoutScrollbar = "_blocklyFlyoutScrollbar_jss20_47"
  , blocklyFlyout = "_blocklyFlyout_jss20_47"
  , blocklyFlyoutBackground = "_blocklyFlyoutBackground_jss20_60"
  , message = "_message_jss20_64"
  , styles$f = {
    blocklyHelp,
    injectionDiv,
    helpFlyoutContainer,
    helpFlyout,
    blocklyFlyoutScrollbar,
    blocklyFlyout,
    blocklyFlyoutBackground,
    message
}
  , logger$8 = Logger$1.get("BlocklyHelp")
  , INJECT_BLOCKLY_TIME_MS = 50
  , codeBlockComponent = V => function({children: J}) {
    const ne = reactExports.useRef(generateUUID());
    if (!V || !J)
        throw new Error("Missing PyriteBlockly for code renderer");
    const ue = J.toString();
    if (ue.startsWith("<")) {
        const ce = new blocklyExports.Options({
            scrollbars: !0,
            parentWorkspace: V.mainWorkspace,
            rtl: V.mainWorkspace.RTL,
            oneBasedIndex: V.mainWorkspace.options.oneBasedIndex,
            renderer: V.mainWorkspace.options.renderer,
            rendererOverrides: V.mainWorkspace.options.rendererOverrides ?? void 0,
            sounds: !1,
            zoom: {
                controls: !1,
                pinch: !1,
                scaleSpeed: 0,
                wheel: !1
            },
            move: {
                scrollbars: !0,
                drag: !1,
                wheel: !1
            }
        })
          , me = blocklyExports.registry.getClassFromOptions(blocklyExports.registry.Type.FLYOUTS_HORIZONTAL_TOOLBOX, V.mainWorkspace.options, !0)
          , ge = new me(ce);
        ge.autoClose = !1,
        ge.MARGIN = 0;
        const Te = V.mainWorkspace.getRenderer().getClassName()
          , _e = V.mainWorkspace.getTheme().getClassName();
        let Se;
        const Ie = () => {
            var $e;
            if (!V)
                throw new Error("Missing PyriteBlockly for help text flyout");
            const ye = document.body.querySelector(`.${styles$f.helpFlyout}.hash-${ne.current} svg`);
            if (ye) {
                clearTimeout(Se);
                const Ne = ge.createDom(blocklyExports.utils.Svg.SVG);
                blocklyExports.utils.dom.insertAfter(Ne, ye),
                ge.init(V.mainWorkspace);
                try {
                    const xe = blocklyExports.utils.xml.textToDom(ue);
                    ge.show([xe])
                } catch (xe) {
                    logger$8.error(xe)
                }
                const ve = Math.ceil(ge.getWorkspace().getMetrics().scrollWidth) + 50
                  , ke = ge.getWorkspace().getInjectionDiv();
                ke.setAttribute("style", `width: ${ve}px;position: static;`),
                window.flyout = ge,
                blocklyExports.utils.dom.removeNode(ye),
                ($e = ke.querySelector(".blocklyFlyout")) == null || $e.classList.add(styles$f.blocklyFlyout)
            } else
                Se = setTimeout(Ie, INJECT_BLOCKLY_TIME_MS)
        }
        ;
        return Se = setTimeout(Ie, INJECT_BLOCKLY_TIME_MS),
        jsxRuntimeExports.jsx("div", {
            className: styles$f.helpFlyoutContainer,
            children: jsxRuntimeExports.jsx("div", {
                className: common_utils.classNames("injectionDiv", styles$f.helpFlyout, Te, _e, `hash-${ne.current}`),
                children: jsxRuntimeExports.jsx("svg", {})
            })
        })
    } else
        return jsxRuntimeExports.jsx("code", {
            children: ue
        })
}
  , BlocklyHelp = ({blockType: V, pyriteBlockly: X}) => {
    const {helpText: J, isFetching: ne, error: ue} = useHelpTextQuery(V, !!V);
    return jsxRuntimeExports.jsx(OffCanvasContent, {
        id: DIALOG_ID.RULES_EDITOR_HELP_PANEL,
        header: t$1("general.help"),
        footer: "",
        children: ue ? jsxRuntimeExports.jsx(Paragraph, {
            className: styles$f.message,
            children: `${ue}`
        }) : ne ? jsxRuntimeExports.jsx(Heading, {
            className: styles$f.message,
            children: t$1("general.loading")
        }) : jsxRuntimeExports.jsx(Markdown, {
            className: common_utils.classNames(styles$f.blocklyHelp, "blockly-help"),
            components: {
                pre: ({children: ce}) => jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
                    children: ce
                }),
                code: codeBlockComponent(X)
            },
            children: t$1(J)
        })
    })
}
  , useAsync = !1
  , awaitString = ""
  , INDENT_STR = " "
  , MOD_MODULE = "mod."
  , MOD_LIB_MODULE = "modlib."
  , MOD_INCLUDES_STR = `
import * as modlib from 'modlib';
`
  , EVENT_TYPE_LOOKUP = new Map([["OtherPlayer", "Player"]])
  , logger$7 = Logger$1.get("ModRulesUtil")
  , warningLogs = new Map
  , addWarning = (V, X) => {
    var J;
    warningLogs.has(V) ? (J = warningLogs.get(V)) == null || J.push(X) : warningLogs.set(V, [X])
}
  , BASE_MOD_CONTEXT = {
    maxGlobalVariableNum: 0,
    objectVarKinds: ["Player", "Team", "CapturePoint"],
    eventParameterFunctions: ["EventPlayer", "EventOtherPlayer", "EventDamageType", "EventMCOM"],
    eventParameters: new Map([["OnGameModeStarted", {
        parameters: [],
        type: "Global",
        info: []
    }], ["OngoingGlobal", {
        parameters: [],
        type: "Global",
        info: []
    }], ["OnPlayerEarnedKill", {
        parameters: ["eventPlayer: any", "evenOtherPlayer: any", "eventDeathType: any", "eventWeaponUnlock: any"],
        type: "Player",
        info: ["eventPlayer: eventPlayer", "evenOtherPlayer: evenOtherPlayer", "eventDeathType: eventDeathType", "eventWeaponUnlock: eventWeaponUnlock"]
    }], ["OnMCOMArmed", {
        parameters: ["eventPlayer: any"],
        type: "Player",
        info: ["eventPlayer: eventPlayer"]
    }]]),
    maxObjectVariableNum: {},
    eventCounts: new Map,
    stringParameters: [],
    eventFunctionNames: new Set,
    eventSubroutineNames: new Set
}
  , getModConvertContext = () => BASE_MOD_CONTEXT
  , BASE_MOD_RULES = {
    events: new Map,
    subroutines: new Map
}
  , BASE_MOD_VARS = {
    player: [],
    team: [],
    global: [],
    capturePoint: [],
    mcom: [],
    vehicle: []
}
  , init$1 = V => {
    const X = getModConvertContext()
      , J = V.objects.map( ({name: ue}) => ue)
      , ne = new Map(X.eventParameters);
    return J.forEach(ue => {
        const ce = {
            parameters: [`event${ue}: ${MOD_MODULE}${ue}`],
            type: ue,
            info: [`event${ue}: event${ue}`]
        };
        ne.set(`Ongoing${ue}`, ce)
    }
    ),
    {
        ...X,
        objectVarKinds: J,
        eventParameterFunctions: V.values.reduce( (ue, {name: ce, functionSignatures: me}) => (!ce.startsWith("Event") || (me == null ? void 0 : me.length) != 1 || me[0].parameterTypes || ue.push(ce),
        ue), []),
        eventParameters: V.events.reduce( (ue, {name: ce, parameters: me=[]}) => {
            ue.has(ce) || ue.set(ce, {
                parameters: [],
                type: "Global",
                info: []
            });
            const ge = ue.get(ce);
            if (ge) {
                ge.type = "Global",
                me.length ? ge.type = me[0].name : addWarning("Events have no parameters", ce);
                const {paramList: Te, infoList: _e} = me.reduce( (Se, {name: Ie}) => {
                    const ye = `event${Ie}`;
                    return Se.paramList.push(`${ye}: ${MOD_MODULE}${EVENT_TYPE_LOOKUP.get(Ie) ?? Ie}`),
                    Se.infoList.push(ye),
                    Se
                }
                , {
                    paramList: [],
                    infoList: []
                });
                ge.parameters = Te,
                ge.info = _e
            }
            return ue
        }
        , ne),
        eventCounts: new Map,
        maxObjectVariableNum: {
            Player: -1
        }
    }
}
  , parseMod = (V, {Rules: X, Subroutines: J}) => (V.stringParameters = [],
{
    rules: parseRules(V, X),
    subroutines: parseSubroutines(V, J)
})
  , parseRules = (V, X) => X.map(J => parseRule(V, J))
  , parseRule = (V, {Event: X, Conditions: J, Actions: ne}) => ({
    event: parseModEvent(X),
    conditions: parseModConditions(V, J),
    actions: parseModActions(V, ne)
})
  , parseSubroutines = (V, X) => X.map( ({Event: J, ParamCount: ne, Conditions: ue, Actions: ce}) => ({
    name: parseSubroutineName(J) ?? "",
    paramCount: ne ?? 0,
    actions: parseModActions(V, ce),
    conditions: parseModConditions(V, ue)
}))
  , parseSubroutineName = V => V[1]
  , parseModEvent = V => {
    const X = V[0]
      , J = V.length > 1 ? V[1] : void 0;
    return {
        eventObjectKind: J,
        eventName: X === "Object" ? `Ongoing${J ?? ""}` : X === "Global" ? "OngoingGlobal" : X
    }
}
  , parseModConditions = (V, X) => X.map(J => ({
    value: parseModParam(V, J)
}))
  , parseModActions = (V, X) => X.map( ({Action: J, Params: ne}) => ({
    actionName: J,
    actionParams: ne ? parseModParams(V, ne) : []
}))
  , parseModParam = (V, X) => {
    const J = typeof X
      , ne = J;
    return J === "boolean" || J === "number" || J === "bigint" ? X : J === "string" ? (V.stringParameters.includes(`${X}`) || V.stringParameters.push(`${X}`),
    X) : J === "object" ? X ? parseModValue(V, X) : {
        valueName: "undefined",
        valueParams: []
    } : (addWarning("unknown types", `${X}`),
    ne)
}
  , parseModValue = (V, {Value: X, Params: J}) => ({
    valueName: X,
    valueParams: J !== void 0 ? parseModParams(V, J) : []
})
  , parseModParams = (V, X) => X.map(J => ({
    value: parseModParam(V, J)
}))
  , getModLines = (V, X, J, ne, ue) => {
    const ce = []
      , me = []
      , {rules: ge=[], subroutines: Te=[]} = X;
    V.maxGlobalVariableNum = -1,
    V.objectVarKinds.forEach($e => {
        V.maxObjectVariableNum[$e] = -1
    }
    ),
    MOD_INCLUDES_STR.split(`
`).forEach($e => ce.push($e)),
    V.eventFunctionNames = new Set,
    ge.forEach($e => {
        const Ne = getRuleLines(V, $e, J, ne, ue);
        Ne.length && Ne.forEach(ve => {
            ce.push(ve)
        }
        ),
        ce.push("")
    }
    ),
    Te.forEach($e => {
        getSubroutineLines(V, $e, J, ne, ue).forEach(ve => {
            ce.push(ve)
        }
        )
    }
    ),
    V.eventSubroutineNames.forEach($e => {
        const Ne = `${$e}()`
          , ve = `${$e}(eventInfo)`;
        for (let ke = 0; ke < ce.length; ke++)
            ce[ke].includes(Ne) && (ce[ke] = ce[ke].replace(Ne, ve))
    }
    ),
    fillModVars(J, V.maxGlobalVariableNum + 1, V.maxObjectVariableNum.Player, V.maxObjectVariableNum.Team, V.maxObjectVariableNum.CapturePoint, V.maxObjectVariableNum.MCOM, V.maxObjectVariableNum.Vehicle),
    getModVarsLines(J).forEach($e => {
        ce.push($e)
    }
    ),
    V.eventFunctionNames = new Set,
    getModEventHandlersLines(V, ne).forEach($e => {
        ce.push($e)
    }
    );
    const ye = getModStrings(V.stringParameters).split(`
`);
    for (const $e of ye)
        me.push($e);
    return {
        outputLinesRules: ce,
        outputLinesVars: me
    }
}
  , getRuleLines = (V, X, J, ne, ue) => {
    const ce = [];
    if (!X.event || !X.conditions || !X.actions)
        return ce;
    const me = "";
    let ge = 0;
    const Te = INDENT_STR.repeat(ge)
      , _e = X.event.eventName;
    let Se = !1;
    const Ie = (V.eventCounts.get(_e) ?? 0) + 1;
    V.eventCounts.set(_e, Ie);
    const ye = V.eventParameters.get(_e);
    ye ? ye.parameters.length > 0 && (Se = !0) : X.event.eventObjectKind && (Se = !0);
    const $e = Se ? "eventInfo: any" : ""
      , Ne = ruleFunctionName(_e, Ie, ne)
      , ve = getUniqueFunctionName(V, Ne);
    return V.eventFunctionNames.add(ve),
    X.conditions.length > 0 && (ce.push(`${Te}${me}function ${ve}_Condition(${$e}): boolean {`),
    getConditionsLines(V, X.conditions, J, null, ue).forEach(we => ce.push(we)),
    ce.push("}"),
    ce.push("")),
    ce.push(Te + me + "function " + ve + "_Action(" + $e + ") {"),
    X.actions.forEach(xe => {
        (xe.actionName == "End" || xe.actionName == "Else" || xe.actionName == "ElseIf") && (ge -= 1),
        getActionLines(V, xe, J, null, ge + 1).forEach(Fe => ce.push(Fe)),
        (xe.actionName == "If" || xe.actionName == "ForVariable" || xe.actionName == "While" || xe.actionName == "Else" || xe.actionName == "ElseIf") && (ge += 1)
    }
    ),
    ce.push("}"),
    getRuleEvaluationLines(ve, Se, X.conditions.length > 0).forEach(xe => ce.push(xe)),
    ce
}
  , ruleFunctionName = (V, X, J) => {
    const ne = J.events.get(V)
      , ue = ne == null ? void 0 : ne.ruleNames[X - 1];
    return ne && X <= ne.ruleNames.length ? `${V}_${makeIdentifier(ue ?? "")}` : `${V}${X}`
}
  , getUniqueFunctionName = (V, X) => {
    const J = [...V.eventFunctionNames].filter(ce => ce.replace(/\d+$/, "") === X).sort().reverse()[0];
    if (!J)
        return X;
    const ne = getNumbersFromEndOfString(J)
      , ue = ne ? Number(ne) : 0;
    return `${X}${ue + 1}`
}
  , getConditionsLines = (V, X, J, ne, ue) => {
    const me = INDENT_STR.repeat(1)
      , ge = [];
    if (X.length < 1)
        return [];
    const Te = ""
      , _e = buildParams(V, X, J, ne, ue)
      , Se = joinParams(_e)
      , Ie = X.length > 1 ? `(${Te}${MOD_MODULE}And${Se})` : Se
      , ye = Ie.split(`
`)
      , $e = INDENT_STR.repeat(2);
    if (ye.length == 1)
        ge.push(`${me} const newState = ${Ie.slice(1, -1)};`);
    else {
        ge.push(`${me} const newState = ${ye[0].slice(1)}`);
        const Ne = ye[ye.length - 1];
        ye[ye.length - 1] = Ne.slice(0, -1),
        ye.splice(1).forEach(ve => {
            ge.push($e + ve)
        }
        )
    }
    return ge.push(`${me}return newState;`),
    ge
}
  , getRuleEvaluationLines = (V, X, J, ne) => {
    const ue = ""
      , me = INDENT_STR.repeat(0)
      , ge = INDENT_STR.repeat(1)
      , Te = "conditionState: any"
      , _e = X ? `${Te}, eventInfo: any` : Te
      , Se = X ? "eventInfo" : ""
      , Ie = [];
    return Ie.push(ue + "function " + V + "(" + _e + ") {"),
    J ? Ie.push(`${me}let newState = ${V}_Condition(${Se});`) : Ie.push(`${me}let newState = true;`),
    Ie.push(me + "if (!conditionState.update(newState)) {"),
    Ie.push(ge + "return;"),
    Ie.push(me + "}"),
    Ie.push(`${me}${V}_Action(${Se});`),
    Ie.push("}"),
    Ie
}
  , getIfLine = ({paramList: V, indentLevel: X}) => [INDENT_STR.repeat(X) + "if " + joinParams(V) + " {"]
  , getElseLine = ({indentLevel: V}) => [`${INDENT_STR.repeat(V)}} else {`]
  , getElseIfLine = ({paramList: V, indentLevel: X}) => [`${INDENT_STR.repeat(X)}} else if ${joinParams(V)} {`]
  , getEndLine = ({indentLevel: V}) => [INDENT_STR.repeat(V) + "}"]
  , getWhileLines = ({paramList: V, indentLevel: X}) => {
    const J = []
      , ne = joinParams(V);
    return ne === "(true)" && J.push(INDENT_STR.repeat(X) + '// TODO: make this function "async"'),
    J.push(INDENT_STR.repeat(X) + "while " + ne + " {"),
    J
}
  , getForVariableLines = ({paramList: V, indentLevel: X}) => {
    const J = []
      , ne = V[0];
    let ue = ne == null ? void 0 : ne.replace("GlobalVar", "Var");
    const ce = V[1]
      , me = V[2]
      , ge = V[3];
    if (!(ue != ne)) {
        ue = ne == null ? void 0 : ne.replace("mod.ObjectVariable(", ""),
        ue = ue == null ? void 0 : ue.replace("PlayerVar)", "Var");
        const Se = ue == null ? void 0 : ue.split(",");
        ue = Se == null ? void 0 : Se[1]
    }
    const _e = `for (let ${ue} = ${ce}; ${ue} < ${me}; ${ue} += ${ge}) {`;
    return J.push(INDENT_STR.repeat(X) + _e),
    J.push(awaitString + `mod.SetVariable(${ne}, ${ue});`),
    J
}
  , getAbortLine = ({indentLevel: V}) => [`${INDENT_STR.repeat(V)}return`]
  , getBreakLine = ({indentLevel: V}) => [`${INDENT_STR.repeat(V)}break`]
  , getSkipIfLines = ({paramList: V, indentLevel: X}) => {
    const J = []
      , ne = INDENT_STR.repeat(X)
      , ue = V[0]
      , ce = V[1];
    return J.push(`${ne}let skipCount = 0;`),
    J.push(`${ne}if (${ce}) skipCount = ${ue}`),
    J.push("// prepend:"),
    J.push("// if (--skipCount < 0) "),
    J
}
  , getSkipLines = ({paramList: V, indentLevel: X}) => {
    const J = []
      , ne = INDENT_STR.repeat(X)
      , ue = joinParams(V);
    return J.push(`${ne}let skipCount = ${ue}; // fixme`),
    J.push("// prepend:"),
    J.push("// if (--skipCount < 0) "),
    J
}
  , getCallSubroutineLine = ({paramList: V, indentLevel: X}) => {
    var ue;
    const J = (ue = V[0]) == null ? void 0 : ue.slice(1, -1)
      , ne = joinParams(V.slice(1));
    return [`${INDENT_STR.repeat(X)}${awaitString}${J}${ne}`]
}
  , getActionLinesFns = {
    If: getIfLine,
    Else: getElseLine,
    ElseIf: getElseIfLine,
    End: getEndLine,
    While: getWhileLines,
    ForVariable: getForVariableLines,
    Abort: getAbortLine,
    Break: getBreakLine,
    SkipIf: getSkipIfLines,
    Skip: getSkipLines,
    CallSubroutine: getCallSubroutineLine
}
  , getActionLines = (V, X, J, ne, ue) => {
    const ce = [];
    if (!X.actionParams)
        return ce;
    const me = buildParams(V, X.actionParams, J, ne, useAsync)
      , ge = X.actionName;
    if (ge in getActionLinesFns)
        getActionLinesFns[ge]({
            paramList: me,
            indentLevel: ue
        }).forEach(Te => ce.push(Te));
    else {
        const _e = ["Wait", "WaitUntil"].includes(ge) ? "await " : ""
          , Se = joinParams(me);
        ce.push(`${INDENT_STR.repeat(ue)}${_e}${MOD_MODULE}${X.actionName}${Se}`)
    }
    return ce
}
  , getSubroutineLines = (V, X, J, ne, ue) => {
    const ce = []
      , me = "";
    if (!X.actions || !X.conditions)
        return ce;
    let ge = 0;
    const Te = INDENT_STR.repeat(ge)
      , _e = makeIdentifier(X.name)
      , Se = ne.subroutines.get(_e) ?? null
      , Ie = usesEventInActions(V, X.actions)
      , ye = Se ? buildSubroutineParams(Se, Ie) : "";
    return Ie && V.eventSubroutineNames.add(_e),
    ce.push(`${Te}${me}function ${_e}(${ye}) {`),
    ce.push(""),
    getConditionsLines(V, X.conditions, J, Se, ue).forEach(Ne => {
        ce.push(Ne)
    }
    ),
    ce.push(""),
    X.actions.forEach(Ne => {
        (Ne.actionName == "End" || Ne.actionName == "Else" || Ne.actionName == "ElseIf") && (ge = ge ? ge - 1 : 0),
        getActionLines(V, Ne, J, Se, ge + 1).forEach(ke => {
            ce.push(ke)
        }
        ),
        (Ne.actionName == "If" || Ne.actionName == "ForVariable" || Ne.actionName == "While" || Ne.actionName == "Else" || Ne.actionName == "ElseIf") && (ge += 1)
    }
    ),
    ce.push("}"),
    ce
}
  , usesEventInActions = (V, X) => X.some(J => usesEventInAction(V, J))
  , usesEventInAction = (V, X) => usesEventInParams(V, X.actionParams)
  , usesEventInParams = (V, X) => X && X.some(J => usesEventInParam(V, J))
  , usesEventInParam = (V, X) => {
    switch (typeof X.value) {
    case "object":
        {
            const ne = X.value
              , ue = ne.valueName;
            if (V.eventParameterFunctions.includes(ue) || usesEventInParams(V, ne.valueParams))
                return !0;
            break
        }
    }
    return !1
}
  , buildSubroutineParams = ({parameters: V}, X) => {
    const J = V.map(ne => {
        const ue = makeIdentifier(ne.name);
        let ce = "unknown";
        switch (ne.type) {
        case "Number":
            ce = "number";
            break;
        case "Boolean":
            ce = "boolean";
            break;
        case "String":
            ce = "string";
            break;
        default:
            addWarning("unknown subroutine parameter types", ne.type),
            ce = "any";
            break
        }
        return `${ue}: ${ce}`
    }
    );
    return X && J.push("eventInfo: any"),
    J.join(", ")
}
  , buildParams = (V, X, J, ne, ue) => {
    const ce = [];
    return X.forEach(me => {
        const ge = typeof me.value;
        switch (ge) {
        case "boolean":
        case "number":
            ce.push(`${me.value}`);
            break;
        case "string":
            ce.push(`"${me.value}"`);
            break;
        case "object":
            ce.push(buildValue(V, me.value, J, ne, ue));
            break;
        default:
            addWarning("Unknown types", ge);
            break
        }
    }
    ),
    ce
}
  , joinParams = (V, X, J=!1, ne=-1) => {
    const ue = ""
      , ce = J ? `,
` : ",";
    let me = "(";
    return J && (me += `
`),
    V.forEach( (ge, Te) => {
        Te && (me += ce),
        ne -= 1,
        ne == 0 && (me += `${ue}(currentArrayElement: any) => `),
        me += ge
    }
    ),
    me += ")",
    me
}
  , buildValue = (V, X, J, ne, ue) => {
    var ye;
    const ce = X.valueName
      , me = ""
      , ge = ["FilteredArray", "SortedArray", "WaitUntil", "IndexOfFirstTrue", "IsTrueForAny", "IsTrueForAll"].includes(ce) ? MOD_LIB_MODULE : MOD_MODULE;
    let Te = me + ge + ce
      , _e = !1;
    if (X.valueParams === void 0)
        return "";
    ["CurrentArrayElement", "GlobalVariable", "GetArgument"].includes(ce) ? (_e = !0,
    Te = ce[0].toLowerCase() + ce.slice(1)) : V.eventParameterFunctions.includes(ce) && (_e = !0,
    Te = "eventInfo." + ce[0].toLowerCase() + ce.slice(1));
    const Se = ["Equals", "Modulo", "Add", "IndexOfFirstTrue", "IsTrueForAny", "And", "Or", "FilteredArray", "LessThan", "GreaterThanEqualTo", "GreaterThan", "LessThan", "DistanceBetween", "Subtract", "Divide", "SetVariable", "DotProduct", "DisplayCustomNotificationMessage"].includes(ce)
      , Ie = ["FilteredArray", "IndexOfFirstTrue", "IsTrueForAny", "IsTrueForAll", "SortedArray"].includes(ce) ? 2 : -1;
    if (ce.endsWith("Item") && X.valueParams.length == 2) {
        const $e = X.valueParams[0].value
          , Ne = X.valueParams[1].value;
        let ve = MOD_MODULE;
        $e && Ne && (ce == $e + "Item" ? (_e = !0,
        Ne.includes(" ") || Ne.includes(".") || Ne.includes("-") ? Te = `${ve}${$e}["${Ne}"]` : Te = `${ve}${$e}.${Ne}`) : addWarning("Unknown Item functions", ce))
    }
    if (_e) {
        if (ce == "GlobalVariable") {
            const $e = X.valueParams[0].value;
            $e > V.maxGlobalVariableNum && (V.maxGlobalVariableNum = $e),
            $e < J.global.length ? Te = `${J.global[$e]}GlobalVar` : Te = `v${$e}GlobalVar`
        } else if (ce == "GetArgument") {
            const $e = X.valueParams[0].value;
            ne != null && ne.parameters[$e] || addWarning("No GetArgument parameter at index", $e.toString()),
            Te = ((ye = ne == null ? void 0 : ne.parameters[$e]) == null ? void 0 : ye.name) ?? ""
        }
    } else {
        const $e = buildParams(V, X.valueParams, J, ne, ue);
        if (ce === "ObjectVariable") {
            addWarning("Object variable substitutions on", ce);
            const Ne = $e[0].toLowerCase().replace("eventinfo.event", "")
              , {index: ve} = V.objectVarKinds.reduce( (ke, xe, we) => {
                const Fe = xe.toLowerCase();
                if (!(Fe in J))
                    return ke;
                const je = Ne.indexOf(Fe);
                return je >= 0 && je < ke.minOffset ? {
                    minOffset: je,
                    index: we
                } : ke
            }
            , {
                minOffset: 1 / 0,
                index: -1
            });
            if (ve >= 0) {
                const ke = parseInt($e[1])
                  , xe = V.objectVarKinds[ve];
                ke > V.maxObjectVariableNum[xe] && (V.maxObjectVariableNum[xe] = ke);
                let we;
                switch (xe) {
                case "Player":
                    we = J.player;
                    break;
                case "Team":
                    we = J.team;
                    break;
                case "CapturePoint":
                    we = J.capturePoint;
                    break;
                case "Vehicle":
                    we = J.vehicle;
                    break;
                case "MCOM":
                    we = J.mcom;
                    break;
                default:
                    we = [],
                    addWarning("Unknown object vars", xe);
                    break
                }
                const Fe = ke < we.length ? we[ke] : `v${ke}`;
                $e[1] = `${Fe}${V.objectVarKinds[ve]}Var`
            }
        }
        Te += joinParams($e, ue, Se, Ie)
    }
    return Te
}
  , getModVarsLines = V => {
    const X = [];
    return X.push("// global vars"),
    V.global.forEach( (J, ne) => {
        X.push(`const ${J}GlobalVar = mod.GlobalVariable(${ne})`)
    }
    ),
    X.push(""),
    X.push("// player vars"),
    V.player.forEach( (J, ne) => {
        X.push(`const ${J}PlayerVar = ${ne};`)
    }
    ),
    X.push(""),
    X.push("// team vars"),
    V.team.forEach( (J, ne) => {
        X.push(`const ${J}TeamVar = ${ne};`)
    }
    ),
    X.push(""),
    X.push("// capture point vars"),
    V.capturePoint.forEach( (J, ne) => {
        X.push(`const ${J}CapturePointVar = ${ne};`)
    }
    ),
    X.push(""),
    X.push("// mcom vars"),
    V.mcom.forEach( (J, ne) => {
        X.push(`const ${J}McomVar = ${ne};`)
    }
    ),
    X.push(""),
    X.push("// vehicle vars"),
    V.vehicle.forEach( (J, ne) => {
        X.push(`const ${J}VehicleVar = ${ne};`)
    }
    ),
    X.push(""),
    X
}
  , getModEventHandlersLines = (V, X, J) => {
    const ne = ""
      , ue = "";
    let ce = ""
      , me = "";
    const ge = new Map([["Global", 0], ["Player", 0], ["Team", 0]]);
    return [...V.eventCounts].reduce( (Te, [_e,Se]) => {
        if (!V.eventParameters.has(_e))
            addWarning("unknown event parameters using eventName", _e),
            Te.push(`${ne}export function ${_e}() {`),
            Te.push("const eventInfo: any = {};"),
            Te.push("let eventNum = 0;");
        else {
            const Ie = V.eventParameters.get(_e)
              , ye = (Ie == null ? void 0 : Ie.parameters) ?? []
              , $e = !!ye.length;
            ce = $e ? ", eventInfo" : "";
            const Ne = (Ie == null ? void 0 : Ie.type) ?? ""
              , ve = $e ? `event${Ne}, ` : "";
            me = `${MOD_LIB_MODULE}get${Ne}Condition(${ve}eventNum++)`;
            const ke = ye.join(", ");
            ge.has(Ne) || ge.set(Ne, 0);
            const xe = ge.get(Ne) || 0;
            ge.set(Ne, xe + Se);
            const we = (Ie == null ? void 0 : Ie.info.join(", ")) ?? "";
            Te.push(`${ne}export function ${_e}(${ke}) {`),
            Te.push(`const eventInfo = {${we}};`),
            Te.push(`let eventNum = ${xe};`)
        }
        return Array.from({
            length: Se
        }).forEach( (Ie, ye) => {
            const $e = ruleFunctionName(_e, ye + 1, X)
              , Ne = getUniqueFunctionName(V, $e);
            V.eventFunctionNames.add(Ne),
            Te.push(`  ${ue}${Ne}(${me}${ce});`)
        }
        ),
        Te.push("}"),
        Te.push(""),
        Te
    }
    , [])
}
  , fillModVars = (V, X, J, ne, ue, ce, me) => {
    V.global.length == 0 && (V.global = Array.from({
        length: X
    }).map( (ge, Te) => `v${Te}`)),
    V.player.length == 0 && J && (V.player = Array.from({
        length: J
    }).map( (ge, Te) => `v${Te}`)),
    V.team.length == 0 && ne && (V.team = Array.from({
        length: ne
    }).map( (ge, Te) => `v${Te}`)),
    V.capturePoint.length == 0 && ue && (V.capturePoint = Array.from({
        length: ue
    }).map( (ge, Te) => `v${Te}`)),
    V.mcom.length == 0 && ce && (V.mcom = Array.from({
        length: ce
    }).map( (ge, Te) => `v${Te}`)),
    V.vehicle.length == 0 && me && (V.vehicle = Array.from({
        length: me
    }).map( (ge, Te) => `v${Te}`))
}
  , sortBasedOnId = (V, X, J) => {
    const ne = J.get(V)
      , ue = J.get(X);
    return !ne || !ue ? 0 : ne.localeCompare(ue)
}
  , parseWsVariables = V => {
    const X = new Map
      , J = new Map
      , ne = new Map
      , ue = new Map
      , ce = new Map
      , me = new Map
      , ge = V.reduce( (Te, {type: _e, name: Se, id: Ie}) => {
        switch (_e) {
        case "Player":
            Te.player.push(Se),
            X.set(Se, Ie);
            break;
        case "TeamId":
            console.warn("TeamId is deprecated, use Team instead");
            break;
        case "Team":
            Te.team.push(Se),
            J.set(Se, Ie);
            break;
        case "CapturePoint":
            Te.capturePoint.push(Se),
            ne.set(Se, Ie);
            break;
        case "MCOM":
            Te.mcom.push(Se),
            ue.set(Se, Ie);
            break;
        case "Vehicle":
            Te.vehicle.push(Se),
            ce.set(Se, Ie);
            break;
        case "Global":
            Te.global.push(Se),
            me.set(Se, Ie);
            break;
        default:
            console.error("unknown variable type: " + _e);
            break
        }
        return Te
    }
    , BASE_MOD_VARS);
    return ge.player.sort( (Te, _e) => sortBasedOnId(Te, _e, X)),
    ge.team.sort( (Te, _e) => sortBasedOnId(Te, _e, J)),
    ge.capturePoint.sort( (Te, _e) => sortBasedOnId(Te, _e, ne)),
    ge.mcom.sort( (Te, _e) => sortBasedOnId(Te, _e, ue)),
    ge.vehicle.sort( (Te, _e) => sortBasedOnId(Te, _e, ce)),
    ge.global.sort( (Te, _e) => sortBasedOnId(Te, _e, me)),
    ge
}
  , parseWsModRules = V => V.blocks.reduce( (X, J) => {
    if (J.type === "modBlock") {
        const ne = J.inputs.RULES.block;
        parseWsModBlocks(ne, X)
    } else
        J.type === "subroutineBlock" ? parseWsSubroutineBlock(J, X) : (J.type,
        addWarning("Unknown mod blocks", J.type));
    return X
}
, {
    events: new Map,
    subroutines: new Map
})
  , parseWsModBlocks = ({fields: V, next: X}, J) => {
    const ne = V.OBJECTTYPE ?? "unknown"
      , ue = V.EVENTTYPE === "Ongoing" ? `${V.EVENTTYPE}${ne}` : V.EVENTTYPE ?? null
      , ce = V.NAME ?? "unknown";
    if (V.EVENTTYPE)
        if (J.events.has(ue)) {
            const me = J.events.get(ue);
            me == null || me.ruleNames.push(ce)
        } else
            J.events.set(ue, {
                ruleNames: [ce]
            });
    X != null && X.block && parseWsModBlocks(X.block, J)
}
  , parseWsSubroutineBlock = ({fields: V, extraState: X}, J) => {
    const ne = (V == null ? void 0 : V.SUBROUTINE_NAME) ?? "";
    return getSubRoutineParams(ne, X == null ? void 0 : X.parameters, J)
}
  , makeIdentifier = V => (V = V.replaceAll(" ", "_"),
V = V.replaceAll("*", "_"),
V = V.replaceAll("-", "_"),
V = V.replaceAll("/", "_"),
V = V.replaceAll(",", "_"),
V = V.replaceAll("%", "Pct"),
V)
  , getSubRoutineParams = (V, X=[], J={
    events: new Map,
    subroutines: new Map
}) => (J.subroutines.has(V) || J.subroutines.set(V, {
    parameters: []
}),
J.subroutines.get(V) === void 0 || J.subroutines.set(V, {
    parameters: X.map( ({name: ue, types: ce}) => ({
        name: ue,
        type: ce
    }))
}),
J)
  , getModStrings = V => {
    const X = V.reduce( (J, ne, ue) => (J[`s${ue}`] = ne,
    J), {});
    return JSON.stringify(X, null, 2)
}
  , toTs = ({compiledRules: V, workspace: X, variables: J, frostDefinitions: ne}) => {
    const ue = init$1(ne)
      , ce = X ? parseWsModRules(X) : BASE_MOD_RULES
      , me = J ? parseWsVariables(J) : BASE_MOD_VARS
      , ge = parseMod(ue, V)
      , {outputLinesRules: Te, outputLinesVars: _e} = getModLines(ue, ge, me, ce, useAsync);
    return warningLogs.size && logger$7.warn([...warningLogs].reduce( (Se, [Ie,ye]) => {
        const $e = ye.reduce( (Ne, ve) => (Ne.set(ve, (Ne.get(ve) ?? 0) + 1),
        Ne), new Map);
        return `${Se}
${Ie}:${[...$e].map( ([Ne,ve]) => ve === 1 ? ` "${Ne}"` : ` "${Ne}"(${ve})`)}`
    }
    , "")),
    {
        rules: Te.join(`
`),
        strings: _e.join(`
`)
    }
}
  , caption$2 = "_caption_1c3kh_1"
  , scriptPreview$1 = "_scriptPreview_1c3kh_6"
  , styles$e = {
    caption: caption$2,
    scriptPreview: scriptPreview$1
}
  , GenerateScriptDialog = ({dialogId: V=DIALOG_ID.BLOCK_TO_SCRIPT_EXPORT, exportWorkspaceFn: X}) => {
    var $e;
    const J = useAtomValue(workspaceAtom)
      , {colors: ne} = reactExports.useContext(ThemeContext)
      , {activeId: ue} = reactExports.useContext(DialogContext)
      , {blueprint: ce} = reactExports.useContext(BlueprintContext)
      , me = ue === V
      , [ge,Te] = reactExports.useState("script-conversion.ts")
      , _e = reactExports.useMemo( () => {
        if (me && X) {
            const Ne = X()
              , ve = Ne ? toTs({
                compiledRules: Ne,
                workspace: J == null ? void 0 : J.mod.blocks,
                variables: J == null ? void 0 : J.mod.variables,
                frostDefinitions: ce == null ? void 0 : ce.blocklyDefinitions
            }) : {
                rules: "",
                strings: ""
            };
            return ve ? `${ve.rules}

// ${ve.strings === "{}" || !ve.strings ? "" : `Strings content - add the following to your strings file: 

${ve.strings}`}` : "// Error generating script!  Please check your Blockly workspace for errors and try again."
        }
        return ""
    }
    , [ce == null ? void 0 : ce.blocklyDefinitions, X, me, ($e = J == null ? void 0 : J.mod) == null ? void 0 : $e.blocks]);
    if (!ce || !me)
        return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
    const Se = `${(new Blob([_e]).size / 1024).toFixed(2)}kb`
      , Ie = Ne => {
        Te(Ne)
    }
      , ye = () => {
        downloadFile(ge, _e)
    }
    ;
    return jsxRuntimeExports.jsxs(DialogContent, {
        id: V,
        header: "Export To Script",
        footer: jsxRuntimeExports.jsxs(ButtonGroup, {
            fillWidth: !0,
            children: [jsxRuntimeExports.jsx(Button, {
                fillWidth: !0,
                color: ne.primary,
                type: BUTTON_TYPES$1.SUBMIT,
                onClick: ye,
                isDisabled: !ge.trim().endsWith(".ts"),
                testId: TEST_ID.GENERATE_SCRIPT_CONFIRM,
                children: t$1("general.export")
            }), jsxRuntimeExports.jsx(Button, {
                fillWidth: !0,
                variant: BUTTON_VARIANTS.SECONDARY,
                type: BUTTON_TYPES$1.SUBMIT,
                testId: TEST_ID.GENERATE_SCRIPT_CANCEL,
                children: t$1("general.cancel")
            })]
        }),
        children: [jsxRuntimeExports.jsxs("div", {
            children: [t$1("general.preview-script-generated-from-blockly"), ":"]
        }), jsxRuntimeExports.jsx("textarea", {
            readOnly: !0,
            className: styles$e.scriptPreview,
            defaultValue: _e
        }), jsxRuntimeExports.jsxs("div", {
            children: [t$1("general.filename"), ":"]
        }), jsxRuntimeExports.jsx(TextInput, {
            label: "Script filename",
            placeholder: "File Name",
            value: ge,
            onChange: Ie,
            fillWidth: !0,
            testId: TEST_ID.GENERATE_SCRIPT_FILENAME
        }), jsxRuntimeExports.jsxs("div", {
            className: styles$e.caption,
            children: [jsxRuntimeExports.jsx(Caption, {
                children: Se
            }), jsxRuntimeExports.jsxs(Caption, {
                children: [t$1("general.format"), ": .ts"]
            })]
        })]
    })
}
  , CreateVariableDialog = ({workspace: V, variablesManager: X, createVariableCallback: J, objectTypes: ne, closeCallback: ue}) => {
    const {colors: ce} = reactExports.useContext(ThemeContext)
      , {open: me} = useDialog(DIALOG_ID.RULES_EDITOR_MANAGE_VARIABLES)
      , [ge,Te] = reactExports.useState("")
      , [_e,Se] = reactExports.useState("")
      , Ie = new Set
      , ye = we => {
        Se(we ? String(we) : "")
    }
      , $e = we => {
        Te(we || "")
    }
    ;
    (V == null ? void 0 : V.getVariable(ge, _e)) ? Ie.add("variable-already-exists") : Ie.delete("variable-already-exists"),
    _e && !(X != null && X.canCreateVariableOfType(_e)) ? Ie.add("too-many-variables") : Ie.delete("too-many-variables");
    const ve = () => {
        ue(),
        me(),
        xe()
    }
      , ke = () => {
        J(ge, _e),
        me(),
        xe()
    }
      , xe = () => {
        Te(""),
        Se(""),
        Ie.clear()
    }
    ;
    return jsxRuntimeExports.jsxs(DialogContent, {
        id: DIALOG_ID.RULES_EDITOR_CREATE_VARIABLE,
        header: t$1("rules.create-variable"),
        footer: jsxRuntimeExports.jsxs(ButtonGroup, {
            fillWidth: !0,
            children: [jsxRuntimeExports.jsx(Button, {
                variant: BUTTON_VARIANTS.SECONDARY,
                type: BUTTON_TYPES.SUBMIT,
                fillWidth: !0,
                onClick: ve,
                children: t$1("general.cancel")
            }), jsxRuntimeExports.jsx(Button, {
                fillWidth: !0,
                type: BUTTON_TYPES.SUBMIT,
                color: ce.primary,
                onClick: ke,
                isDisabled: !ge || !_e || !!Ie.size,
                children: t$1("general.create")
            })]
        }),
        children: [jsxRuntimeExports.jsxs(Section, {
            children: [jsxRuntimeExports.jsxs(Section, {
                subsection: !0,
                children: [jsxRuntimeExports.jsx(Section, {
                    subsection: !0,
                    trimY: !0,
                    children: jsxRuntimeExports.jsx(Heading, {
                        variant: HEADING_VARIANT.FIELD_LABEL,
                        children: t$1("general.name")
                    })
                }), jsxRuntimeExports.jsx(Section, {
                    subsection: !0,
                    trimY: !0,
                    children: jsxRuntimeExports.jsx(TextInput, {
                        label: t$1("general.name"),
                        fillWidth: !0,
                        type: TEXT_INPUT_TYPES.TEXT,
                        value: ge,
                        onChange: $e
                    })
                })]
            }), jsxRuntimeExports.jsxs(Section, {
                subsection: !0,
                children: [jsxRuntimeExports.jsx(Section, {
                    subsection: !0,
                    trimY: !0,
                    children: jsxRuntimeExports.jsx(Heading, {
                        variant: HEADING_VARIANT.FIELD_LABEL,
                        children: t$1("general.type")
                    })
                }), jsxRuntimeExports.jsx(Section, {
                    subsection: !0,
                    trimY: !0,
                    children: jsxRuntimeExports.jsx(Dropdown, {
                        placeholder: t$1("rules.choose-a-variable-type"),
                        items: ne.map(we => ({
                            content: we[0].toString(),
                            value: we[1]
                        })),
                        value: _e,
                        onChange: ye,
                        fillWidth: !0
                    })
                })]
            })]
        }), Ie.size ? jsxRuntimeExports.jsx(Section, {
            subsection: !0,
            children: jsxRuntimeExports.jsx(WarningList, {
                children: [...Ie].map(we => jsxRuntimeExports.jsx(Warning, {
                    text: t$1(`rules.${we}`) ?? "",
                    variant: WARNING_VARIANTS.ERROR
                }, we))
            })
        }) : null]
    })
}
  , VALIDATION_MESSAGES = new Map([["alreadyExisting", t$1("rules.variable-already-exists")]])
  , RenameVariableDialog = ({workspace: V, renameVariableCallback: X, editingName: J, editingType: ne}) => {
    const {open: ue} = useDialog(DIALOG_ID.RULES_EDITOR_MANAGE_VARIABLES)
      , {colors: ce} = reactExports.useContext(ThemeContext)
      , [me,ge] = reactExports.useState(J)
      , [Te,_e] = reactExports.useState(!0)
      , Se = new Set
      , Ie = (ve="") => {
        _e(!1),
        ge(ve)
    }
      , ye = () => {
        X(me),
        _e(!0),
        ue()
    }
      , $e = () => {
        ue(),
        ge(J),
        _e(!0)
    }
    ;
    reactExports.useEffect( () => {
        ge(J)
    }
    , [J]);
    const Ne = V == null ? void 0 : V.getVariable(me, ne);
    return !Te && Ne ? Se.add("alreadyExisting") : Se.delete("alreadyExisting"),
    jsxRuntimeExports.jsxs(DialogContent, {
        id: DIALOG_ID.RULES_EDITOR_RENAME_VARIABLE,
        header: t$1("rules.rename-variable"),
        footer: jsxRuntimeExports.jsxs(ButtonGroup, {
            fillWidth: !0,
            children: [jsxRuntimeExports.jsx(Button, {
                variant: BUTTON_VARIANTS.SECONDARY,
                type: BUTTON_TYPES.SUBMIT,
                fillWidth: !0,
                onClick: $e,
                children: t$1("general.cancel")
            }), jsxRuntimeExports.jsx(Button, {
                fillWidth: !0,
                type: BUTTON_TYPES.SUBMIT,
                color: ce.primary,
                onClick: ye,
                isDisabled: !me || !!Se.size,
                children: t$1("general.confirm")
            })]
        }),
        children: [jsxRuntimeExports.jsx(Section, {
            children: jsxRuntimeExports.jsxs(Section, {
                subsection: !0,
                children: [jsxRuntimeExports.jsx(Section, {
                    subsection: !0,
                    trimY: !0,
                    children: jsxRuntimeExports.jsx(Heading, {
                        variant: HEADING_VARIANT.FIELD_LABEL,
                        children: t$1("general.name")
                    })
                }), jsxRuntimeExports.jsx(Section, {
                    subsection: !0,
                    trimY: !0,
                    children: jsxRuntimeExports.jsx(TextInput, {
                        label: t$1("general.name"),
                        fillWidth: !0,
                        type: TEXT_INPUT_TYPES.TEXT,
                        value: me,
                        onChange: Ie
                    })
                })]
            })
        }), Se.size ? jsxRuntimeExports.jsx(Section, {
            subsection: !0,
            children: jsxRuntimeExports.jsx(WarningList, {
                children: [...Se].map(ve => jsxRuntimeExports.jsx(Warning, {
                    text: VALIDATION_MESSAGES.get(ve) ?? "",
                    variant: WARNING_VARIANTS.ERROR
                }, ve))
            })
        }) : null]
    })
}
  , containerSection = "_containerSection_ag5u6_1"
  , subsection = "_subsection_ag5u6_1"
  , heading = "_heading_ag5u6_5"
  , subHeading = "_subHeading_ag5u6_9"
  , variableListItem = "_variableListItem_ag5u6_14"
  , variableName = "_variableName_ag5u6_19"
  , variableButton = "_variableButton_ag5u6_26"
  , styles$d = {
    containerSection,
    subsection,
    heading,
    subHeading,
    variableListItem,
    variableName,
    variableButton
}
  , ManageVariablesDialog = ({workspace: V, variablesManager: X, variables: J, deleteVariableCallback: ne, createVariableCallback: ue, renameVariableCallback: ce, objectTypes: me, closeCallback: ge, setEditingIdCallback: Te, setEditingNameCallback: _e, setEditingTypeCallback: Se, editingName: Ie, editingType: ye}) => {
    var Ye;
    const {colors: $e} = reactExports.useContext(ThemeContext)
      , {open: Ne, close: ve} = useDialog(DIALOG_ID.RULES_EDITOR_CREATE_VARIABLE)
      , {open: ke} = useDialog(DIALOG_ID.RULES_EDITOR_RENAME_VARIABLE)
      , {open: xe} = useDialog(DIALOG_ID.RULES_EDITOR_CONFIRM_DELETE_VARIABLE)
      , [we,Fe] = reactExports.useState(null)
      , je = reactExports.useState(0)[1]
      , Xe = (X == null ? void 0 : X.maxGlobalVariables) ?? 0
      , ze = (X == null ? void 0 : X.maxObjectVariables) ?? 0
      , qe = (X == null ? void 0 : X.getGlobalVariableCount()) ?? 0
      , Ze = (X == null ? void 0 : X.getObjectVariableCount()) ?? 0
      , et = qe >= Xe
      , it = Ze >= ze
      , at = We => () => {
        const nt = (V == null ? void 0 : V.getVariableUsesById((We == null ? void 0 : We.getId()) ?? "")) ?? [];
        nt.length ? (Fe(We),
        je(nt.length),
        xe()) : (ne(We),
        Fe(null),
        je(0))
    }
      , rt = () => {
        we && (ne(we),
        Fe(null),
        je(0))
    }
      , ft = We => () => {
        _e(We.name),
        Te(We.getId()),
        Se(We.type),
        ke()
    }
      , St = We => We.name ? jsxRuntimeExports.jsxs(ListItem, {
        className: styles$d.variableListItem,
        children: [jsxRuntimeExports.jsx("span", {
            className: styles$d.variableName,
            children: We.name
        }, We.name + We.type), jsxRuntimeExports.jsx("div", {
            className: styles$d.variableButton,
            children: jsxRuntimeExports.jsx(Tooltip, {
                tip: t$1("rules.rename-variable"),
                children: jsxRuntimeExports.jsx(IconButton, {
                    icon: ICON_NAMES.PENCIL,
                    onClick: ft(We)
                })
            })
        }), jsxRuntimeExports.jsx("div", {
            className: styles$d.variableButton,
            children: jsxRuntimeExports.jsx(Tooltip, {
                tip: t$1("rules.delete-variable"),
                children: jsxRuntimeExports.jsx(IconButton, {
                    icon: ICON_NAMES.CLOSE,
                    onClick: at(We)
                })
            })
        })]
    }, We.name + We.type) : null;
    return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsx(DialogContent, {
            id: DIALOG_ID.RULES_EDITOR_MANAGE_VARIABLES,
            header: t$1("general.variables"),
            footer: jsxRuntimeExports.jsxs(ButtonGroup, {
                fillWidth: !0,
                children: [jsxRuntimeExports.jsx(Button, {
                    variant: BUTTON_VARIANTS.SECONDARY,
                    type: BUTTON_TYPES.SUBMIT,
                    fillWidth: !0,
                    onClick: ge,
                    children: t$1("general.close")
                }), jsxRuntimeExports.jsx(Button, {
                    fillWidth: !0,
                    type: BUTTON_TYPES.SUBMIT,
                    color: $e.primary,
                    onClick: Ne,
                    isDisabled: et && it,
                    children: t$1("rules.new-variable")
                })]
            }),
            children: jsxRuntimeExports.jsxs(Section, {
                subsection: !0,
                split: !0,
                className: styles$d.containerSection,
                children: [jsxRuntimeExports.jsxs(Section, {
                    subsection: !0,
                    trimY: !0,
                    className: styles$d.subsection,
                    children: [jsxRuntimeExports.jsx("div", {
                        className: styles$d.heading,
                        children: t$1("rules.global-variables", {
                            nr: qe,
                            max: Xe
                        })
                    }), me[0] && J[me[0][1]] ? (Ye = J[me[0][1]]) == null ? void 0 : Ye.map(St) : t$1("rules.no-variables")]
                }), jsxRuntimeExports.jsxs(Section, {
                    subsection: !0,
                    trimY: !0,
                    className: styles$d.subsection,
                    children: [jsxRuntimeExports.jsx("div", {
                        className: styles$d.heading,
                        children: t$1("rules.object-variables", {
                            nr: Ze,
                            max: ze
                        })
                    }), me.slice(1).map(We => {
                        var nt;
                        return We[0] ? jsxRuntimeExports.jsxs("div", {
                            children: [jsxRuntimeExports.jsx("div", {
                                className: styles$d.subHeading,
                                children: We[0].toString()
                            }), (nt = J[We[1]]) == null ? void 0 : nt.map(St)]
                        }, We[0].toString()) : null
                    }
                    )]
                })]
            })
        }), jsxRuntimeExports.jsx(CreateVariableDialog, {
            workspace: V,
            variablesManager: X,
            createVariableCallback: ue,
            objectTypes: me,
            closeCallback: ve
        }), jsxRuntimeExports.jsx(RenameVariableDialog, {
            workspace: V,
            editingName: Ie,
            editingType: ye,
            renameVariableCallback: ce
        }), jsxRuntimeExports.jsx(DialogContent, {
            id: DIALOG_ID.RULES_EDITOR_CONFIRM_DELETE_VARIABLE,
            header: t$1("rules.delete-variable"),
            footer: jsxRuntimeExports.jsxs(ButtonGroup, {
                fillWidth: !0,
                children: [jsxRuntimeExports.jsx(Button, {
                    fillWidth: !0,
                    variant: BUTTON_VARIANTS.SECONDARY,
                    type: BUTTON_TYPES.SUBMIT,
                    children: t$1("general.cancel")
                }), jsxRuntimeExports.jsx(Button, {
                    fillWidth: !0,
                    color: $e.primary,
                    type: BUTTON_TYPES.SUBMIT,
                    onClick: rt,
                    children: t$1("general.confirm")
                })]
            }),
            children: t$1("rules.delete-variable-confirm", {
                nr: we ? ((V == null ? void 0 : V.getVariableUsesById(we.getId() ?? "")) ?? []).length : 0,
                name: we == null ? void 0 : we.name
            })
        })]
    })
}
  , typesMenu = "_typesMenu_17dxu_1"
  , listContainer = "_listContainer_17dxu_12"
  , listItem = "_listItem_17dxu_19"
  , nameFieldErrorState = "_nameFieldErrorState_17dxu_27"
  , styles$c = {
    typesMenu,
    listContainer,
    listItem,
    nameFieldErrorState
};
var FIELD_KEY = (V => (V.NAME = "name",
V.PARAMETER = "parameter",
V))(FIELD_KEY || {});
const SubroutineDialog = ({parameterTypes: V, editingSubroutineName: X, onCreateSubroutine: J, onRenameSubroutine: ne, dialogRef: ue, nameFieldError: ce}) => {
    const {colors: me} = reactExports.useContext(ThemeContext)
      , [ge,Te] = reactExports.useState("")
      , [_e,Se] = reactExports.useState([])
      , [Ie,ye] = reactExports.useState()
      , [$e,Ne] = reactExports.useState(new Map(common_utils.enumToArray(FIELD_KEY).map(Ze => [Ze, new Set])))
      , ve = new Map([["name", new Map([[VALIDATION_RULE.REQUIRED, t$1("rules.name-required")], [VALIDATION_RULE.MAX_LENGTH, t$1("rules.maximum-length-exceeded", {
        max: 30
    })]])], ["parameter", new Map([[VALIDATION_RULE.REQUIRED, t$1("rules.parameter-required")], [VALIDATION_RULE.MAX_LENGTH, t$1("rules.maximum-length-exceeded", {
        max: 30
    })]])]])
      , ke = Ze => {
        Te(Ze ?? "")
    }
      , xe = Ze => et => {
        $e.set(Ze, new Set([...et])),
        Ne(new Map([...$e]))
    }
      , we = () => {
        Se(Ze => [...Ze, {
            name: "",
            types: new Set
        }])
    }
      , Fe = () => {
        Se(Ze => [...Ze.slice(0, Ze.length - 1)])
    }
      , je = Ze => et => {
        _e[Ze].name = et,
        Se([..._e])
    }
      , Xe = Ze => et => {
        ye(et ? Ze : void 0)
    }
      , ze = (Ze, et) => () => {
        _e[Ze].types.has(et) ? _e[Ze].types.delete(et) : _e[Ze].types.add(et),
        Se([..._e])
    }
      , qe = () => {
        X ? ne(X, ge) : J(ge, _e)
    }
    ;
    return reactExports.useEffect( () => {
        const Ze = () => {
            Te(""),
            Se([])
        }
          , et = at => {
            at.code === "Enter" && at.preventDefault()
        }
          , it = ue == null ? void 0 : ue.current;
        return document.addEventListener("keydown", et),
        it == null || it.addEventListener("close", Ze),
        () => {
            document.removeEventListener("keydown", et),
            it == null || it.removeEventListener("close", Ze)
        }
    }
    , []),
    jsxRuntimeExports.jsxs(DialogContent, {
        id: DIALOG_ID.RULES_EDITOR_CREATE_SUBROUTINE,
        header: t$1(X ? "rules.edit-subroutine" : "rules.create-subroutine"),
        footer: jsxRuntimeExports.jsxs(ButtonGroup, {
            fillWidth: !0,
            children: [jsxRuntimeExports.jsx(Button, {
                variant: BUTTON_VARIANTS.SECONDARY,
                type: BUTTON_TYPES.SUBMIT,
                fillWidth: !0,
                children: t$1("general.cancel")
            }), jsxRuntimeExports.jsx(Button, {
                fillWidth: !0,
                color: me.primary,
                onClick: qe,
                isDisabled: !ge || ge === X,
                children: t$1(X ? "general.ok" : "general.create")
            })]
        }),
        children: [jsxRuntimeExports.jsxs(Section, {
            children: [jsxRuntimeExports.jsx(Section, {
                subsection: !0,
                split: !0,
                trimY: !0,
                children: jsxRuntimeExports.jsx(Heading, {
                    variant: HEADING_VARIANT.FIELD_LABEL,
                    children: t$1("general.name")
                })
            }), jsxRuntimeExports.jsx(Section, {
                subsection: !0,
                children: jsxRuntimeExports.jsx(TextInput, {
                    label: t$1("general.name"),
                    fillWidth: !0,
                    value: ge,
                    onChange: ke,
                    onValidationChange: xe("name"),
                    validation: {
                        required: !0
                    },
                    className: ce ? styles$c.nameFieldErrorState : ""
                })
            }), ce && jsxRuntimeExports.jsx(Warning, {
                variant: WARNING_VARIANTS.ERROR,
                text: ce
            })]
        }), X.length ? null : jsxRuntimeExports.jsxs(Section, {
            children: [jsxRuntimeExports.jsx(Section, {
                subsection: !0,
                children: jsxRuntimeExports.jsx(Heading, {
                    variant: HEADING_VARIANT.FIELD_LABEL,
                    children: t$1("general.parameters")
                })
            }), jsxRuntimeExports.jsx(Section, {
                subsection: !0,
                children: jsxRuntimeExports.jsxs(ButtonGroup, {
                    children: [jsxRuntimeExports.jsx(Button, {
                        fillWidth: !0,
                        type: BUTTON_TYPES.BUTTON,
                        color: me.primary,
                        onClick: we,
                        children: t$1("rules.add-parameter")
                    }), jsxRuntimeExports.jsx(Button, {
                        fillWidth: !0,
                        type: BUTTON_TYPES.BUTTON,
                        color: me.primary,
                        onClick: Fe,
                        children: t$1("rules.remove-parameter")
                    })]
                })
            }), jsxRuntimeExports.jsx(Section, {
                subsection: !0,
                children: _e.length ? _e.map( (Ze, et) => {
                    var it;
                    return jsxRuntimeExports.jsxs(Section, {
                        subsection: !0,
                        children: [jsxRuntimeExports.jsxs(Section, {
                            subsection: !0,
                            split: !0,
                            children: [jsxRuntimeExports.jsx(Heading, {
                                variant: HEADING_VARIANT.FIELD_LABEL,
                                children: t$1("general.name")
                            }), jsxRuntimeExports.jsx(TextInput, {
                                label: t$1("general.name"),
                                fillWidth: !0,
                                value: Ze.name,
                                onChange: je(et),
                                onValidationChange: xe("parameter"),
                                validation: {
                                    required: !0
                                }
                            })]
                        }), jsxRuntimeExports.jsxs(Section, {
                            subsection: !0,
                            split: !0,
                            children: [jsxRuntimeExports.jsx(Heading, {
                                variant: HEADING_VARIANT.FIELD_LABEL,
                                children: t$1("general.type")
                            }), jsxRuntimeExports.jsx(Menu, {
                                isOpen: Ie === et,
                                onToggle: Xe(et),
                                ignoreContextClick: !1,
                                label: jsxRuntimeExports.jsxs("div", {
                                    className: styles$c.typesMenu,
                                    children: [jsxRuntimeExports.jsx("span", {
                                        children: (it = _e[et].types) != null && it.size ? [..._e[et].types].map(at => t$1(`blocks.types.${at.toUpperCase()}`)).join(", ") : t$1("general.any")
                                    }), jsxRuntimeExports.jsx(Icon, {
                                        name: ICON_NAMES.CHEVRON_DOWN_90
                                    })]
                                }),
                                placement: PLACEMENT.TOP,
                                children: jsxRuntimeExports.jsx(List, {
                                    className: styles$c.listContainer,
                                    children: V.map(at => {
                                        var rt;
                                        return jsxRuntimeExports.jsxs(ListItem, {
                                            className: styles$c.listItem,
                                            onClick: ze(et, at),
                                            children: [jsxRuntimeExports.jsx(Checkbox, {
                                                tabIndex: -1,
                                                checked: (rt = _e[et]) == null ? void 0 : rt.types.has(at)
                                            }), t$1(`blocks.types.${at.toUpperCase()}`)]
                                        }, at)
                                    }
                                    )
                                })
                            })]
                        })]
                    }, et)
                }
                ) : null
            })]
        }), [...$e.values()].some(Ze => Ze.size) ? jsxRuntimeExports.jsx(Section, {
            subsection: !0,
            children: jsxRuntimeExports.jsx(WarningList, {
                children: [...$e].map( ([Ze,et]) => [...et].map(it => {
                    var at;
                    return jsxRuntimeExports.jsx(Warning, {
                        text: ((at = ve.get(Ze)) == null ? void 0 : at.get(it)) ?? "",
                        variant: WARNING_VARIANTS.ERROR
                    }, `${Ze}-${it}`)
                }
                ))
            })
        }) : null]
    })
}
;
var coreBrowserExports = requireCoreBrowser();
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
( () => {
    const V = (ne, ue) => {
        let ce = J.getTooltipOfObject(ne);
        ce = coreBrowserExports.utils.string.wrap(ce, J.LIMIT);
        const me = ce.split(`
`);
        for (let ge = 0; ge < me.length; ge++) {
            const Te = document.createElement("div");
            Te.appendChild(document.createTextNode(me[ge])),
            ue.appendChild(Te)
        }
    }
      , X = (ne, ue) => {
        const ce = ne.customTooltip;
        if (ce) {
            const me = ce();
            me ? ue.appendChild(me) : V(ne, ue)
        } else
            V(ne, ue)
    }
      , J = coreBrowserExports.Tooltip;
    J.show_ = function() {
        if (J.blocked_)
            return;
        J.poisonedElement_ = J.element_;
        const ne = J.DIV;
        if (!ne)
            return;
        ne.textContent = "",
        X(J.element_, ne);
        const ue = J.element_.RTL
          , ce = document.documentElement.clientWidth
          , me = document.documentElement.clientHeight;
        ne.style.direction = ue ? "rtl" : "ltr",
        ne.style.display = "block",
        J.visible = !0;
        let ge = J.lastX_;
        ue ? ge -= J.OFFSET_X + ne.offsetWidth : ge += J.OFFSET_X;
        let Te = J.lastY_ + J.OFFSET_Y;
        Te + ne.offsetHeight > me + window.scrollY && (Te -= ne.offsetHeight + 2 * J.OFFSET_Y),
        ue ? ge = Math.max(J.MARGINS - window.scrollX, ge) : ge + ne.offsetWidth > ce + window.scrollX - 2 * J.MARGINS && (ge = ce - ne.offsetWidth - 2 * J.MARGINS),
        ne.style.top = Te + "px",
        ne.style.left = ge + "px"
    }
}
)();
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const registerTooltipExtension = () => {
    const V = (X, J) => {
        const ne = coreBrowserExports.Tooltip.getTooltipOfObject(J)
          , ue = document.createElement("div");
        ue.className = "blockly-custom-tooltip",
        ue.innerHTML = ne,
        X.appendChild(ue)
    }
    ;
    coreBrowserExports.Tooltip.setCustomTooltip(V)
}
;
function fixBrokenXmlValidator(V) {
    return V.querySelectorAll('block[type="variableReferenceBlock"] > field[name="OBJECTTYPE"]:empty').forEach(J => {
        var ne;
        if (J.innerHTML.trim() === "") {
            const ue = (ne = J.parentElement) == null ? void 0 : ne.querySelector('field[name="VAR"]')
              , ce = ue == null ? void 0 : ue.getAttribute("variabletype");
            J.innerHTML = ce ?? ""
        }
    }
    ),
    V
}
function missingBlockValidator(V) {
    var J;
    const X = V.getElementsByTagName("block");
    for (let ne = 0; ne < X.length; ++ne) {
        const ue = X[ne].getAttribute("type")
          , ce = ((J = X[ne].parentElement) == null ? void 0 : J.nodeName) === "value";
        ue && coreBrowserExports.Blocks[ue] === void 0 && (ce ? X[ne].setAttribute("type", "missingValueBlockType_v1") : X[ne].setAttribute("type", "missingActionBlockType_v1"),
        X[ne].innerHTML = `<field name="DELETED_NAME">${ue}</field>
` + X[ne].innerHTML)
    }
    return V
}
const validateJsonBlock = (V, X=!1) => {
    const J = V.next ? Object.entries(V.next).reduce( (ue, [ce,me]) => ({
        ...ue,
        [ce]: validateJsonBlock(me)
    }), {}) : void 0;
    if (coreBrowserExports.Blocks[V.type] === void 0)
        return {
            ...V,
            type: X ? "missingValueBlockType_v1" : "missingActionBlockType_v1",
            inputs: void 0,
            fields: {
                ...V.fields,
                DELETED_NAME: `${V.type}`
            },
            next: J
        };
    const ne = V.inputs ? Object.entries(V.inputs).reduce( (ue, [ce,me]) => ({
        ...ue,
        [ce]: {
            block: validateJsonBlock(me.block, ce.startsWith("VALUE"))
        }
    }), {}) : void 0;
    return {
        ...V,
        inputs: ne,
        next: J
    }
}
  , validateJsonWorkspace = V => ({
    ...V,
    blocks: {
        blocks: (V == null ? void 0 : V.blocks.blocks.map(validateJsonBlock)) ?? []
    }
})
  , BLOCK_RETURNVALUE_ICON_PREFIX = "ICON"
  , BLOCK_LABEL_NAME = "NAME"
  , ICON_HEIGHT_PX = 30
  , ICON_WIDTH_PX = 30;
function resolveTranslationPath(V, X) {
    var J = Array.isArray(V) ? V : V.split(".");
    return J.reduce( (ne, ue) => ne && ne[ue], X)
}
function getBlocklyTranslation(V) {
    const X = blocklyExports.Msg;
    return (V.indexOf(".") === -1 ? X[V] : resolveTranslationPath(V, X)) ?? `%{${V}}`
}
function getTranslatedDisplayName(V) {
    let X = V.displayNameSID ? getBlocklyTranslation(V.displayNameSID) : V.name;
    return V.deprecated && (X = getBlocklyTranslation("PYRITE_OPTION_DEPRECATED").replace("{{name}}", X)),
    X
}
let blocklyAssetPathFunc = V => V;
function getBlocklyAssetPath(V) {
    return blocklyAssetPathFunc(V)
}
function setBlocklyAssetPathFunc(V) {
    blocklyAssetPathFunc = V
}
function getMaxParamaterCount(V) {
    return Math.max(...V.map(X => {
        var J;
        return ((J = X.parameterTypes) == null ? void 0 : J.length) ?? 0
    }
    ))
}
function isParameterIndexOfAnyType(V, X) {
    return !!V.find(J => {
        var ne, ue;
        return ((ue = (ne = J.parameterTypes) == null ? void 0 : ne[X]) == null ? void 0 : ue.anyType) === !0
    }
    )
}
function getAllTypesFromFunctionSignatures(V) {
    return [...new Set(V.flatMap(X => {
        var J;
        return (J = X.parameterTypes) == null ? void 0 : J.flatMap(ne => ne.parameterTypes)
    }
    ).concat(V.map(X => X.returnType)))].filter(X => X !== void 0)
}
function getTypesForBlockParameterIndex(V, X, J) {
    if (isParameterIndexOfAnyType(V, J))
        return null;
    const ne = filterFunctionSignaturesForBlock(V, X);
    return [...new Set(ne.flatMap(ue => {
        var ce, me;
        return (me = (ce = ue.parameterTypes) == null ? void 0 : ce[J]) == null ? void 0 : me.parameterTypes
    }
    ))].filter(ue => ue !== void 0)
}
function getTypesForBlockOutput(V, X) {
    let J = [];
    const ne = filterFunctionSignaturesForBlock(V, X);
    return J = [...new Set(ne.map(ue => ue.returnType))].filter(ue => ue !== void 0),
    J.length === 0 && (J = null),
    J
}
function filterFunctionSignaturesForBlock(V, X) {
    return V.filter(J => {
        var ue, ce, me;
        const ne = [];
        for (let ge = 0; ge < X.inputList.length; ge++) {
            const Te = X.getInputTargetBlock(`VALUE-${ge}`);
            if (!Te || (ce = (ue = J.parameterTypes) == null ? void 0 : ue[ge]) != null && ce.anyType) {
                ne[ge] = !0;
                continue
            }
            const _e = ((me = Te.outputConnection) == null ? void 0 : me.getCheck()) ?? [];
            ne[ge] = _e.some(Se => {
                var Ie, ye, $e;
                return ($e = (ye = (Ie = J.parameterTypes) == null ? void 0 : Ie[ge]) == null ? void 0 : ye.parameterTypes) == null ? void 0 : $e.includes(Se)
            }
            )
        }
        return !ne.includes(!1)
    }
    )
}
function isEventRelatedToBlock(V, X) {
    return V.blockId === X.id || V.newParentId === X.id || V.oldParentId === X.id
}
function getIconPathForBlocklyType(V) {
    switch (V) {
    case "any":
        return getBlocklyAssetPath("assets/blockly/icons/type-any.svg");
    case "Array":
        return getBlocklyAssetPath("assets/blockly/icons/type-array.svg");
    case "Boolean":
        return getBlocklyAssetPath("assets/blockly/icons/type-boolean.svg");
    case "Global":
        return getBlocklyAssetPath("assets/blockly/icons/type-global.svg");
    case "Message":
        return getBlocklyAssetPath("assets/blockly/icons/type-message.svg");
    case "Number":
        return getBlocklyAssetPath("assets/blockly/icons/type-number.svg");
    case "Player":
        return getBlocklyAssetPath("assets/blockly/icons/type-player.svg");
    case "SquadId":
    case "Squad":
        return getBlocklyAssetPath("assets/blockly/icons/type-squadid.svg");
    case "String":
        return getBlocklyAssetPath("assets/blockly/icons/type-string.svg");
    case "TeamId":
    case "Team":
        return getBlocklyAssetPath("assets/blockly/icons/type-teamid.svg");
    case "FactionId":
        return getBlocklyAssetPath("assets/blockly/icons/type-factionid.svg");
    case "Vector":
        return getBlocklyAssetPath("assets/blockly/icons/type-vector.svg");
    case "DeathType":
        return getBlocklyAssetPath("assets/blockly/icons/type-deathtype.svg");
    case "WeaponUnlock":
        return getBlocklyAssetPath("assets/blockly/icons/type-weaponunlock.svg");
    case "Vehicle":
        return getBlocklyAssetPath("assets/blockly/icons/type-vehicle.svg");
    case "Objective":
        return getBlocklyAssetPath("assets/blockly/icons/type-objective.svg");
    case "CapturePoint":
        return getBlocklyAssetPath("assets/blockly/icons/type-capturepoint.svg");
    case "AreaTrigger":
        return getBlocklyAssetPath("assets/blockly/icons/type-areatrigger.svg");
    case "Camera":
        return getBlocklyAssetPath("assets/blockly/icons/type-camera.svg");
    case "DamageType":
        return getBlocklyAssetPath("assets/blockly/icons/type-damagetype.svg");
    case "EmplacementSpawner":
        return getBlocklyAssetPath("assets/blockly/icons/type-emplacementspawner.svg");
    case "HQ":
        return getBlocklyAssetPath("assets/blockly/icons/type-hq.svg");
    case "InteractPoint":
        return getBlocklyAssetPath("assets/blockly/icons/type-interactpoint.svg");
    case "LootSpawner":
    case "PrefabSpawner":
        return getBlocklyAssetPath("assets/blockly/icons/type-lootspawner.svg");
    case "MCOM":
        return getBlocklyAssetPath("assets/blockly/icons/type-mcom.svg");
    case "RingOfFire":
        return getBlocklyAssetPath("assets/blockly/icons/type-ringoffire.svg");
    case "ScreenEffect":
        return getBlocklyAssetPath("assets/blockly/icons/type-screeneffect.svg");
    case "Sector":
        return getBlocklyAssetPath("assets/blockly/icons/type-sector.svg");
    case "SFX":
        return getBlocklyAssetPath("assets/blockly/icons/type-sfx.svg");
    case "SpatialObject":
        return getBlocklyAssetPath("assets/blockly/icons/type-spatialobject.svg");
    case "Spawner":
        return getBlocklyAssetPath("assets/blockly/icons/type-spawner.svg");
    case "SpawnPoint":
        return getBlocklyAssetPath("assets/blockly/icons/type-spawnpoint.svg");
    case "Transform":
        return getBlocklyAssetPath("assets/blockly/icons/type-transform.svg");
    case "UIButtonEvent":
        return getBlocklyAssetPath("assets/blockly/icons/type-uibuttonevent.svg");
    case "UIWidget":
        return getBlocklyAssetPath("assets/blockly/icons/type-uiwidget.svg");
    case "Variables":
    case "Variable":
        return getBlocklyAssetPath("assets/blockly/icons/type-variables.svg");
    case "VehicleSpawner":
        return getBlocklyAssetPath("assets/blockly/icons/type-vehiclespawner.svg");
    case "VFX":
        return getBlocklyAssetPath("assets/blockly/icons/type-vfx.svg");
    case "VO":
        return getBlocklyAssetPath("assets/blockly/icons/type-vo.svg");
    case "WaypointPath":
        return getBlocklyAssetPath("assets/blockly/icons/type-waypointpath.svg");
    case "WorldIcon":
        return getBlocklyAssetPath("assets/blockly/icons/type-worldicon.svg");
    default:
        return V.startsWith("Enum_") ? getBlocklyAssetPath("assets/blockly/icons/type-itemindex.svg") : getBlocklyAssetPath("assets/blockly/icons/type-null.svg")
    }
}
function populateReturnValueIcons(V, X, J) {
    const ne = V.inputList.find(ue => ue.name = BLOCK_LABEL_NAME);
    if (ne) {
        ne.fieldRow.filter(ce => {
            var me;
            return (me = ce == null ? void 0 : ce.name) == null ? void 0 : me.startsWith("ICON")
        }
        ).forEach(ce => {
            ne.removeField((ce == null ? void 0 : ce.name) ?? "")
        }
        );
        const ue = J ? getTypesForBlockOutput(J, V) ?? X.types : [];
        ue === X.types ? ne.insertFieldAt(0, new blocklyExports.FieldImage(getIconPathForBlocklyType("any"),ICON_WIDTH_PX,ICON_HEIGHT_PX), `${BLOCK_RETURNVALUE_ICON_PREFIX}-0`) : ue.forEach( (ce, me) => {
            ne.insertFieldAt(me, new blocklyExports.FieldImage(getIconPathForBlocklyType(ce),ICON_WIDTH_PX,ICON_HEIGHT_PX), `${BLOCK_RETURNVALUE_ICON_PREFIX}-${me}`)
        }
        )
    }
}
function replaceObjectInputWithAllObjectTypes(V, X) {
    return V == null ? void 0 : V.map(J => {
        var ne;
        return J.parameterTypes ? {
            ...J,
            parameterTypes: ((ne = J.parameterTypes) == null ? void 0 : ne.map(ue => {
                if (ue.parameterTypes.includes("Object")) {
                    const ce = [...ue.parameterTypes].splice(ue.parameterTypes.indexOf("Object"), 1);
                    return {
                        ...ue,
                        parameterTypes: ce.concat(X)
                    }
                }
                return ue
            }
            )) ?? J.parameterTypes
        } : J
    }
    )
}
class PyriteBlocklyEventsSubroutineParametersChange extends blocklyExports.Events.Abstract {
    constructor() {
        super(...arguments),
        this.isBlank = !1
    }
}
function createActionBlocks(V) {
    V.actions.forEach(X => {
        const {name: J, displayNameSID: ne, functionSignatures: ue} = X;
        coreBrowserExports.Blocks[J] = {
            init() {
                if (this.appendDummyInput(BLOCK_LABEL_NAME).appendField(getTranslatedDisplayName(X)),
                ue !== void 0)
                    for (let ce = 0; ce < this.maxParametersCount(); ce++)
                        this.appendValueInput(`VALUE-${ce}`).setCheck(this.getTypesForParameterIndex(ce));
                this.setPreviousStatement(!0, "actionBlock"),
                this.setNextStatement(!0, "actionBlock"),
                this.setInputsInline(!0),
                this.setTooltip(this.getTooltipText()),
                this.setStyle("action-block-style")
            },
            maxParametersCount() {
                return ue ? getMaxParamaterCount(ue) : 0
            },
            getTypesForParameterIndex(ce) {
                return ue ? getTypesForBlockParameterIndex(ue, this, ce) ?? V.types : []
            },
            getTooltipText() {
                if (!ue)
                    return "";
                const ce = filterFunctionSignaturesForBlock(ue, this);
                return ((ue == null ? void 0 : ue.map(me => {
                    var _e;
                    const ge = ce.includes(me)
                      , Te = `${ne ? getBlocklyTranslation(ne) : J}(${me.parameterTypes ? (_e = me.parameterTypes) == null ? void 0 : _e.map( (Se, Ie) => `<span style="color: rgba(255, 255, 255, 0.7);">${Se.anyType ? getBlocklyTranslation("PYRITE_TYPE_ANYTYPE") : Se.parameterTypes.map(ye => getBlocklyTranslation(`PYRITE_TYPE_${ye.toUpperCase()}`)).join(" | ")}</span>`).join(", ") : ""})`;
                    return ge ? `<b>${Te}</b>` : `<span style="opacity: 0.7">${Te}</span>`
                }
                )) ?? []).join("<br /><br />")
            },
            onchange(ce) {
                if (isEventRelatedToBlock(ce, this) && ue) {
                    for (let me = 0; me < this.maxParametersCount(); me++) {
                        const ge = this.getInput(`VALUE-${me}`)
                          , Te = this.getTypesForParameterIndex(me);
                        ge == null || ge.setCheck(Te)
                    }
                    this.setTooltip(this.getTooltipText()),
                    this instanceof coreBrowserExports.BlockSvg && this.render()
                }
            }
        }
    }
    ),
    coreBrowserExports.Blocks.actionComment = {
        init() {
            const X = new coreBrowserExports.FieldMultilineInput("");
            this.appendDummyInput().appendField(X, "TEXT"),
            this.setPreviousStatement(!0, null),
            this.setNextStatement(!0, null),
            this.setColour(0),
            this.setStyle("comment-block-style")
        }
    },
    coreBrowserExports.Blocks.missingActionBlockType_v1 = {
        init() {
            this.appendDummyInput().appendField(new coreBrowserExports.FieldLabelSerializable("BLOCK NAME"), "DELETED_NAME"),
            this.appendDummyInput().appendField("DELETED"),
            this.setInputsInline(!0),
            this.setPreviousStatement(!0, null),
            this.setNextStatement(!0, null),
            this.setColour(0),
            this.setTooltip(""),
            this.setHelpUrl(""),
            this.setStyle("action-block-style")
        }
    }
}
function createConvenienceBlocks(V) {
    coreBrowserExports.Blocks.ArrayContains = {
        init() {
            this.jsonInit({
                type: "Convenience",
                message0: `%1 ${getBlocklyTranslation("PYRITE_CONVENIENCE_ARRAYCONTAINS")} %2 %3`,
                args0: [{
                    type: "field_image",
                    name: `${BLOCK_RETURNVALUE_ICON_PREFIX}-0`,
                    src: getIconPathForBlocklyType("Boolean"),
                    width: ICON_WIDTH_PX,
                    height: ICON_HEIGHT_PX
                }, {
                    type: "input_value",
                    name: "VALUE-0",
                    check: "Array"
                }, {
                    type: "input_value",
                    name: "VALUE-1",
                    check: V.types
                }],
                inputsInline: !0,
                colour: 0,
                tooltip: "",
                helpUrl: "",
                output: "Boolean"
            }),
            this.setStyle("value-block-style")
        }
    },
    coreBrowserExports.Blocks.IndexOfArrayValue = {
        init() {
            this.jsonInit({
                type: "Convenience",
                message0: `%1 ${getBlocklyTranslation("PYRITE_CONVENIENCE_INDEXOFARRAYVALUE")} %2 %3`,
                args0: [{
                    type: "field_image",
                    name: `${BLOCK_RETURNVALUE_ICON_PREFIX}-0`,
                    src: getIconPathForBlocklyType("Number"),
                    width: ICON_WIDTH_PX,
                    height: ICON_HEIGHT_PX
                }, {
                    type: "input_value",
                    name: "VALUE-0",
                    check: "Array"
                }, {
                    type: "input_value",
                    name: "VALUE-1",
                    check: V.types
                }],
                inputsInline: !0,
                colour: 0,
                tooltip: "",
                helpUrl: "",
                output: "Number"
            }),
            this.setStyle("value-block-style")
        }
    },
    coreBrowserExports.Blocks.RemoveFromArray = {
        init() {
            this.jsonInit({
                type: "Convenience",
                message0: `%1 ${getBlocklyTranslation("PYRITE_CONVENIENCE_REMOVEFROMARRAY")} %2 %3`,
                args0: [{
                    type: "field_image",
                    name: `${BLOCK_RETURNVALUE_ICON_PREFIX}-0`,
                    src: getIconPathForBlocklyType("Array"),
                    width: ICON_WIDTH_PX,
                    height: ICON_HEIGHT_PX
                }, {
                    type: "input_value",
                    name: "VALUE-0",
                    check: "Array"
                }, {
                    type: "input_value",
                    name: "VALUE-1",
                    check: V.types
                }],
                inputsInline: !0,
                colour: 0,
                tooltip: "",
                helpUrl: "",
                output: "Array"
            }),
            this.setStyle("value-block-style")
        }
    }
}
function createLiteralBlocks() {
    coreBrowserExports.Blocks.Text = {
        init() {
            this.jsonInit({
                type: "Text",
                message0: "%1 %2 %3",
                args0: [{
                    type: "field_image",
                    name: "VARICON0",
                    src: getBlocklyAssetPath("./assets/blockly/quote0.png"),
                    width: 12,
                    height: 12,
                    flipRtl: !1
                }, {
                    type: "field_input",
                    name: "TEXT",
                    text: ""
                }, {
                    type: "field_image",
                    name: "VARICON1",
                    src: getBlocklyAssetPath("./assets/blockly/quote1.png"),
                    width: 12,
                    height: 12,
                    flipRtl: !1
                }],
                output: "String",
                colour: "#5dc8ce",
                helpUrl: "",
                tooltip: ""
            }),
            this.setStyle("value-block-style")
        }
    },
    coreBrowserExports.Blocks.Number = {
        init() {
            this.jsonInit({
                type: "Number",
                message0: "%1 %2 %3",
                args0: [{
                    type: "field_image",
                    name: "VARICON0",
                    src: getBlocklyAssetPath("./assets/blockly/1x1.png"),
                    width: 1,
                    height: 12,
                    flipRtl: !1
                }, {
                    type: "field_number",
                    name: "NUM",
                    value: 0
                }, {
                    type: "field_image",
                    name: "VARICON1",
                    src: getBlocklyAssetPath("./assets/blockly/1x1.png"),
                    width: 1,
                    height: 12,
                    flipRtl: !1
                }],
                output: "Number",
                colour: "#5dc8ce",
                helpUrl: "",
                tooltip: ""
            }),
            this.setStyle("value-block-style")
        }
    },
    coreBrowserExports.Blocks.Boolean = {
        init() {
            this.jsonInit({
                type: "Boolean",
                message0: "%1",
                args0: [{
                    type: "field_dropdown",
                    name: "BOOL",
                    options: [[getBlocklyTranslation("TRUE"), "TRUE"], [getBlocklyTranslation("FALSE"), "FALSE"]]
                }],
                output: "Boolean",
                colour: "#5dc8ce",
                tooltip: "",
                helpUrl: ""
            }),
            this.setStyle("value-block-style")
        }
    }
}
function createLogicBlocks() {
    coreBrowserExports.Blocks.Compare = {
        init() {
            this.jsonInit({
                type: "Compare",
                message0: "%1 %2 %3",
                args0: [{
                    type: "input_value",
                    name: "A"
                }, {
                    type: "field_dropdown",
                    name: "OP",
                    options: [["==", "EQ"], ["!=", "NEQ"], ["<", "LT"], ["<=", "LTE"], [">", "GT"], [">=", "GTE"]]
                }, {
                    type: "input_value",
                    name: "B"
                }],
                inputsInline: !0,
                output: "Boolean",
                style: "logic_blocks",
                helpUrl: ""
            })
        }
    }
}
function createModBlocks() {
    coreBrowserExports.Blocks.modBlock = {
        init() {
            this.appendDummyInput().appendField(new coreBrowserExports.FieldLabel(getBlocklyTranslation("PYRITE_MOD"),"fieldHeaderText"), "NAME"),
            this.appendStatementInput("RULES").setCheck("ruleBlock"),
            this.setInputsInline(!0),
            this.setTooltip(""),
            this.setHelpUrl(""),
            this.setMovable(!0),
            this.setDeletable(!1),
            this.setStyle("mod-block-style")
        }
    },
    coreBrowserExports.Blocks.conditionBlock = {
        init() {
            this.appendDummyInput().appendField(getBlocklyTranslation("PYRITE_CONDITION"), "NAME"),
            this.appendValueInput("CONDITION").setCheck("Boolean"),
            this.setInputsInline(!0),
            this.setPreviousStatement(!0, "conditionBlock"),
            this.setNextStatement(!0, "conditionBlock"),
            this.setTooltip(""),
            this.setHelpUrl(""),
            this.setStyle("condition-block-style")
        }
    }
}
function generateObjectTypes(V) {
    return V.map(X => [getTranslatedDisplayName(X), X.name])
}
function createRuleBlocks(V) {
    coreBrowserExports.Blocks.ruleBlock = {
        init() {
            this.appendDummyInput().appendField(new coreBrowserExports.FieldLabel(getBlocklyTranslation("PYRITE_RULE"),"fieldHeaderText ruleBlockRuleText")).appendField(new coreBrowserExports.FieldTextInput(getBlocklyTranslation("PYRITE_NEW_RULE")), "NAME"),
            this.appendDummyInput("EVENT").appendField(getBlocklyTranslation("PYRITE_EVENT")),
            this.appendDummyInput().appendField(new coreBrowserExports.FieldDropdown(this.generateOptions), "EVENTTYPE"),
            this.appendDummyInput("OBJECTTYPE_DUMMY"),
            this.appendStatementInput("CONDITIONS").setCheck("conditionBlock").appendField(new coreBrowserExports.FieldLabel(getBlocklyTranslation("PYRITE_CONDITIONS"),"fieldHeaderText ruleBlockConditionText")),
            this.appendStatementInput("ACTIONS").setCheck("actionBlock").appendField(new coreBrowserExports.FieldLabel(getBlocklyTranslation("PYRITE_ACTIONS"),"fieldHeaderText ruleBlockActionText")),
            this.setInputsInline(!0),
            this.setPreviousStatement(!0, "ruleBlock"),
            this.setNextStatement(!0, "ruleBlock"),
            this.setStyle("rule-block-style"),
            this.updateShape(!0)
        },
        domToMutation(X) {
            const J = this
              , ne = X.getAttribute("isOnGoingEvent") === "true";
            J.updateShape(ne)
        },
        saveExtraState: function() {
            return {
                isOngoingEvent: this.getFieldValue("EVENTTYPE") === "Ongoing"
            }
        },
        loadExtraState: function(X) {
            this.updateShape(!!X.isOngoingEvent)
        },
        generateOptions() {
            return V.events.map(X => [getTranslatedDisplayName(X), X.name])
        },
        onchange(X) {
            if (isEventRelatedToBlock(X, this) && X.type === coreBrowserExports.Events.CHANGE && X.name === "EVENTTYPE" && X.newValue !== X.oldValue) {
                const J = X.newValue === "Ongoing";
                this.updateShape(J)
            }
        },
        updateShape(X) {
            var ue, ce;
            const J = this
              , ne = J.getField("OBJECTTYPE");
            X ? ne || (ue = J.getInput("OBJECTTYPE_DUMMY")) == null || ue.appendField(new coreBrowserExports.FieldDropdown( () => generateObjectTypes(V.objects)), "OBJECTTYPE") : ne && ((ce = J.getInput("OBJECTTYPE_DUMMY")) == null || ce.removeField("OBJECTTYPE"))
        }
    }
}
function createControlBlocks(V) {
    coreBrowserExports.Blocks.controls_if_if = {
        init() {
            this.appendDummyInput().appendField(getBlocklyTranslation("CONTROLS_IF_MSG_IF")),
            this.setPreviousStatement(!0, null),
            this.setNextStatement(!0, null),
            this.setStyle("control-block-alt-style")
        }
    },
    coreBrowserExports.Blocks.controls_if_elseif = {
        init() {
            this.appendDummyInput().appendField(getBlocklyTranslation("CONTROLS_IF_MSG_ELSEIF")),
            this.setPreviousStatement(!0, null),
            this.setNextStatement(!0, null),
            this.setStyle("control-block-style")
        }
    },
    coreBrowserExports.Blocks.controls_if_else = {
        init() {
            this.appendDummyInput().appendField(getBlocklyTranslation("CONTROLS_IF_MSG_ELSE")),
            this.setPreviousStatement(!0, null),
            this.setStyle("control-block-style")
        }
    },
    V.controlActions.forEach(X => {
        const {name: J, displayNameSID: ne} = X;
        J === "Break" ? coreBrowserExports.Blocks.Break = {
            init() {
                this.appendDummyInput().appendField(getTranslatedDisplayName(X)),
                this.setPreviousStatement(!0, "actionBlock"),
                this.setNextStatement(!0, "actionBlock"),
                this.setStyle("control-block-style")
            }
        } : J === "Continue" ? coreBrowserExports.Blocks.Continue = {
            init() {
                this.appendDummyInput().appendField(getTranslatedDisplayName(X)),
                this.setPreviousStatement(!0, "actionBlock"),
                this.setNextStatement(!0, "actionBlock"),
                this.setStyle("control-block-style")
            }
        } : J === "If" ? coreBrowserExports.Blocks.If = {
            init() {
                this.appendDummyInput().appendField(getTranslatedDisplayName(X)),
                this.appendValueInput("VALUE-0").setCheck("Boolean"),
                this.appendStatementInput("DO").setCheck("actionBlock"),
                this.setInputsInline(!0),
                this.setPreviousStatement(!0, "actionBlock"),
                this.setNextStatement(!0, "actionBlock"),
                this.setColour(230),
                this.setMutator(new coreBrowserExports.icons.MutatorIcon(["controls_if_elseif", "controls_if_else"],this)),
                this.setTooltip(""),
                this.setHelpUrl(""),
                this.setStyle("control-block-style")
            },
            domToMutation(ue) {
                this.elseifCount_ = parseInt(ue.getAttribute("elseif") ?? "0", 10),
                this.elseCount_ = parseInt(ue.getAttribute("else") ?? "0", 10),
                this.rebuildShape()
            },
            saveExtraState: function() {
                return !this.elseifCount_ && !this.elseCount_ ? {} : {
                    elseif: this.elseifCount_,
                    else: 1
                }
            },
            loadExtraState: function(ue) {
                this.elseifCount_ = ue.elseif,
                this.elseCount_ = ue.else,
                this.rebuildShape()
            },
            reconnectChildBlocks(ue, ce, me) {
                var Te, _e;
                for (var ge = 0; ge <= this.elseifCount_; ge++)
                    (Te = ue[ge]) == null || Te.reconnect(this, "IF" + (ge + 1)),
                    (_e = ce[ge]) == null || _e.reconnect(this, "DO" + (ge + 1));
                me && (me == null || me.reconnect(this, "ELSE"))
            },
            decompose(ue) {
                const ce = ue.newBlock("controls_if_if");
                ce.initSvg();
                for (var me = ce.nextConnection, ge = 1; ge <= this.elseifCount_; ge++) {
                    var Te = ue.newBlock("controls_if_elseif");
                    Te.initSvg(),
                    me.connect(Te.previousConnection),
                    me = Te.nextConnection
                }
                if (this.elseCount_) {
                    var _e = ue.newBlock("controls_if_else");
                    _e.initSvg(),
                    me.connect(_e.previousConnection)
                }
                return ce
            },
            compose(ue) {
                var _e;
                var ce = (_e = ue.nextConnection) == null ? void 0 : _e.targetBlock();
                this.elseifCount_ = 0,
                this.elseCount_ = 0;
                for (var me = [], ge = [], Te = null; ce && !ce.isInsertionMarker(); ) {
                    switch (ce.type) {
                    case "controls_if_elseif":
                        this.elseifCount_++,
                        me.push(ce.valueConnection_),
                        ge.push(ce.statementConnection_);
                        break;
                    case "controls_if_else":
                        this.elseCount_++,
                        Te = ce.statementConnection_;
                        break;
                    default:
                        throw TypeError("Unknown block type: " + ce.type)
                    }
                    ce = ce.nextConnection && ce.nextConnection.targetBlock()
                }
                this.updateShape(),
                this.reconnectChildBlocks(me, ge, Te)
            },
            saveConnections(ue) {
                var _e;
                for (var ce = (_e = ue.nextConnection) == null ? void 0 : _e.targetBlock(), me = 1; ce; ) {
                    switch (ce.type) {
                    case "controls_if_elseif":
                        var ge = this.getInput("IF" + me)
                          , Te = this.getInput("DO" + me);
                        ce.valueConnection_ = ge && ge.connection.targetConnection,
                        ce.statementConnection_ = Te && Te.connection.targetConnection,
                        me++;
                        break;
                    case "controls_if_else":
                        var Te = this.getInput("ELSE");
                        ce.statementConnection_ = Te && Te.connection.targetConnection;
                        break;
                    default:
                        throw TypeError("Unknown block type: " + ce.type)
                    }
                    ce = ce.nextConnection && ce.nextConnection.targetBlock()
                }
            },
            rebuildShape() {
                var Se, Ie, ye, $e;
                var ue = []
                  , ce = []
                  , me = null;
                this.getInput("ELSE") && (me = ((Ie = (Se = this.getInput("ELSE")) == null ? void 0 : Se.connection) == null ? void 0 : Ie.targetConnection) ?? null);
                for (var ge = 1; this.getInput("IF" + ge); ) {
                    var Te = this.getInput("IF" + ge)
                      , _e = this.getInput("DO" + ge);
                    const Ne = (ye = Te == null ? void 0 : Te.connection) == null ? void 0 : ye.targetConnection
                      , ve = ($e = _e == null ? void 0 : _e.connection) == null ? void 0 : $e.targetConnection;
                    Ne && ue.push(Ne),
                    ve && ce.push(ve),
                    ge++
                }
                this.updateShape(),
                this.reconnectChildBlocks(ue, ce, me)
            },
            updateShape() {
                this.getInput("ELSE") && this.removeInput("ELSE");
                for (var ue = 1; this.getInput("IF" + ue); )
                    this.removeInput("IF" + ue),
                    this.removeInput("DO" + ue),
                    ue++;
                for (ue = 1; ue <= this.elseifCount_; ue++)
                    this.appendValueInput("IF" + ue).setCheck("Boolean").appendField(getBlocklyTranslation("CONTROLS_IF_MSG_ELSEIF")),
                    this.appendStatementInput("DO" + ue).appendField("").setCheck("actionBlock");
                this.elseCount_ && this.appendStatementInput("ELSE").appendField(getBlocklyTranslation("CONTROLS_IF_MSG_ELSE")).setCheck("actionBlock")
            }
        } : J === "ForGlobalVariable" ? coreBrowserExports.Blocks[J] = {
            init: function() {
                this.jsonInit({
                    type: "controls_global_for_loop",
                    message0: "Loop Global Variable %1 From %2 To %3 By %4 %5",
                    args0: [{
                        type: "input_value",
                        name: "VALUE-0",
                        check: "GlobalVariable"
                    }, {
                        type: "input_value",
                        name: "VALUE-1",
                        check: "Number"
                    }, {
                        type: "input_value",
                        name: "VALUE-2",
                        check: "Number"
                    }, {
                        type: "input_value",
                        name: "VALUE-3",
                        check: "Number"
                    }, {
                        type: "input_statement",
                        name: "DO",
                        check: "actionBlock"
                    }],
                    inputsInline: !0,
                    previousStatement: "actionBlock",
                    nextStatement: "actionBlock",
                    colour: "#d89a3c",
                    tooltip: "",
                    helpUrl: ""
                })
            }
        } : J === "ForObjectVariable" ? coreBrowserExports.Blocks[J] = {
            init: function() {
                this.jsonInit({
                    type: "controls_object_for_loop",
                    message0: "Loop Object Variable %1 From %2 To %3 By %4 %5",
                    args0: [{
                        type: "input_value",
                        name: "VALUE-0",
                        check: "ObjectVariable"
                    }, {
                        type: "input_value",
                        name: "VALUE-1",
                        check: "Number"
                    }, {
                        type: "input_value",
                        name: "VALUE-2",
                        check: "Number"
                    }, {
                        type: "input_value",
                        name: "VALUE-3",
                        check: "Number"
                    }, {
                        type: "input_statement",
                        name: "DO",
                        check: "actionBlock"
                    }],
                    inputsInline: !0,
                    previousStatement: "actionBlock",
                    nextStatement: "actionBlock",
                    colour: "#d89a3c",
                    tooltip: "",
                    helpUrl: ""
                })
            }
        } : J === "ForVariable" ? coreBrowserExports.Blocks[J] = {
            init: function() {
                this.appendDummyInput().appendField(getTranslatedDisplayName(X)),
                this.appendValueInput("VALUE-0").setCheck("Variable"),
                this.appendDummyInput().appendField(getBlocklyTranslation("PYRITE_CONTROL_FROM")),
                this.appendValueInput("VALUE-1").setCheck("Number"),
                this.appendDummyInput().appendField(getBlocklyTranslation("PYRITE_CONTROL_TO")),
                this.appendValueInput("VALUE-2").setCheck("Number"),
                this.appendDummyInput().appendField(getBlocklyTranslation("PYRITE_CONTROL_BY")),
                this.appendValueInput("VALUE-3").setCheck("Number"),
                this.appendStatementInput("DO").setCheck("actionBlock"),
                this.setInputsInline(!0),
                this.setPreviousStatement(!0, "actionBlock"),
                this.setNextStatement(!0, "actionBlock"),
                this.setTooltip(""),
                this.setHelpUrl(""),
                this.setStyle("control-block-style")
            }
        } : J === "While" && (coreBrowserExports.Blocks.While = {
            init() {
                this.appendDummyInput().appendField(getTranslatedDisplayName(X)),
                this.appendValueInput("VALUE-0").setCheck("Boolean"),
                this.appendStatementInput("DO").setCheck("actionBlock"),
                this.setInputsInline(!0),
                this.setPreviousStatement(!0, "actionBlock"),
                this.setNextStatement(!0, "actionBlock"),
                this.setTooltip(""),
                this.setHelpUrl(""),
                this.setStyle("control-block-style")
            }
        })
    }
    )
}
function createValueBlocks(V) {
    function X(J) {
        var ce;
        const ne = V.selectionLists.find(me => me.name === J)
          , ue = ((ce = ne == null ? void 0 : ne.selectionValues) == null ? void 0 : ce.map(me => [getTranslatedDisplayName(me), me.name])) ?? [];
        return ue.length > 0 ? ue : [["N/A", "never"]]
    }
    V.values.forEach(J => {
        const {name: ne, displayNameSID: ue, eventParameter: ce, functionSignatures: me} = J
          , ge = V.selectionLists.filter(_e => {
            var Se;
            return _e.returnType === ((Se = me == null ? void 0 : me[0]) == null ? void 0 : Se.returnType)
        }
        )
          , Te = ge.length > 0;
        coreBrowserExports.Blocks[ne] = {
            init() {
                if (this.appendDummyInput(BLOCK_LABEL_NAME).appendField(getTranslatedDisplayName(J)),
                populateReturnValueIcons(this, V, me),
                Te)
                    this.appendDummyInput().appendField(new coreBrowserExports.FieldDropdown( () => ge.map( (_e, Se) => [getTranslatedDisplayName(_e), _e.name])), "VALUE-0"),
                    this.appendDummyInput().appendField(new coreBrowserExports.FieldDropdown( () => X(this.getFieldValue("VALUE-0"))), "VALUE-1");
                else if (me !== void 0)
                    for (let _e = 0; _e < this.maxParametersCount(); _e++)
                        this.appendValueInput(`VALUE-${_e}`).setCheck(this.getTypesForParameterIndex(_e));
                else
                    throw new Error(`Block '${ne}' is missing functionSignatures`);
                this.setOutput(!0, this.getTypesForOutput()),
                this.setTooltip(this.getTooltipText()),
                this.setInputsInline(!0),
                this.setStyle("value-block-style")
            },
            maxParametersCount() {
                return me ? getMaxParamaterCount(me) : 0
            },
            getTypesForParameterIndex(_e) {
                return me ? getTypesForBlockParameterIndex(me, this, _e) ?? V.types : []
            },
            getTypesForOutput() {
                return me ? getTypesForBlockOutput(me, this) ?? V.types : []
            },
            getTooltipText() {
                if (!me)
                    return "";
                const _e = filterFunctionSignaturesForBlock(me, this);
                return ((me == null ? void 0 : me.map(Se => {
                    var $e;
                    const Ie = _e.includes(Se)
                      , ye = `${ue ? getBlocklyTranslation(ue) : ne}(${Se.parameterTypes && !Te ? ($e = Se.parameterTypes) == null ? void 0 : $e.map( (Ne, ve) => `<span style="color: rgba(255, 255, 255, 0.7);">${Ne.anyType ? getBlocklyTranslation("PYRITE_TYPE_ANYTYPE") : Ne.parameterTypes.map(ke => getBlocklyTranslation(`PYRITE_TYPE_${ke.toUpperCase()}`)).join(" | ")}</span>`).join(", ") : ""}): ${getBlocklyTranslation(Se.returnType ? `PYRITE_TYPE_${Se.returnType.toUpperCase()}` : "PYRITE_TYPE_ANYTYPE")}`;
                    return Ie ? `<b>${ye}</b>` : `<span style="opacity: 0.7">${ye}</span>`
                }
                )) ?? []).join("<br /><br />")
            },
            onchange(_e) {
                if (isEventRelatedToBlock(_e, this) && me && !Te) {
                    for (let Se = 0; Se < this.maxParametersCount(); Se++) {
                        const Ie = this.getInput(`VALUE-${Se}`)
                          , ye = this.getTypesForParameterIndex(Se);
                        Ie == null || Ie.setCheck(ye)
                    }
                    this.setOutput(!0, this.getTypesForOutput()),
                    this.setTooltip(this.getTooltipText()),
                    populateReturnValueIcons(this, V, me),
                    this instanceof coreBrowserExports.BlockSvg && this.render()
                }
                if (_e.type === coreBrowserExports.Events.CHANGE && isEventRelatedToBlock(_e, this) && Te && _e.name === "VALUE-0" && _e.newValue !== _e.oldValue) {
                    const Se = this.getField("VALUE-1");
                    if (Se) {
                        const ye = Se.getOptions()[0][1];
                        Se.setValue(ye)
                    }
                }
                if ([coreBrowserExports.Events.MOVE, coreBrowserExports.Events.CHANGE].indexOf(_e.type) > -1 && ce) {
                    let Se, Ie = this.getParent();
                    do
                        (Ie == null ? void 0 : Ie.type) === "ruleBlock" && (Se = Ie),
                        Ie = (Ie == null ? void 0 : Ie.getParent()) ?? null;
                    while (Se === void 0 && Ie);
                    if (Se) {
                        const ye = Se.getFieldValue("EVENTTYPE")
                          , $e = V.events.find(ve => ve.name === ye)
                          , Ne = ye === "Ongoing";
                        if ($e || Ne) {
                            let ve = !0, ke;
                            if (Ne) {
                                const xe = Se.getFieldValue("OBJECTTYPE")
                                  , we = V.objects.find(Fe => Fe.name === xe);
                                ve = (we == null ? void 0 : we.type) === ce
                            } else if ($e) {
                                const xe = $e.parameters.findIndex(we => we.name === ce);
                                ve = xe > -1,
                                ke = $e.parameters[xe]
                            }
                            this.setEnabled(!0),
                            ve ? (this.setWarningText(null, "unsupportedRuleEvent"),
                            ke != null && ke.deprecated ? this.setWarningText(getBlocklyTranslation("PYRITE_DEPRECATED_RULE_EVENT"), "deprecatedRuleEvent") : this.setWarningText(null, "deprecatedRuleEvent"),
                            this.setStyle("value-block-style")) : (this.setWarningText(getBlocklyTranslation("PYRITE_UNSUPPORTED_RULE_EVENT"), "unsupportedRuleEvent"),
                            this.setWarningText(null, "deprecatedRuleEvent"),
                            this.setStyle("unsupported-value-block-style"))
                        }
                    } else
                        this.setStyle("value-block-style"),
                        this.setWarningText(null, "unsupportedRuleEvent")
                }
            }
        }
    }
    ),
    coreBrowserExports.Blocks.missingValueBlockType_v1 = {
        init() {
            this.appendDummyInput().appendField(new coreBrowserExports.FieldLabelSerializable("BLOCK NAME",void 0,void 0), "DELETED_NAME"),
            this.appendDummyInput().appendField("DELETED"),
            this.setInputsInline(!0),
            this.setOutput(!0, null),
            this.setColour(0),
            this.setTooltip(""),
            this.setHelpUrl(""),
            this.setStyle("value-block-style")
        }
    }
}
let createdBlocksForVersion;
class BlocklyImporterManager {
    constructor(X) {
        this.mainWorkspace = X
    }
    init(X, J) {
        if (typeof X > "u")
            throw new Error("Missing rulesVersion!");
        this.mainWorkspace instanceof coreBrowserExports.WorkspaceSvg && console.debug("Frostbite Block Definitions", J),
        this.definitions = J,
        createdBlocksForVersion !== X && (console.log(`Creating blocks for rulesVersion ${X}`),
        createdBlocksForVersion = X,
        this.createBlocks())
    }
    createBlocks() {
        createModBlocks(),
        createLiteralBlocks(),
        createLogicBlocks(),
        this.definitions && (createConvenienceBlocks(this.definitions),
        createRuleBlocks(this.definitions),
        createValueBlocks(this.definitions),
        createActionBlocks(this.definitions),
        createControlBlocks(this.definitions))
    }
}
var BlocklyWorkspaceCallback = (V => (V.MANAGE_VARIABLES = "MANAGE_CUSTOM_VARIABLES",
V.CUSTOM_VARIABLE_FLYOUT = "CUSTOM_VARIABLE_FLYOUT",
V.RENAME_VARIABLE = "RENAME_CUSTOM_VARIABLES",
V.CREATE_SUBROUTINE = "CREATE_CUSTOM_SUBROUTINE",
V.CUSTOM_SUBROUTINE_FLYOUT = "CUSTOM_SUBROUTINE_FLYOUT",
V))(BlocklyWorkspaceCallback || {});
class BlocklySubroutineManager {
    constructor(X) {
        this.mainWorkspace = X,
        this.parameters = new Map,
        this.createNewSubroutineAction = J => {}
        ,
        this.renameSubroutineCallbackAction = (J, ne) => {}
        ,
        this.deleteSubroutineCallbackAction = J => {}
        ,
        this.renameSubroutineCallback = J => {
            this.renameSubroutineCallbackAction(this.subroutines, J)
        }
        ,
        this.deleteSubroutineCallback = J => {
            this.deleteSubroutineCallbackAction(J)
        }
        ,
        this.createSubroutineBlocks()
    }
    init(X) {
        this.definitions = X
    }
    get subroutines() {
        return this.mainWorkspace ? this.mainWorkspace.getTopBlocks(!0).filter(X => X.type === "subroutineBlock").map(X => X.getFieldValue("SUBROUTINE_NAME")) : []
    }
    destroy() {
        this.mainWorkspace instanceof coreBrowserExports.WorkspaceSvg && this.mainWorkspace.removeButtonCallback(BlocklyWorkspaceCallback.CREATE_SUBROUTINE)
    }
    subroutinesFlyoutCallback(X) {
        var ce;
        const J = []
          , ne = document.createElement("button");
        if (ne.setAttribute("text", getBlocklyTranslation("PYRITE_CREATE_SUBROUTINE")),
        ne.setAttribute("callbackKey", "CREATE_CUSTOM_SUBROUTINE"),
        J.push(ne),
        ((ce = this.definitions) == null ? void 0 : ce.values.find(me => me.name === "GetArgument")) && this.subroutines.length > 0) {
            const me = coreBrowserExports.utils.xml.createElement("block");
            me.setAttribute("type", "subroutineArgumentBlock"),
            J.push(me)
        }
        if (coreBrowserExports.Blocks.subroutineBlock && coreBrowserExports.Blocks.subroutineInstanceBlock)
            for (const me of this.subroutines) {
                const ge = coreBrowserExports.utils.xml.createElement("block");
                ge.setAttribute("type", "subroutineInstanceBlock");
                const Te = coreBrowserExports.utils.xml.createElement("field");
                Te.setAttribute("name", "SUBROUTINE_NAME"),
                Te.appendChild(coreBrowserExports.utils.xml.createTextNode(me)),
                ge.appendChild(Te),
                J.push(ge)
            }
        return J
    }
    createSubroutineBlocks() {
        const X = this;
        this.mainWorkspace instanceof coreBrowserExports.WorkspaceSvg && (this.mainWorkspace.registerToolboxCategoryCallback(BlocklyWorkspaceCallback.CUSTOM_SUBROUTINE_FLYOUT, J => this.subroutinesFlyoutCallback(this.mainWorkspace)),
        this.mainWorkspace.registerButtonCallback(BlocklyWorkspaceCallback.CREATE_SUBROUTINE, () => {
            this.createNewSubroutine()
        }
        )),
        coreBrowserExports.Blocks.subroutineBlock = {
            init() {
                this.appendDummyInput().appendField(new coreBrowserExports.FieldLabel(getBlocklyTranslation("PYRITE_SUBROUTINE"),"fieldHeaderText subroutineBlockSubroutineText")).appendField(new coreBrowserExports.FieldLabelSerializable(getBlocklyTranslation("PYRITE_NEW_SUBROUTINE")), "SUBROUTINE_NAME"),
                this.appendDummyInput("PARAMETERS").appendField(new coreBrowserExports.FieldLabel("",""), "PARAMETER_LABELS"),
                this.appendStatementInput("CONDITIONS").setCheck("conditionBlock").appendField(new coreBrowserExports.FieldLabel(getBlocklyTranslation("PYRITE_CONDITIONS"),"fieldHeaderText ruleBlockConditionText")),
                this.appendStatementInput("ACTIONS").setCheck("actionBlock").appendField(new coreBrowserExports.FieldLabel(getBlocklyTranslation("PYRITE_ACTIONS"),"fieldHeaderText ruleBlockActionText")),
                this.setInputsInline(!0),
                this.setStyle("subroutine-block-style"),
                this.updateShape()
            },
            onchange(J) {
                J.type === coreBrowserExports.Events.BLOCK_CREATE ? this.setDeletable(!1) : J instanceof PyriteBlocklyEventsSubroutineParametersChange && this.updateShape()
            },
            domToMutation(J) {
                var ge;
                const ne = this
                  , ue = J.parentElement
                  , ce = (ge = ue == null ? void 0 : ue.querySelector('field[name="SUBROUTINE_NAME"]')) == null ? void 0 : ge.textContent
                  , me = [];
                J.querySelectorAll("parameter").forEach(Te => {
                    var _e;
                    Te.textContent && (me == null || me.push({
                        name: Te.textContent,
                        types: ((_e = Te.getAttribute("types")) == null ? void 0 : _e.split(",")) ?? []
                    }))
                }
                ),
                ce && X.parameters.set(ce, me),
                ne.updateShape(me)
            },
            saveExtraState: function() {
                var ce;
                const ne = this.getFieldValue("SUBROUTINE_NAME")
                  , ue = (ce = X.parameters.get(ne)) == null ? void 0 : ce.map(me => {
                    var ge;
                    return {
                        types: Array.isArray(me.types) ? (ge = me.types) == null ? void 0 : ge.join(",") : me.types,
                        name: me.name
                    }
                }
                );
                return {
                    ...ne && {
                        subroutineName: ne
                    },
                    parameters: ue
                }
            },
            loadExtraState: function(J) {
                var ne;
                J.subroutineName && X.parameters.set(J.subroutineName, ((ne = J.parameters) == null ? void 0 : ne.map(ue => ({
                    types: Array.isArray(ue.types) ? ue.types : ue.types.split(","),
                    name: ue.name
                }))) ?? []),
                this.updateShape(J.parameters ?? [])
            },
            updateShape(J) {
                const ne = this
                  , ue = ne.getFieldValue("SUBROUTINE_NAME");
                if (J = J ?? (ue ? X.parameters.get(ue) : []),
                J) {
                    const ce = ne.getField("PARAMETER_LABELS");
                    ce && ce.setValue(J.map(me => me.name).join(", "))
                }
            },
            customContextMenu(J) {
                {
                    const ne = {
                        text: getBlocklyTranslation("rules.subroutines.edit-subroutine"),
                        enabled: !0,
                        callback: () => {
                            X.renameSubroutineCallback(this)
                        }
                    }
                      , ue = {
                        text: getBlocklyTranslation("rules.subroutines.delete-subroutine"),
                        enabled: !0,
                        callback: () => {
                            X.deleteSubroutineCallback(this)
                        }
                    };
                    J.unshift(ne),
                    J.unshift(ue)
                }
            }
        },
        coreBrowserExports.Blocks.subroutineInstanceBlock = {
            init() {
                this.appendDummyInput().appendField(new coreBrowserExports.FieldLabelSerializable(""), "SUBROUTINE_NAME"),
                this.setPreviousStatement(!0, "actionBlock"),
                this.setNextStatement(!0, "actionBlock"),
                this.setInputsInline(!0),
                this.setStyle("action-block-style"),
                this.updateShape()
            },
            onchange(J) {
                J instanceof PyriteBlocklyEventsSubroutineParametersChange && this.updateShape()
            },
            domToMutation(J) {
                var ge;
                const ne = this
                  , ue = J.parentElement
                  , ce = (ge = ue == null ? void 0 : ue.querySelector('field[name="SUBROUTINE_NAME"]')) == null ? void 0 : ge.textContent
                  , me = [];
                J.querySelectorAll("parameter").forEach(Te => {
                    var _e;
                    Te.textContent && (me == null || me.push({
                        name: Te.textContent,
                        types: ((_e = Te.getAttribute("types")) == null ? void 0 : _e.split(",")) ?? []
                    }))
                }
                ),
                ce && X.parameters.set(ce, me),
                ne.updateShape(me)
            },
            saveExtraState: function() {
                var ce;
                const ne = this.getFieldValue("SUBROUTINE_NAME")
                  , ue = (ce = X.parameters.get(ne)) == null ? void 0 : ce.map(me => {
                    var ge;
                    return {
                        types: Array.isArray(me.types) ? (ge = me.types) == null ? void 0 : ge.join(",") : me.types,
                        name: me.name
                    }
                }
                );
                return {
                    ...ne && {
                        subroutineName: ne
                    },
                    parameters: ue
                }
            },
            loadExtraState: function(J) {
                var ne;
                J.subroutineName && X.parameters.set(J.subroutineName, ((ne = J.parameters) == null ? void 0 : ne.map(ue => ({
                    types: Array.isArray(ue.types) ? ue.types : ue.types.split(","),
                    name: ue.name
                }))) ?? []),
                this.updateShape(J.parameters || [])
            },
            updateShape(J) {
                const ne = this
                  , ue = ne.getFieldValue("SUBROUTINE_NAME")
                  , ce = J ?? (ue ? X.parameters.get(ue) ?? [] : []);
                let me = 0;
                ne.getInput("ENDPARAMS") && ne.removeInput("ENDPARAMS"),
                ne.inputList.map(ge => ge.name).forEach(ge => {
                    var Te, _e;
                    if (ge.startsWith("PARAM-")) {
                        me++;
                        const Se = +ge.split("-")[1]
                          , Ie = ce[Se];
                        Ie ? ((_e = ne.getInput(`PARAM-${Se}`)) == null || _e.setCheck((Ie.types.length === 0 ? (Te = X.definitions) == null ? void 0 : Te.types : Ie.types) ?? null),
                        ne.setFieldValue(Ie.name, `PARAMLABELVALUE-${Se}`)) : (ne.removeInput(`PARAM-${Se}`),
                        ne.removeInput(`PARAMLABEL-${Se}`))
                    }
                }
                ),
                ce.length > me && ce.slice(me).forEach(ge => {
                    const Te = ce.findIndex(_e => _e.name === ge.name);
                    if (Te !== -1) {
                        ne.appendDummyInput(`PARAMLABEL-${Te}`).appendField(new coreBrowserExports.FieldLabel(ge.name), `PARAMLABELVALUE-${Te}`);
                        const _e = Array.isArray(ge.types) ? ge.types : ge.types.split(",");
                        ne.appendValueInput(`PARAM-${Te}`).setCheck(_e.length === 1 && _e[0] === "" ? null : _e)
                    }
                }
                ),
                ne.appendDummyInput("ENDPARAMS")
            }
        },
        coreBrowserExports.Blocks.subroutineArgumentBlock = {
            init() {
                var J;
                this.appendDummyInput().appendField(new coreBrowserExports.FieldLabel(getBlocklyTranslation("PYRITE_SUBROUTINE_GET_ARGUMENT"))),
                this.appendDummyInput().appendField(new coreBrowserExports.FieldDropdown(this.argumentDropdownCreate.bind(this),function(ne) {}
                ), "ARGUMENT_INDEX"),
                this.setOutput(!0, (J = X.definitions) == null ? void 0 : J.types),
                this.setInputsInline(!0),
                this.setStyle("value-block-style")
            },
            argumentDropdownCreate() {
                const ne = this.getRootBlock();
                if (ne.type === "subroutineBlock") {
                    const ce = ne.getFieldValue("SUBROUTINE_NAME")
                      , me = X.parameters.get(ce);
                    if (me)
                        return me.map( (ge, Te) => [ge.name, `${Te}`])
                }
                return [[getBlocklyTranslation("rules.subroutines.no-parameters"), "1"]]
            },
            onchange(J) {
                J instanceof PyriteBlocklyEventsSubroutineParametersChange ? this.refreshTextContent() : isEventRelatedToBlock(J, this) && (J.type === coreBrowserExports.Events.CHANGE || J.type === coreBrowserExports.Events.MOVE) && this.refreshTextContent()
            },
            refreshTextContent() {
                const J = this.getField("ARGUMENT_INDEX")
                  , ue = J.getOptions().find(ce => ce[1] === J.getValue());
                ue && J.textElement_ && (J.textElement_.textContent = ue[0].toString() ?? "",
                J.forceRerender())
            }
        }
    }
    registerCreateNewSubroutineAction(X) {
        this.createNewSubroutineAction = X
    }
    createNewSubroutine() {
        this.createNewSubroutineAction(this.subroutines)
    }
    refreshToolboxes() {
        this.mainWorkspace instanceof coreBrowserExports.WorkspaceSvg && this.mainWorkspace.refreshToolboxSelection()
    }
    renameSubroutine(X, J) {
        if (X !== J && this.subroutineExists(X)) {
            const ne = this.getSubroutineBlock(X);
            if (ne) {
                const ce = ne.getField("SUBROUTINE_NAME");
                ce && ce.setValue(J)
            }
            this.getSubroutineInstanceBlocks(X).forEach(ce => {
                const me = ce.getField("SUBROUTINE_NAME");
                me && me.setValue(J)
            }
            );
            const ue = this.parameters.get(X);
            ue && (this.parameters.delete(X),
            this.parameters.set(J, ue))
        }
    }
    setSubroutineParametes(X, J) {
        const ne = this.getSubroutineBlock(X);
        if (ne) {
            this.parameters.set(X, J);
            const ue = new PyriteBlocklyEventsSubroutineParametersChange;
            ue.blockId = ne.id,
            ue.workspaceId = ne.workspace.id,
            ue.isUiEvent = !1,
            ue.recordUndo = !1,
            ue.isBlank = !1,
            ne.workspace.fireChangeListener(ue)
        }
        this.refreshToolboxes()
    }
    getSubroutineParameters(X) {
        return this.parameters.get(X) ?? []
    }
    subroutineExists(X) {
        const J = ue => ue === X;
        return this.subroutines.findIndex(J) !== -1
    }
    getSubroutineBlock(X) {
        const J = this.mainWorkspace.getBlocksByType("subroutineBlock", !1).filter(ne => ne.getFieldValue("SUBROUTINE_NAME") === X)[0];
        return J || void 0
    }
    getSubroutineInstanceBlocks(X) {
        return this.mainWorkspace.getBlocksByType("subroutineInstanceBlock", !1).filter(J => J.getFieldValue("SUBROUTINE_NAME") === X)
    }
    deleteSubroutine(X) {
        if (this.subroutineExists(X)) {
            const J = this.getSubroutineBlock(X);
            J && J.dispose(!0),
            this.getSubroutineInstanceBlocks(X).forEach(ne => {
                ne.dispose(!0)
            }
            )
        }
        this.refreshToolboxes()
    }
    registerRenameSubroutineCallbackAction(X) {
        this.renameSubroutineCallbackAction = X
    }
    registerDeleteSubroutineCallbackAction(X) {
        this.deleteSubroutineCallbackAction = X
    }
    createSubroutineDefinitionBlock(X) {
        const J = coreBrowserExports.utils.xml.createElement("block");
        J.setAttribute("type", "subroutineBlock");
        const ne = coreBrowserExports.utils.xml.createElement("field");
        ne.setAttribute("name", "SUBROUTINE_NAME"),
        ne.appendChild(coreBrowserExports.utils.xml.createTextNode(X));
        const {top: ue, left: ce, width: me, height: ge} = this.mainWorkspace.getMetricsManager().getViewMetrics()
          , Te = ce + me / 2
          , _e = ue + ge / 2 - 150;
        J.setAttribute("x", Te.toString()),
        J.setAttribute("y", _e.toString()),
        J.appendChild(ne),
        this.mainWorkspace instanceof coreBrowserExports.WorkspaceSvg && this.mainWorkspace.paste(J),
        this.refreshToolboxes()
    }
}
class BlocklyVariablesManager {
    constructor(X) {
        this.mainWorkspace = X,
        this.maxGlobalVariables = 0,
        this.maxObjectVariables = 0,
        this.objectTypes = [],
        this.manageVariablesAction = (J, ne) => {}
        ,
        this.renameVariableCallbackAction = J => {}
        ,
        this.deleteVariableCallbackAction = J => {}
        ,
        this.renameVariableCallback = J => {
            this.renameVariableCallbackAction(J)
        }
        ,
        this.deleteVariableCallback = J => {
            this.deleteVariableCallbackAction(J)
        }
    }
    init(X) {
        this.definitions = X,
        this.objectTypes = this.definitions.objects.map(J => [getTranslatedDisplayName(J), J.type]),
        this.maxGlobalVariables = this.definitions.constraints.maxGlobalVariables,
        this.maxObjectVariables = this.definitions.constraints.maxObjectVariables,
        this.createVariableTypesBlocks(this.objectTypes)
    }
    destroy() {
        this.mainWorkspace instanceof coreBrowserExports.WorkspaceSvg && this.mainWorkspace.removeButtonCallback(BlocklyWorkspaceCallback.MANAGE_VARIABLES)
    }
    getGlobalVariableCount() {
        return this.mainWorkspace.getVariablesOfType("Global").length
    }
    getObjectVariableCount() {
        return this.mainWorkspace.getAllVariables().filter(X => X.type !== "Global" && X.type !== "").length
    }
    canCreateVariableOfType(X) {
        return X === "Global" ? this.getGlobalVariableCount() < this.maxGlobalVariables : this.getObjectVariableCount() < this.maxObjectVariables
    }
    registerManageVariablesAction(X) {
        this.manageVariablesAction = X
    }
    get availableObjectTypes() {
        return this.objectTypes.filter(J => this.mainWorkspace.getVariablesOfType(J[1]).length > 0)
    }
    variablesFlyoutCallback(X) {
        const J = []
          , ne = document.createElement("button");
        if (ne.setAttribute("text", getBlocklyTranslation("PYRITE_MANAGE_VARIABLES")),
        ne.setAttribute("callbackKey", "MANAGE_CUSTOM_VARIABLES"),
        J.push(ne),
        this.availableObjectTypes.length > 0) {
            const ce = coreBrowserExports.utils.xml.createElement("block");
            ce.setAttribute("type", "variableReferenceBlock"),
            J.push(ce);
            const me = coreBrowserExports.utils.xml.createElement("value");
            me.setAttribute("name", "VALUE-0"),
            me.appendChild(ce.cloneNode());
            const ge = coreBrowserExports.utils.xml.createElement("block");
            ge.setAttribute("type", "GetVariable"),
            ge.appendChild(me),
            J.push(ge);
            const Te = coreBrowserExports.utils.xml.createElement("value");
            Te.setAttribute("name", "VALUE-0"),
            Te.appendChild(ce.cloneNode());
            const _e = coreBrowserExports.utils.xml.createElement("block");
            _e.setAttribute("type", "SetVariable"),
            _e.appendChild(Te),
            J.push(_e)
        }
        return J
    }
    createVariableTypesBlocks(X) {
        this.mainWorkspace instanceof coreBrowserExports.WorkspaceSvg && (this.mainWorkspace.registerToolboxCategoryCallback(BlocklyWorkspaceCallback.CUSTOM_VARIABLE_FLYOUT, J => this.variablesFlyoutCallback(this.mainWorkspace)),
        this.mainWorkspace.registerButtonCallback(BlocklyWorkspaceCallback.MANAGE_VARIABLES, () => {
            var J;
            this.manageVariablesAction(X, (J = this.definitions) == null ? void 0 : J.constraints)
        }
        )),
        coreBrowserExports.Blocks.variableReferenceBlock = {
            init() {
                const J = this;
                this.appendDummyInput().appendField(new coreBrowserExports.FieldDropdown( () => J.availableObjectTypes()), "OBJECTTYPE").appendField(getBlocklyTranslation("PYRITE_TYPE_VARIABLE")),
                this.appendDummyInput().appendField(new coreBrowserExports.FieldVariable(" "), "VAR"),
                this.setInputsInline(!0),
                this.setOutput(!0, "Variable"),
                this.setColour("#33b4ff");
                const ne = this.getField("VAR");
                ne.setValidator(function(ue) {
                    var ge;
                    const ce = (ge = this.getVariable()) == null ? void 0 : ge.type
                      , me = ce ? ce !== "Global" : !1;
                    J.updateShape(me)
                }),
                ne.menuGenerator_ = this.variableDropdownCreate,
                this.setStyle("variable-block-style")
            },
            availableObjectTypes() {
                return this.workspace === void 0 ? [["", ""]] : X.filter(ne => {
                    var ue;
                    return ((ue = this.workspace) == null ? void 0 : ue.getVariablesOfType(ne[1]).length) > 0
                }
                )
            },
            domToMutation(J) {
                const ne = J.getAttribute("isObjectVar") === "true";
                this.updateShape(ne)
            },
            saveExtraState: function() {
                const J = this.getFieldValue("VAR")
                  , ne = this.workspace.getVariableById(J);
                return {
                    isObjectVar: (ne == null ? void 0 : ne.type) !== "Global"
                }
            },
            loadExtraState: function(J) {
                this.updateShape(J == null ? void 0 : J.isObjectVar)
            },
            updateShape(J) {
                var ge;
                const ue = ((ge = this.getField("VAR").getVariable()) == null ? void 0 : ge.type) ?? null
                  , ce = this.getInput("OBJECT")
                  , me = this.getInput("FORLABEL");
                J ? (me || this.appendDummyInput("FORLABEL").appendField(new coreBrowserExports.FieldLabel(getBlocklyTranslation("PYRITE_CONTROL_FOR"))),
                ce ? ce.setCheck(ue) : this.appendValueInput("OBJECT").setCheck(ue)) : (ce && this.removeInput("OBJECT"),
                me && this.removeInput("FORLABEL"))
            },
            onchange(J) {
                const ne = this.getField("VAR")
                  , ue = this.getFieldValue("OBJECTTYPE")
                  , ce = ue !== "Global";
                if (J.type === coreBrowserExports.Events.VAR_RENAME && ne.refreshVariableName(),
                (J.type === coreBrowserExports.Events.CHANGE || J.type === coreBrowserExports.Events.VAR_CREATE) && this.updateShape(ce),
                J.type === coreBrowserExports.Events.CREATE || J.type === coreBrowserExports.Events.CHANGE || J.type === coreBrowserExports.Events.VAR_CREATE) {
                    const me = ne == null ? void 0 : ne.getVariable()
                      , ge = me == null ? void 0 : me.type;
                    if (ne && ge !== ue) {
                        const Te = this.workspace.getVariablesOfType(ue);
                        Te.length > 0 && ne.setValue(Te[0].getId())
                    }
                }
            },
            customContextMenu(J) {},
            variableDropdownCreate() {
                var ce, me;
                const J = (ce = this.sourceBlock_) == null ? void 0 : ce.getFieldValue("OBJECTTYPE")
                  , ne = ((me = this.sourceBlock_) == null ? void 0 : me.workspace.getVariablesOfType(J).map(ge => [ge.name, ge.getId()])) ?? [];
                return ne.length > 0 ? ne : [["", ""]]
            },
            customFromXml(J) {
                var Te, _e, Se;
                const ne = J.getAttribute("id") || ""
                  , ue = J.textContent || ""
                  , ce = J.getAttribute("variabletype") || ""
                  , me = coreBrowserExports.Variables.getOrCreateVariablePackage((Te = this.sourceBlock_) == null ? void 0 : Te.workspace, ne, ue, ce);
                if (ce != null && ce !== me.type)
                    throw Error("Serialized variable type with id '" + me.getId() + "' had type " + me.type + ", and does not match variable field that references it: " + coreBrowserExports.Xml.domToText(J) + ".");
                const ge = (_e = this.sourceBlock_) == null ? void 0 : _e.getInput("OBJECT");
                ge ? ge.setCheck(ce) : ce !== "Global" && ((Se = this.sourceBlock_) == null || Se.appendValueInput("OBJECT").setCheck(ce))
            }
        }
    }
    registerRenameVariableCallbackAction(X) {
        this.renameVariableCallbackAction = X
    }
    registerDeleteVariableCallbackAction(X) {
        this.deleteVariableCallbackAction = X
    }
}
const EXCLUDE_BLOCKS = ["ObjectVariable", "GlobalVariable", "CallSubroutine", "Else", "ElseIf", "End"]
  , CONTROL_BLOCKS = ["Break", "Continue", "ForGlobalVariable", "ForObjectVariable", "ForVariable", "If", "While"]
  , EXCLUDE_TYPES = ["Variable"];
class PyriteBlocklyBase {
    constructor() {
        this.default = `<xml xmlns="https://developers.google.com/blockly/xml">
        <block type="modBlock" deletable="false">
            <statement name="RULES">
                <block type="ruleBlock"></block>
            </statement>
        </block>
    </xml>`,
        this.definitions = {}
    }
    registerModRules(X) {
        this.modRules = X
    }
    registerDefinitions(X, J, ne, ue) {
        if (!this.blockImporterManager || !this.subroutinesManager || !this.variablesManager)
            throw new Error("You need to create Workspaces before registring definitions!");
        let ce = ["String", "Number", "Boolean"]
          , me = [];
        const {isObjectInputWildcard: ge=!1} = ue ?? {};
        this.rulesVersion = X,
        this.definitions = {
            objects: [{
                name: "Global",
                type: "Global",
                deprecated: !1,
                displayNameSID: "PYRITE_OBJECT_GLOBAL"
            }].concat(J.objects).map(Te => (ce = ce.concat(Te.type ?? []),
            me = me.concat(Te.type ?? []),
            Te)),
            events: [{
                name: "Ongoing",
                parameters: [],
                deprecated: !1,
                displayNameSID: "PYRITE_EVENT_ONGOING"
            }].concat(J.events.map(Te => ({
                ...Te,
                parameters: Te.parameters.map(_e => typeof _e == "string" ? {
                    name: _e,
                    deprecated: !1
                } : _e)
            }))),
            values: J.values.filter(Te => EXCLUDE_BLOCKS.indexOf(Te.name) === -1 && CONTROL_BLOCKS.indexOf(Te.name) === -1).map(Te => Te.functionSignatures && (ce = ce.concat(getAllTypesFromFunctionSignatures(Te.functionSignatures)),
            ge && Te.functionSignatures.some(_e => {
                var Se;
                return (Se = _e.parameterTypes) == null ? void 0 : Se.some(Ie => Ie.parameterTypes.some(ye => ye === "Object"))
            }
            )) ? {
                ...Te,
                functionSignatures: replaceObjectInputWithAllObjectTypes(Te.functionSignatures, me)
            } : Te),
            actions: J.actions.filter(Te => EXCLUDE_BLOCKS.indexOf(Te.name) === -1 && CONTROL_BLOCKS.indexOf(Te.name) === -1).map(Te => Te.functionSignatures && (ce = ce.concat(getAllTypesFromFunctionSignatures(Te.functionSignatures)),
            ge && Te.functionSignatures.some(_e => {
                var Se;
                return (Se = _e.parameterTypes) == null ? void 0 : Se.some(Ie => Ie.parameterTypes.some(ye => ye === "Object"))
            }
            )) ? {
                ...Te,
                functionSignatures: replaceObjectInputWithAllObjectTypes(Te.functionSignatures, me)
            } : Te),
            selectionLists: J.selectionLists.map(Te => (Te.returnType && (ce = ce.concat(Te.returnType)),
            Te)),
            controlActions: J.actions.filter(Te => CONTROL_BLOCKS.indexOf(Te.name) !== -1).map(Te => (Te.functionSignatures && (ce = ce.concat(getAllTypesFromFunctionSignatures(Te.functionSignatures))),
            Te)),
            types: [],
            constraints: ne
        },
        this.definitions.types = [...new Set(ce)].filter(Te => EXCLUDE_TYPES.indexOf(Te) === -1),
        this.blockImporterManager.init(this.rulesVersion, this.definitions),
        this.subroutinesManager.init(this.definitions),
        this.variablesManager.init(this.definitions)
    }
    setupManagers(X) {
        this.blockImporterManager = new BlocklyImporterManager(X),
        this.subroutinesManager = new BlocklySubroutineManager(X),
        this.variablesManager = new BlocklyVariablesManager(X)
    }
    hasChanges() {
        var ye, $e, Ne;
        let X = !1;
        const J = this.mainWorkspace.getAllVariables()
          , ne = this.mainWorkspace.getTopBlocks(!1)
          , ce = coreBrowserExports.Xml.workspaceToDom(this.mainWorkspace, !0).querySelectorAll('block[type="ruleBlock"]')
          , me = ce[0]
          , ge = ((ye = me == null ? void 0 : me.querySelector('field[name="NAME"]')) == null ? void 0 : ye.innerHTML) !== getBlocklyTranslation("PYRITE_NEW_RULE")
          , Te = (($e = me == null ? void 0 : me.querySelector('field[name="EVENTTYPE"]')) == null ? void 0 : $e.innerHTML) !== "Ongoing"
          , _e = ((Ne = me == null ? void 0 : me.querySelector('field[name="OBJECTTYPE"]')) == null ? void 0 : Ne.innerHTML) !== "Global"
          , Se = !!(me != null && me.querySelector('statement[name="CONDITIONS"] block'))
          , Ie = !!(me != null && me.querySelector('statement[name="ACTIONS"] block'));
        return (ne.length > 1 || J.length > 0 || ce.length !== 1 || ge || Te || _e || Se || Ie) && (X = !0),
        X
    }
    loadDefault() {
        coreBrowserExports.Xml.domToWorkspace(coreBrowserExports.utils.xml.textToDom(this.default), this.mainWorkspace)
    }
    export() {
        if (!this.hasChanges())
            return null;
        const X = this.mainWorkspace.options.readOnly;
        this.mainWorkspace.options.readOnly = !1;
        const J = this.mainWorkspace.getAllVariables()
          , ne = {
            mainWorkspace: coreBrowserExports.Xml.domToText(coreBrowserExports.Xml.workspaceToDom(this.mainWorkspace, !0)),
            variables: coreBrowserExports.Xml.domToText(coreBrowserExports.Xml.variablesToDom(J))
        };
        return this.mainWorkspace.options.readOnly = X,
        ne
    }
}
class PyriteBlockly extends PyriteBlocklyBase {
    constructor(X, J) {
        super(),
        this.changeListeners = [],
        this.mainWorkspace = blocklyExports.inject(X, J),
        this.setupManagers(this.mainWorkspace),
        registerTooltipExtension()
    }
    destroy() {
        this.mainWorkspace.dispose(),
        this.changeListeners.forEach(X => {
            this.mainWorkspace.removeChangeListener(X)
        }
        )
    }
    addChangeListener(X) {
        this.mainWorkspace.addChangeListener(J => {
            X(J)
        }
        )
    }
    async validateWorkspaceDom(X) {
        return X = fixBrokenXmlValidator(X),
        X = missingBlockValidator(X),
        X
    }
    validateWorkspaceJson(X) {
        return validateJsonWorkspace(X)
    }
}
function asArrayValue(V) {
    return Array.isArray(V) ? V : V != null ? [V] : []
}
function asSingleValue(V) {
    if (Array.isArray(V)) {
        if (V.length > 0) {
            if (V.length > 1)
                throw new Error("Value is an array containing more than 1 elements. Expecting only 1.");
            return V[0]
        }
        return null
    }
    return V
}
function createActionBlockGenerators(V, X) {
    [].concat(X.actions, X.controlActions).forEach(J => {
        const {name: ne, functionSignatures: ue} = J;
        V.registerBlockGeneratorCallback(ne, ce => {
            let me = [];
            if (ue !== void 0) {
                const Te = getMaxParamaterCount(ue);
                for (let _e = 0; _e < Te; _e++) {
                    const Se = ce.getInputTargetBlock(`VALUE-${_e}`);
                    if (Se) {
                        const Ie = V.blockToObj(Se);
                        me[_e] = asSingleValue(Ie)
                    }
                }
            }
            const ge = {
                Action: ne,
                Params: me.length > 0 ? me : void 0
            };
            if (ne === "If" || ne === "While" || ne == "ForGlobalVariable" || ne == "ForObjectVariable" || ne == "ForVariable") {
                let Te = [ge];
                const _e = ce.getInputTargetBlock("DO")
                  , Se = V.blockToObj(_e);
                if (Se && (Te = Te.concat(Se)),
                ne === "If" && "elseifCount_"in ce && typeof ce.elseifCount_ == "number") {
                    const Ie = ce;
                    for (let ye = 1; ye <= Ie.elseifCount_; ye++)
                        if (Ie.getInput("IF" + ye)) {
                            const $e = Ie.getInputTargetBlock("IF" + ye)
                              , Ne = V.blockToObj($e);
                            me = asArrayValue(Ne),
                            Te = Te.concat({
                                Action: "ElseIf",
                                Params: me.length > 0 ? me : void 0
                            });
                            const ve = Ie.getInputTargetBlock("DO" + ye)
                              , ke = V.blockToObj(ve);
                            ke && (Te = Te.concat(ke))
                        }
                    if (Ie.getInput("ELSE")) {
                        Te = Te.concat({
                            Action: "Else"
                        });
                        const ye = Ie.getInputTargetBlock("ELSE")
                          , $e = V.blockToObj(ye);
                        $e && (Te = Te.concat($e))
                    }
                }
                return Te = Te.concat({
                    Action: "End"
                }),
                Te
            }
            return ge
        }
        )
    }
    ),
    V.registerBlockGeneratorCallback("actionComment", J => []),
    V.registerBlockGeneratorCallback("missingActionBlockType_v1", J => [])
}
function createConvenienceBlockGenerators(V) {
    V.registerBlockGeneratorCallback("ArrayContains", X => {
        const J = V.blockToObj(X.getInputTargetBlock("VALUE-0"))
          , ne = V.blockToObj(X.getInputTargetBlock("VALUE-1"))
          , ce = {
            Value: "Equals",
            Params: [{
                Value: "CurrentArrayElement"
            }, asSingleValue(ne)]
        };
        return {
            Value: "IsTrueForAny",
            Params: [asSingleValue(J), ce]
        }
    }
    ),
    V.registerBlockGeneratorCallback("IndexOfArrayValue", X => {
        const J = V.blockToObj(X.getInputTargetBlock("VALUE-0"))
          , ne = V.blockToObj(X.getInputTargetBlock("VALUE-1"))
          , ce = {
            Value: "Equals",
            Params: [{
                Value: "CurrentArrayElement"
            }, asSingleValue(ne)]
        };
        return {
            Value: "IndexOfFirstTrue",
            Params: [asSingleValue(J), ce]
        }
    }
    ),
    V.registerBlockGeneratorCallback("RemoveFromArray", X => {
        const J = V.blockToObj(X.getInputTargetBlock("VALUE-0"))
          , ne = V.blockToObj(X.getInputTargetBlock("VALUE-1"))
          , ce = {
            Value: "NotEqualTo",
            Params: [{
                Value: "CurrentArrayElement"
            }, asSingleValue(ne)]
        };
        return {
            Value: "FilteredArray",
            Params: [asSingleValue(J), ce]
        }
    }
    )
}
function createLiteralBlockGenerators(V) {
    V.registerBlockGeneratorCallback("Text", X => X.getFieldValue("TEXT")),
    V.registerBlockGeneratorCallback("Number", X => X.getFieldValue("NUM")),
    V.registerBlockGeneratorCallback("Boolean", X => X.getFieldValue("BOOL") === "TRUE")
}
function createLogicBlockGenerators(V) {
    V.registerBlockGeneratorCallback("Compare", X => {
        const J = X.getFieldValue("OP")
          , ne = V.blockToObj(X.getInputTargetBlock("A"))
          , ue = V.blockToObj(X.getInputTargetBlock("B"));
        return {
            Value: "Compare",
            Params: [J, ne, ue]
        }
    }
    )
}
function createModBlockGenerators(V, X) {
    V.registerBlockGeneratorCallback("modBlock", J => {
        const ne = asArrayValue(V.blockToObj(J.getInputTargetBlock("RULES")))
          , ue = []
          , ce = J.workspace.getTopBlocks(!1);
        for (const Se of ce)
            if (Se.type === "subroutineBlock") {
                const Ie = asSingleValue(V.blockToObj(Se));
                Ie && ue.push(Ie)
            }
        const me = J.workspace.getBlocksByType("variableReferenceBlock", !1)
          , ge = new Set
          , Te = {};
        return me.forEach(Se => {
            var Ne;
            const Ie = Se.getFieldValue("VAR")
              , ye = J.workspace.getVariableById(Ie)
              , $e = ye == null ? void 0 : ye.type;
            if (!(!ye || !$e))
                if ($e === "Global")
                    ge.add(Ie);
                else {
                    const ve = (Ne = X.objects.find(ke => ke.type === $e)) == null ? void 0 : Ne.name;
                    if (!ve)
                        throw new Error(`Could not find object name for variable type '${$e}'`);
                    Te[ve] || (Te[ve] = new Set),
                    Te[ve].add(Ie)
                }
        }
        ),
        {
            Settings: {
                GlobalVariableCount: ge.size,
                ObjectVariableCounts: Object.keys(Te).map(Se => [Se, Te[Se].size])
            },
            Rules: ne,
            Subroutines: ue
        }
    }
    ),
    V.registerBlockGeneratorCallback("ruleBlock", J => {
        const ne = J
          , ue = getEventDefinition(ne)
          , ce = asArrayValue(V.blockToObj(ne.getInputTargetBlock("CONDITIONS")))
          , me = asArrayValue(V.blockToObj(ne.getInputTargetBlock("ACTIONS")));
        return {
            Event: ue,
            Conditions: ce,
            Actions: me
        }
    }
    ),
    V.registerBlockGeneratorCallback("conditionBlock", J => asSingleValue(V.blockToObj(J.getInputTargetBlock("CONDITION"))))
}
function getEventDefinition(V) {
    const X = []
      , J = V.getField("EVENTTYPE")
      , ne = V.getField("OBJECTTYPE");
    return (J == null ? void 0 : J.getValue()) === "Ongoing" ? ((ne == null ? void 0 : ne.getValue()) !== "Global" && X.push("Object"),
    X.push(ne == null ? void 0 : ne.getValue())) : X.push(J == null ? void 0 : J.getValue()),
    X
}
function createSubroutineBlockGenerators(V, X) {
    V.registerBlockGeneratorCallback("subroutineBlock", J => {
        const ne = asArrayValue(V.blockToObj(J.getInputTargetBlock("ACTIONS")))
          , ue = asArrayValue(V.blockToObj(J.getInputTargetBlock("CONDITIONS")))
          , ce = J.getFieldValue("SUBROUTINE_NAME")
          , me = X.getSubroutineParameters(ce);
        return {
            Event: ["Subroutine", ce],
            ParamCount: me.length > 0 ? me.length : void 0,
            Conditions: ue,
            Actions: ne
        }
    }
    ),
    V.registerBlockGeneratorCallback("subroutineInstanceBlock", J => {
        const ne = J.getFieldValue("SUBROUTINE_NAME")
          , ue = [ne];
        return X.getSubroutineParameters(ne).forEach( (ge, Te) => {
            const _e = J.getInputTargetBlock(`PARAM-${Te}`);
            if (_e) {
                const Se = V.blockToObj(_e)
                  , Ie = Te + 1;
                ue[Ie] = asSingleValue(Se)
            }
        }
        ),
        {
            Action: "CallSubroutine",
            Params: ue
        }
    }
    ),
    V.registerBlockGeneratorCallback("subroutineArgumentBlock", J => ({
        Value: "GetArgument",
        Params: [+J.getFieldValue("ARGUMENT_INDEX")]
    }))
}
function createVariableBlockGenerators(V) {
    V.registerBlockGeneratorCallback("variableReferenceBlock", X => {
        const J = X.getFieldValue("OBJECTTYPE")
          , ne = X.getFieldValue("VAR")
          , ue = X.getInputTargetBlock("OBJECT")
          , ce = ue ? asSingleValue(V.blockToObj(ue)) : null;
        return J !== "Global" ? {
            Value: "ObjectVariable",
            Params: [ce, getVariableWorkspaceIndex(X.workspace, ne)]
        } : {
            Value: "GlobalVariable",
            Params: [getVariableWorkspaceIndex(X.workspace, ne)]
        }
    }
    )
}
function createValueBlockGenerators(V, X) {
    X.values.forEach(J => {
        const {name: ne, functionSignatures: ue} = J
          , me = X.selectionLists.filter(ge => {
            var Te;
            return ge.returnType === ((Te = ue == null ? void 0 : ue[0]) == null ? void 0 : Te.returnType)
        }
        ).length > 0;
        V.registerBlockGeneratorCallback(ne, ge => {
            const Te = [];
            if (ue !== void 0) {
                const Se = getMaxParamaterCount(ue);
                for (let Ie = 0; Ie < Se; Ie++) {
                    const ye = ge.getInputTargetBlock(`VALUE-${Ie}`);
                    let $e = ge.getFieldValue(`VALUE-${Ie}`);
                    if (ye) {
                        const Ne = V.blockToObj(ye);
                        Te[Ie] = asSingleValue(Ne)
                    } else if ($e) {
                        if (me && Ie === 0) {
                            const Ne = X.selectionLists.find(ve => ve.name === $e);
                            Ne ? $e = Ne.listType : console.error(`Could not find Selection List '${$e}'!`)
                        } else {
                            const Ne = getTypesForBlockParameterIndex(ue, ge, Ie)
                              , ve = (Ne == null ? void 0 : Ne.includes("Number")) ?? !1
                              , ke = /^-?\d+\.?\d*$/.test($e);
                            ve && ke && ($e = parseInt($e, 10))
                        }
                        $e != null && (Te[Ie] = $e)
                    }
                }
            }
            return {
                Value: ne,
                Params: Te.length > 0 ? Te : void 0
            }
        }
        )
    }
    ),
    V.registerBlockGeneratorCallback("missingValueBlockType_v1", J => [])
}
function getVariableWorkspaceIndex(V, X) {
    const J = V.getVariableById(X);
    if (!J)
        return console.error("Could not get Workspace Index for Variable with id", X),
        -1;
    const ne = V.getBlocksByType("variableReferenceBlock", !1)
      , ce = [...new Set(ne.filter(me => me.getFieldValue("OBJECTTYPE") === J.type).map(me => me.getFieldValue("VAR")))].sort( (me, ge) => me.localeCompare(ge)).indexOf(X);
    return ce === -1 && console.error("Could not get index for Variable with ID", X),
    ce
}
class JsonGenerator {
    constructor() {
        this.blockGeneratorMap = new Map
    }
    init(X, J) {
        this.definitions = X,
        this.subroutineManager = J,
        this.createBlockGenerators()
    }
    registerBlockGeneratorCallback(X, J) {
        if (this.blockGeneratorMap.has(X)) {
            console.error(`Block Generator for '${X}' has already been registred!`);
            return
        }
        this.blockGeneratorMap.set(X, J)
    }
    fromWorkspace(X) {
        return this.fromWorkspaceAsString(X)
    }
    fromWorkspaceAsString(X) {
        const J = this.compile(X);
        return J ? JSON.stringify(J) : ""
    }
    fromWorkspaceAsObject(X) {
        return this.compile(X)
    }
    blockToObj(X) {
        if (X) {
            const J = this.blockGeneratorMap.get(X.type);
            if (J) {
                const ne = J(X);
                return this.scrubStatementBlock(X, ne)
            } else
                return console.warn("JSON Generator does not know how to generate block type " + X.type),
                this.scrubStatementBlock(X, [])
        }
        return null
    }
    compile(X) {
        const J = X.getTopBlocks(!1);
        for (const ne of J)
            if (ne.type === "modBlock")
                return asSingleValue(this.blockToObj(ne));
        return null
    }
    scrubStatementBlock(X, J) {
        var ce;
        const ne = (ce = X.nextConnection) == null ? void 0 : ce.targetBlock();
        if (!ne)
            return J;
        const ue = this.blockToObj(ne);
        return ue ? (Array.isArray(J) ? J : [J]).concat(ue) : J
    }
    createBlockGenerators() {
        if (!this.definitions)
            throw new Error("Block definitions is undefined for Block Generators!");
        if (!this.subroutineManager)
            throw new Error("Subroutine Manager is undefined for Block Generators!");
        createModBlockGenerators(this, this.definitions),
        createLiteralBlockGenerators(this),
        createLogicBlockGenerators(this),
        createConvenienceBlockGenerators(this),
        createValueBlockGenerators(this, this.definitions),
        createActionBlockGenerators(this, this.definitions),
        createVariableBlockGenerators(this),
        createSubroutineBlockGenerators(this, this.subroutineManager)
    }
}
const HIDDEN_ACTION_BLOCKS = ["SetVariable"]
  , HIDDEN_VALUE_BLOCKS = ["GetVariable", "IndexOfFirstTrue", "GetArgument"];
class PortalToolboxCategory extends coreBrowserExports.ToolboxCategory {
    constructor(X, J, ne) {
        super(X, J, ne)
    }
    createIconDom_() {
        const X = document.createElement("img");
        return this.cssConfig_.icon && (X.src = getAssetPath(`/assets/blockly/icons/${this.cssConfig_.icon}.svg`),
        X.width = 30,
        X.height = 30,
        X.classList.add("categoryIcon")),
        X
    }
}
const createBlock = (V, X) => {
    const J = new DOMParser().parseFromString(`<block type="${V}" />`, "text/xml").getElementsByTagName("block")[0];
    return X && J.setAttribute("displayName", X),
    J
}
  , createField = (V, X) => new DOMParser().parseFromString(`<field name="${V}">${X}</field>`, "text/xml").getElementsByTagName("field")[0]
  , createLabel = V => new DOMParser().parseFromString(`<label text="${V}" />`, "text/xml").getElementsByTagName("label")[0];
class BlocklyToolboxManager {
    constructor(X) {
        Tt(this, "definitions");
        this.mainWorkspace = X,
        coreBrowserExports.registry.register(coreBrowserExports.registry.Type.TOOLBOX_ITEM, coreBrowserExports.ToolboxCategory.registrationName, PortalToolboxCategory, !0)
    }
    init(X) {
        this.definitions = X,
        this.refreshToolbox()
    }
    getLocalizedCategory(X) {
        return X = X.replace(" ", "_").toUpperCase(),
        t$1(`blocks.categories.${X}`)
    }
    refreshToolbox() {
        var X;
        this.mainWorkspace.updateToolbox(this.getToolbox()),
        (X = this.mainWorkspace.getToolbox()) == null || X.refreshSelection()
    }
    getToolbox() {
        var ke, xe, we, Fe;
        const X = document.implementation.createDocument(null, "xml")
          , J = X.getElementsByTagName("xml")[0]
          , ne = () => {
            const je = X.createElement("sep");
            J.appendChild(je)
        }
          , ue = [];
        (ke = this.definitions) == null || ke.values.filter(je => !je.deprecated && HIDDEN_VALUE_BLOCKS.indexOf(je.name) === -1).forEach(je => {
            var ze;
            ((ze = this.definitions) == null ? void 0 : ze.selectionLists.find(qe => {
                var Ze, et;
                return qe.returnType === ((et = (Ze = je.functionSignatures) == null ? void 0 : Ze[0]) == null ? void 0 : et.returnType)
            }
            )) && ue.push(je.name)
        }
        );
        const ce = X.createElement("category");
        ce.setAttribute("name", this.getLocalizedCategory("RULES")),
        ce.setAttribute("categorystyle", "rules-category"),
        ce.setAttribute("css-icon", "toolbox-rules"),
        J.appendChild(ce);
        const me = X.createElement("block");
        me.setAttribute("type", "conditionBlock"),
        me.setAttribute("displayName", t$1("PYRITE_CONDITION"));
        const ge = X.createElement("block");
        ge.setAttribute("type", "ruleBlock"),
        ge.setAttribute("displayName", t$1("PYRITE_RULE")),
        ce.appendChild(ge),
        ce.appendChild(me),
        ne();
        const Te = (xe = this.definitions) == null ? void 0 : xe.actions.filter(je => !je.deprecated && HIDDEN_ACTION_BLOCKS.indexOf(je.name) === -1).reduce( (je, Xe) => {
            const ze = Xe.category ?? "Other";
            return je[ze] = je[ze] || [],
            je[ze].push(Xe),
            je
        }
        , Object.create(null));
        Te && Object.keys(Te).sort( (je, Xe) => je.localeCompare(Xe)).forEach(je => {
            const Xe = Te[je].sort( (ze, qe) => ze.name.localeCompare(qe.name)).sort( (ze, qe) => (ze.subCategory ?? "").localeCompare(qe.subCategory ?? ""));
            if (Xe.length > 0) {
                const ze = X.createElement("category");
                ze.setAttribute("name", this.getLocalizedCategory(je)),
                ze.setAttribute("categorystyle", "actions-category"),
                ze.setAttribute("css-icon", `toolbox-actions-${je.replace(" ", "").toLowerCase()}`),
                J.appendChild(ze);
                const qe = [];
                Xe.forEach(Ze => {
                    if (Ze.subCategory && !qe.includes(Ze.subCategory)) {
                        qe.push(Ze.subCategory);
                        const it = X.createElement("label");
                        it.setAttribute("text", this.getLocalizedCategory(Ze.subCategory)),
                        ze.appendChild(it)
                    }
                    const et = X.createElement("block");
                    et.setAttribute("type", Ze.name),
                    Ze.displayNameSID && et.setAttribute("displayName", t$1(Ze.displayNameSID)),
                    ze.appendChild(et)
                }
                )
            }
        }
        ),
        ne();
        const _e = (we = this.definitions) == null ? void 0 : we.values.filter(je => !je.deprecated && HIDDEN_VALUE_BLOCKS.indexOf(je.name) === -1).reduce( (je, Xe) => {
            const ze = Xe.category ?? "Other";
            return je[ze] = je[ze] || [],
            je[ze].push(Xe),
            je
        }
        , Object.create(null));
        if (_e) {
            const je = X.createElement("category");
            je.setAttribute("name", this.getLocalizedCategory("SELECTION_LISTS")),
            je.setAttribute("categorystyle", "values-category"),
            je.setAttribute("css-icon", "toolbox-values-selectionlists"),
            Object.keys(_e).sort( (Xe, ze) => Xe.localeCompare(ze)).forEach(Xe => {
                const ze = _e[Xe].sort( (et, it) => et.name.localeCompare(it.name)).sort( (et, it) => (et.subCategory ?? "").localeCompare(it.subCategory ?? ""))
                  , qe = X.createElement("category");
                qe.setAttribute("name", this.getLocalizedCategory(Xe)),
                qe.setAttribute("categorystyle", "values-category"),
                qe.setAttribute("css-icon", `toolbox-values-${Xe.replace(" ", "").toLowerCase()}`),
                J.appendChild(qe);
                const Ze = [];
                switch (ze.forEach(et => {
                    if (et.subCategory && !Ze.includes(et.subCategory)) {
                        Ze.push(et.subCategory);
                        const at = X.createElement("label");
                        at.setAttribute("text", this.getLocalizedCategory(et.subCategory)),
                        qe.appendChild(at)
                    }
                    const it = X.createElement("block");
                    it.setAttribute("type", et.name),
                    et.displayNameSID && it.setAttribute("displayName", t$1(et.displayNameSID)),
                    ue.includes(et.name) ? je.appendChild(it) : qe.appendChild(it)
                }
                ),
                Xe) {
                case "Arrays":
                    {
                        const et = X.createElement("label");
                        et.setAttribute("text", this.getLocalizedCategory("CONVENIENCE")),
                        qe.appendChild(et),
                        qe.appendChild(createBlock("ArrayContains", t$1("PYRITE_CONVENIENCE_ARRAYCONTAINS"))),
                        qe.appendChild(createBlock("IndexOfArrayValue", t$1("PYRITE_CONVENIENCE_INDEXOFARRAYVALUE"))),
                        qe.appendChild(createBlock("RemoveFromArray", t$1("PYRITE_CONVENIENCE_REMOVEFROMARRAY")));
                        break
                    }
                }
                qe.childNodes.length === 0 && qe.remove()
            }
            ),
            J.appendChild(je)
        }
        const Se = X.createElement("category");
        Se.setAttribute("name", this.getLocalizedCategory("LITERALS")),
        Se.setAttribute("categorystyle", "values-category"),
        Se.setAttribute("css-icon", "toolbox-values-literals");
        const Ie = createBlock("Number", t$1("blocks.types.NUMBER"));
        Ie.appendChild(createField("NUM", "123")),
        Se.appendChild(createLabel(this.getLocalizedCategory("TEXT"))),
        Se.appendChild(createBlock("Text", t$1("blocks.types.TEXT"))),
        Se.appendChild(createLabel(this.getLocalizedCategory("NUMBER"))),
        Se.appendChild(Ie),
        Se.appendChild(createLabel(this.getLocalizedCategory("BOOLEAN"))),
        Se.appendChild(createBlock("Boolean", t$1("blocks.types.BOOLEAN"))),
        J.appendChild(Se),
        ne();
        const ye = X.createElement("category");
        ye.setAttribute("name", this.getLocalizedCategory("VARIABLES")),
        ye.setAttribute("categorystyle", "values-category"),
        ye.setAttribute("css-icon", "toolbox-variables"),
        ye.setAttribute("custom", "CUSTOM_VARIABLE_FLYOUT"),
        J.appendChild(ye);
        const $e = X.createElement("category");
        $e.setAttribute("name", this.getLocalizedCategory("SUBROUTINES")),
        $e.setAttribute("categorystyle", "subroutines-category"),
        $e.setAttribute("css-icon", "toolbox-subroutines"),
        $e.setAttribute("custom", "CUSTOM_SUBROUTINE_FLYOUT"),
        J.appendChild($e);
        const Ne = X.createElement("category");
        return Ne.setAttribute("name", this.getLocalizedCategory("CONTROL_ACTIONS")),
        Ne.setAttribute("categorystyle", "controls-category"),
        Ne.setAttribute("css-icon", "toolbox-controlactions"),
        (Fe = this.definitions) == null || Fe.controlActions.filter(je => !je.deprecated).forEach(je => {
            const Xe = X.createElement("block");
            Xe.setAttribute("type", je.name),
            je.displayNameSID && Xe.setAttribute("displayName", t$1(je.displayNameSID)),
            Ne.appendChild(Xe)
        }
        ),
        J.appendChild(Ne),
        new XMLSerializer().serializeToString(X)
    }
}
class BlocklyWorkspaceSearchManager {
    constructor(X) {
        Tt(this, "htmlDiv", null);
        Tt(this, "searchContainerElement", null);
        Tt(this, "inputElement", null);
        Tt(this, "textInputPlaceholder", getBlocklyTranslation("rules.search"));
        Tt(this, "blocks", []);
        Tt(this, "currentBlockIndex", -1);
        Tt(this, "searchText", "");
        Tt(this, "searchOnInput", !0);
        Tt(this, "caseSensitive", !1);
        Tt(this, "preserveSelected", !0);
        Tt(this, "boundEvents", []);
        Tt(this, "searchActive", !1);
        this.workspace = X
    }
    init() {
        this.createDom()
    }
    dispose() {
        for (const X of this.boundEvents)
            coreBrowserExports.utils.browserEvents.unbind(X);
        this.boundEvents = [],
        this.htmlDiv && (this.htmlDiv.remove(),
        this.htmlDiv = null),
        this.searchContainerElement = null,
        this.inputElement = null
    }
    createDom() {
        const X = this.workspace.getInjectionDiv();
        this.htmlDiv = document.createElement("div"),
        coreBrowserExports.utils.dom.addClass(this.htmlDiv, "ws-search-container-parent"),
        this.searchContainerElement = document.createElement("div"),
        coreBrowserExports.utils.dom.addClass(this.searchContainerElement, "ws-search-container"),
        this.inputElement = this.createTextInput(),
        coreBrowserExports.utils.dom.addClass(this.inputElement, "ws-search-input"),
        this.addEvent(this.inputElement, "keydown", this, ue => this.onKeyDown(ue)),
        this.addEvent(this.inputElement, "input", this, () => this.onInput()),
        this.addEvent(this.inputElement, "click", this, () => this.searchAndHighlight(this.searchText, this.preserveSelected));
        const J = document.createElement("a");
        coreBrowserExports.utils.dom.addClass(J, "ws-search-button"),
        this.addEvent(J, "click", this, () => this.serachClick());
        const ne = document.createElement("i");
        coreBrowserExports.utils.dom.addClass(ne, "ws-search-icon"),
        J.appendChild(ne),
        this.searchContainerElement.appendChild(this.inputElement),
        this.searchContainerElement.appendChild(J),
        this.htmlDiv.appendChild(this.searchContainerElement),
        X.insertBefore(this.htmlDiv, this.workspace.getParentSvg())
    }
    addEvent(X, J, ne, ue) {
        const ce = coreBrowserExports.browserEvents.conditionalBind(X, J, ne, ue);
        this.boundEvents.push(ce)
    }
    createTextInput() {
        const X = document.createElement("input");
        return X.type = "search",
        X.setAttribute("placeholder", this.textInputPlaceholder),
        X
    }
    onInput() {
        if (this.searchOnInput && this.inputElement) {
            const X = this.inputElement.value.trim();
            X !== this.searchText && this.searchAndHighlight(X, this.preserveSelected)
        }
    }
    onKeyDown(X) {
        if (X.key === "Enter") {
            if (this.searchOnInput)
                this.next();
            else if (this.inputElement) {
                const J = this.inputElement.value.trim();
                J !== this.searchText && this.searchAndHighlight(J, this.preserveSelected)
            }
        }
    }
    serachClick() {
        this.searchActive ? this.closeSearch() : this.openSearch()
    }
    closeSearch() {
        this.workspace.markFocused(),
        this.clearBlocks(),
        this.searchContainerElement && coreBrowserExports.utils.dom.removeClass(this.searchContainerElement, "ws-search-container-active"),
        this.inputElement && coreBrowserExports.utils.dom.removeClass(this.inputElement, "ws-search-input-active"),
        this.searchActive = !1
    }
    openSearch() {
        var X;
        (X = this.inputElement) == null || X.focus(),
        this.searchText && this.searchAndHighlight(this.searchText, !0),
        this.searchContainerElement && coreBrowserExports.utils.dom.addClass(this.searchContainerElement, "ws-search-container-active"),
        this.inputElement && coreBrowserExports.utils.dom.addClass(this.inputElement, "ws-search-input-active"),
        this.searchActive = !0
    }
    previous() {
        this.setCurrentBlock(this.currentBlockIndex - 1)
    }
    next() {
        this.setCurrentBlock(this.currentBlockIndex + 1)
    }
    setCurrentBlock(X) {
        if (!this.blocks.length)
            return;
        let J = this.blocks[this.currentBlockIndex];
        J && this.unhighlightCurrentSelection(J),
        this.currentBlockIndex = (X % this.blocks.length + this.blocks.length) % this.blocks.length,
        J = this.blocks[this.currentBlockIndex],
        this.highlightCurrentSelection(J),
        this.scrollToVisible(J)
    }
    searchAndHighlight(X, J) {
        const ne = this.blocks[this.currentBlockIndex];
        this.searchText = X.trim(),
        this.clearBlocks(),
        this.blocks = this.getMatchingBlocks(this.workspace, this.searchText, this.caseSensitive),
        this.highlightSearchGroup(this.blocks);
        let ue = 0;
        J && (ue = this.blocks.indexOf(ne),
        ue = ue > -1 ? ue : 0),
        this.setCurrentBlock(ue)
    }
    getSearchPool(X) {
        return X.getAllBlocks(!0).filter(ne => {
            const ue = ne.getSurroundParent();
            return !ue || !ue.isCollapsed()
        }
        )
    }
    isBlockMatch(X, J, ne) {
        let ue = "";
        if (X.isCollapsed())
            ue = X.toString();
        else {
            const ce = [];
            X.inputList.forEach(me => {
                me.fieldRow.forEach(ge => {
                    ce.push(ge.getText())
                }
                )
            }
            ),
            ue = ce.join(" ").trim()
        }
        return ne || (ue = ue.toLowerCase()),
        ue.indexOf(J) > -1
    }
    getMatchingBlocks(X, J, ne) {
        return J ? (this.caseSensitive || (J = J.toLowerCase()),
        this.getSearchPool(X).filter(ce => this.isBlockMatch(ce, J, ne))) : []
    }
    clearBlocks() {
        this.unhighlightSearchGroup(this.blocks);
        const X = this.blocks[this.currentBlockIndex];
        X && this.unhighlightCurrentSelection(X),
        this.currentBlockIndex = -1,
        this.blocks = []
    }
    highlightCurrentSelection(X) {
        const ne = X.pathObject.svgPath;
        coreBrowserExports.utils.dom.addClass(ne, "blocklyWsSearchCurrent")
    }
    unhighlightCurrentSelection(X) {
        const ne = X.pathObject.svgPath;
        coreBrowserExports.utils.dom.removeClass(ne, "blocklyWsSearchCurrent")
    }
    highlightSearchGroup(X) {
        X.forEach(J => {
            const ue = J.pathObject.svgPath;
            coreBrowserExports.utils.dom.addClass(ue, "blocklyWsSearchHighlight")
        }
        )
    }
    unhighlightSearchGroup(X) {
        X.forEach(J => {
            const ue = J.pathObject.svgPath;
            coreBrowserExports.utils.dom.removeClass(ue, "blocklyWsSearchHighlight")
        }
        )
    }
    scrollToVisible(X) {
        if (!this.workspace.isMovable())
            return;
        const J = X.getRelativeToSurfaceXY()
          , ne = this.workspace.scale
          , ue = X
          , ce = ue.width * ne
          , me = ue.height * ne
          , ge = J.y * ne
          , Te = (J.y + ue.height) * ne
          , _e = this.workspace.RTL ? J.x * ne - ce : J.x * ne
          , Se = this.workspace.RTL ? J.x * ne : J.x * ne + ce
          , Ie = this.workspace.getMetrics();
        let ye = Ie.viewLeft;
        const $e = _e < Ie.viewLeft
          , Ne = Se > Ie.viewLeft + Ie.viewWidth
          , ve = ce > Ie.viewWidth;
        !ve && $e || ve && !this.workspace.RTL ? ye = _e : (!ve && Ne || ve && this.workspace.RTL) && (ye = Se - Ie.viewWidth);
        let ke = Ie.viewTop;
        const xe = ge < Ie.viewTop
          , we = Te > Ie.viewTop + Ie.viewHeight
          , Fe = me > Ie.viewHeight;
        if (xe || Fe && we ? ke = ge : we && (ke = Te - Ie.viewHeight),
        ye !== Ie.viewLeft || ke !== Ie.viewTop) {
            const je = document.activeElement;
            this.workspace.scroll(-ye, -ke),
            je && je.focus()
        }
    }
}
var fuzzysort = {
    exports: {}
};
(function(V) {
    ( (X, J) => {
        V.exports ? V.exports = J() : X.fuzzysort = J()
    }
    )(commonjsGlobal, X => {
        var J = (Ye, We) => {
            if (Ye == "farzher")
                return {
                    target: "farzher was here (^-^*)/",
                    score: 0,
                    _indexes: [0]
                };
            if (!Ye || !We)
                return rt;
            var nt = Se(Ye);
            Ze(We) || (We = _e(We));
            var ct = nt.bitflags;
            return (ct & We._bitflags) !== ct ? rt : ye(nt, We)
        }
          , ne = (Ye, We, nt) => {
            if (Ye == "farzher")
                return [{
                    target: "farzher was here (^-^*)/",
                    score: 0,
                    _indexes: [0],
                    obj: We ? We[0] : rt
                }];
            if (!Ye)
                return nt && nt.all ? Ie(Ye, We, nt) : at;
            var ct = Se(Ye)
              , Et = ct.bitflags;
            ct.containsSpace;
            var Ke = nt && nt.threshold || it
              , mt = nt && nt.limit || et
              , lt = 0
              , Qe = 0
              , gt = We.length;
            if (nt && nt.key)
                for (var Nt = nt.key, Gt = 0; Gt < gt; ++Gt) {
                    var Ht = We[Gt]
                      , Kt = qe(Ht, Nt);
                    if (Kt && (Ze(Kt) || (Kt = _e(Kt)),
                    (Et & Kt._bitflags) === Et)) {
                        var Ot = ye(ct, Kt);
                        Ot !== rt && (Ot.score < Ke || (Ot = {
                            target: Ot.target,
                            _targetLower: "",
                            _targetLowerCodes: rt,
                            _nextBeginningIndexes: rt,
                            _bitflags: 0,
                            score: Ot.score,
                            _indexes: Ot._indexes,
                            obj: Ht
                        },
                        lt < mt ? (St.add(Ot),
                        ++lt) : (++Qe,
                        Ot.score > St.peek().score && St.replaceTop(Ot))))
                    }
                }
            else if (nt && nt.keys)
                for (var kt = nt.scoreFn || ze, Xt = nt.keys, vt = Xt.length, Gt = 0; Gt < gt; ++Gt) {
                    for (var Ht = We[Gt], Jt = new Array(vt), Ct = 0; Ct < vt; ++Ct) {
                        var Nt = Xt[Ct]
                          , Kt = qe(Ht, Nt);
                        if (!Kt) {
                            Jt[Ct] = rt;
                            continue
                        }
                        Ze(Kt) || (Kt = _e(Kt)),
                        (Et & Kt._bitflags) !== Et ? Jt[Ct] = rt : Jt[Ct] = ye(ct, Kt)
                    }
                    Jt.obj = Ht;
                    var Mt = kt(Jt);
                    Mt !== rt && (Mt < Ke || (Jt.score = Mt,
                    lt < mt ? (St.add(Jt),
                    ++lt) : (++Qe,
                    Mt > St.peek().score && St.replaceTop(Jt))))
                }
            else
                for (var Gt = 0; Gt < gt; ++Gt) {
                    var Kt = We[Gt];
                    if (Kt && (Ze(Kt) || (Kt = _e(Kt)),
                    (Et & Kt._bitflags) === Et)) {
                        var Ot = ye(ct, Kt);
                        Ot !== rt && (Ot.score < Ke || (lt < mt ? (St.add(Ot),
                        ++lt) : (++Qe,
                        Ot.score > St.peek().score && St.replaceTop(Ot))))
                    }
                }
            if (lt === 0)
                return at;
            for (var nn = new Array(lt), Gt = lt - 1; Gt >= 0; --Gt)
                nn[Gt] = St.poll();
            return nn.total = lt + Qe,
            nn
        }
          , ue = (Ye, We, nt) => {
            if (typeof We == "function")
                return ce(Ye, We);
            if (Ye === rt)
                return rt;
            We === void 0 && (We = "<b>"),
            nt === void 0 && (nt = "</b>");
            var ct = ""
              , Et = 0
              , Ke = !1
              , mt = Ye.target
              , lt = mt.length
              , Qe = Ye._indexes;
            Qe = Qe.slice(0, Qe.len).sort( (Gt, Ht) => Gt - Ht);
            for (var gt = 0; gt < lt; ++gt) {
                var Nt = mt[gt];
                if (Qe[Et] === gt) {
                    if (++Et,
                    Ke || (Ke = !0,
                    ct += We),
                    Et === Qe.length) {
                        ct += Nt + nt + mt.substr(gt + 1);
                        break
                    }
                } else
                    Ke && (Ke = !1,
                    ct += nt);
                ct += Nt
            }
            return ct
        }
          , ce = (gt, We) => {
            if (gt === rt)
                return rt;
            var nt = gt.target
              , ct = nt.length
              , Et = gt._indexes;
            Et = Et.slice(0, Et.len).sort( (Ht, Kt) => Ht - Kt);
            for (var Ke = "", mt = 0, lt = 0, Qe = !1, gt = [], Nt = 0; Nt < ct; ++Nt) {
                var Gt = nt[Nt];
                if (Et[lt] === Nt) {
                    if (++lt,
                    Qe || (Qe = !0,
                    gt.push(Ke),
                    Ke = ""),
                    lt === Et.length) {
                        Ke += Gt,
                        gt.push(We(Ke, mt++)),
                        Ke = "",
                        gt.push(nt.substr(Nt + 1));
                        break
                    }
                } else
                    Qe && (Qe = !1,
                    gt.push(We(Ke, mt++)),
                    Ke = "");
                Ke += Gt
            }
            return gt
        }
          , me = Ye => Ye._indexes.slice(0, Ye._indexes.len).sort( (We, nt) => We - nt)
          , ge = Ye => {
            typeof Ye != "string" && (Ye = "");
            var We = Ne(Ye);
            return {
                target: Ye,
                _targetLower: We._lower,
                _targetLowerCodes: We.lowerCodes,
                _nextBeginningIndexes: rt,
                _bitflags: We.bitflags,
                score: rt,
                _indexes: [0],
                obj: rt
            }
        }
          , Te = Ye => {
            typeof Ye != "string" && (Ye = ""),
            Ye = Ye.trim();
            var We = Ne(Ye)
              , nt = [];
            if (We.containsSpace) {
                var ct = Ye.split(/\s+/);
                ct = [...new Set(ct)];
                for (var Et = 0; Et < ct.length; Et++)
                    if (ct[Et] !== "") {
                        var Ke = Ne(ct[Et]);
                        nt.push({
                            lowerCodes: Ke.lowerCodes,
                            _lower: ct[Et].toLowerCase(),
                            containsSpace: !1
                        })
                    }
            }
            return {
                lowerCodes: We.lowerCodes,
                bitflags: We.bitflags,
                containsSpace: We.containsSpace,
                _lower: We._lower,
                spaceSearches: nt
            }
        }
          , _e = Ye => {
            if (Ye.length > 999)
                return ge(Ye);
            var We = we.get(Ye);
            return We !== void 0 || (We = ge(Ye),
            we.set(Ye, We)),
            We
        }
          , Se = Ye => {
            if (Ye.length > 999)
                return Te(Ye);
            var We = Fe.get(Ye);
            return We !== void 0 || (We = Te(Ye),
            Fe.set(Ye, We)),
            We
        }
          , Ie = (Ye, We, nt) => {
            var ct = [];
            ct.total = We.length;
            var Et = nt && nt.limit || et;
            if (nt && nt.key)
                for (var Ke = 0; Ke < We.length; Ke++) {
                    var mt = We[Ke]
                      , lt = qe(mt, nt.key);
                    if (lt) {
                        Ze(lt) || (lt = _e(lt)),
                        lt.score = it,
                        lt._indexes.len = 0;
                        var Qe = lt;
                        if (Qe = {
                            target: Qe.target,
                            _targetLower: "",
                            _targetLowerCodes: rt,
                            _nextBeginningIndexes: rt,
                            _bitflags: 0,
                            score: lt.score,
                            _indexes: rt,
                            obj: mt
                        },
                        ct.push(Qe),
                        ct.length >= Et)
                            return ct
                    }
                }
            else if (nt && nt.keys)
                for (var Ke = 0; Ke < We.length; Ke++) {
                    for (var mt = We[Ke], gt = new Array(nt.keys.length), Nt = nt.keys.length - 1; Nt >= 0; --Nt) {
                        var lt = qe(mt, nt.keys[Nt]);
                        if (!lt) {
                            gt[Nt] = rt;
                            continue
                        }
                        Ze(lt) || (lt = _e(lt)),
                        lt.score = it,
                        lt._indexes.len = 0,
                        gt[Nt] = lt
                    }
                    if (gt.obj = mt,
                    gt.score = it,
                    ct.push(gt),
                    ct.length >= Et)
                        return ct
                }
            else
                for (var Ke = 0; Ke < We.length; Ke++) {
                    var lt = We[Ke];
                    if (lt && (Ze(lt) || (lt = _e(lt)),
                    lt.score = it,
                    lt._indexes.len = 0,
                    ct.push(lt),
                    ct.length >= Et))
                        return ct
                }
            return ct
        }
          , ye = (Ye, We, nt=!1) => {
            if (nt === !1 && Ye.containsSpace)
                return $e(Ye, We);
            for (var ct = Ye._lower, Et = Ye.lowerCodes, Ke = Et[0], mt = We._targetLowerCodes, lt = Et.length, Qe = mt.length, Ht = 0, gt = 0, Nt = 0; ; ) {
                var Gt = Ke === mt[gt];
                if (Gt) {
                    if (je[Nt++] = gt,
                    ++Ht,
                    Ht === lt)
                        break;
                    Ke = Et[Ht]
                }
                if (++gt,
                gt >= Qe)
                    return rt
            }
            var Ht = 0
              , Kt = !1
              , Ot = 0
              , kt = We._nextBeginningIndexes;
            kt === rt && (kt = We._nextBeginningIndexes = ke(We.target)),
            gt = je[0] === 0 ? 0 : kt[je[0] - 1];
            var Xt = 0;
            if (gt !== Qe)
                for (; ; )
                    if (gt >= Qe) {
                        if (Ht <= 0 || (++Xt,
                        Xt > 200))
                            break;
                        --Ht;
                        var vt = Xe[--Ot];
                        gt = kt[vt]
                    } else {
                        var Gt = Et[Ht] === mt[gt];
                        if (Gt) {
                            if (Xe[Ot++] = gt,
                            ++Ht,
                            Ht === lt) {
                                Kt = !0;
                                break
                            }
                            ++gt
                        } else
                            gt = kt[gt]
                    }
            var Jt = We._targetLower.indexOf(ct, je[0])
              , Ct = ~Jt;
            if (Ct && !Kt)
                for (var Mt = 0; Mt < Nt; ++Mt)
                    je[Mt] = Jt + Mt;
            var nn = !1;
            Ct && (nn = We._nextBeginningIndexes[Jt - 1] === Jt);
            {
                if (Kt)
                    var tn = Xe
                      , mn = Ot;
                else
                    var tn = je
                      , mn = Nt;
                for (var dn = 0, Qt = 0, Mt = 1; Mt < lt; ++Mt)
                    tn[Mt] - tn[Mt - 1] !== 1 && (dn -= tn[Mt],
                    ++Qt);
                var on = tn[lt - 1] - tn[0] - (lt - 1);
                if (dn -= (12 + on) * Qt,
                tn[0] !== 0 && (dn -= tn[0] * tn[0] * .2),
                !Kt)
                    dn *= 1e3;
                else {
                    for (var zt = 1, Mt = kt[0]; Mt < Qe; Mt = kt[Mt])
                        ++zt;
                    zt > 24 && (dn *= (zt - 24) * 10)
                }
                Ct && (dn /= 1 + lt * lt * 1),
                nn && (dn /= 1 + lt * lt * 1),
                dn -= Qe - lt,
                We.score = dn;
                for (var Mt = 0; Mt < mn; ++Mt)
                    We._indexes[Mt] = tn[Mt];
                return We._indexes.len = mn,
                We
            }
        }
          , $e = (Ye, We) => {
            for (var nt = new Set, ct = 0, Et = rt, Ke = 0, mt = Ye.spaceSearches, Nt = 0; Nt < mt.length; ++Nt) {
                var lt = mt[Nt];
                if (Et = ye(lt, We),
                Et === rt)
                    return rt;
                ct += Et.score,
                Et._indexes[0] < Ke && (ct -= Ke - Et._indexes[0]),
                Ke = Et._indexes[0];
                for (var Qe = 0; Qe < Et._indexes.len; ++Qe)
                    nt.add(Et._indexes[Qe])
            }
            var gt = ye(Ye, We, !0);
            if (gt !== rt && gt.score > ct)
                return gt;
            Et.score = ct;
            var Nt = 0;
            for (let Gt of nt)
                Et._indexes[Nt++] = Gt;
            return Et._indexes.len = Nt,
            Et
        }
          , Ne = Ye => {
            for (var We = Ye.length, nt = Ye.toLowerCase(), ct = [], Et = 0, Ke = !1, mt = 0; mt < We; ++mt) {
                var lt = ct[mt] = nt.charCodeAt(mt);
                if (lt === 32) {
                    Ke = !0;
                    continue
                }
                var Qe = lt >= 97 && lt <= 122 ? lt - 97 : lt >= 48 && lt <= 57 ? 26 : lt <= 127 ? 30 : 31;
                Et |= 1 << Qe
            }
            return {
                lowerCodes: ct,
                bitflags: Et,
                containsSpace: Ke,
                _lower: nt
            }
        }
          , ve = Ye => {
            for (var We = Ye.length, nt = [], ct = 0, Et = !1, Ke = !1, mt = 0; mt < We; ++mt) {
                var lt = Ye.charCodeAt(mt)
                  , Qe = lt >= 65 && lt <= 90
                  , gt = Qe || lt >= 97 && lt <= 122 || lt >= 48 && lt <= 57
                  , Nt = Qe && !Et || !Ke || !gt;
                Et = Qe,
                Ke = gt,
                Nt && (nt[ct++] = mt)
            }
            return nt
        }
          , ke = Ye => {
            for (var We = Ye.length, nt = ve(Ye), ct = [], Et = nt[0], Ke = 0, mt = 0; mt < We; ++mt)
                Et > mt ? ct[mt] = Et : (Et = nt[++Ke],
                ct[mt] = Et === void 0 ? We : Et);
            return ct
        }
          , xe = () => {
            we.clear(),
            Fe.clear(),
            je = [],
            Xe = []
        }
          , we = new Map
          , Fe = new Map
          , je = []
          , Xe = []
          , ze = Ye => {
            for (var We = it, nt = Ye.length, ct = 0; ct < nt; ++ct) {
                var Et = Ye[ct];
                if (Et !== rt) {
                    var Ke = Et.score;
                    Ke > We && (We = Ke)
                }
            }
            return We === it ? rt : We
        }
          , qe = (Ye, We) => {
            var nt = Ye[We];
            if (nt !== void 0)
                return nt;
            var ct = We;
            Array.isArray(We) || (ct = We.split("."));
            for (var Et = ct.length, Ke = -1; Ye && ++Ke < Et; )
                Ye = Ye[ct[Ke]];
            return Ye
        }
          , Ze = Ye => typeof Ye == "object"
          , et = 1 / 0
          , it = -et
          , at = [];
        at.total = 0;
        var rt = null
          , ft = Ye => {
            var We = []
              , nt = 0
              , ct = {}
              , Et = Ke => {
                for (var mt = 0, lt = We[mt], Qe = 1; Qe < nt; ) {
                    var gt = Qe + 1;
                    mt = Qe,
                    gt < nt && We[gt].score < We[Qe].score && (mt = gt),
                    We[mt - 1 >> 1] = We[mt],
                    Qe = 1 + (mt << 1)
                }
                for (var Nt = mt - 1 >> 1; mt > 0 && lt.score < We[Nt].score; Nt = (mt = Nt) - 1 >> 1)
                    We[mt] = We[Nt];
                We[mt] = lt
            }
            ;
            return ct.add = Ke => {
                var mt = nt;
                We[nt++] = Ke;
                for (var lt = mt - 1 >> 1; mt > 0 && Ke.score < We[lt].score; lt = (mt = lt) - 1 >> 1)
                    We[mt] = We[lt];
                We[mt] = Ke
            }
            ,
            ct.poll = Ke => {
                if (nt !== 0) {
                    var mt = We[0];
                    return We[0] = We[--nt],
                    Et(),
                    mt
                }
            }
            ,
            ct.peek = Ke => {
                if (nt !== 0)
                    return We[0]
            }
            ,
            ct.replaceTop = Ke => {
                We[0] = Ke,
                Et()
            }
            ,
            ct
        }
          , St = ft();
        return {
            single: J,
            go: ne,
            highlight: ue,
            prepare: ge,
            indexes: me,
            cleanup: xe
        }
    }
    )
}
)(fuzzysort);
var fuzzysortExports = fuzzysort.exports;
class BlocklyToolboxPlugin extends coreBrowserExports.Toolbox {
    constructor(J) {
        super(J);
        Tt(this, "SEARCHBAR_CLASS", "searchbar");
        Tt(this, "TOOLBAR_CLASS", "toolbar");
        Tt(this, "timeout");
        Tt(this, "input", null);
        Tt(this, "categoryId", generateUUID());
        Tt(this, "categoryExpandedCache", new Map);
        J.addChangeListener(this.onWorkspaceChange.bind(this))
    }
    init() {
        super.init(),
        this.initSearchbar()
    }
    render(J) {
        if (J.contents.length === 0 || J.contents[0].toolboxitemid !== this.categoryId) {
            const ue = '<xml><category css-icon="search" colour="#004444" expanded="false" name="' + getBlocklyTranslation("blocks.categories.SEARCH") + '" hidden="true" toolboxitemid="' + this.categoryId + '"></category></xml>'
              , ce = coreBrowserExports.utils.toolbox.convertToolboxDefToJson(ue);
            J.contents = [ce == null ? void 0 : ce.contents[0]].concat(J.contents)
        }
        super.render(J),
        this.restoreExpandedState()
    }
    clearSearch() {
        this.clearSearchResult(),
        this.input && (this.input.value = "")
    }
    initSearchbar() {
        var ce, me;
        this.input = document.createElement("input"),
        this.input.placeholder = getBlocklyTranslation("rules.search"),
        this.input.className = this.SEARCHBAR_CLASS,
        this.input.size = 2,
        this.input.type = "search",
        this.input.addEventListener("keyup", this.search.bind(this)),
        this.input.addEventListener("search", this.search.bind(this));
        const J = document.createElement("div");
        J.className = this.SEARCHBAR_CLASS + "div";
        const ne = document.createElement("span");
        ne.className = this.SEARCHBAR_CLASS + "span",
        ne.appendChild(this.input),
        J.appendChild(ne);
        const ue = (ce = this.HtmlDiv) == null ? void 0 : ce.firstChild;
        ue && (ue.classList.add(this.TOOLBAR_CLASS),
        (me = this.HtmlDiv) == null || me.insertBefore(J, this.HtmlDiv.firstChild))
    }
    search(J) {
        clearTimeout(this.timeout),
        this.timeout = setTimeout( () => {
            const ne = J.target.value.trim();
            if (ne.length > 0) {
                const ue = this.recursiveSearch(ne, this.toolboxDef_);
                if (ue.length > 0) {
                    const ce = this.getToolboxItemById(this.categoryId);
                    ce.updateFlyoutContents(ue),
                    ce.show(),
                    this.setSelectedItem(ce)
                } else
                    this.clearSearchResult()
            } else
                this.clearSearchResult()
        }
        , 100)
    }
    getTargets(J) {
        let ne = [];
        if (J !== void 0) {
            const ue = J;
            if (ue && ue.contents && Array.isArray(ue.contents)) {
                if (ue.toolboxitemid && ue.toolboxitemid === this.categoryId)
                    return ne;
                for (const ce of ue.contents)
                    if (typeof ce == "object" && ce.kind) {
                        if (ce.kind === "BLOCK") {
                            const me = ce;
                            if (!me.type)
                                continue;
                            ne.push(me)
                        } else if (ce.kind === "CATEGORY") {
                            const me = this.getTargets(ce);
                            ne = [...ne, ...me]
                        }
                    }
            }
        }
        return ne
    }
    recursiveSearch(J, ne) {
        const ue = this.getTargets(ne);
        return fuzzysortExports.go(J, ue, {
            keys: ["displayName", "type"],
            threshold: -5e3
        }).map(me => me.obj)
    }
    clearSearchResult() {
        const J = this.workspace_.getFlyout();
        J && J.hide();
        const ne = this.getToolboxItemById(this.categoryId);
        ne && ne.hide()
    }
    storeExpandedState() {
        this.getToolboxItems().forEach(J => {
            if (J instanceof coreBrowserExports.CollapsibleToolboxCategory) {
                const ne = J;
                ne !== void 0 && ne.getId() !== this.categoryId && this.categoryExpandedCache.set(J.getId(), !!ne.isExpanded())
            }
        }
        )
    }
    restoreExpandedState() {
        this.categoryExpandedCache.forEach( (J, ne) => {
            const ue = this.getToolboxItemById(ne);
            if (ue instanceof coreBrowserExports.CollapsibleToolboxCategory) {
                const ce = ue;
                ce && typeof ce.setExpanded == "function" && ce.setExpanded(J)
            }
        }
        )
    }
    onWorkspaceChange(J) {
        J.type === coreBrowserExports.Events.TOOLBOX_ITEM_SELECT && this.storeExpandedState()
    }
    compare(J, ne) {
        if (typeof J == "string" && typeof ne == "string" && (J = this.prepareString(J),
        ne = this.prepareString(ne),
        J.length > 0 && ne.length > 0)) {
            const ue = J.split("_")
              , ce = ne.split("_");
            for (const me of ue)
                for (const ge of ce)
                    if (ge.startsWith(me))
                        return !0
        }
        return !1
    }
    prepareString(J) {
        return J = this.breakUpCamelCase(J),
        J = J.toLowerCase().trim(),
        this.replaceWhitespaceWithUnderscore(J)
    }
    breakUpCamelCase(J) {
        return J.replace(/([A-Z])/g, " $1")
    }
    replaceWhitespaceWithUnderscore(J) {
        return J.replace(/\s+/g, "_")
    }
}
const HELP_CONTEXT_ITEM_ID = "blockPyriteHelp"
  , logger$6 = Logger$1.get("RulesEditor")
  , WORKSPACE_SAVE_TO_CACHE_DEBOUNCE_MS = 300
  , sharedWorkspaceOptions = {
    readOnly: !1,
    media: getAssetPath("/assets/blockly/"),
    trashcan: !1,
    rtl: !1,
    move: {
        scrollbars: !0,
        drag: !0,
        wheel: !1
    },
    zoom: {
        controls: !0,
        wheel: !0,
        startScale: 1,
        maxScale: 4,
        minScale: .25,
        scaleSpeed: 1.05
    },
    sounds: !1,
    renderer: "portal",
    toolbox: '<xml xmlns="https://developers.google.com/blockly/xml"><category /></xml>',
    theme: "portal-dark",
    plugins: {
        toolbox: BlocklyToolboxPlugin
    }
}
  , usePyriteBlockly = ({mount: V, rulesVersion: X, definitions: J, onContextMenuHelp: ne, onNewSubroutine: ue, onConfirmDeleteSubroutine: ce, onRenameSubroutine: me, onManageVariables: ge, onRenameVariable: Te, onDeleteVariable: _e, onChange: Se}) => {
    const Ie = reactExports.useRef(void 0)
      , [ye,$e] = useOnWindowResize(500)
      , Ne = reactExports.useRef(!1)
      , ve = reactExports.useRef("")
      , ke = reactExports.useRef(null)
      , [xe,we] = reactExports.useState(!1)
      , [Fe] = useDebounce( () => {
        const Ke = je();
        Ke && Se && Se({
            ...Ke
        })
    }
    , WORKSPACE_SAVE_TO_CACHE_DEBOUNCE_MS)
      , je = () => {
        var Ke, mt;
        return (Ke = Ie.current) != null && Ke.mainWorkspace ? blocklyExports.serialization.workspaces.save((mt = Ie.current) == null ? void 0 : mt.mainWorkspace) : ""
    }
      , Xe = () => {
        var Ke, mt, lt;
        return ((Ke = Ie.current) == null ? void 0 : Ke.mainWorkspace) && ((lt = ke.current) == null ? void 0 : lt.fromWorkspaceAsObject((mt = Ie.current) == null ? void 0 : mt.mainWorkspace))
    }
      , ze = () => {
        var Ke, mt, lt;
        if ((Ke = Ie.current) != null && Ke.mainWorkspace) {
            const Qe = blocklyExports.utils.xml.domToText(blocklyExports.Xml.workspaceToDom((mt = Ie.current) == null ? void 0 : mt.mainWorkspace))
              , gt = (lt = Ie.current) == null ? void 0 : lt.mainWorkspace.getAllVariables()
              , Nt = gt ? blocklyExports.utils.xml.domToText(blocklyExports.Xml.variablesToDom(gt)) : void 0;
            return JSON.stringify({
                mainWorkspace: Qe,
                variables: Nt
            })
        }
    }
      , qe = Ke => {
        var mt, lt, Qe;
        if ((mt = Ie.current) == null || mt.mainWorkspace.dragTargetAreas.splice(1),
        !(Ke.type === blocklyExports.Events.UI || Ke.type === blocklyExports.Events.VIEWPORT_CHANGE || Ke.type === blocklyExports.Events.BLOCK_DRAG)) {
            if (logger$6.extend("event").debug(Ke),
            Ke.type === blocklyExports.Events.TOOLBOX_ITEM_SELECT) {
                (lt = blocklyExports.getSelected()) == null || lt.unselect();
                return
            }
            if (Ke.type === blocklyExports.Events.FINISHED_LOADING) {
                Ne.current || (Qe = Ie.current) == null || Qe.mainWorkspace.clearUndo();
                return
            }
            Ke.type === blocklyExports.Events.SELECTED || Ke.type === blocklyExports.Events.CLICK || Fe()
        }
    }
      , Ze = Ke => {
        var lt, Qe, gt, Nt;
        const mt = Ke.getFieldValue("SUBROUTINE_NAME");
        if (mt) {
            ve.current = mt;
            const Gt = (((Qe = (lt = Ie.current) == null ? void 0 : lt.mainWorkspace) == null ? void 0 : Qe.getBlocksByType("subroutineInstanceBlock", !1)) ?? []).filter(Ht => Ht.getFieldValue("SUBROUTINE_NAME") === mt);
            Gt.length ? ce && ce(Gt.length, mt) : (Nt = (gt = Ie.current) == null ? void 0 : gt.subroutinesManager) == null || Nt.deleteSubroutine(mt)
        }
    }
      , et = (Ke, mt) => {
        const lt = mt.getFieldValue("SUBROUTINE_NAME");
        lt && me && me(lt)
    }
      , it = Ke => {
        const mt = at(Ke);
        ge && ge(mt, Ke)
    }
      , at = Ke => Ke.reduce( (mt, lt) => {
        var Nt, Gt;
        const Qe = lt[1]
          , gt = (Gt = (Nt = Ie.current) == null ? void 0 : Nt.mainWorkspace) == null ? void 0 : Gt.getVariablesOfType(Qe);
        return gt && (mt[Qe] = gt),
        mt
    }
    , {})
      , rt = () => {
        var Ke, mt;
        ve.current && ((mt = (Ke = Ie.current) == null ? void 0 : Ke.subroutinesManager) == null || mt.deleteSubroutine(ve.current),
        ve.current = "")
    }
      , ft = (Ke, mt) => {
        var lt, Qe;
        (Qe = (lt = Ie.current) == null ? void 0 : lt.subroutinesManager) == null || Qe.renameSubroutine(Ke, mt)
    }
      , St = (Ke, mt) => {
        var lt, Qe, gt, Nt;
        Ke && ((Qe = (lt = Ie.current) == null ? void 0 : lt.subroutinesManager) == null || Qe.createSubroutineDefinitionBlock(Ke),
        (Nt = (gt = Ie.current) == null ? void 0 : gt.subroutinesManager) == null || Nt.setSubroutineParametes(Ke, mt.map( ({name: Gt, types: Ht}) => ({
            name: Gt,
            types: [...Ht.values()]
        }))))
    }
      , Ye = (Ke, mt) => {
        var lt, Qe;
        (Qe = (lt = Ie.current) == null ? void 0 : lt.mainWorkspace) == null || Qe.createVariable(Ke, mt),
        logger$6.debug(`Created new ${mt} variable ${Ke}`)
    }
      , We = (Ke, mt) => {
        var lt, Qe, gt, Nt;
        (Qe = (lt = Ie.current) == null ? void 0 : lt.mainWorkspace) == null || Qe.renameVariableById(mt, Ke),
        (Nt = (gt = Ie.current) == null ? void 0 : gt.mainWorkspace.getToolbox()) == null || Nt.refreshSelection(),
        logger$6.log(`Renamed variableId '${mt}' to "${Ke}"`)
    }
      , nt = Ke => {
        var lt, Qe, gt, Nt, Gt, Ht;
        const mt = ((Qe = (lt = Ie.current) == null ? void 0 : lt.mainWorkspace) == null ? void 0 : Qe.getVariableUsesById(Ke.getId() ?? "")) ?? [];
        Ke && ((Nt = (gt = Ie.current) == null ? void 0 : gt.mainWorkspace) == null || Nt.getVariableMap().deleteVariableInternal(Ke, mt),
        (Ht = (Gt = Ie.current) == null ? void 0 : Gt.mainWorkspace.getToolbox()) == null || Ht.refreshSelection())
    }
      , ct = (Ke, mt=!1) => {
        if (Ie.current && (!Ne.current || mt)) {
            if (Ke && Ke.mainWorkspace || Ke != null && Ke.mod) {
                Ie.current.mainWorkspace.clear();
                try {
                    if (Ke.mainWorkspace) {
                        const lt = blocklyExports.utils.xml.textToDom((Ke == null ? void 0 : Ke.variables) ?? "<xml />");
                        logger$6.debug("Loading Variables DOM", lt),
                        blocklyExports.Xml.domToVariables(lt, Ie.current.mainWorkspace),
                        Ie.current.validateWorkspaceDom(blocklyExports.utils.xml.textToDom((Ke == null ? void 0 : Ke.mainWorkspace) ?? Ie.current.default)).then(Qe => {
                            logger$6.debug("Loading Workspace DOM", Qe),
                            Ie != null && Ie.current && blocklyExports.Xml.domToWorkspace(Qe, Ie.current.mainWorkspace)
                        }
                        )
                    } else
                        Ke.mod && (logger$6.debug("Loading mod into workspace", Ke),
                        blocklyExports.serialization.workspaces.load(Ie.current.validateWorkspaceJson(Ke.mod), Ie.current.mainWorkspace))
                } catch (lt) {
                    logger$6.error("Could not load Blockly workspace:", lt),
                    Ie.current.mainWorkspace.clear(),
                    Ie.current.loadDefault()
                }
            } else
                Ie.current.mainWorkspace.clear(),
                Ie.current.loadDefault(),
                Ie.current.mainWorkspace.clearUndo();
            Ne.current = !0
        }
    }
      , Et = () => {
        var Ke, mt;
        (Ke = Ie.current) != null && Ke.mainWorkspace && blocklyExports.svgResize((mt = Ie.current) == null ? void 0 : mt.mainWorkspace)
    }
    ;
    return reactExports.useEffect( () => {
        var lt, Qe, gt, Nt, Gt, Ht;
        if (!V.current || !J)
            return;
        blocklyExports.ContextMenuRegistry.registry.register({
            displayText: () => blocklyExports.Msg.HELP,
            preconditionFn: () => "enabled",
            callback: ne || ( () => {}
            ),
            scopeType: blocklyExports.ContextMenuRegistry.ScopeType.BLOCK,
            id: HELP_CONTEXT_ITEM_ID,
            weight: 1
        }),
        Ie.current = new PyriteBlockly(V.current,sharedWorkspaceOptions);
        const Ke = new BlocklyToolboxManager(Ie.current.mainWorkspace);
        return new BlocklyWorkspaceSearchManager(Ie.current.mainWorkspace).init(),
        Ie.current.mainWorkspace.setVisible(!1),
        Ie.current.addChangeListener(qe),
        ue && ((lt = Ie.current.subroutinesManager) == null || lt.registerCreateNewSubroutineAction(ue)),
        (Qe = Ie.current.subroutinesManager) == null || Qe.registerDeleteSubroutineCallbackAction(Ze),
        (gt = Ie.current.subroutinesManager) == null || gt.registerRenameSubroutineCallbackAction(et),
        (Nt = Ie.current.variablesManager) == null || Nt.registerManageVariablesAction(it),
        Te && ((Gt = Ie.current.variablesManager) == null || Gt.registerRenameVariableCallbackAction(Te)),
        _e && ((Ht = Ie.current.variablesManager) == null || Ht.registerDeleteVariableCallbackAction(_e)),
        Ie.current.registerDefinitions(X, J, J.constraints, {
            isObjectInputWildcard: !0
        }),
        Ke.init(Ie.current.definitions),
        Ie.current.mainWorkspace.setVisible(!0),
        ke.current = new JsonGenerator,
        ke.current.init(Ie.current.definitions, Ie.current.subroutinesManager),
        we(!0),
        () => {
            var Kt;
            blocklyExports.ContextMenuRegistry.registry.unregister(HELP_CONTEXT_ITEM_ID),
            (Kt = Ie.current) == null || Kt.destroy(),
            Ne.current = !1,
            we(!1)
        }
    }
    , [J]),
    reactExports.useEffect( () => {
        var Ke, mt;
        (Ke = Ie.current) != null && Ke.mainWorkspace && blocklyExports.svgResize((mt = Ie.current) == null ? void 0 : mt.mainWorkspace)
    }
    , [$e, ye]),
    {
        subroutineManager: {
            deleteRequest: Ze,
            delete: rt,
            create: St,
            rename: ft
        },
        variableManager: {
            create: Ye,
            delete: nt,
            rename: We
        },
        blocklyInstance: Ie.current,
        getSerializedWorkspace: je,
        getWorkspaceExport: Xe,
        getWorkspaceExportAsXml: ze,
        getVariables: at,
        loadRules: ct,
        isMounted: xe,
        resizeBlocklyWorkspace: Et
    }
}
  , headingText = "_headingText_1qayv_1"
  , pageWrapper = "_pageWrapper_1qayv_6"
  , notSupportedTakeOver = "_notSupportedTakeOver_1qayv_11"
  , blocklyContainer = "_blocklyContainer_1qayv_25"
  , disabled = "_disabled_1qayv_39"
  , caption$1 = "_caption_1qayv_49"
  , scriptPreview = "_scriptPreview_1qayv_54"
  , rulesButtons = "_rulesButtons_1qayv_59"
  , rulesButtonGroup = "_rulesButtonGroup_1qayv_70"
  , styles$b = {
    headingText,
    pageWrapper,
    notSupportedTakeOver,
    blocklyContainer,
    disabled,
    caption: caption$1,
    scriptPreview,
    rulesButtons,
    rulesButtonGroup
};
class CustomInsertionMarkerManager extends blocklyExports.InsertionMarkerManager {
    constructor(J) {
        super(J);
        Tt(this, "connectionLine", null);
        Tt(this, "connectionIndicator", null);
        this.block = J
    }
    update(J, ne) {
        super.update(J, ne),
        this.updateConnectionLine(J)
    }
    createConnectionLine() {
        const ne = this.block.workspace.getRenderer().getConstants().CONNECTION_INDICATOR_RADIUS;
        if (!this.connectionLine && (this.connectionLine = blocklyExports.utils.dom.createSvgElement("line", {
            class: "blocklyConnectionLine",
            x1: 0,
            y1: 0,
            x2: 0,
            y2: 0
        }, this.localConnection_.sourceBlock_.getSvgRoot()),
        this.connectionIndicator = blocklyExports.utils.dom.createSvgElement("g", {
            class: "blocklyInputConnectionIndicator"
        }, this.closestConnection_.sourceBlock_.getSvgRoot()),
        this.connectionIndicator)) {
            blocklyExports.utils.dom.createSvgElement("circle", {
                r: ne
            }, this.connectionIndicator);
            const ue = this.closestConnection_.offsetInBlock_;
            this.connectionIndicator.setAttribute("transform", "translate(" + ue.x + "," + ue.y + ")")
        }
    }
    updateConnectionLine(J) {
        const ue = this.block.workspace.getRenderer().getConstants().CONNECTION_INDICATOR_RADIUS;
        if (this.closestConnection_ && this.localConnection_ && this.connectionLine) {
            const ce = ue
              , me = this.localConnection_.offsetInBlock_
              , ge = this.closestConnection_.x - this.localConnection_.x - J.x + me.x
              , Te = this.closestConnection_.y - this.localConnection_.y - J.y + me.y
              , _e = Math.atan2(Te - me.y, ge - me.x);
            Math.sqrt(Math.pow(ge - me.x, 2) + Math.pow(Te - me.y, 2)) < ce * 2 + 1 ? blocklyExports.utils.dom.addClass(this.connectionLine, "hidden") : (blocklyExports.utils.dom.removeClass(this.connectionLine, "hidden"),
            this.connectionLine.setAttribute("x1", (me.x + Math.cos(_e) * ce).toString()),
            this.connectionLine.setAttribute("y1", (me.y + Math.sin(_e) * ce).toString()),
            this.connectionLine.setAttribute("x2", (ge - Math.cos(_e) * ce).toString()),
            this.connectionLine.setAttribute("y2", (Te - Math.sin(_e) * ce).toString()))
        }
    }
    hideConnectionLine() {
        this.localConnection_ && this.connectionLine && (this.localConnection_.sourceBlock_.getSvgRoot().removeChild(this.connectionLine),
        this.connectionLine = null,
        this.closestConnection_.sourceBlock_.getSvgRoot().removeChild(this.connectionIndicator),
        this.connectionIndicator = null)
    }
    showInsertionInputOutline_() {
        this.createConnectionLine(),
        super.showInsertionInputOutline_()
    }
    hideInsertionInputOutline_() {
        this.hideConnectionLine(),
        super.hideInsertionInputOutline_()
    }
}
var StyleType = (V => (V.Disabled = "blockStyleDisabled",
V.Error = "blockStyleError",
V.Deprecated = "blocklyStyleDeprecated",
V))(StyleType || {});
function makeDisabledPattern(V, X) {
    const J = [];
    if (V.constants) {
        const ne = coreBrowserExports.utils.dom.createSvgElement(coreBrowserExports.utils.Svg.PATTERN, {
            id: "disabledPatternStyle",
            patternUnits: "userSpaceOnUse",
            width: 10,
            height: 10
        }, X);
        coreBrowserExports.utils.dom.createSvgElement(coreBrowserExports.utils.Svg.RECT, {
            width: 10,
            height: 10,
            fill: V.constants.BLOCK_DISABLED_PATTERN_FILL_COLOUR
        }, ne),
        coreBrowserExports.utils.dom.createSvgElement(coreBrowserExports.utils.Svg.PATH, {
            class: "disabledPatternGridLines",
            d: "M 0 0 L 10 10 M 10 0 L 0 10",
            stroke: V.constants.BLOCK_DISABLED_PATTERN_STROKE_COLOUR,
            strokewidth: 2 * V.constants.GRID_UNIT
        }, ne),
        J.push({
            attribute: "fill",
            value: `url(#${ne.id})`
        })
    }
    return J
}
function makeErrorPattern(V, X) {
    const J = [];
    if (V.constants) {
        const ne = coreBrowserExports.utils.dom.createSvgElement(coreBrowserExports.utils.Svg.PATTERN, {
            id: "errorPatternStyle",
            patternUnits: "userSpaceOnUse",
            width: 15,
            height: 15
        }, X);
        coreBrowserExports.utils.dom.createSvgElement(coreBrowserExports.utils.Svg.RECT, {
            width: 15,
            height: 15,
            fill: V.constants.BLOCK_ERROR_PATTERN_FILL_COLOUR
        }, ne),
        coreBrowserExports.utils.dom.createSvgElement(coreBrowserExports.utils.Svg.PATH, {
            d: "M 0 0 M 15 0 L 0 15",
            stroke: V.constants.BLOCK_ERROR_PATTERN_STROKE_COLOUR,
            strokewidth: 2 * V.constants.GRID_UNIT
        }, ne),
        J.push({
            attribute: "fill",
            value: `url(#${ne.id})`
        }),
        J.push({
            attribute: "stroke",
            value: V.constants.BLOCK_ERROR_HIGHLIGHT_STROKE_COLOUR
        }),
        J.push({
            attribute: "stroke-width",
            value: "2px"
        })
    }
    return J
}
function makeDeprecatedPattern(V, X) {
    const J = [];
    if (V.constants) {
        const ne = coreBrowserExports.utils.dom.createSvgElement(coreBrowserExports.utils.Svg.PATTERN, {
            id: "deprecatedPatternStyle",
            patternUnits: "userSpaceOnUse",
            width: 15,
            height: 15
        }, X);
        coreBrowserExports.utils.dom.createSvgElement(coreBrowserExports.utils.Svg.RECT, {
            width: 15,
            height: 15,
            fill: V.constants.BLOCK_DEPRECATED_PATTERN_FILL_COLOUR
        }, ne),
        coreBrowserExports.utils.dom.createSvgElement(coreBrowserExports.utils.Svg.PATH, {
            d: "M 0 0 M 15 0 L 0 15",
            stroke: V.constants.BLOCK_DEPRECATED_PATTERN_STROKE_COLOUR,
            strokewidth: 2 * V.constants.GRID_UNIT
        }, ne),
        J.push({
            attribute: "fill",
            value: `url(#${ne.id})`
        }),
        J.push({
            attribute: "stroke",
            value: V.constants.BLOCK_DEPRECATED_HIGHLIGHT_STROKE_COLOUR
        }),
        J.push({
            attribute: "stroke-width",
            value: "2px"
        })
    }
    return J
}
class BlocklyBlockStyleManager {
    constructor() {
        Tt(this, "constants", null);
        Tt(this, "defs", null);
        Tt(this, "styles", new Map)
    }
    init(X) {
        this.constants = X
    }
    makeStyles(X) {
        this.defs = coreBrowserExports.utils.dom.createSvgElement("defs", {}, X),
        this.defs && (this.styles.set(StyleType.Disabled, makeDisabledPattern(this, this.defs)),
        this.styles.set(StyleType.Error, makeErrorPattern(this, this.defs)),
        this.styles.set(StyleType.Deprecated, makeDeprecatedPattern(this, this.defs)))
    }
    getCss(X) {
        return this.constants ? `
        ${X}  .blocklyDisabled > .blocklyOutlinePath {
            fill: url(#disabledPatternStyle');
        }
        ${X}  .blocklyError > .blocklyOutlinePath {
            fill: url(#errorPatternStyle');
        }
        ${X}  .blocklyDeprecated > .blocklyOutlinePath {
            fill: url(#deprecatedPatternStyle');
        }
        ${X}  .blocklyText.ruleBlockRuleText {
            fill: ${this.constants.RULE_BLOCK_RULE_TEXT_COLOR};
        }
        ${X}  .blocklyText.ruleBlockConditionText {
            fill: ${this.constants.RULE_BLOCK_CONDITION_TEXT_COLOR};
        }
        ${X}  .blocklyText.ruleBlockActionText {
            fill: ${this.constants.RULE_BLOCK_ACTION_TEXT_COLOR};
        }
        ${X}  .blocklyText.subroutineBlockSubroutineText {
            fill: ${this.constants.SUBROUTINE_BLOCK_SUBROUTINE_TEXT_COLOR};
        }
        ${X}  .blocklyText.fieldHeaderText {
            font-family: ${this.constants.FIELD_TEXT_HEADER_FONTFAMILY};
            font-weight: ${this.constants.FIELD_TEXT_HEADER_FONTWEIGHT};
        }

        ${X}  .blocklyPath.blocklyWsSearchHighlight {
            stroke + ${this.constants.SEARCH_HIGHLIGHT_GROUP_STROKE_COLOUR};
            stroke-width: ${this.constants.SEARCH_HIGHLIGHT_GROUP_STROKE_WIDTH}px;
        }
        ${X}  .blocklyPath.blocklyWsSearchHighlight.blocklyWsSearchCurrent {
            stroke: ${this.constants.SEARCH_HIGHLIGHT_CURRENT_STROKE_COLOUR};
            stroke-width: ${this.constants.SEARCH_HIGHLIGHT_CURRENT_STROKE_WIDTH}px;
        }

        ${X} .blocklyStatementConnectionIndicator.connected {
            display: none;
        }

        ${X} .blocklyStatementConnectionIndicator polygon:first-child {
            fill: #000000;
        }

        ${X} .blocklySelected > .blocklyStatementConnectionIndicator polygon:first-child {
            fill: ${this.constants.SELECTED_GLOW_COLOUR};
        }

        ${X} .blocklyStatementConnectionIndicator.ruleBlock polygon:last-child {
            fill: ${this.constants.RULE_BLOCK_RULE_CONNECTION_COLOR};
        }

        ${X} .blocklyStatementConnectionIndicator.conditionBlock polygon:last-child {
            fill: ${this.constants.RULE_BLOCK_CONDITION_CONNECTION_COLOR};
        }

        ${X} .blocklyStatementConnectionIndicator.actionBlock polygon:last-child {
            fill: ${this.constants.RULE_BLOCK_ACTION_CONNECTION_COLOR};
        }
        ` : ""
    }
    applyStyle(X, J) {
        const ne = this.styles.get(J);
        if (ne)
            for (const ue of ne)
                X.setAttribute(ue.attribute, ue.value)
    }
}
const Dr = class Dr {
    static parse(X) {
        X = String(X).toLowerCase().trim();
        let J = Dr.Colors[X];
        if (J || (J = X.substring(0, 2) === "0x" ? "#" + X.substring(2) : X,
        J = J[0] === "#" ? J : "#" + J,
        /^#[0-9a-f]{6}$/.test(J)))
            return J;
        if (/^#[0-9a-f]{3}$/.test(J))
            return ["#", J[1], J[1], J[2], J[2], J[3], J[3]].join("");
        const ne = X.match(/^(?:rgb)?\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/);
        if (ne) {
            const ue = Number(ne[1])
              , ce = Number(ne[2])
              , me = Number(ne[3]);
            if (ue >= 0 && ue < 256 && ce >= 0 && ce < 256 && me >= 0 && me < 256)
                return Dr.rgbToHex(ue, ce, me)
        }
        return ""
    }
    static rgbToHex(X, J, ne) {
        const ue = X << 16 | J << 8 | ne;
        return X < 16 ? "#" + (16777216 | ue).toString(16).substr(1) : "#" + ue.toString(16)
    }
    static rgbArrayToHex(X) {
        return Dr.rgbToHex(X[0], X[1], X[2])
    }
    static hexToRgb(X) {
        const J = Dr.parse(X);
        if (!J)
            return [0, 0, 0];
        const ne = parseInt(J.substr(1), 16)
          , ue = ne >> 16
          , ce = ne >> 8 & 255
          , me = ne & 255;
        return [ue, ce, me]
    }
    static blend(X, J, ne) {
        const ue = Dr.parse(X);
        if (!ue)
            return "";
        const ce = Dr.parse(J);
        if (!ce)
            return "";
        const me = Dr.hexToRgb(ue)
          , ge = Dr.hexToRgb(ce)
          , Te = Math.round(ge[0] + ne * (me[0] - ge[0]))
          , _e = Math.round(ge[1] + ne * (me[1] - ge[1]))
          , Se = Math.round(ge[2] + ne * (me[2] - ge[2]));
        return Dr.rgbToHex(Te, _e, Se)
    }
    static luminance(X) {
        return (.2126 * X[0] + .7152 * X[1] + .0722 * X[2]) / 255
    }
    static darken(X, J) {
        return Dr.blend("#000000", X, J)
    }
    static lighten(X, J) {
        return Dr.blend("#ffffff", X, J)
    }
}
;
Tt(Dr, "Colors", {
    text: "#575E75",
    workspace: "#F9F9F9",
    toolboxHover: "#4C97FF",
    toolboxSelected: "#e9eef2",
    toolboxText: "#575E75",
    toolbox: "#FFFFFF",
    flyout: "#444",
    scrollbar: "#CECDCE",
    scrollbarHover: "#CECDCE",
    textField: "#FFFFFF",
    insertionMarker: "#000000",
    insertionMarkerOpacity: .2,
    dragShadowOpacity: .4,
    stackGlow: "#FFF200",
    stackGlowSize: 4,
    stackGlowOpacity: 1,
    replacementGlow: "#FFF200",
    replacementGlowSize: 2,
    replacementGlowOpacity: 1,
    highlightGlow: "#FFF200",
    highlightGlowSize: 1.1,
    highlightGlowOpacity: 1,
    selectedGlow: "#FFF200",
    selectedGlowSize: .4,
    warningGlow: "#E53D00",
    warningGlowSize: 1.1,
    warningGlowOpacity: 1,
    colourPickerStroke: "#FFFFFF",
    fieldShadow: "rgba(255, 255, 255, 0.2)",
    dropDownShadow: "rgba(0, 0, 0, .3)",
    numPadBackground: "#547AB2",
    numPadBorder: "#435F91",
    numPadActiveBackground: "#435F91",
    numPadText: "#FFFFFF",
    valueReportBackground: "#FFFFFF",
    valueReportBorder: "#AAAAAA",
    canvasTransitionLength: 500
});
let BlocklyColors = Dr;
class PortalConstantProvider extends coreBrowserExports.zelos.ConstantProvider {
    constructor() {
        super(...arguments);
        Tt(this, "GRID_UNIT", 4);
        Tt(this, "ICON_SEPARATOR_HEIGHT", 8 * this.GRID_UNIT);
        Tt(this, "ELLIPSES", "");
        Tt(this, "ELLIPSES_RADIUS", 6);
        Tt(this, "ELLIPSES_SPACING", 8);
        Tt(this, "COLLAPSE_IMAGE_DATAURI", "data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg enable-background='new 0 0 24 24' version='1.1' viewBox='0 0 24 24' xml:space='preserve' xmlns='http://www.w3.org/2000/svg'%3E%3Cstyle type='text/css'%3E .st0%7Bfill:%23CF8B17;%7D .st1%7Bfill:%23FFFFFF;%7D%0A%3C/style%3E%3Ctitle%3Erepeat%3C/title%3E%3Ccircle cx='12' cy='12' r='10.503' fill='none' stroke='%23fff' stroke-linecap='square' stroke-linejoin='round' stroke-width='2'/%3E%3Cg transform='matrix(.0086269 0 0 -.0086269 4.8224 17.354)'%3E%3Cpath d='m1611 367.42q0 53-37 90l-651 651q-38 38-91 38-54 0-90-38l-651-651q-38-36-38-90 0-53 38-91l74-75q39-37 91-37 53 0 90 37l486 486 486-486q37-37 90-37 52 0 91 37l75 75q37 39 37 91z' fill='%23fff'/%3E%3C/g%3E%3C/svg%3E%0A");
        Tt(this, "EXPAND_IMAGE_DATAURI", "data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg enable-background='new 0 0 24 24' version='1.1' viewBox='0 0 24 24' xml:space='preserve' xmlns='http://www.w3.org/2000/svg'%3E%3Cstyle type='text/css'%3E .st0%7Bfill:%23CF8B17;%7D .st1%7Bfill:%23FFFFFF;%7D%0A%3C/style%3E%3Ctitle%3Erepeat%3C/title%3E%3Ccircle cx='12' cy='12' r='10.503' fill='none' stroke='%23fff' stroke-linecap='square' stroke-linejoin='round' stroke-width='2'/%3E%3Cg transform='matrix(.0086269 0 0 -.0086269 4.8224 17.654)'%3E%3Cpath d='m1611 832q0-53-37-90l-651-651q-38-38-91-38-54 0-90 38l-651 651q-38 36-38 90 0 53 38 91l74 75q39 37 91 37 53 0 90-37l486-486 486 486q37 37 90 37 52 0 91-37l75-75q37-39 37-91z' fill='%23fff'/%3E%3C/g%3E%3C/svg%3E%0A");
        Tt(this, "CONNECTION_INDICATOR_RADIUS", 5);
        Tt(this, "NOTCH", this.makeNotch());
        Tt(this, "START_HAT", this.makeStartHat());
        Tt(this, "PUZZLE_TAB", this.makePuzzleTab());
        Tt(this, "INSIDE_CORNERS", this.makeInsideCorners());
        Tt(this, "OUTSIDE_CORNERS", this.makeOutsideCorners());
        Tt(this, "NO_PADDING", 0);
        Tt(this, "SMALL_PADDING", this.GRID_UNIT);
        Tt(this, "MEDIUM_PADDING", 3 * this.GRID_UNIT);
        Tt(this, "MEDIUM_LARGE_PADDING", 6 * this.GRID_UNIT);
        Tt(this, "LARGE_PADDING", 6 * this.GRID_UNIT);
        Tt(this, "TALL_INPUT_FIELD_OFFSET_Y", this.MEDIUM_PADDING);
        Tt(this, "TAB_HEIGHT", 15);
        Tt(this, "TAB_OFFSET_FROM_TOP", 0);
        Tt(this, "TAB_VERTICAL_OVERLAP", 2.5);
        Tt(this, "TAB_WIDTH", 8);
        Tt(this, "NOTCH_WIDTH", 9 * this.GRID_UNIT);
        Tt(this, "NOTCH_HEIGHT", 2 * this.GRID_UNIT);
        Tt(this, "MIN_BLOCK_WIDTH", 2 * this.GRID_UNIT);
        Tt(this, "EMPTY_BLOCK_SPACER_HEIGHT", 16);
        Tt(this, "DUMMY_INPUT_MIN_HEIGHT", 8 * this.GRID_UNIT);
        Tt(this, "DUMMY_INPUT_SHADOW_MIN_HEIGHT", 6 * this.GRID_UNIT);
        Tt(this, "CORNER_RADIUS", .25 * this.GRID_UNIT);
        Tt(this, "NOTCH_OFFSET_LEFT", 3 * this.GRID_UNIT);
        Tt(this, "STATEMENT_INPUT_NOTCH_OFFSET", this.NOTCH_OFFSET_LEFT);
        Tt(this, "STATEMENT_BOTTOM_SPACER", -this.NOTCH_HEIGHT);
        Tt(this, "STATEMENT_INPUT_PADDING_LEFT", 8 * this.GRID_UNIT);
        Tt(this, "BETWEEN_STATEMENT_PADDING_Y", 4);
        Tt(this, "TOP_ROW_MIN_HEIGHT", 4 * this.CORNER_RADIUS);
        Tt(this, "TOP_ROW_PRECEDES_STATEMENT_MIN_HEIGHT", this.LARGE_PADDING);
        Tt(this, "BOTTOM_ROW_MIN_HEIGHT", 4 * this.CORNER_RADIUS);
        Tt(this, "STATEMENT_INPUT_SPACER_MIN_WIDTH", 40 * this.GRID_UNIT);
        Tt(this, "CURSOR_RADIUS", 5);
        Tt(this, "SHAPE_IN_SHAPE_PADDING", {
            1: {
                0: 5 * this.GRID_UNIT,
                1: 2 * this.GRID_UNIT,
                2: 5 * this.GRID_UNIT,
                3: 5 * this.GRID_UNIT
            },
            2: {
                0: 3 * this.GRID_UNIT,
                1: 3 * this.GRID_UNIT,
                2: 1 * this.GRID_UNIT,
                3: 2 * this.GRID_UNIT
            },
            3: {
                0: 2 * this.GRID_UNIT,
                1: 2 * this.GRID_UNIT,
                2: 2 * this.GRID_UNIT,
                3: 2 * this.GRID_UNIT
            }
        });
        Tt(this, "MAX_DYNAMIC_CONNECTION_SHAPE_WIDTH", 16 * this.GRID_UNIT);
        Tt(this, "SELECTED_GLOW_COLOUR", "#aec0cc");
        Tt(this, "SELECTED_GLOW_SIZE", .1);
        Tt(this, "REPLACEMENT_GLOW_COLOUR", "#fff200");
        Tt(this, "REPLACEMENT_GLOW_SIZE", 1);
        Tt(this, "BOTTOM_ROW_AFTER_STATEMENT_MIN_HEIGHT", 6 * this.GRID_UNIT);
        Tt(this, "ADD_START_HATS", !1);
        Tt(this, "START_HAT_HEIGHT", 22);
        Tt(this, "START_HAT_WIDTH", 96);
        Tt(this, "SPACER_DEFAULT_HEIGHT", 15);
        Tt(this, "MIN_BLOCK_HEIGHT", 12 * this.GRID_UNIT);
        Tt(this, "EMPTY_INLINE_INPUT_PADDING", 4 * this.GRID_UNIT);
        Tt(this, "EMPTY_INLINE_INPUT_HEIGHT", 8 * this.GRID_UNIT);
        Tt(this, "EXTERNAL_VALUE_INPUT_PADDING", 2);
        Tt(this, "EMPTY_STATEMENT_INPUT_HEIGHT", 12 * this.GRID_UNIT);
        Tt(this, "START_POINT", coreBrowserExports.utils.svgPaths.moveBy(0, 0));
        Tt(this, "JAGGED_TEETH_HEIGHT", 0);
        Tt(this, "JAGGED_TEETH_WIDTH", 0);
        Tt(this, "FIELD_TEXT_FONTSIZE", 3 * this.GRID_UNIT);
        Tt(this, "FIELD_TEXT_FONTWEIGHT", "400");
        Tt(this, "FIELD_TEXT_FONTFAMILY", getFontFallback('"BFText-Regular"'));
        Tt(this, "FIELD_TEXT_HEADER_FONTWEIGHT", "600");
        Tt(this, "FIELD_TEXT_HEADER_FONTFAMILY", getFontFallback('"Purista-Semibold"'));
        Tt(this, "FIELD_TEXT_HEIGHT", -1);
        Tt(this, "FIELD_TEXT_BASELINE", -1);
        Tt(this, "FIELD_BORDER_RECT_RADIUS", 4 * this.CORNER_RADIUS);
        Tt(this, "FIELD_BORDER_RECT_HEIGHT", 8 * this.GRID_UNIT);
        Tt(this, "FIELD_BORDER_RECT_X_PADDING", 2 * this.GRID_UNIT);
        Tt(this, "FIELD_BORDER_RECT_Y_PADDING", 1.625 * this.GRID_UNIT);
        Tt(this, "FIELD_BORDER_RECT_COLOUR", "#fff");
        Tt(this, "FIELD_TEXT_BASELINE_CENTER", !0);
        Tt(this, "FIELD_DROPDOWN_BORDER_RECT_HEIGHT", 8 * this.GRID_UNIT);
        Tt(this, "FIELD_DROPDOWN_NO_BORDER_RECT_SHADOW", !0);
        Tt(this, "FIELD_DROPDOWN_COLOURED_DIV", !0);
        Tt(this, "FIELD_DROPDOWN_SVG_ARROW", !0);
        Tt(this, "FIELD_DROPDOWN_SVG_ARROW_PADDING", this.FIELD_BORDER_RECT_X_PADDING);
        Tt(this, "FIELD_DROPDOWN_SVG_ARROW_SIZE", 12);
        Tt(this, "FIELD_DROPDOWN_SVG_ARROW_DATAURI", "data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMi43MSIgaGVpZ2h0PSI4Ljc5IiB2aWV3Qm94PSIwIDAgMTIuNzEgOC43OSI+PHRpdGxlPmRyb3Bkb3duLWFycm93PC90aXRsZT48ZyBvcGFjaXR5PSIwLjEiPjxwYXRoIGQ9Ik0xMi43MSwyLjQ0QTIuNDEsMi40MSwwLDAsMSwxMiw0LjE2TDguMDgsOC4wOGEyLjQ1LDIuNDUsMCwwLDEtMy40NSwwTDAuNzIsNC4xNkEyLjQyLDIuNDIsMCwwLDEsMCwyLjQ0LDIuNDgsMi40OCwwLDAsMSwuNzEuNzFDMSwwLjQ3LDEuNDMsMCw2LjM2LDBTMTEuNzUsMC40NiwxMiwuNzFBMi40NCwyLjQ0LDAsMCwxLDEyLjcxLDIuNDRaIiBmaWxsPSIjMjMxZjIwIi8+PC9nPjxwYXRoIGQ9Ik02LjM2LDcuNzlhMS40MywxLjQzLDAsMCwxLTEtLjQyTDEuNDIsMy40NWExLjQ0LDEuNDQsMCwwLDEsMC0yYzAuNTYtLjU2LDkuMzEtMC41Niw5Ljg3LDBhMS40NCwxLjQ0LDAsMCwxLDAsMkw3LjM3LDcuMzdBMS40MywxLjQzLDAsMCwxLDYuMzYsNy43OVoiIGZpbGw9IiNmZmYiLz48L3N2Zz4=");
        Tt(this, "FIELD_DROPDOWN_SVG_CHECKMARK_SIZE", 12);
        Tt(this, "FIELD_DROPDOWN_SVG_CHECKMARK_DATAURI", "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBmaWxsPSIjZmZmZmZmIiBkPSJNMjAuMjg1IDJsLTExLjI4NSAxMS41NjctNS4yODYtNS4wMTEtMy43MTQgMy43MTYgOSA4LjcyOCAxNS0xNS4yODV6Ii8+PC9zdmc+");
        Tt(this, "FIELD_DROPDOWN_TEXT_COLOR", "#ffffff");
        Tt(this, "FILED_DROPDOWN_HIGHLIGHTCOLOR", "#ff0000");
        Tt(this, "FILED_DROPDOWN_TEXT_HIGHLIGHTCOLOR", "#ff00ff");
        Tt(this, "FIELD_TEXTINPUT_BOX_SHADOW", !0);
        Tt(this, "FIELD_COLOUR_FULL_BLOCK", !0);
        Tt(this, "FIELD_COLOUR_DEFAULT_WIDTH", 2 * this.GRID_UNIT);
        Tt(this, "FIELD_COLOUR_DEFAULT_HEIGHT", 4 * this.GRID_UNIT);
        Tt(this, "FIELD_CHECKBOX_X_OFFSET", 1 * this.GRID_UNIT);
        Tt(this, "FIELD_TEXT_COLOR", "#575E75");
        Tt(this, "FIELD_EDITABLE_TEXT_COLOR_HOVER", "#fff");
        Tt(this, "CURSOR_COLOUR", "#ffa200");
        Tt(this, "MARKER_COLOUR", "#4286f4");
        Tt(this, "CURSOR_WS_WIDTH", 20 * this.GRID_UNIT);
        Tt(this, "WS_CURSOR_HEIGHT", 5);
        Tt(this, "CURSOR_STACK_PADDING", 10);
        Tt(this, "CURSOR_BLOCK_PADDING", 2);
        Tt(this, "CURSOR_STROKE_WIDTH", 4);
        Tt(this, "FULL_BLOCK_FIELDS", !0);
        Tt(this, "INSERTION_MARKER_COLOUR", "#000000");
        Tt(this, "INSERTION_MARKER_OPACITY", .2);
        Tt(this, "SEARCH_HIGHLIGHT_GROUP_STROKE_COLOUR", "#0000ff");
        Tt(this, "SEARCH_HIGHLIGHT_GROUP_STROKE_WIDTH", .5 * this.GRID_UNIT);
        Tt(this, "SEARCH_HIGHLIGHT_CURRENT_STROKE_COLOUR", "#ff00ff");
        Tt(this, "SEARCH_HIGHLIGHT_CURRENT_STROKE_WIDTH", 1 * this.GRID_UNIT);
        Tt(this, "RULE_BLOCK_RULE_TEXT_COLOR", "#ffffff");
        Tt(this, "RULE_BLOCK_RULE_CONNECTION_COLOR", "#e882ff");
        Tt(this, "RULE_BLOCK_CONDITION_TEXT_COLOR", "#ffffff");
        Tt(this, "RULE_BLOCK_CONDITION_CONNECTION_COLOR", "#0a4f78");
        Tt(this, "RULE_BLOCK_ACTION_TEXT_COLOR", "#ffffff");
        Tt(this, "RULE_BLOCK_ACTION_CONNECTION_COLOR", "#b7a11c");
        Tt(this, "SUBROUTINE_BLOCK_SUBROUTINE_TEXT_COLOR", "#ffffff");
        Tt(this, "SHAPES", {
            HEXAGONAL: 1,
            ROUND: 2,
            SQUARE: 3,
            PUZZLE: 4,
            NOTCH: 5
        });
        Tt(this, "highlightedGlowFilterId", "");
        Tt(this, "highlightedGlowFilter");
        Tt(this, "warningGlowFilterId", "");
        Tt(this, "warningGlowFilter");
        Tt(this, "BLOCK_DISABLED_PATTERN_STROKE_COLOUR", "#4f4f4f");
        Tt(this, "BLOCK_DISABLED_PATTERN_FILL_COLOUR", "rgba(255,255,255,0.5)");
        Tt(this, "BLOCK_ERROR_PATTERN_STROKE_COLOUR", "#ff0000");
        Tt(this, "BLOCK_ERROR_PATTERN_FILL_COLOUR", "#aaa");
        Tt(this, "BLOCK_ERROR_HIGHLIGHT_STROKE_COLOUR", "#ff0000");
        Tt(this, "BLOCK_DEPRECATED_PATTERN_STROKE_COLOUR", "#ff0000");
        Tt(this, "BLOCK_DEPRECATED_PATTERN_FILL_COLOUR", "#aaa");
        Tt(this, "BLOCK_DEPRECATED_HIGHLIGHT_STROKE_COLOUR", "#ff0000");
        Tt(this, "BLOCK_OUTLINE_STROKE_WIDTH", 2);
        Tt(this, "RULE_CATEGORY_COLOR", "#ffffff");
        Tt(this, "SUBROUTINES_CATEGORY_COLOR", "#ffffff");
        Tt(this, "VALUES_CATEGORY_COLOR", "#ffffff");
        Tt(this, "ACTIONS_CATEGORY_COLOR", "#ffffff");
        Tt(this, "CONTROLS_CATEGORY_COLOR", "#ffffff");
        Tt(this, "INPUT_VALUE_TYPE_ICON_MAX_COUNT", 6);
        Tt(this, "INPUT_VALUE_TYPE_ICON_MAX_SIZE", 30);
        Tt(this, "INPUT_VALUE_TYPE_ICON_MARGIN", 2);
        Tt(this, "styleManager", new BlocklyBlockStyleManager)
    }
    init() {
        super.init(),
        this.ELLIPSES = this.makeEllipses(),
        this.styleManager.init(this)
    }
    getStyleManager() {
        return this.styleManager
    }
    createDom(J, ne, ue) {
        var $e;
        super.createDom(J, ne, ue);
        const ce = coreBrowserExports.utils.dom.createSvgElement("defs", {}, J)
          , me = coreBrowserExports.utils.dom.createSvgElement("filter", {
            id: "blocklyHighlightGlowFilter" + this.randomIdentifier,
            height: "160%",
            width: "180%",
            y: "-30%",
            x: "-40%"
        }, ce);
        coreBrowserExports.utils.dom.createSvgElement("feGaussianBlur", {
            in: "SourceGraphic",
            stdDeviation: BlocklyColors.Colors.highlightGlowSize
        }, me);
        const ge = coreBrowserExports.utils.dom.createSvgElement("feComponentTransfer", {
            result: "outBlur"
        }, me);
        coreBrowserExports.utils.dom.createSvgElement("feFuncA", {
            type: "table",
            tableValues: "0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"
        }, ge),
        coreBrowserExports.utils.dom.createSvgElement("feFlood", {
            "flood-color": BlocklyColors.Colors.highlightGlow,
            "flood-opacity": BlocklyColors.Colors.highlightGlowOpacity,
            result: "outColor"
        }, me),
        coreBrowserExports.utils.dom.createSvgElement("feComposite", {
            in: "outColor",
            in2: "outBlur",
            operator: "in",
            result: "outGlow"
        }, me),
        this.highlightedGlowFilterId = me.id,
        this.highlightedGlowFilter = me;
        const Te = coreBrowserExports.utils.dom.createSvgElement("filter", {
            id: "blocklyHighlightWarningFilter" + this.randomIdentifier,
            height: "160%",
            width: "180%",
            y: "-30%",
            x: "-40%"
        }, ce);
        coreBrowserExports.utils.dom.createSvgElement("feGaussianBlur", {
            in: "SourceGraphic",
            stdDeviation: BlocklyColors.Colors.warningGlowSize
        }, Te);
        const _e = coreBrowserExports.utils.dom.createSvgElement("feComponentTransfer", {
            result: "outBlur"
        }, Te);
        coreBrowserExports.utils.dom.createSvgElement("feFuncA", {
            type: "table",
            tableValues: "0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"
        }, _e),
        coreBrowserExports.utils.dom.createSvgElement("feFlood", {
            "flood-color": BlocklyColors.Colors.warningGlow,
            "flood-opacity": BlocklyColors.Colors.warningGlowOpacity,
            result: "outColor"
        }, Te),
        coreBrowserExports.utils.dom.createSvgElement("feComposite", {
            in: "outColor",
            in2: "outBlur",
            operator: "in",
            result: "outGlow"
        }, Te),
        this.warningGlowFilterId = Te.id,
        this.warningGlowFilter = Te;
        const Se = this.FIELD_DROPDOWN_SVG_ARROW_SIZE;
        coreBrowserExports.utils.dom.createSvgElement("image", {
            id: "blocklyDropdownArrowSvg",
            height: Se + "px",
            width: Se + "px"
        }, ce).setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", this.FIELD_DROPDOWN_SVG_ARROW_DATAURI),
        coreBrowserExports.utils.dom.createSvgElement("image", {
            id: "blocklyDropdownCheckmarkSvg"
        }, ce).setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", this.FIELD_DROPDOWN_SVG_CHECKMARK_DATAURI),
        ($e = this.styleManager) == null || $e.makeStyles(J)
    }
    makeEllipses() {
        const J = this.ELLIPSES_RADIUS
          , ne = this.ELLIPSES_SPACING;
        let ue = "";
        for (let ce = 0; ce < 3; ce++)
            ue += coreBrowserExports.utils.svgPaths.moveBy(ne, 0) + coreBrowserExports.utils.svgPaths.arc("a", "180 1,1", J, coreBrowserExports.utils.svgPaths.point(J * 2, 0));
        for (let ce = 0; ce < 3; ce++)
            ue += coreBrowserExports.utils.svgPaths.arc("a", "180 1,1", J, coreBrowserExports.utils.svgPaths.point(-J * 2, 0)) + coreBrowserExports.utils.svgPaths.moveBy(-ne, 0);
        return ue
    }
    makeNotch() {
        const J = this.NOTCH_WIDTH
          , ne = this.NOTCH_HEIGHT
          , ue = J / 3
          , ce = ue / 3
          , me = ne / 2
          , ge = me / 2
          , Te = Ie => coreBrowserExports.utils.svgPaths.curve("c", [coreBrowserExports.utils.svgPaths.point(Ie * ce / 2, 0), coreBrowserExports.utils.svgPaths.point(Ie * ce * 3 / 4, ge / 2), coreBrowserExports.utils.svgPaths.point(Ie * ce, ge)]) + coreBrowserExports.utils.svgPaths.line([coreBrowserExports.utils.svgPaths.point(Ie * ce, me)]) + coreBrowserExports.utils.svgPaths.curve("c", [coreBrowserExports.utils.svgPaths.point(Ie * ce / 4, ge / 2), coreBrowserExports.utils.svgPaths.point(Ie * ce / 2, ge), coreBrowserExports.utils.svgPaths.point(Ie * ce, ge)]) + coreBrowserExports.utils.svgPaths.lineOnAxis("h", Ie * ue) + coreBrowserExports.utils.svgPaths.curve("c", [coreBrowserExports.utils.svgPaths.point(Ie * ce / 2, 0), coreBrowserExports.utils.svgPaths.point(Ie * ce * 3 / 4, -(ge / 2)), coreBrowserExports.utils.svgPaths.point(Ie * ce, -ge)]) + coreBrowserExports.utils.svgPaths.line([coreBrowserExports.utils.svgPaths.point(Ie * ce, -me)]) + coreBrowserExports.utils.svgPaths.curve("c", [coreBrowserExports.utils.svgPaths.point(Ie * ce / 4, -(ge / 2)), coreBrowserExports.utils.svgPaths.point(Ie * ce / 2, -ge), coreBrowserExports.utils.svgPaths.point(Ie * ce, -ge)])
          , _e = Te(1)
          , Se = Te(-1);
        return {
            type: this.SHAPES.NOTCH,
            width: J,
            height: ne,
            pathLeft: _e,
            pathRight: Se
        }
    }
    setDynamicProperties_(J) {
        super.setDynamicProperties_(J),
        this.SELECTED_GLOW_COLOUR = J.getComponentStyle("selectedGlowColour") || this.SELECTED_GLOW_COLOUR;
        const ne = Number(J.getComponentStyle("selectedGlowSize"));
        this.SELECTED_GLOW_SIZE = ne && !isNaN(ne) ? ne : this.SELECTED_GLOW_SIZE,
        this.REPLACEMENT_GLOW_COLOUR = J.getComponentStyle("replacementGlowColour") || this.REPLACEMENT_GLOW_COLOUR;
        const ue = Number(J.getComponentStyle("replacementGlowSize"));
        this.REPLACEMENT_GLOW_SIZE = ue && !isNaN(ue) ? ue : this.REPLACEMENT_GLOW_SIZE,
        this.FIELD_BORDER_RECT_COLOUR = J.getComponentStyle("fieldBorderRectColor") || this.FIELD_BORDER_RECT_COLOUR,
        this.FIELD_TEXT_COLOR = J.getComponentStyle("fieldTextColor") || this.FIELD_TEXT_COLOR,
        this.FIELD_DROPDOWN_TEXT_COLOR = J.getComponentStyle("fieldDropdownTextColor") || this.FIELD_DROPDOWN_TEXT_COLOR,
        this.FILED_DROPDOWN_HIGHLIGHTCOLOR = J.getComponentStyle("fieldDropDownHighlightColor") || this.FILED_DROPDOWN_HIGHLIGHTCOLOR,
        this.FILED_DROPDOWN_TEXT_HIGHLIGHTCOLOR = J.getComponentStyle("fieldDropDownTextHighlightColor") || this.FILED_DROPDOWN_TEXT_HIGHLIGHTCOLOR,
        this.FIELD_EDITABLE_TEXT_COLOR_HOVER = J.getComponentStyle("fieldEditableTextHoverColor") || this.FIELD_EDITABLE_TEXT_COLOR_HOVER,
        this.SEARCH_HIGHLIGHT_CURRENT_STROKE_COLOUR = J.getComponentStyle("wsSearchHighlightCurrentColor") || this.SEARCH_HIGHLIGHT_CURRENT_STROKE_COLOUR,
        this.SEARCH_HIGHLIGHT_GROUP_STROKE_COLOUR = J.getComponentStyle("wsSearchHighlightGroupColor") || this.SEARCH_HIGHLIGHT_GROUP_STROKE_COLOUR,
        this.BLOCK_DISABLED_PATTERN_STROKE_COLOUR = J.getComponentStyle("blockDisablePatternStrokeColor") || this.BLOCK_DISABLED_PATTERN_STROKE_COLOUR,
        this.BLOCK_DISABLED_PATTERN_FILL_COLOUR = J.getComponentStyle("blockDisablePatternFillColor") || this.BLOCK_DISABLED_PATTERN_FILL_COLOUR,
        this.BLOCK_ERROR_PATTERN_STROKE_COLOUR = J.getComponentStyle("blockErrorPatternStrokeColor") || this.BLOCK_ERROR_PATTERN_STROKE_COLOUR,
        this.BLOCK_ERROR_PATTERN_FILL_COLOUR = J.getComponentStyle("blockErrorPatternFillColor") || this.BLOCK_ERROR_PATTERN_FILL_COLOUR,
        this.BLOCK_ERROR_HIGHLIGHT_STROKE_COLOUR = J.getComponentStyle("blockErrorHighlightStrokeColor") || this.BLOCK_ERROR_HIGHLIGHT_STROKE_COLOUR,
        this.BLOCK_DEPRECATED_PATTERN_STROKE_COLOUR = J.getComponentStyle("blockDeprecatedPatternStrokeColor") || this.BLOCK_DEPRECATED_PATTERN_STROKE_COLOUR,
        this.BLOCK_DEPRECATED_PATTERN_FILL_COLOUR = J.getComponentStyle("blockDeprecatedPatternFillColor") || this.BLOCK_DEPRECATED_PATTERN_FILL_COLOUR,
        this.BLOCK_DEPRECATED_HIGHLIGHT_STROKE_COLOUR = J.getComponentStyle("blockDeprecatedHighlightStrokeColor") || this.BLOCK_DEPRECATED_HIGHLIGHT_STROKE_COLOUR,
        this.RULE_BLOCK_RULE_TEXT_COLOR = J.getComponentStyle("ruleBlockRuleTextColor") || this.RULE_BLOCK_RULE_TEXT_COLOR,
        this.RULE_BLOCK_RULE_CONNECTION_COLOR = J.getComponentStyle("ruleBlockRuleConnectionColor") || this.RULE_BLOCK_RULE_CONNECTION_COLOR,
        this.RULE_BLOCK_CONDITION_TEXT_COLOR = J.getComponentStyle("ruleBlockConditionTextColor") || this.RULE_BLOCK_CONDITION_TEXT_COLOR,
        this.RULE_BLOCK_CONDITION_CONNECTION_COLOR = J.getComponentStyle("ruleBlockConditionConnectionColor") || this.RULE_BLOCK_CONDITION_CONNECTION_COLOR,
        this.RULE_BLOCK_ACTION_TEXT_COLOR = J.getComponentStyle("ruleBlockActionTextColor") || this.RULE_BLOCK_ACTION_TEXT_COLOR,
        this.RULE_BLOCK_ACTION_CONNECTION_COLOR = J.getComponentStyle("ruleBlockActionConnectionColor") || this.RULE_BLOCK_ACTION_CONNECTION_COLOR,
        this.SUBROUTINE_BLOCK_SUBROUTINE_TEXT_COLOR = J.getComponentStyle("subroutineBlockSubroutineTextColor") || this.SUBROUTINE_BLOCK_SUBROUTINE_TEXT_COLOR,
        this.RULE_CATEGORY_COLOR = J.getComponentStyle("rulesCategoryColor") || this.RULE_CATEGORY_COLOR,
        this.SUBROUTINES_CATEGORY_COLOR = J.getComponentStyle("subroutinesCategoryColor") || this.SUBROUTINES_CATEGORY_COLOR,
        this.VALUES_CATEGORY_COLOR = J.getComponentStyle("valuesCategoryColor") || this.VALUES_CATEGORY_COLOR,
        this.ACTIONS_CATEGORY_COLOR = J.getComponentStyle("actionsCategoryColor") || this.ACTIONS_CATEGORY_COLOR,
        this.CONTROLS_CATEGORY_COLOR = J.getComponentStyle("controlsCategoryColor") || this.CONTROLS_CATEGORY_COLOR
    }
    shapeFor(J) {
        let ne = J.getCheck();
        switch (!ne && J.targetConnection && (ne = J.targetConnection.getCheck()),
        J.type) {
        case coreBrowserExports.ConnectionType.INPUT_VALUE:
        case coreBrowserExports.ConnectionType.OUTPUT_VALUE:
            {
                const ue = J.getSourceBlock().getOutputShape();
                if (ue != null)
                    switch (ue) {
                    case this.SHAPES.HEXAGONAL:
                        return this.HEXAGONAL;
                    case this.SHAPES.ROUND:
                        return this.ROUNDED;
                    case this.SHAPES.SQUARE:
                        return this.SQUARED
                    }
                return this.ROUNDED
            }
        case coreBrowserExports.ConnectionType.PREVIOUS_STATEMENT:
        case coreBrowserExports.ConnectionType.NEXT_STATEMENT:
            return this.NOTCH;
        default:
            throw Error("Unknown type")
        }
    }
    getCSS_(J) {
        return [J + " .blocklyMainBackground {", "stroke: none;", "}", J + " .blocklyText,", J + " .blocklyFlyoutLabelText {", "font: " + this.FIELD_TEXT_FONTWEIGHT + " " + this.FIELD_TEXT_FONTSIZE + "pt " + this.FIELD_TEXT_FONTFAMILY + ";", "}", J + " .blocklyText {", "fill: #fff;", "}", J + " .blocklyNonEditableText>rect:not(.blocklyDropdownRect),", J + " .blocklyEditableText>rect:not(.blocklyDropdownRect) {", "fill: " + this.FIELD_BORDER_RECT_COLOUR + ";", "}", J + " .blocklyNonEditableText>text:not(.blocklyDropdownText),", J + " .blocklyEditableText>text:not(.blocklyDropdownText),", J + " .blocklyNonEditableText>g>text,", J + " .blocklyEditableText>g>text {", "fill: " + this.FIELD_TEXT_COLOR + ";", "}", J + " .blocklyFlyoutLabelText {", "fill: #575E75;", "}", J + " .blocklyText.blocklyBubbleText {", "fill: white;", "stroke: rgba(38, 255, 223, 0.5);", "stroke-width: 3px", "}", J + " .blocklyDraggable:not(.blocklyDisabled)", " .blocklyEditableText:not(.editing):hover>rect,", J + " .blocklyDraggable:not(.blocklyDisabled)", " .blocklyEditableText:not(.editing):hover>.blocklyPath {", "stroke: " + this.FIELD_EDITABLE_TEXT_COLOR_HOVER + ";", "stroke-width: 2;", "}", J + " .blocklyHtmlInput {", "font-family: " + this.FIELD_TEXT_FONTFAMILY + ";", "font-weight: " + this.FIELD_TEXT_FONTWEIGHT + ";", "fill: " + this.FIELD_TEXT_COLOR + ";", "}", J + " .blocklyDropdownText {", "fill: " + this.FIELD_DROPDOWN_TEXT_COLOR + ";", "}", J + ".blocklyWidgetDiv .goog-menuitem,", J + ".blocklyDropDownDiv .goog-menuitem {", "font-family: " + this.FIELD_TEXT_FONTFAMILY + ";", "}", J + ".blocklyDropDownDiv .goog-menuitem-content {", "color: #fff;", "}", J + " .blocklyMenuItemHighlight {", "background-color: " + this.FILED_DROPDOWN_HIGHLIGHTCOLOR + ";", "}", J + " .blocklyMenuItemHighlight .blocklyMenuItemContent {", "color: " + this.FILED_DROPDOWN_TEXT_HIGHLIGHTCOLOR + ";", "}", J + " .blocklyMenuItemSelected .blocklyMenuItemCheckbox {", "background: url(" + this.FIELD_DROPDOWN_SVG_CHECKMARK_DATAURI + ");", "float: left;", "margin-left: -24px;", "position: static;", "background-size: contain;", "width: " + this.FIELD_DROPDOWN_SVG_CHECKMARK_SIZE + "px;", "height: " + this.FIELD_DROPDOWN_SVG_CHECKMARK_SIZE + "px;", "}", J + " .blocklyMenuItemHighlight .blocklyMenuItemCheckbox {", "filter: invert();", "}", J + " .blocklyHighlightedConnectionPath {", "stroke: " + this.SELECTED_GLOW_COLOUR + ";", "}", J + " .blocklyDisabled > .blocklyOutlinePath {", "fill: url(#blocklyDisabledPattern)", "}", J + " .blocklyInsertionMarker>.blocklyPath {", "fill-opacity: " + this.INSERTION_MARKER_OPACITY + ";", "stroke: none;", "}", J + " .blocklyConnectionIndicator, " + J + " .blocklyInputConnectionIndicator {", "fill: #ff0000;", "fill-opacity: 0.9;", "stroke: #ffff00;", "stroke-width: 3px;", "}", J + " .blocklyConnectionIndicator {", "display: none;", "}", J + " .blocklyBlockDragSurface > g > .blocklyDraggable > .blocklyConnectionIndicator {", "display: block;", "}", J + " .blocklyConnectionLine {", "stroke: #ffff00;", "stroke-width: 4px;", "}", J + " .blocklyConnectionLine.hidden {", "display: none;", "}"].concat([this.styleManager.getCss(J)])
    }
}
class PortalDrawer extends blocklyExports.zelos.Drawer {
    constructor(J, ne) {
        super(J, ne);
        Tt(this, "portalPathObject");
        Tt(this, "portalRenderInfo");
        Tt(this, "block");
        this.block = J,
        this.portalPathObject = J.pathObject,
        this.portalRenderInfo = ne
    }
    drawInternals_() {
        this.portalPathObject.clearInputIconIndicators(),
        super.drawInternals_()
    }
    isStatementBlock() {
        var J, ne, ue;
        return !!(this.block.nextConnection && this.block.nextConnection.getCheck() && (((J = this.block.nextConnection.getCheck()) == null ? void 0 : J.indexOf("actionBlock")) !== -1 || ((ne = this.block.nextConnection.getCheck()) == null ? void 0 : ne.indexOf("conditionBlock")) !== -1 || ((ue = this.block.nextConnection.getCheck()) == null ? void 0 : ue.indexOf("ruleBlock")) !== -1))
    }
    drawOutline_() {
        this.portalPathObject.clearStatementConnectors(),
        super.drawOutline_()
    }
    drawInlineInput_(J) {
        super.drawInlineInput_(J),
        this.portalPathObject.setValueInputPath(J)
    }
}
class PortalInlineInput extends coreBrowserExports.blockRendering.InlineInput {
    constructor(J, ne) {
        var ue, ce;
        super(J, ne);
        Tt(this, "portalConstants");
        if (this.portalConstants = J,
        !((ue = ne.connection) != null && ue.targetConnection) && ((ce = ne.connection) != null && ce.getCheck())) {
            const me = this.height / 1.3
              , ge = this.portalConstants.INPUT_VALUE_TYPE_ICON_MAX_SIZE
              , Te = me > ge ? ge : me;
            let _e = ne.connection.getCheck() ?? [];
            _e.length > this.portalConstants.INPUT_VALUE_TYPE_ICON_MAX_COUNT && (_e = ["any"]),
            this.width += _e.length * Te + (_e.length - 1) * this.portalConstants.INPUT_VALUE_TYPE_ICON_MARGIN
        }
    }
}
class CustomCollapsedInputRow extends coreBrowserExports.blockRendering.Row {
    measure() {
        this.width = this.minWidth,
        this.height = this.constants_.EMPTY_STATEMENT_INPUT_HEIGHT
    }
}
class PortalRenderInfo extends coreBrowserExports.zelos.RenderInfo {
    addCollapsedRow_(X) {
        return this.rows.push(X),
        X = new CustomCollapsedInputRow(this.constants_),
        X.hasDummyInput = !0,
        X
    }
    addInput_(X, J) {
        X.type === coreBrowserExports.inputTypes.DUMMY && J.hasDummyInput && J.align === coreBrowserExports.ALIGN_LEFT && X.align === coreBrowserExports.ALIGN_RIGHT && (J.rightAlignedDummyInput = X),
        this.isInline && X.type === coreBrowserExports.inputTypes.VALUE ? (J.elements.push(new PortalInlineInput(this.constants_,X)),
        J.hasInlineInput = !0) : X.type === coreBrowserExports.inputTypes.STATEMENT ? (J.elements.push(new coreBrowserExports.blockRendering.StatementInput(this.constants_,X)),
        J.hasStatement = !0) : X.type === coreBrowserExports.inputTypes.VALUE ? (J.elements.push(new coreBrowserExports.blockRendering.ExternalValueInput(this.constants_,X)),
        J.hasExternalInput = !0) : X.type === coreBrowserExports.inputTypes.DUMMY && (J.minHeight = Math.max(J.minHeight, X.getSourceBlock() && X.getSourceBlock().isShadow() ? this.constants_.DUMMY_INPUT_SHADOW_MIN_HEIGHT : this.constants_.DUMMY_INPUT_MIN_HEIGHT),
        J.hasDummyInput = !0),
        J.align === null && (J.align = X.align)
    }
    getInRowSpacing_(X, J) {
        return (!X || !J) && this.outputConnection && this.outputConnection.isDynamicShape && !this.hasStatementInput && !this.bottomRow.hasNextConnection ? this.constants_.NO_PADDING : X ? X && coreBrowserExports.blockRendering.Types.isLeftRoundedCorner(X) && J && (coreBrowserExports.blockRendering.Types.isPreviousConnection(J) || coreBrowserExports.blockRendering.Types.isNextConnection(J)) ? J.notchOffset - this.constants_.CORNER_RADIUS : X && coreBrowserExports.blockRendering.Types.isLeftSquareCorner(X) && J && coreBrowserExports.blockRendering.Types.isHat(J) ? this.constants_.NO_PADDING : this.constants_.MEDIUM_LARGE_PADDING : J && coreBrowserExports.blockRendering.Types.isStatementInput(J) ? this.constants_.STATEMENT_INPUT_PADDING_LEFT : this.constants_.MEDIUM_PADDING
    }
}
class PortalPathObject extends coreBrowserExports.zelos.PathObject {
    constructor(J, ne, ue) {
        super(J, ne, ue);
        Tt(this, "svgPathHighlighted", null);
        Tt(this, "svgPathHighlightedWarning", null);
        Tt(this, "svgOutputConnectionIndicator", null);
        Tt(this, "portalConstants", this.constants);
        Tt(this, "statementConnectorIndicator");
        Tt(this, "valueInputIconIndicator");
        coreBrowserExports.utils.dom.addClass(this.svgPath, "blocklyBlockBackground"),
        this.statementConnectorIndicator = new Map,
        this.valueInputIconIndicator = new Map
    }
    setPath(J) {
        super.setPath(J),
        this.svgPathHighlighted && this.svgPathHighlighted.setAttribute("d", J),
        this.svgPathHighlightedWarning && this.svgPathHighlightedWarning.setAttribute("d", J)
    }
    updateDisabled(J) {
        this.setClass_("blocklyDisabled", J),
        J && this.portalConstants.getStyleManager().applyStyle(this.svgPath, StyleType.Disabled)
    }
    updateError(J) {
        this.setClass_("blocklyError", J),
        J && this.portalConstants.getStyleManager().applyStyle(this.svgPath, StyleType.Error)
    }
    applyColour(J) {
        var ue;
        this.svgPath.setAttribute("stroke", this.style.colourTertiary),
        this.svgPath.setAttribute("fill", this.style.colourPrimary),
        this.svgPath.setAttribute("stroke-width", `${this.portalConstants.BLOCK_OUTLINE_STROKE_WIDTH}px`),
        this.updateShadow_(J.isShadow()),
        this.updateDisabled(!J.isEnabled() || J.getInheritedDisabled());
        const ne = J.type.includes("missingValueBlockType") || J.type.includes("missingActionBlockType");
        this.updateError(ne);
        for (let ce = 0, me = Object.keys(this.outlines), ge; ge = me[ce]; ce++)
            (ue = this.outlines.get(ge)) == null || ue.setAttribute("fill", this.style.colourSecondary);
        if (J.isShadow() && J.getParent()) {
            const ce = J.getParent().style.colourTertiary
              , me = coreBrowserExports.utils.colour.hexToRgb(ce);
            BlocklyColors.luminance(me) < .15 ? this.svgPath.setAttribute("stroke", BlocklyColors.lighten(ce, .3)) : this.svgPath.setAttribute("stroke", J.getParent().style.colourTertiary)
        }
    }
    setOutlinePath(J, ne) {
        const ue = this.getOutlinePath_(J);
        ue.setAttribute("d", ne),
        ue.setAttribute("stroke", this.style.colourTertiary),
        ue.setAttribute("fill", this.style.colourSecondary)
    }
    updateHighlighted(J) {
        this.setClass_("blocklyHighlighted", J),
        J ? this.svgPathHighlighted || (this.svgPathHighlighted = this.svgPath.cloneNode(!0),
        this.svgPathHighlighted.setAttribute("fill", "none"),
        this.svgPathHighlighted.setAttribute("filter", "url(#" + this.portalConstants.highlightedGlowFilterId + ")"),
        this.svgRoot.appendChild(this.svgPathHighlighted)) : this.svgPathHighlighted && (this.svgRoot.removeChild(this.svgPathHighlighted),
        this.svgPathHighlighted = null)
    }
    updateHighlightedWarning(J) {
        this.setClass_("blocklyHighlightedWarning", J),
        J ? this.svgPathHighlightedWarning || (this.svgPathHighlightedWarning = this.svgPath.cloneNode(!0),
        this.svgPathHighlightedWarning.setAttribute("fill", "none"),
        this.svgPathHighlightedWarning.setAttribute("filter", "url(#" + this.portalConstants.warningGlowFilterId + ")"),
        this.svgRoot.appendChild(this.svgPathHighlightedWarning)) : this.svgPathHighlightedWarning && (this.svgRoot.removeChild(this.svgPathHighlightedWarning),
        this.svgPathHighlightedWarning = null)
    }
    updateSelected(J) {
        if (super.updateSelected(J),
        J && (this.svgOutputConnectionIndicator && (this.svgRoot.removeChild(this.svgOutputConnectionIndicator),
        this.svgRoot.appendChild(this.svgOutputConnectionIndicator)),
        this.statementConnectorIndicator))
            for (const ne of this.statementConnectorIndicator)
                ne[1] && (this.svgRoot.removeChild(ne[1]),
                this.svgRoot.appendChild(ne[1]))
    }
    positionConnectionIndicator(J, ne) {
        var ue;
        this.svgOutputConnectionIndicator || (this.svgOutputConnectionIndicator = coreBrowserExports.utils.dom.createSvgElement("g", {
            class: "blocklyConnectionIndicator"
        }),
        this.svgOutputConnectionIndicator && (this.svgRoot.appendChild(this.svgOutputConnectionIndicator),
        coreBrowserExports.utils.dom.createSvgElement("circle", {
            r: this.portalConstants.CONNECTION_INDICATOR_RADIUS
        }, this.svgOutputConnectionIndicator))),
        (ue = this.svgOutputConnectionIndicator) == null || ue.setAttribute("transform", this.translate(J, ne))
    }
    getOutlinePath_(J) {
        return this.outlines.get(J) || this.outlines.set(J, coreBrowserExports.utils.dom.createSvgElement(coreBrowserExports.utils.Svg.PATH, {
            class: "blocklyOutlinePath",
            d: ""
        }, this.svgRoot)),
        this.remainingOutlines.delete(J),
        this.outlines.get(J)
    }
    clearStatementConnectors() {
        for (const J of this.statementConnectorIndicator)
            J[1] && this.svgRoot.removeChild(J[1]);
        this.statementConnectorIndicator.clear()
    }
    positionStatementInputConnections(J) {
        var ue;
        const ne = J.input;
        if (ne.connection && ne.connection.type === coreBrowserExports.ConnectionType.NEXT_STATEMENT) {
            const ce = J.xPos
              , me = J.centerline;
            let ge = (ue = ne.connection) == null ? void 0 : ue.targetBlock();
            if (ge) {
                let Te = ne.connection
                  , _e = Te.getOffsetInBlock().y;
                do {
                    let Se = this.statementConnectorIndicator.get(ge);
                    const Ie = Te.getCheck();
                    !Se && Ie && (Se = this.createStatementConnectionShape(Ie),
                    this.statementConnectorIndicator.set(ge, Se)),
                    Se == null || Se.setAttribute("transform", this.translate(ce, _e + ge.height / 2)),
                    Te = ge.nextConnection,
                    ge = Te ? Te.targetBlock() : null,
                    _e += Te.getOffsetInBlock().y
                } while (ge !== null)
            } else {
                const _e = ne.connection.getCheck();
                if (_e) {
                    const Se = this.createStatementConnectionShape(_e);
                    this.statementConnectorIndicator.set(0, Se),
                    Se == null || Se.setAttribute("transform", this.translate(ce, me))
                }
            }
        }
    }
    positionStatementOutputConnection(J, ne, ue) {
        if (J) {
            const ce = J.nextConnection;
            if (!this.statementConnectorIndicator.get(J)) {
                const ge = this.createStatementConnectionShape(ce == null ? void 0 : ce.getCheck());
                ge && this.statementConnectorIndicator.set(J, ge)
            }
            const me = this.statementConnectorIndicator.get(J);
            me && me.setAttribute("transform", this.translate(ne, ue))
        }
    }
    createStatementConnectionShape(J) {
        const ne = coreBrowserExports.utils.dom.createSvgElement("g", {
            class: "blocklyStatementConnectionIndicator"
        });
        if (ne) {
            const ue = this.portalConstants.CONNECTION_INDICATOR_RADIUS + this.portalConstants.BLOCK_OUTLINE_STROKE_WIDTH;
            if (coreBrowserExports.utils.dom.createSvgElement(coreBrowserExports.utils.Svg.POLYGON, {
                points: "0,x -x,0 0,-x x,0".replace(/x/g, ue.toString())
            }, ne),
            coreBrowserExports.utils.dom.createSvgElement(coreBrowserExports.utils.Svg.POLYGON, {
                points: "0,x -x,0 0,-x x,0".replace(/x/g, this.portalConstants.CONNECTION_INDICATOR_RADIUS.toString())
            }, ne),
            this.svgRoot.appendChild(ne),
            J)
                for (const ce of J)
                    ce && ne.classList.add(ce.toString())
        }
        return ne
    }
    clearInputIconIndicators() {
        this.valueInputIconIndicator.forEach( (J, ne) => {
            J && this.svgRoot.removeChild(J),
            this.valueInputIconIndicator.delete(ne)
        }
        )
    }
    setValueInputPath(J) {
        const ne = J.input;
        if (!J.connectionModel.targetConnection) {
            const ce = coreBrowserExports.utils.dom.createSvgElement("g", {
                class: "blocklyValueIcon"
            })
              , me = J.height / 1.3
              , ge = this.portalConstants.INPUT_VALUE_TYPE_ICON_MAX_SIZE
              , Te = me > ge ? ge : me;
            let _e = J.connectionModel.getCheck() ?? [];
            if (_e.length > this.portalConstants.INPUT_VALUE_TYPE_ICON_MAX_COUNT && (_e = ["any"]),
            _e) {
                const Se = _e.length * Te + (_e.length - 1) * this.portalConstants.INPUT_VALUE_TYPE_ICON_MARGIN;
                let Ie = J.width / 2 - Se / 2;
                isLanguageRTL() && (Ie += Te);
                for (const ye of _e)
                    if (ye) {
                        const $e = coreBrowserExports.utils.dom.createSvgElement(coreBrowserExports.utils.Svg.IMAGE, {
                            height: Te + "px",
                            width: Te + "px",
                            alt: ""
                        }, ce);
                        $e.setAttributeNS(coreBrowserExports.utils.dom.XLINK_NS, "xlink:href", getIconPathForBlocklyType(ye)),
                        $e.setAttribute("transform", this.translate(Ie, -Te / 2)),
                        Ie += Te + this.portalConstants.INPUT_VALUE_TYPE_ICON_MARGIN
                    }
            }
            this.svgRoot.appendChild(ce),
            this.valueInputIconIndicator.set(ne.name, ce)
        }
        const ue = this.valueInputIconIndicator.get(ne.name);
        ue && ue.setAttribute("transform", this.translate(J.xPos, J.centerline))
    }
    translate(J, ne) {
        return isLanguageRTL() ? `translate(-${J},${ne})` : `translate(${J},${ne})`
    }
}
class PortalRenderer extends coreBrowserExports.zelos.Renderer {
    constructor(X) {
        super(X)
    }
    init(X, J) {
        super.init(X, J)
    }
    makePathObject(X, J) {
        return new PortalPathObject(X,J,this.getConstants())
    }
    makeConstants_() {
        return new PortalConstantProvider
    }
    makeRenderInfo_(X) {
        return new PortalRenderInfo(this,X)
    }
    makeDrawer_(X, J) {
        return new PortalDrawer(X,J)
    }
    shouldInsertDraggedBlock(X, J) {
        return !1
    }
}
coreBrowserExports.blockRendering.register("portal", PortalRenderer);
const portalDarkComponentStyle = {
    workspaceBackgroundColour: "rgba(0, 0, 0, 0)",
    toolboxBackgroundColour: "rgba(30, 39, 40, 0.8)",
    toolboxForegroundColour: "#ffffff",
    flyoutBackgroundColour: "#0a0a0a",
    flyoutForegroundColour: "#ffffff",
    flyoutOpacity: 1,
    scrollbarColour: "#ffffff",
    scrollbarOpacity: .05,
    insertionMarkerColour: "#aec0cc",
    insertionMarkerOpacity: .3,
    markerColour: "#d0d0d0",
    cursorColour: "#d0d0d0",
    selectedGlowColour: "#aec0cc",
    selectedGlowOpacity: 1,
    replacementGlowColour: "#aec0cc",
    replacementGlowOpacity: .5,
    fieldBorderRectColor: "#a8a8a8",
    fieldTextColor: "#000000",
    fieldDropdownTextColor: "#ffffff",
    fieldDropDownHighlightColor: "#aec0cc",
    fieldDropDownTextHighlightColor: "#000000",
    fieldEditableTextHoverColor: "#aec0cc",
    wsSearchHighlightCurrentColor: "#aec0cc",
    wsSearchHighlightGroupColor: "#ffffff",
    blockDisablePatternFillColor: "rgba(20,20,20,0.66)",
    blockDisablePatternStrokeColor: "#4f4f4f",
    blockErrorPatternFillColor: "#141414",
    blockErrorPatternStrokeColor: "#aa2b3f",
    blockErrorHighlightStrokeColor: "#ff2b3f",
    blockDeprecatedPatternFillColor: "#383629",
    blockDeprecatedPatternStrokeColor: "#a6aa2b",
    blockDeprecatedHighlightStrokeColor: "#ffe32b",
    ruleBlockRuleTextColor: "#ffffff",
    ruleBlockRuleConnectionColor: "#e882ff",
    ruleBlockConditionTextColor: "#ffffff",
    ruleBlockConditionConnectionColor: "#0a4f78",
    ruleBlockActionTextColor: "#ffffff",
    ruleBlockActionConnectionColor: "#b7a11c",
    subroutineBlockSubroutineTextColor: "#ed7f33",
    rulesCategoryColor: "#b45ac7",
    subroutinesCategoryColor: "#8a4211",
    valuesCategoryColor: "#1d8c58",
    actionsCategoryColor: "#b7a11c",
    controlsCategoryColor: "#2a90d0"
}
  , portalDarkBlockStyles = {}
  , modBlockStyleDark = {
    colourPrimary: "#222b2d",
    colourSecondary: "#0a0a0a",
    colourTertiary: "#161d1e",
    hat: "false"
}
  , ruleBlockStyleDark = {
    colourPrimary: "#682177",
    colourSecondary: "#0a0a0a",
    colourTertiary: "#390f42",
    hat: "false"
}
  , conditionBlockStyleDark = {
    colourPrimary: "#0a4f78",
    colourSecondary: "#0a0a0a",
    colourTertiary: "#003a5d",
    hat: "false"
}
  , valueBlockStyle = {
    colourPrimary: "#0f5736",
    colourSecondary: "#0a0a0a",
    colourTertiary: "#033d23",
    hat: "false"
}
  , actionBlockStyle = {
    colourPrimary: "#847000",
    colourSecondary: "#0a0a0a",
    colourTertiary: "#493e00",
    hat: "false"
}
  , commentBlockStyle = {
    colourPrimary: "#141414",
    colourSecondary: "#0a0a0a",
    colourTertiary: "#141414",
    hat: "false"
}
  , variableBlockStyle = {
    colourPrimary: "#0f5736",
    colourSecondary: "#0a0a0a",
    colourTertiary: "#033d23",
    hat: "false"
}
  , subroutineBlockStyle = {
    colourPrimary: "#622c07",
    colourSecondary: "#0a0a0a",
    colourTertiary: "#461e02",
    hat: "false"
}
  , controlBlocksStyle = {
    colourPrimary: "#351f95",
    colourSecondary: "#0a0a0a",
    colourTertiary: "#351f95",
    hat: "false"
}
  , controlBlocksAltStyle = {
    colourPrimary: "#2b1b71",
    colourSecondary: "#0a0a0a",
    colourTertiary: "#2b1b71",
    hat: "false"
}
  , unsupportedValueBlockStyle = {
    colourPrimary: "#262626",
    colourSecondary: "#0a0a0a",
    colourTertiary: "#ff0000",
    hat: "false"
};
portalDarkBlockStyles["mod-block-style"] = modBlockStyleDark;
portalDarkBlockStyles["rule-block-style"] = ruleBlockStyleDark;
portalDarkBlockStyles["condition-block-style"] = conditionBlockStyleDark;
portalDarkBlockStyles["value-block-style"] = valueBlockStyle;
portalDarkBlockStyles["action-block-style"] = actionBlockStyle;
portalDarkBlockStyles["comment-block-style"] = commentBlockStyle;
portalDarkBlockStyles["variable-block-style"] = variableBlockStyle;
portalDarkBlockStyles["subroutine-block-style"] = subroutineBlockStyle;
portalDarkBlockStyles["control-block-style"] = controlBlocksStyle;
portalDarkBlockStyles["control-block-alt-style"] = controlBlocksAltStyle;
portalDarkBlockStyles["unsupported-value-block-style"] = unsupportedValueBlockStyle;
const portalDarkCategoryStyles = {
    "rules-category": {
        colour: "#b45ac7"
    },
    "values-category": {
        colour: "#1d8c58"
    },
    "subroutines-category": {
        colour: "#bd6222"
    },
    "actions-category": {
        colour: "#b7a11c"
    },
    "controls-category": {
        colour: "#5939e6"
    }
};
coreBrowserExports.Theme.defineTheme("portal-dark", {
    base: coreBrowserExports.Theme.Classic,
    componentStyles: portalDarkComponentStyle,
    blockStyles: portalDarkBlockStyles,
    categoryStyles: portalDarkCategoryStyles,
    name: "portal-dark"
});
Blockly.setLocale(BlocklyLocalePlaceholders);
Blockly.VerticalFlyout.prototype.getFlyoutScale = () => 1;
setBlocklyAssetPathFunc(getAssetPath);
Blockly.Tooltip.HOVER_MS = 100;
Blockly.config.snapRadius = 48;
Blockly.config.connectingSnapRadius = 96;
Blockly.InsertionMarkerManager = CustomInsertionMarkerManager;
Blockly.ContextMenuRegistry.registry.unregister("collapseWorkspace");
Blockly.ContextMenuRegistry.registry.unregister("expandWorkspace");
Blockly.ContextMenuRegistry.registry.unregister("blockCollapseExpand");
Blockly.ContextMenuRegistry.registry.unregister("blockInline");
Blockly.ContextMenuRegistry.registry.unregister("blockComment");
Blockly.ContextMenuRegistry.registry.unregister("blockDisable");
Blockly.icons.WarningIcon.prototype.drawIcon_ = function(V) {
    Blockly.utils.dom.createSvgElement(Blockly.utils.Svg.PATH, {
        fill: "#fff",
        d: "M16,1.9L0.3,30.1h31.4L16,1.9z M18,28.2h-4v-4h4V28.2z M14,22.2v-12h4v12H14z",
        transform: "scale(0.5)"
    }, V)
}
;
window._Blockly = Blockly;
const logger$5 = Logger$1.get("RulesEditor")
  , RulesEditorPage = () => {
    var xt, Vt;
    const [V,X] = useAtom(workspaceAtom)
      , J = useAtomValue(isOwnerAtom)
      , ne = useAtomValue(nameAtom)
      , ue = reactExports.useRef(null)
      , {blueprint: ce} = reactExports.useContext(BlueprintContext)
      , {colors: me, spacings: ge} = reactExports.useContext(ThemeContext)
      , {t: Te} = useTranslation()
      , {open: _e, close: Se, dialogRef: Ie} = useDialog(DIALOG_ID.RULES_EDITOR_CREATE_SUBROUTINE)
      , {open: ye} = useDialog(DIALOG_ID.RULES_EDITOR_CONFIRM_DELETE_SUBROUTINE)
      , {open: $e} = useDialog(DIALOG_ID.IMPORT_WORKSPACE)
      , {open: Ne, close: ve} = useDialog(DIALOG_ID.RULES_EDITOR_MANAGE_VARIABLES)
      , {open: ke} = useDialog(DIALOG_ID.EXPORT_WORKSPACE_DIALOG);
    useDialog(DIALOG_ID.EXPORT_MOD_DIALOG);
    const {open: xe} = useOffCanvas(DIALOG_ID.RULES_EDITOR_HELP_PANEL)
      , {open: we} = useDialog(DIALOG_ID.BLOCK_TO_SCRIPT_EXPORT)
      , {open: Fe} = useDialog(DIALOG_ID.RULES_EDITOR_CONFIRM_RESET_WORKSPACE)
      , [je,Xe] = reactExports.useState("")
      , [ze,qe] = reactExports.useState([])
      , [Ze,et] = reactExports.useState({})
      , [it,at] = reactExports.useState("")
      , [rt,ft] = reactExports.useState("")
      , [St,Ye] = reactExports.useState("")
      , [We,nt] = reactExports.useState("")
      , [ct,Et] = reactExports.useState(0)
      , [Ke,mt] = reactExports.useState(void 0)
      , lt = useAtomValue(primaryNavIsCollapsed)
      , [Qe,gt] = reactExports.useState("")
      , [Nt,Gt] = reactExports.useState()
      , [Ht,Kt] = reactExports.useState("")
      , [Ot,kt] = reactExports.useState(0)
      , [Xt,vt] = reactExports.useState("")
      , [Jt,Ct] = reactExports.useState("json")
      , Mt = `${(new Blob([Xt]).size / 1024).toFixed(2)}kb`
      , [nn,tn] = reactExports.useState()
      , mn = () => {
        Gt(void 0),
        Kt(""),
        kt(0)
    }
      , dn = Pt => {
        const qt = Pt.block;
        qt != null && qt.type && (mt(qt.type),
        xe(!0))
    }
      , Qt = () => {
        Xe(""),
        _e()
    }
      , on = Pt => {
        logger$5.debug("Delete variable", Pt)
    }
      , zt = Pt => {
        logger$5.debug("Rename variable", Pt)
    }
      , $t = (Pt, qt) => {
        Et(Pt),
        nt(qt),
        ye()
    }
      , Ut = Pt => {
        X({
            mod: {
                ...Pt
            }
        })
    }
      , An = Pt => {
        Xe(Pt),
        _e()
    }
      , yt = (Pt, qt) => {
        qe([...qt]),
        et(Pt),
        logger$5.debug("setVariableObjectTypes", qt),
        Ne()
    }
      , {subroutineManager: Dt, variableManager: Bt, loadRules: Wt, isMounted: ut, getSerializedWorkspace: Ge, getWorkspaceExport: st, getVariables: ht, blocklyInstance: At, resizeBlocklyWorkspace: Ft} = usePyriteBlockly({
        mount: ue,
        rulesVersion: (ce == null ? void 0 : ce.rulesVersion) ?? 0,
        definitions: ce == null ? void 0 : ce.blocklyDefinitions,
        onContextMenuHelp: dn,
        onNewSubroutine: Qt,
        onConfirmDeleteSubroutine: $t,
        onRenameSubroutine: An,
        onManageVariables: yt,
        onRenameVariable: zt,
        onDeleteVariable: on,
        onChange: Ut
    });
    ut && Wt(V);
    const an = () => {
        const Pt = Ge();
        Pt ? (gt(`${sanitizeFilename(ne)}_workspace.json`),
        vt(JSON.stringify({
            mod: Pt
        })),
        Ct("json"),
        ke()) : logger$5.warn("There is no available workspace to export")
    }
      , Sn = () => {
        downloadFile(Qe, Xt)
    }
      , Rn = Pt => {
        if (Pt.endsWith(".json")) {
            Ct("json");
            const qt = Ge();
            vt(JSON.stringify({
                mod: qt
            }))
        }
        gt(Pt)
    }
      , ts = () => {
        mn(),
        $e()
    }
      , yn = () => {
        loadFile( (Pt, qt, rn) => {
            var un, fn, On, Hn;
            if (typeof ((un = Pt.target) == null ? void 0 : un.result) == "string")
                try {
                    const Kn = (fn = Pt.target) != null && fn.result.startsWith("<") ? (On = Pt.target) == null ? void 0 : On.result : JSON.parse((Hn = Pt.target) == null ? void 0 : Hn.result);
                    logger$5.debug("modRules JSON file import", Kn),
                    Gt(Kn),
                    Kt(qt ?? ""),
                    kt(rn ?? 0)
                } catch (Kn) {
                    logger$5.error("Failed to import workspace", Kn)
                }
        }
        , ["application/json"])
    }
      , xn = () => {
        Wt(Nt, !0)
    }
      , En = (Pt, qt) => {
        var rn, un;
        if ((un = (rn = At == null ? void 0 : At.subroutinesManager) == null ? void 0 : rn.subroutines) != null && un.find(fn => fn === Pt)) {
            tn(Te("rules.variable-already-exists"));
            return
        }
        Dt.create(Pt, qt),
        Se(),
        tn(void 0)
    }
      , wn = (Pt, qt) => {
        var rn, un;
        if ((un = (rn = At == null ? void 0 : At.subroutinesManager) == null ? void 0 : rn.subroutines) != null && un.find(fn => fn === qt)) {
            tn(Te("rules.variable-already-exists"));
            return
        }
        Dt.rename(Pt, qt),
        Se(),
        tn(void 0)
    }
      , Qn = (Pt, qt) => {
        Bt.create(Pt, qt),
        et({
            ...ht(ze)
        })
    }
      , pr = Pt => {
        Bt.delete(Pt),
        et({
            ...ht(ze)
        }),
        Ne()
    }
      , ar = Pt => {
        Bt.rename(Pt, rt),
        et({
            ...ht(ze)
        })
    }
      , _t = () => {
        we()
    }
      , Be = Pt => {
        gt(Pt)
    }
      , Je = () => {
        mn()
    }
      , ot = () => {
        At == null || At.mainWorkspace.clear(),
        At == null || At.loadDefault()
    }
      , pt = Pt => {
        const qt = Qe.replace(/(\.json$)/, `.${Pt}`);
        Rn(qt),
        Ct(Pt)
    }
    ;
    return reactExports.useEffect( () => {
        Ft()
    }
    , [lt, Ft]),
    jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsx(ExperienceHeading, {
            heading: Te("general.rules-editor"),
            subheading: Te("general.blocks"),
            title: Te("general.create-rules")
        }), jsxRuntimeExports.jsx("div", {
            className: styles$b.rulesButtons,
            children: jsxRuntimeExports.jsxs(ButtonGroup, {
                className: styles$b.rulesButtonGroup,
                children: [jsxRuntimeExports.jsx(Tooltip, {
                    tip: "Export to Script",
                    children: jsxRuntimeExports.jsx(IconButton, {
                        variant: ICON_BUTTON_VARIANT.TRANSPARENT,
                        size: ICON_BUTTON_SIZE.SM,
                        icon: ICON_NAMES.DOWNLOAD,
                        onClick: _t,
                        testId: TEST_ID.WORKSPACE_EXPORT_CONVERTED_SCRIPT_BUTTON
                    })
                }), jsxRuntimeExports.jsx(Tooltip, {
                    tip: Te("rules.export-workspace"),
                    children: jsxRuntimeExports.jsx(IconButton, {
                        variant: ICON_BUTTON_VARIANT.TRANSPARENT,
                        size: ICON_BUTTON_SIZE.SM,
                        icon: ICON_NAMES.EXPORT,
                        onClick: an,
                        testId: TEST_ID.WORKSPACE_EXPORT_BUTTON
                    })
                }), J && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                    children: [jsxRuntimeExports.jsx(Tooltip, {
                        tip: Te("rules.import-workspace"),
                        children: jsxRuntimeExports.jsx(IconButton, {
                            variant: ICON_BUTTON_VARIANT.TRANSPARENT,
                            size: ICON_BUTTON_SIZE.SM,
                            icon: ICON_NAMES.IMPORT,
                            onClick: ts,
                            testId: TEST_ID.WORKSPACE_IMPORT_BUTTON
                        })
                    }), jsxRuntimeExports.jsx(Tooltip, {
                        tip: Te("rules.reset-workspace"),
                        children: jsxRuntimeExports.jsx(IconButton, {
                            variant: ICON_BUTTON_VARIANT.TRANSPARENT,
                            size: ICON_BUTTON_SIZE.SM,
                            icon: ICON_NAMES.RESET,
                            onClick: Fe,
                            testId: TEST_ID.WORKSPACE_RESET
                        })
                    })]
                })]
            })
        }), jsxRuntimeExports.jsx("div", {
            className: styles$b.notSupportedTakeOver,
            children: jsxRuntimeExports.jsx(PromptBox, {
                children: jsxRuntimeExports.jsx(Well, {
                    children: jsxRuntimeExports.jsx(Heading, {
                        variant: HEADING_VARIANT.SECONDARY_SUBHEADING,
                        children: Te("general.rules-editor-not-available-at-screen-size")
                    })
                })
            })
        }), jsxRuntimeExports.jsx("div", {
            className: common_utils.classNames(styles$b.blocklyContainer, "blockly"),
            ref: ue
        }), Ke ? jsxRuntimeExports.jsx(BlocklyHelp, {
            blockType: Ke,
            pyriteBlockly: At
        }) : null, VITE_ENVIRONMENT !== "production", jsxRuntimeExports.jsx(SubroutineDialog, {
            parameterTypes: ((Vt = (xt = At == null ? void 0 : At.subroutinesManager) == null ? void 0 : xt.definitions) == null ? void 0 : Vt.types) ?? [],
            editingSubroutineName: je,
            onCreateSubroutine: En,
            onRenameSubroutine: wn,
            dialogRef: Ie,
            nameFieldError: nn
        }), jsxRuntimeExports.jsx(ManageVariablesDialog, {
            workspace: At == null ? void 0 : At.mainWorkspace,
            variablesManager: At == null ? void 0 : At.variablesManager,
            variables: Ze,
            createVariableCallback: Qn,
            deleteVariableCallback: pr,
            renameVariableCallback: ar,
            setEditingIdCallback: ft,
            editingName: it,
            setEditingNameCallback: at,
            editingType: St,
            setEditingTypeCallback: Ye,
            objectTypes: ze,
            closeCallback: ve
        }), jsxRuntimeExports.jsx(DialogContent, {
            id: DIALOG_ID.RULES_EDITOR_CONFIRM_DELETE_SUBROUTINE,
            header: Te("rules.delete-subroutine"),
            footer: jsxRuntimeExports.jsxs(ButtonGroup, {
                fillWidth: !0,
                children: [jsxRuntimeExports.jsx(Button, {
                    fillWidth: !0,
                    variant: BUTTON_VARIANTS.SECONDARY,
                    type: BUTTON_TYPES.SUBMIT,
                    children: Te("general.cancel")
                }), jsxRuntimeExports.jsx(Button, {
                    fillWidth: !0,
                    color: me.primary,
                    type: BUTTON_TYPES.SUBMIT,
                    onClick: Dt.delete,
                    children: Te("general.confirm")
                })]
            }),
            children: Te("rules.delete-subroutine-confirm", {
                nr: ct,
                name: We
            })
        }), jsxRuntimeExports.jsxs(DialogContent, {
            id: DIALOG_ID.EXPORT_WORKSPACE_DIALOG,
            header: Te("rules.export-workspace"),
            footer: jsxRuntimeExports.jsxs(ButtonGroup, {
                fillWidth: !0,
                children: [jsxRuntimeExports.jsx(Button, {
                    fillWidth: !0,
                    color: me.primary,
                    type: BUTTON_TYPES.SUBMIT,
                    onClick: Sn,
                    isDisabled: !Qe.trim().endsWith(".json"),
                    children: "Export"
                }), jsxRuntimeExports.jsx(Button, {
                    fillWidth: !0,
                    variant: BUTTON_VARIANTS.SECONDARY,
                    type: BUTTON_TYPES.SUBMIT,
                    children: Te("general.cancel")
                })]
            }),
            children: [jsxRuntimeExports.jsx(TextInput, {
                label: Te("rules.export-workspace"),
                placeholder: "File Name",
                value: Qe,
                onChange: Rn,
                fillWidth: !0
            }), jsxRuntimeExports.jsxs("div", {
                className: styles$b.caption,
                children: [jsxRuntimeExports.jsx(Caption, {
                    children: Mt
                }), jsxRuntimeExports.jsxs(Caption, {
                    children: [Te("general.format"), ": .json"]
                })]
            }), jsxRuntimeExports.jsx(Radio, {
                name: "exportFormat",
                onChange: pt,
                options: [{
                    label: "JSON",
                    value: "json"
                }],
                value: Jt
            })]
        }), jsxRuntimeExports.jsxs(DialogContent, {
            id: DIALOG_ID.EXPORT_MOD_DIALOG,
            header: Te("rules.export-mod"),
            footer: jsxRuntimeExports.jsxs(ButtonGroup, {
                fillWidth: !0,
                children: [jsxRuntimeExports.jsx(Button, {
                    fillWidth: !0,
                    color: me.primary,
                    type: BUTTON_TYPES.SUBMIT,
                    onClick: Sn,
                    isDisabled: !Qe.trim().endsWith(".json"),
                    children: Te("general.export")
                }), jsxRuntimeExports.jsx(Button, {
                    fillWidth: !0,
                    variant: BUTTON_VARIANTS.SECONDARY,
                    type: BUTTON_TYPES.SUBMIT,
                    children: Te("general.cancel")
                })]
            }),
            children: [jsxRuntimeExports.jsx(TextInput, {
                label: Te("rules.export-mod"),
                placeholder: Te("general.filename"),
                value: Qe,
                onChange: Be,
                fillWidth: !0
            }), jsxRuntimeExports.jsxs("div", {
                className: styles$b.caption,
                children: [jsxRuntimeExports.jsx(Caption, {
                    children: Mt
                }), jsxRuntimeExports.jsxs(Caption, {
                    children: [Te("general.format"), ": .json"]
                })]
            })]
        }), jsxRuntimeExports.jsxs(DialogContent, {
            id: DIALOG_ID.IMPORT_WORKSPACE,
            header: Te("rules.import-workspace"),
            footer: jsxRuntimeExports.jsxs(ButtonGroup, {
                fillWidth: !0,
                children: [jsxRuntimeExports.jsx(Button, {
                    fillWidth: !0,
                    color: me.primary,
                    type: BUTTON_TYPES.SUBMIT,
                    onClick: xn,
                    children: Te("general.import")
                }), jsxRuntimeExports.jsx(Button, {
                    fillWidth: !0,
                    variant: BUTTON_VARIANTS.SECONDARY,
                    type: BUTTON_TYPES.SUBMIT,
                    children: Te("general.cancel")
                })]
            }),
            children: [jsxRuntimeExports.jsx(ButtonGroup, {
                fillWidth: !0,
                gap: ge.xxs,
                children: jsxRuntimeExports.jsx(TextInput, {
                    label: Te("general.import-file"),
                    placeholder: Te("general.load-file"),
                    value: Ht,
                    action: {
                        text: Te(Ht ? "general.cancel-current-workspace-import" : "general.select-file"),
                        onClick: Ht ? Je : yn,
                        icon: Ht ? ICON_NAMES.TRASH : ICON_NAMES.FOLDER,
                        iconOnly: !0
                    },
                    fillWidth: !0,
                    readOnly: !0
                })
            }), jsxRuntimeExports.jsxs("div", {
                className: styles$b.caption,
                children: [jsxRuntimeExports.jsxs(Caption, {
                    children: [(Ot / 1024).toFixed(2), "kb"]
                }), jsxRuntimeExports.jsxs(Caption, {
                    children: [Te("general.format"), ": .json"]
                })]
            })]
        }), jsxRuntimeExports.jsx(DialogContent, {
            id: DIALOG_ID.RULES_EDITOR_CONFIRM_RESET_WORKSPACE,
            header: Te("rules.reset-workspace"),
            footer: jsxRuntimeExports.jsxs(ButtonGroup, {
                fillWidth: !0,
                children: [jsxRuntimeExports.jsx(Button, {
                    fillWidth: !0,
                    variant: BUTTON_VARIANTS.SECONDARY,
                    type: BUTTON_TYPES.SUBMIT,
                    children: Te("general.cancel")
                }), jsxRuntimeExports.jsx(Button, {
                    fillWidth: !0,
                    color: me.primary,
                    type: BUTTON_TYPES.SUBMIT,
                    onClick: ot,
                    children: Te("general.confirm")
                })]
            }),
            children: Te("rules.reset-workspace-confirm")
        }), jsxRuntimeExports.jsx(GenerateScriptDialog, {
            dialogId: DIALOG_ID.BLOCK_TO_SCRIPT_EXPORT,
            exportWorkspaceFn: st
        })]
    })
}
  , modlib = `// export * from './store';

export function Concat(s1: string, s2: string) {
    return s1 + s2;
}

export function Add(a: number, b: number) {
    return a + b;
}

export function And(...rest: boolean[]): boolean {
    for (let i = 0; i < rest.length; i++) {
        const cond = rest[i];
        if (!cond) return false;
    }
    return true;
}

type ConditionFunction = () => boolean;

export function AndFn(...rest: ConditionFunction[]): boolean {
    for (let i = 0; i < rest.length; i++) {
        const condFn = rest[i];
        if (!condFn()) return false;
    }
    return true;
}

export function EnableVFX(vfx: mod.VFX, arg1: number, arg3: boolean, pos: mod.Vector) {
    mod.EnableVFX(vfx, arg3);
}

export function GetGameModeTimeElapsed() {
    return mod.GetRoundTime();
}

export function Skip(number: number) {
    console.log('Skip: fix me');
}

export function SkipIf(number: number, b: boolean) {
    console.log('SkipIf: fix me');
}

export function getPlayerId(player: mod.Player): number {
    return mod.GetObjId(player);
}

export function getTeamId(team: mod.Team): number {
    return mod.GetObjId(team);
}

export function ConvertArray(array: mod.Array): any[] {
    let v = [];
    let n = mod.CountOf(array);
    for (let i = 0; i < n; i++) {
        let currentElement = mod.ValueInArray(array, i);
        v.push(currentElement);
    }
    return v;
}

export function FilteredArray(array: mod.Array, cond: (currentElement: any) => boolean): mod.Array {
    const arr = ConvertArray(array);
    let v = mod.EmptyArray();
    let n = arr.length;
    for (let i = 0; i < n; i++) {
        let currentElement = arr[i];
        if (cond(currentElement)) mod.AppendToArray(v, currentElement);
    }
    return v;
}

export function IndexOfFirstTrue(array: mod.Array, cond: (element: any, arg: any) => boolean, arg: any = null): number {
    const arr = ConvertArray(array);
    let n = arr.length;
    for (let i = 0; i < n; i++) {
        let currentArrayElement = arr[i];
        if (cond(currentArrayElement, arg)) return i;
    }
    return -1;
}

export function IfThenElse<T>(condition: boolean, ifTrue: () => T, ifFalse: () => T) {
    if (condition) return ifTrue();
    else return ifFalse();
}

export function IsTrueForAll(array: mod.Array, condition: (element: any, arg: any) => boolean, arg: any = null) {
    const arr = ConvertArray(array);
    let n = arr.length;
    for (let i = 0; i < n; i++) {
        let currentArrayElement = arr[i];
        if (!condition(currentArrayElement, arg)) return false;
    }
    return true;
}

export function IsTrueForAny(array: mod.Array, condition: (element: any, arg: any) => boolean, arg: any = null) {
    const arr = ConvertArray(array);
    let n = arr.length;
    for (let i = 0; i < n; i++) {
        let currentArrayElement = arr[i];
        if (condition(currentArrayElement, arg)) return true;
    }
    return false;
}

export function SortedArray(array: any[], compare: (a: any, b: any) => number) {
    let v1 = array.slice();
    v1.sort(compare);
    let v2 = [];
    for (let e of v1) v2.push(e);
    return v2;
}

export function Equals(a: any, b: any) {
    if (a == null || b == null) debugger;
    return mod.Equals(a, b);
}

export async function WaitUntil(delay: number, cond: () => boolean) {
    // complete rush hack. this will likely wait way too long and other problems.
    let deltaCount = 10;
    let deltaWait = delay / deltaCount;
    for (let t = 0; t < deltaCount; t++) {
        if (!cond()) break;
        await mod.Wait(deltaWait);
    }
}

export class ConditionState {
    lastState: boolean;

    constructor() {
        this.lastState = false;
    }

    update(newState: boolean): boolean {
        // if the new state is false then reset last state and don't trigger action
        if (!newState) {
            this.lastState = false;
            return false;
        }
        // if last state was already true then don't trigger
        if (this.lastState) return false;
        // if the state just transitioned to true then trigger
        this.lastState = true;
        return true;
    }
}

class Conditions {
    constructor() {
        this.conditionStates = [];
    }

    conditionStates: ConditionState[];

    getConditionState(n: number): ConditionState {
        while (n >= this.conditionStates.length) {
            this.conditionStates.push(new ConditionState());
        }
        return this.conditionStates[n];
    }
}

let playerConditions: Conditions[] = [];
let teamConditions: Conditions[] = [];
let capturePointConditions: Conditions[] = [];
let mcomConditions: Conditions[] = [];
let vehicleConditions: Conditions[] = [];
let globalConditions: Conditions = new Conditions();

function getObjectCondition(id: number, objectConditions: Conditions[], n: number) {
    while (id >= objectConditions.length) {
        objectConditions.push(new Conditions());
    }
    let conditions = objectConditions[id];
    return conditions.getConditionState(n);
}

export function getPlayerCondition(obj: mod.Player, n: number) {
    let id = getPlayerId(obj);
    while (id >= playerConditions.length) {
        playerConditions.push(new Conditions());
    }
    let conditions = playerConditions[id];
    return conditions.getConditionState(n);
}

export function getTeamCondition(team: mod.Team, n: number) {
    let id = getTeamId(team);
    while (id >= teamConditions.length) {
        teamConditions.push(new Conditions());
    }
    let conditions = teamConditions[id];
    return conditions.getConditionState(n);
}

export function getCapturePointCondition(obj: mod.CapturePoint, n: number) {
    let id = mod.GetObjId(obj);
    return getObjectCondition(id, capturePointConditions, n);
}

export function getMCOMCondition(obj: mod.MCOM, n: number) {
    let id = mod.GetObjId(obj);
    return getObjectCondition(id, mcomConditions, n);
}

export function getVehicleCondition(obj: mod.Vehicle, n: number) {
    let id = mod.GetObjId(obj);
    return getObjectCondition(id, vehicleConditions, n);
}

export function getGlobalCondition(n: number) {
    return globalConditions.getConditionState(n);
}

export function getPlayersInTeam(team: mod.Team) {
    const allPlayers = mod.AllPlayers();
    const n = mod.CountOf(allPlayers);
    let teamMembers = [];

    for (let i = 0; i < n; i++) {
        let player = mod.ValueInArray(allPlayers, i) as mod.Player;
        if (mod.GetTeam(player) == team) {
            teamMembers.push(player);
        }
    }
    return teamMembers;
}

//-----------------------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------------------//
// Helper functions to create UI from a JSON object tree:
//-----------------------------------------------------------------------------------------------//

type UIVector = mod.Vector | number[];

interface UIParams {
    name: string;
    type: string;
    position: any;
    size: any;
    anchor: mod.UIAnchor;
    parent: mod.UIWidget;
    visible: boolean;
    textLabel: string;
    textColor: UIVector;
    textAlpha: number;
    textSize: number;
    textAnchor: mod.UIAnchor;
    padding: number;
    bgColor: UIVector;
    bgAlpha: number;
    bgFill: mod.UIBgFill;
    imageType: mod.UIImageType;
    imageColor: UIVector;
    imageAlpha: number;
    teamId?: mod.Team;
    playerId?: mod.Player;
    children?: any[];
    buttonEnabled: boolean;
    buttonColorBase: UIVector;
    buttonAlphaBase: number;
    buttonColorDisabled: UIVector;
    buttonAlphaDisabled: number;
    buttonColorPressed: UIVector;
    buttonAlphaPressed: number;
    buttonColorHover: UIVector;
    buttonAlphaHover: number;
    buttonColorFocused: UIVector;
    buttonAlphaFocused: number;
}

function __asModVector(param: number[] | mod.Vector) {
    if (Array.isArray(param)) return mod.CreateVector(param[0], param[1], param.length == 2 ? 0 : param[2]);
    else return param;
}

function __asModMessage(param: string | mod.Message) {
    if (typeof param === 'string') return mod.Message(param);
    return param;
}

function __fillInDefaultArgs(params: UIParams) {
    if (!params.hasOwnProperty('name')) params.name = '';
    if (!params.hasOwnProperty('position')) params.position = mod.CreateVector(0, 0, 0);
    if (!params.hasOwnProperty('size')) params.size = mod.CreateVector(100, 100, 0);
    if (!params.hasOwnProperty('anchor')) params.anchor = mod.UIAnchor.TopLeft;
    if (!params.hasOwnProperty('parent')) params.parent = mod.GetUIRoot();
    if (!params.hasOwnProperty('visible')) params.visible = true;
    if (!params.hasOwnProperty('padding')) params.padding = params.type == 'Container' ? 0 : 8;
    if (!params.hasOwnProperty('bgColor')) params.bgColor = mod.CreateVector(0.25, 0.25, 0.25);
    if (!params.hasOwnProperty('bgAlpha')) params.bgAlpha = 0.5;
    if (!params.hasOwnProperty('bgFill')) params.bgFill = mod.UIBgFill.Solid;
}

function __setNameAndGetWidget(uniqueName: any, params: any) {
    let widget = mod.FindUIWidgetWithName(uniqueName) as mod.UIWidget;
    mod.SetUIWidgetName(widget, params.name);
    return widget;
}

const __cUniqueName = '----uniquename----';

function __addUIContainer(params: UIParams) {
    __fillInDefaultArgs(params);
    let restrict = params.teamId ?? params.playerId;
    if (restrict) {
        mod.AddUIContainer(
            __cUniqueName,
            __asModVector(params.position),
            __asModVector(params.size),
            params.anchor,
            params.parent,
            params.visible,
            params.padding,
            __asModVector(params.bgColor),
            params.bgAlpha,
            params.bgFill,
            restrict
        );
    } else {
        mod.AddUIContainer(
            __cUniqueName,
            __asModVector(params.position),
            __asModVector(params.size),
            params.anchor,
            params.parent,
            params.visible,
            params.padding,
            __asModVector(params.bgColor),
            params.bgAlpha,
            params.bgFill
        );
    }
    let widget = __setNameAndGetWidget(__cUniqueName, params);
    if (params.children) {
        params.children.forEach((childParams: any) => {
            childParams.parent = widget;
            __addUIWidget(childParams);
        });
    }
    return widget;
}

function __fillInDefaultTextArgs(params: UIParams) {
    if (!params.hasOwnProperty('textLabel')) params.textLabel = '';
    if (!params.hasOwnProperty('textSize')) params.textSize = 0;
    if (!params.hasOwnProperty('textColor')) params.textColor = mod.CreateVector(1, 1, 1);
    if (!params.hasOwnProperty('textAlpha')) params.textAlpha = 1;
    if (!params.hasOwnProperty('textAnchor')) params.textAnchor = mod.UIAnchor.CenterLeft;
}

function __addUIText(params: UIParams) {
    __fillInDefaultArgs(params);
    __fillInDefaultTextArgs(params);
    let restrict = params.teamId ?? params.playerId;
    if (restrict) {
        mod.AddUIText(
            __cUniqueName,
            __asModVector(params.position),
            __asModVector(params.size),
            params.anchor,
            params.parent,
            params.visible,
            params.padding,
            __asModVector(params.bgColor),
            params.bgAlpha,
            params.bgFill,
            __asModMessage(params.textLabel),
            params.textSize,
            __asModVector(params.textColor),
            params.textAlpha,
            params.textAnchor,
            restrict
        );
    } else {
        mod.AddUIText(
            __cUniqueName,
            __asModVector(params.position),
            __asModVector(params.size),
            params.anchor,
            params.parent,
            params.visible,
            params.padding,
            __asModVector(params.bgColor),
            params.bgAlpha,
            params.bgFill,
            __asModMessage(params.textLabel),
            params.textSize,
            __asModVector(params.textColor),
            params.textAlpha,
            params.textAnchor
        );
    }
    return __setNameAndGetWidget(__cUniqueName, params);
}

function __fillInDefaultImageArgs(params: any) {
    if (!params.hasOwnProperty('imageType')) params.imageType = mod.UIImageType.None;
    if (!params.hasOwnProperty('imageColor')) params.imageColor = mod.CreateVector(1, 1, 1);
    if (!params.hasOwnProperty('imageAlpha')) params.imageAlpha = 1;
}

function __addUIImage(params: UIParams) {
    __fillInDefaultArgs(params);
    __fillInDefaultImageArgs(params);
    let restrict = params.teamId ?? params.playerId;
    if (restrict) {
        mod.AddUIImage(
            __cUniqueName,
            __asModVector(params.position),
            __asModVector(params.size),
            params.anchor,
            params.parent,
            params.visible,
            params.padding,
            __asModVector(params.bgColor),
            params.bgAlpha,
            params.bgFill,
            params.imageType,
            __asModVector(params.imageColor),
            params.imageAlpha,
            restrict
        );
    } else {
        mod.AddUIImage(
            __cUniqueName,
            __asModVector(params.position),
            __asModVector(params.size),
            params.anchor,
            params.parent,
            params.visible,
            params.padding,
            __asModVector(params.bgColor),
            params.bgAlpha,
            params.bgFill,
            params.imageType,
            __asModVector(params.imageColor),
            params.imageAlpha
        );
    }
    return __setNameAndGetWidget(__cUniqueName, params);
}

function __fillInDefaultArg(params: any, argName: any, defaultValue: any) {
    if (!params.hasOwnProperty(argName)) params[argName] = defaultValue;
}

function __fillInDefaultButtonArgs(params: any) {
    if (!params.hasOwnProperty('buttonEnabled')) params.buttonEnabled = true;
    if (!params.hasOwnProperty('buttonColorBase')) params.buttonColorBase = mod.CreateVector(0.7, 0.7, 0.7);
    if (!params.hasOwnProperty('buttonAlphaBase')) params.buttonAlphaBase = 1;
    if (!params.hasOwnProperty('buttonColorDisabled')) params.buttonColorDisabled = mod.CreateVector(0.2, 0.2, 0.2);
    if (!params.hasOwnProperty('buttonAlphaDisabled')) params.buttonAlphaDisabled = 0.5;
    if (!params.hasOwnProperty('buttonColorPressed')) params.buttonColorPressed = mod.CreateVector(0.25, 0.25, 0.25);
    if (!params.hasOwnProperty('buttonAlphaPressed')) params.buttonAlphaPressed = 1;
    if (!params.hasOwnProperty('buttonColorHover')) params.buttonColorHover = mod.CreateVector(1, 1, 1);
    if (!params.hasOwnProperty('buttonAlphaHover')) params.buttonAlphaHover = 1;
    if (!params.hasOwnProperty('buttonColorFocused')) params.buttonColorFocused = mod.CreateVector(1, 1, 1);
    if (!params.hasOwnProperty('buttonAlphaFocused')) params.buttonAlphaFocused = 1;
}

function __addUIButton(params: UIParams) {
    __fillInDefaultArgs(params);
    __fillInDefaultButtonArgs(params);
    let restrict = params.teamId ?? params.playerId;
    if (restrict) {
        mod.AddUIButton(
            __cUniqueName,
            __asModVector(params.position),
            __asModVector(params.size),
            params.anchor,
            params.parent,
            params.visible,
            params.padding,
            __asModVector(params.bgColor),
            params.bgAlpha,
            params.bgFill,
            params.buttonEnabled,
            __asModVector(params.buttonColorBase),
            params.buttonAlphaBase,
            __asModVector(params.buttonColorDisabled),
            params.buttonAlphaDisabled,
            __asModVector(params.buttonColorPressed),
            params.buttonAlphaPressed,
            __asModVector(params.buttonColorHover),
            params.buttonAlphaHover,
            __asModVector(params.buttonColorFocused),
            params.buttonAlphaFocused,
            restrict
        );
    } else {
        mod.AddUIButton(
            __cUniqueName,
            __asModVector(params.position),
            __asModVector(params.size),
            params.anchor,
            params.parent,
            params.visible,
            params.padding,
            __asModVector(params.bgColor),
            params.bgAlpha,
            params.bgFill,
            params.buttonEnabled,
            __asModVector(params.buttonColorBase),
            params.buttonAlphaBase,
            __asModVector(params.buttonColorDisabled),
            params.buttonAlphaDisabled,
            __asModVector(params.buttonColorPressed),
            params.buttonAlphaPressed,
            __asModVector(params.buttonColorHover),
            params.buttonAlphaHover,
            __asModVector(params.buttonColorFocused),
            params.buttonAlphaFocused
        );
    }
    return __setNameAndGetWidget(__cUniqueName, params);
}

function __addUIWidget(params: UIParams) {
    if (params == null) return undefined;
    if (params.type == 'Container') return __addUIContainer(params);
    else if (params.type == 'Text') return __addUIText(params);
    else if (params.type == 'Image') return __addUIImage(params);
    else if (params.type == 'Button') return __addUIButton(params);
    return undefined;
}

export function ParseUI(...params: any[]) {
    let widget: mod.UIWidget | undefined;
    for (let a = 0; a < params.length; a++) {
        widget = __addUIWidget(params[a] as UIParams);
    }
    return widget;
}

export function DisplayCustomNotificationMessage(
    msg: mod.Message,
    custom: number,
    duration: number,
    target?: mod.Player | mod.Team
) {
    bf2042.DisplayCustomNotificationMessage(msg, custom, duration, target);
}

export function ClearCustomNotificationMessage(custom: number, target?: mod.Player | mod.Team) {
    bf2042.ClearCustomNotificationMessage(custom, target);
}

export function ClearAllCustomNotificationMessages(target: mod.Player) {
    bf2042.ClearAllCustomNotificationMessages(target);
}

/** Support for migrating a 2042 project to latest Portal
 *
 * You would not normally need to use this if you're starting with latest Portal
 */
export namespace bf2042 {
    export const PrimaryWeapons = {
        P90: mod.PrimaryWeapons.USG_90,
        'PP-19 Bizon': mod.PrimaryWeapons.USG_90,
        Remington870: mod.PrimaryWeapons.USG_90,
        M1_GRA: mod.PrimaryWeapons.USG_90,
        BAR1918: mod.PrimaryWeapons.USG_90,
        M249_ALX: mod.PrimaryWeapons.USG_90,
        SPAS12_ALX: mod.PrimaryWeapons.USG_90,
        M39EMR: mod.PrimaryWeapons.USG_90,
        'AKS-74u_RUM': mod.PrimaryWeapons.USG_90,
        'SCAR MK17': mod.PrimaryWeapons.USG_90,
        Pecheneg: mod.PrimaryWeapons.USG_90,
        'DAO-12': mod.PrimaryWeapons.USG_90,
        'SLX Spear': mod.PrimaryWeapons.USG_90,
        STG44: mod.PrimaryWeapons.USG_90,
        GOL: mod.PrimaryWeapons.USG_90,
        M98B: mod.PrimaryWeapons.USG_90,
        M95: mod.PrimaryWeapons.USG_90,
    };

    export const SecondaryWeapons = {
        M1911_ALX: mod.SecondaryWeapons.P18,
        'Keltec-P50': mod.SecondaryWeapons.P18,
        MP412REX_RUM: mod.SecondaryWeapons.P18,
        'NVK-P125': mod.SecondaryWeapons.P18,
        Taurus: mod.SecondaryWeapons.P18,
        M93R_ALX: mod.SecondaryWeapons.P18,
        MP443_ALX: mod.SecondaryWeapons.P18,
        M93R_RUM: mod.SecondaryWeapons.P18,
    };

    export const OpenGadgets = {
        Mortar: mod.OpenGadgets.PortableMortar,
        Defibrillator: mod.OpenGadgets.Defibrillator,
        SupplyPouch: mod.OpenGadgets.SupplyPouch,
        DeployableCover: mod.OpenGadgets.DeployableCover,
        AmmoCrate: mod.OpenGadgets.SupplyBag,
        HealthCrate: mod.OpenGadgets.SupplyBag,
        RPG7_RUM: mod.OpenGadgets.UnguidedRocketLauncher,
    };

    export const MeleeWeapons = {
        Hatchet: mod.MeleeWeapons.Sledgehammer,
        SkeletonizedKnife: mod.MeleeWeapons.Sledgehammer,
        Knife_BF3: mod.MeleeWeapons.MeleeKnife,
    };

    export const Throwables = {
        Dynamite: mod.Throwables.StunGrenade,
    };

    export enum MCOMs {
        A,
        B,
        C,
        D,
        E,
        F,
        G,
        H,
    }

    export enum CapturePoints {
        A,
        B,
        C,
        D,
        E,
        F,
        G,
        H,
    }

    export const InventorySlots = {
        PrimaryWeapon: mod.InventorySlots.PrimaryWeapon,
        SecondaryWeapon: mod.InventorySlots.SecondaryWeapon,
        CharacterGadget: mod.InventorySlots.ClassGadget,
        Throwable: mod.InventorySlots.Throwable,
    };

    export const CharacterGadgets = {
        ConstructionKit: mod.OpenGadgets.RepairTool,
        StimPistol: mod.OpenGadgets.Defibrillator,
        SupplyBag: mod.OpenGadgets.SupplyBag,
        XM370A: mod.OpenGadgets.IncendiaryAirburstWeaponSystem,
        AutoTurret: mod.OpenGadgets.DeployableCover,
        GrappleGun: mod.OpenGadgets.DemolitionCharge,
        MedKit: mod.OpenGadgets.DemolitionCharge,
        MedicBag_ALX: mod.OpenGadgets.SupplyBag,
        BallisticShield: mod.OpenGadgets.DemolitionCharge,
        SignalHacker: mod.OpenGadgets.DemolitionCharge,
        ReconDrone: mod.OpenGadgets.ReconDrone,
        AmmoBag_ALX: mod.OpenGadgets.SupplyBag,
    };

    export const SoldierKits = {
        Alpha: undefined,
        Bravo: undefined,
        Juliet: undefined,
        India: undefined,
        Foxtrot: undefined,
        Delta: undefined,
        Kilo: undefined,
    };

    export const Sounds = {
        ObjectiveCappingComplete: mod.VoiceOverEvents2D.ObjectiveCaptured,
        NewObjectiveGiven_02: mod.VoiceOverEvents2D.ObjectiveLocated,
        NewObjectiveGiven_01: mod.VoiceOverEvents2D.ObjectiveLocated,
        ObjectiveCapping: mod.VoiceOverEvents2D.ObjectiveCapturing,
        ShowObjective: mod.VoiceOverEvents2D.ObjectiveLocated,
        ObjectiveCompleted_01: mod.VoiceOverEvents2D.ObjectiveLost,
        ObjectiveCompleted_02: mod.VoiceOverEvents2D.ObjectiveLost,
        ObjectiveFailed: mod.VoiceOverEvents2D.ObjectiveLost,
        ObjectiveUpdated: mod.VoiceOverEvents2D.ObjectiveLost,
    };

    export const LocationalSounds = {
        Alarm_01: mod.SoundEvents3D.Alarm_Start,
        Ping: mod.SoundEvents3D.Explosion,
    };

    export const MCOMStateBool = {
        IsArmed: undefined,
    };

    export const VoiceOvers = {
        ObjectiveLost: mod.VoiceOverEvents2D.ObjectiveLost,
        ObjectiveTaken_Friendly: mod.VoiceOverEvents2D.ObjectiveCaptured,
    };

    export const CustomMessages = {
        HeaderText: mod.CustomNotificationSlots.HeaderText,
        MessageText1: mod.CustomNotificationSlots.MessageText1,
        MessageText2: mod.CustomNotificationSlots.MessageText2,
        MessageText3: mod.CustomNotificationSlots.MessageText3,
        MessageText4: mod.CustomNotificationSlots.MessageText4,
    };

    export const RestrictedInputs = {
        CycleAbilityUp: mod.RestrictedInputs.CyclePrimary,
        CycleAbilityDown: mod.RestrictedInputs.CyclePrimary,
        CycleSecondary: mod.RestrictedInputs.CyclePrimary,
    };

    export const Vehicles = {
        M1_Abrams: mod.VehicleList.Abrams,
        T90M: mod.VehicleList.Abrams,
        LAV25: mod.VehicleList.Abrams,
        BTR82A: mod.VehicleList.Abrams,
        AH64E: mod.VehicleList.Abrams,
        Mi24P: mod.VehicleList.Abrams,
        F35C: mod.VehicleList.Abrams,
        SU57: mod.VehicleList.SU57,
        Leopard: mod.VehicleList.Leopard,
    };

    export const stringkeys = mod.stringkeys;

    export function TriggerAudio(sound: mod.VoiceOverEvents2D, target: mod.Team) {}

    export const GetCapturePoint = mod.GetCapturePoint;

    export function SetRoundTimeLimit(time: number) {
        mod.SetGameModeTimeLimit(time);
    }

    export function EnablePlayerSpawning(enable: boolean) {}

    export function EnableDefaultWinCondition(enable: boolean) {}

    export const SetTargetScore = mod.SetGameModeTargetScore;

    // todo: Should this be GetGameModeTargetScore
    export const GetTargetScore = mod.GetTargetScore;

    export function EnableDefaultScoring(enable: boolean) {}

    export const Message = mod.Message;
    export const Equals = mod.Equals;
    export const GreaterThan = mod.GreaterThan;
    export const LessThan = mod.LessThan;
    export const LessThanEqualTo = mod.LessThanEqualTo;

    export const SetVariable = mod.SetVariable;
    export const GetVariable = mod.GetVariable;
    export const AppendToArray = mod.AppendToArray;
    export const CreateVector = mod.CreateVector;
    export const SetVariableAtIndex = mod.SetVariableAtIndex;

    export const SetTeam = mod.SetTeam;

    export function GetTeamId(id: number) {
        if (id == 0) {
            return mod.GetTeam(3);
        }
        return mod.GetTeam(id);
    }

    export const ObjectVariable = mod.ObjectVariable;
    export const GreaterThanEqualTo = mod.GreaterThanEqualTo;
    export const And = mod.And;
    export const Or = mod.Or;
    export const Not = mod.Not;
    export const NotEqualTo = mod.NotEqualTo;

    export const Wait = mod.Wait;

    type GetSoldierStateType = typeof mod.GetSoldierState;

    export const GetSoldierState = ((arg0: mod.Player, arg1: mod.SoldierStateBool): boolean | mod.Vector | number => {
        if (arg1 === mod.SoldierStateBool.IsInteracting) {
            // Debugging
            console.log('GetSoldierState IsInteracting');
        }
        return mod.GetSoldierState(arg0, arg1 as mod.SoldierStateBool);
    }) as GetSoldierStateType;

    export const SoldierStateBool = mod.SoldierStateBool;
    export const SoldierStateVector = mod.SoldierStateVector;
    export const SoldierStateNumber = mod.SoldierStateNumber;

    export const Multiply = mod.Multiply;
    export const Divide = mod.Divide;
    export const Add = mod.Add;
    export const Subtract = mod.Subtract;
    export const Modulo = mod.Modulo;
    export const RoundToInteger = mod.RoundToInteger;
    export const RandomValueInArray = mod.RandomValueInArray;
    export const ClosestPlayerTo = mod.ClosestPlayerTo;
    export const DistanceBetween = mod.DistanceBetween;
    export const IsPlayerValid = mod.IsPlayerValid;
    export const GlobalVariable = mod.GlobalVariable;
    export const SpotTarget = mod.SpotTarget;

    export const XComponentOf = mod.XComponentOf;
    export const YComponentOf = mod.YComponentOf;
    export const ZComponentOf = mod.ZComponentOf;

    export const CountOf = mod.CountOf;
    export const ValueInArray = mod.ValueInArray;
    export const EmptyArray = mod.EmptyArray;

    export const AllPlayers = mod.AllPlayers;

    export const EnableVOMessaging = function (enable: boolean) {
        console.error('EnableVOMessaging is not implemented in modlib');
    };

    export const SetCapturePointOwner = mod.SetCapturePointOwner;
    export const SendErrorReport = mod.SendErrorReport;
    export const StopChasingVariable = mod.StopChasingVariable;
    export const ChaseVariableOverTime = mod.ChaseVariableOverTime;
    export const ChaseVariableAtRate = mod.ChaseVariableAtRate;

    export function CompareVehicleName(a: mod.VehicleList, b: mod.VehicleList): boolean {
        return a === b;
    }

    export function Teleport(obj: mod.Player | mod.MCOM | mod.CapturePoint, position: mod.Vector, direction: number) {
        console.error('modlib Teleport is not fully implemented yet');
        if (mod.IsType(obj, mod.Types.Player)) {
            // Teleport player
            mod.Teleport(obj as mod.Player, mod.CreateVector(0, 0, 0), direction);
        } else if (mod.IsType(obj, mod.Types.MCOM)) {
            // Teleport MCOM
            console.warn('Teleporting MCOM is not implemented yet');
        } else if (mod.IsType(obj, mod.Types.CapturePoint)) {
            // Teleport Capture Point
            console.warn('Teleporting Capture Point is not implemented yet');
        } else {
            console.error('Invalid object type for teleportation');
        }
    }

    export const RightVector = mod.RightVector;
    export const UpVector = mod.UpVector;
    export const ForwardVector = mod.ForwardVector;
    export const WorldVectorOf = mod.WorldVectorOf;

    export const ForceRevive = mod.ForceRevive;
    export const SetRedeployTime = mod.SetRedeployTime;

    export function ResetRoundTime() {
        console.error('modlib ResetRoundTime is not implemented yet');
    }

    export function SpawnPlayer(player: mod.Player) {
        console.error('modlib SpawnPlayer is not implemented yet');
    }

    export const WorldIconImages = mod.WorldIconImages;

    export const Kill = mod.Kill;

    // Inventory functions
    export const IsInventorySlotActive = mod.IsInventorySlotActive;
    export const ForceSwitchInventory = mod.ForceSwitchInventory;
    export const RemovePlayerInventory = mod.RemovePlayerInventory;
    export const HasInventory = mod.HasInventory;
    export const SetInventoryMagazineAmmo = mod.SetInventoryMagazineAmmo;
    export const IsUsingKit = mod.IsUsingKit;

    export const SetPlayerMaxHealth = mod.SetPlayerMaxHealth;
    export const SetPlayerDamage = function (player: mod.Player, damage: number) {
        console.warn('SetPlayerDamage is deprecated, use mod.Heal instead');
        mod.Heal(player, -damage);
    };

    export function SetSpawnOverride(arg0: any, arg2: boolean) {
        console.error('modlib SetSpawnOverride is not implemented yet');
    }

    export let WorldIcons: any = {
        A: mod.GetWorldIcon(0),
    };

    export const SetWorldIconOwner = mod.SetWorldIconOwner;

    export function SetWorldIconText(worldIcon: mod.WorldIcon, text: mod.Message) {
        mod.SetWorldIconText(worldIcon, text);
    }

    export const EnableWorldIconImage = mod.EnableWorldIconImage;
    export const EnableWorldIconText = mod.EnableWorldIconText;
    export const SetWorldIconImage = mod.SetWorldIconImage;
    export const SetWorldIconPosition = mod.SetWorldIconPosition;

    export enum Maps {
        Oasis,
        Discarded,
        Irreversible,
        Port,
        Rural,
        Kaleidoscope,
        Orbital,
        Harbor,
        LongHaul,
        Drained,
        Ridge,
        TheWall,
        Frost,
        Boulder,
        LightsOut,
    }

    export function IsCurrentMap(map: Maps): boolean {
        return map == Maps.Rural;
    }

    export function GetGameModeTimeElapsed() {
        return mod.GetRoundTime();
    }

    export function GetMatchTimeElapsed() {
        return mod.GetRoundTime();
    }

    export function TriggerAudioAtLocation(arg0: mod.SoundEvents3D, arg1: mod.Vector, arg2?: number) {
        // TODO: replace with newer audio system
        // mod.TriggerAudioAtLocation(arg0, arg1);
    }

    export function SetGamemodeScore(team: mod.Team | mod.Player, score: number) {
        mod.SetGameModeTargetScore(score);
    }

    export function PauseRoundTime(pause: boolean) {
        mod.PauseGameModeTime(pause);
    }

    export function EndRound(teamOrPlayer: mod.Team | mod.Player | number) {
        if (typeof teamOrPlayer === 'number') {
            mod.EndGameMode(mod.GetTeam(teamOrPlayer));
        } else {
            mod.EndGameMode(teamOrPlayer as mod.Player);
        }
    }

    export function GetGamemodeScore(teamOrPlayer: mod.Team | mod.Player | number) {
        if (typeof teamOrPlayer === 'number') {
            ShowEventGameModeMessage;
            return mod.GetGameModeScore(mod.GetTeam(teamOrPlayer));
        } else {
            return mod.GetGameModeScore(teamOrPlayer as mod.Team);
        }
    }

    export function AddSoldierWeapon(obj: mod.Player, weapon: mod.PrimaryWeapons) {}

    export function ShowNotificationMessage(msg: mod.Message, target?: mod.Player | mod.Team) {
        if (target) {
            mod.DisplayNotificationMessage(msg, target as mod.Player);
        } else {
            mod.DisplayNotificationMessage(msg);
        }
    }

    export function ClearAllCustomNotificationMessages(target: mod.Player) {
        try {
            ClearCustomNotificationMessage(mod.CustomNotificationSlots.HeaderText, target);
        } catch {}
        try {
            ClearCustomNotificationMessage(mod.CustomNotificationSlots.MessageText1, target);
        } catch {}
        try {
            ClearCustomNotificationMessage(mod.CustomNotificationSlots.MessageText2, target);
        } catch {}
        try {
            ClearCustomNotificationMessage(mod.CustomNotificationSlots.MessageText3, target);
        } catch {}
        try {
            ClearCustomNotificationMessage(mod.CustomNotificationSlots.MessageText4, target);
        } catch {}
    }

    export function ClearCustomNotificationMessage(
        custom: mod.CustomNotificationSlots,
        target?: mod.Player | mod.Team
    ) {
        try {
            if (target) {
                // if target is player, just delete message in their slot
                if (mod.IsType(target, mod.Types.Player)) {
                    mod.DeleteUIWidget(mod.FindUIWidgetWithName(custom + String(target as mod.Player)));
                }
                // if target is team, delete message in slot for all players on team
                else if (mod.IsType(target, mod.Types.Team)) {
                    const teamMembers = getPlayersInTeam(target as mod.Team);
                    for (let i = 0; i < teamMembers.length; i++) {
                        let player = teamMembers[i];
                        mod.DeleteUIWidget(mod.FindUIWidgetWithName(custom + String(player)));
                    }
                }
            } else {
                // if no target, delete for all players
                const allPlayers = mod.AllPlayers();
                const n = mod.CountOf(allPlayers);
                for (let i = 0; i < n; i++) {
                    let player = mod.ValueInArray(allPlayers, i) as mod.Player;
                    mod.DeleteUIWidget(mod.FindUIWidgetWithName(custom + String(player)));
                }
            }
        } catch {
            console.error('Could not clear custom message for specified target(s)');
        }
    }

    export function DisplayCustomNotificationMessage(
        msg: mod.Message,
        custom: mod.CustomNotificationSlots,
        duration: number,
        target?: mod.Player | mod.Team
    ) {
        const CreateHeader = async (widgetId: string, msg: mod.Message, targetPlayer: mod.Player, slot: number) => {
            mod.AddUIText(
                widgetId,
                mod.CreateVector(50, 250 + slot * (40 + 5), 0),
                mod.CreateVector(250, 60, 0),
                mod.UIAnchor.TopRight,
                mod.GetUIRoot(),
                true,
                8,
                mod.CreateVector(1, 1, 1),
                1,
                mod.UIBgFill.Blur,
                msg,
                30,
                mod.CreateVector(1, 1, 1),
                1,
                mod.UIAnchor.Center,
                targetPlayer
            );
            if (duration > 0) {
                await mod.Wait(duration);
                mod.DeleteUIWidget(mod.FindUIWidgetWithName(widgetId));
            }
        };
        const CreateSubText = async (widgetId: string, msg: mod.Message, targetPlayer: mod.Player, slot: number) => {
            mod.AddUIText(
                widgetId,
                mod.CreateVector(85, 270 + slot * (40 + 3), 0),
                mod.CreateVector(125, 40, 0),
                mod.UIAnchor.TopRight,
                mod.GetUIRoot(),
                true,
                8,
                mod.CreateVector(1, 1, 1),
                1,
                mod.UIBgFill.Blur,
                msg,
                20,
                mod.CreateVector(1, 1, 1),
                1,
                mod.UIAnchor.Center,
                targetPlayer
            );
            if (duration > 0) {
                await mod.Wait(duration);
                mod.DeleteUIWidget(mod.FindUIWidgetWithName(widgetId));
            }
        };
        const createNotificationFunction = custom < 1 ? CreateHeader : CreateSubText;

        if (target) {
            // if target is player, fill message in their slot
            if (mod.IsType(target, mod.Types.Player)) {
                const widgetId = custom + String(target);
                createNotificationFunction(widgetId, msg, target as mod.Player, custom);
            }
            // if target is team, fill message in slot for all players on team
            else if (mod.IsType(target, mod.Types.Team)) {
                const teamMates = getPlayersInTeam(target as mod.Team);
                teamMates.forEach((player) => {
                    const widgetId = custom + String(player);
                    createNotificationFunction(widgetId, msg, player, custom);
                });
            }
        } else {
            const allPlayers = mod.AllPlayers();
            const n = mod.CountOf(allPlayers);
            for (let i = 0; i < n; i++) {
                let player = mod.ValueInArray(allPlayers, i) as mod.Player;
                const widgetId = custom + String(player);
                createNotificationFunction(widgetId, msg, player, custom);
            }
        }
    }

    export function ShowEventGameModeMessage(event: mod.Message, target?: mod.Player | mod.Team) {
        //TODO: restore these once DisplayGameModeMessage is fixed
        // if (target) {
        //     mod.DisplayGameModeMessage(event, target as mod.Player );
        // } else{
        //     mod.DisplayGameModeMessage(event);
        // }

        const MakeShiftDisplayGameModeMessage = async (message: mod.Message, target?: mod.Player | mod.Team) => {
            const widgetId = 'GameModeMessage';
            if (target) {
                mod.AddUIText(
                    widgetId,
                    mod.CreateVector(0, 0, 0),
                    mod.CreateVector(2500, 80, 0),
                    mod.UIAnchor.TopCenter,
                    mod.GetUIRoot(),
                    true,
                    8,
                    mod.CreateVector(1, 1, 1),
                    1,
                    mod.UIBgFill.Blur,
                    message,
                    30,
                    mod.CreateVector(1, 1, 1),
                    1,
                    mod.UIAnchor.Center,
                    target as mod.Player
                );
            } else {
                mod.AddUIText(
                    widgetId,
                    mod.CreateVector(0, 0, 0),
                    mod.CreateVector(2500, 80, 0),
                    mod.UIAnchor.TopCenter,
                    mod.GetUIRoot(),
                    true,
                    8,
                    mod.CreateVector(1, 1, 1),
                    1,
                    mod.UIBgFill.Blur,
                    message,
                    30,
                    mod.CreateVector(1, 1, 1),
                    1,
                    mod.UIAnchor.Center
                );
            }

            await mod.Wait(6);
            mod.DeleteUIWidget(mod.FindUIWidgetWithName(widgetId));
        };

        if (target) {
            MakeShiftDisplayGameModeMessage(event, target as mod.Player);
        } else {
            MakeShiftDisplayGameModeMessage(event);
        }
    }

    export function ShowHighlightedGameModeMessage(event: mod.Message, target?: mod.Player | mod.Team) {
        if (target) {
            mod.DisplayHighlightedWorldLogMessage(event, target as mod.Player);
        } else {
            mod.DisplayHighlightedWorldLogMessage(event);
        }
    }
}
`;
function _defineProperty$3(V, X, J) {
    return X in V ? Object.defineProperty(V, X, {
        value: J,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : V[X] = J,
    V
}
function ownKeys$3(V, X) {
    var J = Object.keys(V);
    if (Object.getOwnPropertySymbols) {
        var ne = Object.getOwnPropertySymbols(V);
        X && (ne = ne.filter(function(ue) {
            return Object.getOwnPropertyDescriptor(V, ue).enumerable
        })),
        J.push.apply(J, ne)
    }
    return J
}
function _objectSpread2$1(V) {
    for (var X = 1; X < arguments.length; X++) {
        var J = arguments[X] != null ? arguments[X] : {};
        X % 2 ? ownKeys$3(Object(J), !0).forEach(function(ne) {
            _defineProperty$3(V, ne, J[ne])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(V, Object.getOwnPropertyDescriptors(J)) : ownKeys$3(Object(J)).forEach(function(ne) {
            Object.defineProperty(V, ne, Object.getOwnPropertyDescriptor(J, ne))
        })
    }
    return V
}
function _objectWithoutPropertiesLoose(V, X) {
    if (V == null)
        return {};
    var J = {}, ne = Object.keys(V), ue, ce;
    for (ce = 0; ce < ne.length; ce++)
        ue = ne[ce],
        !(X.indexOf(ue) >= 0) && (J[ue] = V[ue]);
    return J
}
function _objectWithoutProperties(V, X) {
    if (V == null)
        return {};
    var J = _objectWithoutPropertiesLoose(V, X), ne, ue;
    if (Object.getOwnPropertySymbols) {
        var ce = Object.getOwnPropertySymbols(V);
        for (ue = 0; ue < ce.length; ue++)
            ne = ce[ue],
            !(X.indexOf(ne) >= 0) && Object.prototype.propertyIsEnumerable.call(V, ne) && (J[ne] = V[ne])
    }
    return J
}
function _slicedToArray(V, X) {
    return _arrayWithHoles(V) || _iterableToArrayLimit(V, X) || _unsupportedIterableToArray(V, X) || _nonIterableRest()
}
function _arrayWithHoles(V) {
    if (Array.isArray(V))
        return V
}
function _iterableToArrayLimit(V, X) {
    if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(V)))) {
        var J = []
          , ne = !0
          , ue = !1
          , ce = void 0;
        try {
            for (var me = V[Symbol.iterator](), ge; !(ne = (ge = me.next()).done) && (J.push(ge.value),
            !(X && J.length === X)); ne = !0)
                ;
        } catch (Te) {
            ue = !0,
            ce = Te
        } finally {
            try {
                !ne && me.return != null && me.return()
            } finally {
                if (ue)
                    throw ce
            }
        }
        return J
    }
}
function _unsupportedIterableToArray(V, X) {
    if (V) {
        if (typeof V == "string")
            return _arrayLikeToArray(V, X);
        var J = Object.prototype.toString.call(V).slice(8, -1);
        if (J === "Object" && V.constructor && (J = V.constructor.name),
        J === "Map" || J === "Set")
            return Array.from(V);
        if (J === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(J))
            return _arrayLikeToArray(V, X)
    }
}
function _arrayLikeToArray(V, X) {
    (X == null || X > V.length) && (X = V.length);
    for (var J = 0, ne = new Array(X); J < X; J++)
        ne[J] = V[J];
    return ne
}
function _nonIterableRest() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function _defineProperty$2(V, X, J) {
    return X in V ? Object.defineProperty(V, X, {
        value: J,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : V[X] = J,
    V
}
function ownKeys$2(V, X) {
    var J = Object.keys(V);
    if (Object.getOwnPropertySymbols) {
        var ne = Object.getOwnPropertySymbols(V);
        X && (ne = ne.filter(function(ue) {
            return Object.getOwnPropertyDescriptor(V, ue).enumerable
        })),
        J.push.apply(J, ne)
    }
    return J
}
function _objectSpread2(V) {
    for (var X = 1; X < arguments.length; X++) {
        var J = arguments[X] != null ? arguments[X] : {};
        X % 2 ? ownKeys$2(Object(J), !0).forEach(function(ne) {
            _defineProperty$2(V, ne, J[ne])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(V, Object.getOwnPropertyDescriptors(J)) : ownKeys$2(Object(J)).forEach(function(ne) {
            Object.defineProperty(V, ne, Object.getOwnPropertyDescriptor(J, ne))
        })
    }
    return V
}
function compose$1() {
    for (var V = arguments.length, X = new Array(V), J = 0; J < V; J++)
        X[J] = arguments[J];
    return function(ne) {
        return X.reduceRight(function(ue, ce) {
            return ce(ue)
        }, ne)
    }
}
function curry$1(V) {
    return function X() {
        for (var J = this, ne = arguments.length, ue = new Array(ne), ce = 0; ce < ne; ce++)
            ue[ce] = arguments[ce];
        return ue.length >= V.length ? V.apply(this, ue) : function() {
            for (var me = arguments.length, ge = new Array(me), Te = 0; Te < me; Te++)
                ge[Te] = arguments[Te];
            return X.apply(J, [].concat(ue, ge))
        }
    }
}
function isObject$1(V) {
    return {}.toString.call(V).includes("Object")
}
function isEmpty(V) {
    return !Object.keys(V).length
}
function isFunction(V) {
    return typeof V == "function"
}
function hasOwnProperty(V, X) {
    return Object.prototype.hasOwnProperty.call(V, X)
}
function validateChanges(V, X) {
    return isObject$1(X) || errorHandler$1("changeType"),
    Object.keys(X).some(function(J) {
        return !hasOwnProperty(V, J)
    }) && errorHandler$1("changeField"),
    X
}
function validateSelector(V) {
    isFunction(V) || errorHandler$1("selectorType")
}
function validateHandler(V) {
    isFunction(V) || isObject$1(V) || errorHandler$1("handlerType"),
    isObject$1(V) && Object.values(V).some(function(X) {
        return !isFunction(X)
    }) && errorHandler$1("handlersType")
}
function validateInitial(V) {
    V || errorHandler$1("initialIsRequired"),
    isObject$1(V) || errorHandler$1("initialType"),
    isEmpty(V) && errorHandler$1("initialContent")
}
function throwError$1(V, X) {
    throw new Error(V[X] || V.default)
}
var errorMessages$1 = {
    initialIsRequired: "initial state is required",
    initialType: "initial state should be an object",
    initialContent: "initial state shouldn't be an empty object",
    handlerType: "handler should be an object or a function",
    handlersType: "all handlers should be a functions",
    selectorType: "selector should be a function",
    changeType: "provided value of changes should be an object",
    changeField: 'it seams you want to change a field in the state which is not specified in the "initial" state',
    default: "an unknown error accured in `state-local` package"
}
  , errorHandler$1 = curry$1(throwError$1)(errorMessages$1)
  , validators$1 = {
    changes: validateChanges,
    selector: validateSelector,
    handler: validateHandler,
    initial: validateInitial
};
function create(V) {
    var X = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    validators$1.initial(V),
    validators$1.handler(X);
    var J = {
        current: V
    }
      , ne = curry$1(didStateUpdate)(J, X)
      , ue = curry$1(updateState)(J)
      , ce = curry$1(validators$1.changes)(V)
      , me = curry$1(extractChanges)(J);
    function ge() {
        var _e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function(Se) {
            return Se
        }
        ;
        return validators$1.selector(_e),
        _e(J.current)
    }
    function Te(_e) {
        compose$1(ne, ue, ce, me)(_e)
    }
    return [ge, Te]
}
function extractChanges(V, X) {
    return isFunction(X) ? X(V.current) : X
}
function updateState(V, X) {
    return V.current = _objectSpread2(_objectSpread2({}, V.current), X),
    X
}
function didStateUpdate(V, X, J) {
    return isFunction(X) ? X(V.current) : Object.keys(J).forEach(function(ne) {
        var ue;
        return (ue = X[ne]) === null || ue === void 0 ? void 0 : ue.call(X, V.current[ne])
    }),
    J
}
var index = {
    create
}
  , config$1 = {
    paths: {
        vs: "https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/min/vs"
    }
};
function curry(V) {
    return function X() {
        for (var J = this, ne = arguments.length, ue = new Array(ne), ce = 0; ce < ne; ce++)
            ue[ce] = arguments[ce];
        return ue.length >= V.length ? V.apply(this, ue) : function() {
            for (var me = arguments.length, ge = new Array(me), Te = 0; Te < me; Te++)
                ge[Te] = arguments[Te];
            return X.apply(J, [].concat(ue, ge))
        }
    }
}
function isObject(V) {
    return {}.toString.call(V).includes("Object")
}
function validateConfig(V) {
    return V || errorHandler("configIsRequired"),
    isObject(V) || errorHandler("configType"),
    V.urls ? (informAboutDeprecation(),
    {
        paths: {
            vs: V.urls.monacoBase
        }
    }) : V
}
function informAboutDeprecation() {
    console.warn(errorMessages.deprecation)
}
function throwError(V, X) {
    throw new Error(V[X] || V.default)
}
var errorMessages = {
    configIsRequired: "the configuration object is required",
    configType: "the configuration object should be an object",
    default: "an unknown error accured in `@monaco-editor/loader` package",
    deprecation: `Deprecation warning!
    You are using deprecated way of configuration.

    Instead of using
      monaco.config({ urls: { monacoBase: '...' } })
    use
      monaco.config({ paths: { vs: '...' } })

    For more please check the link https://github.com/suren-atoyan/monaco-loader#config
  `
}
  , errorHandler = curry(throwError)(errorMessages)
  , validators = {
    config: validateConfig
}
  , compose = function V() {
    for (var X = arguments.length, J = new Array(X), ne = 0; ne < X; ne++)
        J[ne] = arguments[ne];
    return function(ue) {
        return J.reduceRight(function(ce, me) {
            return me(ce)
        }, ue)
    }
};
function merge(V, X) {
    return Object.keys(X).forEach(function(J) {
        X[J]instanceof Object && V[J] && Object.assign(X[J], merge(V[J], X[J]))
    }),
    _objectSpread2$1(_objectSpread2$1({}, V), X)
}
var CANCELATION_MESSAGE = {
    type: "cancelation",
    msg: "operation is manually canceled"
};
function makeCancelable(V) {
    var X = !1
      , J = new Promise(function(ne, ue) {
        V.then(function(ce) {
            return X ? ue(CANCELATION_MESSAGE) : ne(ce)
        }),
        V.catch(ue)
    }
    );
    return J.cancel = function() {
        return X = !0
    }
    ,
    J
}
var _state$create = index.create({
    config: config$1,
    isInitialized: !1,
    resolve: null,
    reject: null,
    monaco: null
})
  , _state$create2 = _slicedToArray(_state$create, 2)
  , getState = _state$create2[0]
  , setState = _state$create2[1];
function config(V) {
    var X = validators.config(V)
      , J = X.monaco
      , ne = _objectWithoutProperties(X, ["monaco"]);
    setState(function(ue) {
        return {
            config: merge(ue.config, ne),
            monaco: J
        }
    })
}
function init() {
    var V = getState(function(X) {
        var J = X.monaco
          , ne = X.isInitialized
          , ue = X.resolve;
        return {
            monaco: J,
            isInitialized: ne,
            resolve: ue
        }
    });
    if (!V.isInitialized) {
        if (setState({
            isInitialized: !0
        }),
        V.monaco)
            return V.resolve(V.monaco),
            makeCancelable(wrapperPromise);
        if (window.monaco && window.monaco.editor)
            return storeMonacoInstance(window.monaco),
            V.resolve(window.monaco),
            makeCancelable(wrapperPromise);
        compose(injectScripts, getMonacoLoaderScript)(configureLoader)
    }
    return makeCancelable(wrapperPromise)
}
function injectScripts(V) {
    return document.body.appendChild(V)
}
function createScript(V) {
    var X = document.createElement("script");
    return V && (X.src = V),
    X
}
function getMonacoLoaderScript(V) {
    var X = getState(function(ne) {
        var ue = ne.config
          , ce = ne.reject;
        return {
            config: ue,
            reject: ce
        }
    })
      , J = createScript("".concat(X.config.paths.vs, "/loader.js"));
    return J.onload = function() {
        return V()
    }
    ,
    J.onerror = X.reject,
    J
}
function configureLoader() {
    var V = getState(function(J) {
        var ne = J.config
          , ue = J.resolve
          , ce = J.reject;
        return {
            config: ne,
            resolve: ue,
            reject: ce
        }
    })
      , X = window.require;
    X.config(V.config),
    X(["vs/editor/editor.main"], function(J) {
        storeMonacoInstance(J),
        V.resolve(J)
    }, function(J) {
        V.reject(J)
    })
}
function storeMonacoInstance(V) {
    getState().monaco || setState({
        monaco: V
    })
}
function __getMonacoInstance() {
    return getState(function(V) {
        var X = V.monaco;
        return X
    })
}
var wrapperPromise = new Promise(function(V, X) {
    return setState({
        resolve: V,
        reject: X
    })
}
)
  , loader = {
    config,
    init,
    __getMonacoInstance
}
  , le = {
    wrapper: {
        display: "flex",
        position: "relative",
        textAlign: "initial"
    },
    fullWidth: {
        width: "100%"
    },
    hide: {
        display: "none"
    }
}
  , v = le
  , ae = {
    container: {
        display: "flex",
        height: "100%",
        width: "100%",
        justifyContent: "center",
        alignItems: "center"
    }
}
  , Y = ae;
function Me({children: V}) {
    return React$2.createElement("div", {
        style: Y.container
    }, V)
}
var Z = Me
  , $ = Z;
function Ee({width: V, height: X, isEditorReady: J, loading: ne, _ref: ue, className: ce, wrapperProps: me}) {
    return React$2.createElement("section", {
        style: {
            ...v.wrapper,
            width: V,
            height: X
        },
        ...me
    }, !J && React$2.createElement($, null, ne), React$2.createElement("div", {
        ref: ue,
        style: {
            ...v.fullWidth,
            ...!J && v.hide
        },
        className: ce
    }))
}
var ee = Ee
  , H = reactExports.memo(ee);
function Ce(V) {
    reactExports.useEffect(V, [])
}
var k = Ce;
function he(V, X, J=!0) {
    let ne = reactExports.useRef(!0);
    reactExports.useEffect(ne.current || !J ? () => {
        ne.current = !1
    }
    : V, X)
}
var l = he;
function D() {}
function h(V, X, J, ne) {
    return De(V, ne) || be(V, X, J, ne)
}
function De(V, X) {
    return V.editor.getModel(te(V, X))
}
function be(V, X, J, ne) {
    return V.editor.createModel(X, J, ne ? te(V, ne) : void 0)
}
function te(V, X) {
    return V.Uri.parse(X)
}
function Oe({original: V, modified: X, language: J, originalLanguage: ne, modifiedLanguage: ue, originalModelPath: ce, modifiedModelPath: me, keepCurrentOriginalModel: ge=!1, keepCurrentModifiedModel: Te=!1, theme: _e="light", loading: Se="Loading...", options: Ie={}, height: ye="100%", width: $e="100%", className: Ne, wrapperProps: ve={}, beforeMount: ke=D, onMount: xe=D}) {
    let[we,Fe] = reactExports.useState(!1)
      , [je,Xe] = reactExports.useState(!0)
      , ze = reactExports.useRef(null)
      , qe = reactExports.useRef(null)
      , Ze = reactExports.useRef(null)
      , et = reactExports.useRef(xe)
      , it = reactExports.useRef(ke)
      , at = reactExports.useRef(!1);
    k( () => {
        let Ye = loader.init();
        return Ye.then(We => (qe.current = We) && Xe(!1)).catch(We => (We == null ? void 0 : We.type) !== "cancelation" && console.error("Monaco initialization: error:", We)),
        () => ze.current ? St() : Ye.cancel()
    }
    ),
    l( () => {
        if (ze.current && qe.current) {
            let Ye = ze.current.getOriginalEditor()
              , We = h(qe.current, V || "", ne || J || "text", ce || "");
            We !== Ye.getModel() && Ye.setModel(We)
        }
    }
    , [ce], we),
    l( () => {
        if (ze.current && qe.current) {
            let Ye = ze.current.getModifiedEditor()
              , We = h(qe.current, X || "", ue || J || "text", me || "");
            We !== Ye.getModel() && Ye.setModel(We)
        }
    }
    , [me], we),
    l( () => {
        let Ye = ze.current.getModifiedEditor();
        Ye.getOption(qe.current.editor.EditorOption.readOnly) ? Ye.setValue(X || "") : X !== Ye.getValue() && (Ye.executeEdits("", [{
            range: Ye.getModel().getFullModelRange(),
            text: X || "",
            forceMoveMarkers: !0
        }]),
        Ye.pushUndoStop())
    }
    , [X], we),
    l( () => {
        var Ye, We;
        (We = (Ye = ze.current) == null ? void 0 : Ye.getModel()) == null || We.original.setValue(V || "")
    }
    , [V], we),
    l( () => {
        let {original: Ye, modified: We} = ze.current.getModel();
        qe.current.editor.setModelLanguage(Ye, ne || J || "text"),
        qe.current.editor.setModelLanguage(We, ue || J || "text")
    }
    , [J, ne, ue], we),
    l( () => {
        var Ye;
        (Ye = qe.current) == null || Ye.editor.setTheme(_e)
    }
    , [_e], we),
    l( () => {
        var Ye;
        (Ye = ze.current) == null || Ye.updateOptions(Ie)
    }
    , [Ie], we);
    let rt = reactExports.useCallback( () => {
        var nt;
        if (!qe.current)
            return;
        it.current(qe.current);
        let Ye = h(qe.current, V || "", ne || J || "text", ce || "")
          , We = h(qe.current, X || "", ue || J || "text", me || "");
        (nt = ze.current) == null || nt.setModel({
            original: Ye,
            modified: We
        })
    }
    , [J, X, ue, V, ne, ce, me])
      , ft = reactExports.useCallback( () => {
        var Ye;
        !at.current && Ze.current && (ze.current = qe.current.editor.createDiffEditor(Ze.current, {
            automaticLayout: !0,
            ...Ie
        }),
        rt(),
        (Ye = qe.current) == null || Ye.editor.setTheme(_e),
        Fe(!0),
        at.current = !0)
    }
    , [Ie, _e, rt]);
    reactExports.useEffect( () => {
        we && et.current(ze.current, qe.current)
    }
    , [we]),
    reactExports.useEffect( () => {
        !je && !we && ft()
    }
    , [je, we, ft]);
    function St() {
        var We, nt, ct, Et;
        let Ye = (We = ze.current) == null ? void 0 : We.getModel();
        ge || ((nt = Ye == null ? void 0 : Ye.original) == null || nt.dispose()),
        Te || ((ct = Ye == null ? void 0 : Ye.modified) == null || ct.dispose()),
        (Et = ze.current) == null || Et.dispose()
    }
    return React$2.createElement(H, {
        width: $e,
        height: ye,
        isEditorReady: we,
        loading: Se,
        _ref: Ze,
        className: Ne,
        wrapperProps: ve
    })
}
var ie = Oe;
reactExports.memo(ie);
function Pe() {
    let[V,X] = reactExports.useState(loader.__getMonacoInstance());
    return k( () => {
        let J;
        return V || (J = loader.init(),
        J.then(ne => {
            X(ne)
        }
        )),
        () => J == null ? void 0 : J.cancel()
    }
    ),
    V
}
var Le = Pe;
function He(V) {
    let X = reactExports.useRef();
    return reactExports.useEffect( () => {
        X.current = V
    }
    , [V]),
    X.current
}
var se = He
  , _ = new Map;
function Ve({defaultValue: V, defaultLanguage: X, defaultPath: J, value: ne, language: ue, path: ce, theme: me="light", line: ge, loading: Te="Loading...", options: _e={}, overrideServices: Se={}, saveViewState: Ie=!0, keepCurrentModel: ye=!1, width: $e="100%", height: Ne="100%", className: ve, wrapperProps: ke={}, beforeMount: xe=D, onMount: we=D, onChange: Fe, onValidate: je=D}) {
    let[Xe,ze] = reactExports.useState(!1)
      , [qe,Ze] = reactExports.useState(!0)
      , et = reactExports.useRef(null)
      , it = reactExports.useRef(null)
      , at = reactExports.useRef(null)
      , rt = reactExports.useRef(we)
      , ft = reactExports.useRef(xe)
      , St = reactExports.useRef()
      , Ye = reactExports.useRef(ne)
      , We = se(ce)
      , nt = reactExports.useRef(!1)
      , ct = reactExports.useRef(!1);
    k( () => {
        let mt = loader.init();
        return mt.then(lt => (et.current = lt) && Ze(!1)).catch(lt => (lt == null ? void 0 : lt.type) !== "cancelation" && console.error("Monaco initialization: error:", lt)),
        () => it.current ? Ke() : mt.cancel()
    }
    ),
    l( () => {
        var lt, Qe, gt, Nt;
        let mt = h(et.current, V || ne || "", X || ue || "", ce || J || "");
        mt !== ((lt = it.current) == null ? void 0 : lt.getModel()) && (Ie && _.set(We, (Qe = it.current) == null ? void 0 : Qe.saveViewState()),
        (gt = it.current) == null || gt.setModel(mt),
        Ie && ((Nt = it.current) == null || Nt.restoreViewState(_.get(ce))))
    }
    , [ce], Xe),
    l( () => {
        var mt;
        (mt = it.current) == null || mt.updateOptions(_e)
    }
    , [_e], Xe),
    l( () => {
        !it.current || ne === void 0 || (it.current.getOption(et.current.editor.EditorOption.readOnly) ? it.current.setValue(ne) : ne !== it.current.getValue() && (ct.current = !0,
        it.current.executeEdits("", [{
            range: it.current.getModel().getFullModelRange(),
            text: ne,
            forceMoveMarkers: !0
        }]),
        it.current.pushUndoStop(),
        ct.current = !1))
    }
    , [ne], Xe),
    l( () => {
        var lt, Qe;
        let mt = (lt = it.current) == null ? void 0 : lt.getModel();
        mt && ue && ((Qe = et.current) == null || Qe.editor.setModelLanguage(mt, ue))
    }
    , [ue], Xe),
    l( () => {
        var mt;
        ge !== void 0 && ((mt = it.current) == null || mt.revealLine(ge))
    }
    , [ge], Xe),
    l( () => {
        var mt;
        (mt = et.current) == null || mt.editor.setTheme(me)
    }
    , [me], Xe);
    let Et = reactExports.useCallback( () => {
        var mt;
        if (!(!at.current || !et.current) && !nt.current) {
            ft.current(et.current);
            let lt = ce || J
              , Qe = h(et.current, ne || V || "", X || ue || "", lt || "");
            it.current = (mt = et.current) == null ? void 0 : mt.editor.create(at.current, {
                model: Qe,
                automaticLayout: !0,
                ..._e
            }, Se),
            Ie && it.current.restoreViewState(_.get(lt)),
            et.current.editor.setTheme(me),
            ge !== void 0 && it.current.revealLine(ge),
            ze(!0),
            nt.current = !0
        }
    }
    , [V, X, J, ne, ue, ce, _e, Se, Ie, me, ge]);
    reactExports.useEffect( () => {
        Xe && rt.current(it.current, et.current)
    }
    , [Xe]),
    reactExports.useEffect( () => {
        !qe && !Xe && Et()
    }
    , [qe, Xe, Et]),
    Ye.current = ne,
    reactExports.useEffect( () => {
        var mt, lt;
        Xe && Fe && ((mt = St.current) == null || mt.dispose(),
        St.current = (lt = it.current) == null ? void 0 : lt.onDidChangeModelContent(Qe => {
            ct.current || Fe(it.current.getValue(), Qe)
        }
        ))
    }
    , [Xe, Fe]),
    reactExports.useEffect( () => {
        if (Xe) {
            let mt = et.current.editor.onDidChangeMarkers(lt => {
                var gt;
                let Qe = (gt = it.current.getModel()) == null ? void 0 : gt.uri;
                if (Qe && lt.find(Nt => Nt.path === Qe.path)) {
                    let Nt = et.current.editor.getModelMarkers({
                        resource: Qe
                    });
                    je == null || je(Nt)
                }
            }
            );
            return () => {
                mt == null || mt.dispose()
            }
        }
        return () => {}
    }
    , [Xe, je]);
    function Ke() {
        var mt, lt;
        (mt = St.current) == null || mt.dispose(),
        ye ? Ie && _.set(ce, it.current.saveViewState()) : (lt = it.current.getModel()) == null || lt.dispose(),
        it.current.dispose()
    }
    return React$2.createElement(H, {
        width: $e,
        height: Ne,
        isEditorReady: Xe,
        loading: Te,
        _ref: at,
        className: ve,
        wrapperProps: ke
    })
}
var fe = Ve
  , de = reactExports.memo(fe);
const accessMap = {
    RW: !1,
    R: !0
}
  , typeMap = {
    Boolean: "boolean",
    Number: "number",
    String: "string",
    Object: "mod.Object"
};
function handleBeforeMount(V) {
    V.languages.typescript.javascriptDefaults.setCompilerOptions({
        noLib: !0
    })
}
function generateActionFunctionDeclarations(V) {
    const {name: X, functionSignatures: J} = V
      , ne = [];
    return (J ?? [{
        parameterTypes: []
    }]).forEach(me => {
        let ge = `export function ${X}(`;
        ge += generateFunctionParameters(me),
        ge += "): void;",
        ne.push(ge)
    }
    ),
    ne.join(`
`)
}
function generateFunctionParameters(V) {
    const X = getParamaterCount(V)
      , J = [];
    for (let ue = 0; ue < X; ue++) {
        const ce = getParameterType(V, ue)
          , me = `arg${ue}`;
        J.push(`${me}: ${ce}`)
    }
    return J.join(", ")
}
function getParamaterCount(V) {
    var X;
    return ((X = V.parameterTypes) == null ? void 0 : X.length) ?? 0
}
function getParameterType(V, X) {
    if (!V.parameterTypes)
        return "UndefinedType";
    const J = V.parameterTypes[X];
    return isParameterOfAnyType(J) ? "Any" : J.parameterTypes.map(ue => ue in typeMap ? typeMap[ue] : fixParameterName(ue)).join(" | ")
}
function fixParameterName(V) {
    return V.startsWith("Enum_") ? V.slice(5) : V
}
function isParameterOfAnyType(V) {
    return (V == null ? void 0 : V.anyType) === !0
}
function generateValueFunctionDeclarations(V) {
    const {name: X, functionSignatures: J} = V
      , ne = [];
    return J == null || J.forEach(ue => {
        let ce = "Any";
        if (ue.returnType && (ce = fixParameterName(ue.returnType)),
        ce in typeMap && (ce = typeMap[ce]),
        X.endsWith("Item") && X === ce + "Item")
            return;
        let me = `export function ${X}(`;
        me += generateFunctionParameters(ue),
        me += `): ${ce};`,
        ne.push(me)
    }
    ),
    ne.join(`
`)
}
function BFScriptEditor({language: V, height: X, theme: J, contents: ne, attachedRef: ue, access: ce, isDummy: me, isError: ge, onChange: Te}) {
    const _e = Le()
      , {rawBlueprint: Se} = reactExports.useContext(BlueprintContext)
      , Ie = Se ? getRawBlocklyDefinitions(Se) : void 0;
    return reactExports.useEffect( () => {
        if (_e && Ie && !me) {
            const ye = [];
            ye.push("export function Wait(n: number): Promise<void>;"),
            Ie.actions.forEach(at => {
                const {name: rt, category: ft} = at;
                if (ft === "Logic" && !["ChaseVariableAtRate", "ChaseVariableOverTime", "StopChasingVariable", "SetVariable", "SetObjectTransform", "MoveObject", "RotateObject"].includes(rt))
                    return;
                const St = generateActionFunctionDeclarations(at);
                ye.push(St)
            }
            );
            const $e = ye.join(`
`);
            _e.languages.typescript.typescriptDefaults.addExtraLib(`
                declare namespace mod {
                    ${$e}
                }

                `, "action functions");
            const Ne = [];
            Ie.values.forEach(at => {
                const rt = generateValueFunctionDeclarations(at);
                Ne.push(rt)
            }
            );
            const ve = Ne.join(`
`);
            _e.languages.typescript.typescriptDefaults.addExtraLib(`
                declare namespace mod {
                    ${ve}
                }

                `, "value functions");
            const ke = ["Number", "String", "Boolean"]
              , xe = [];
            xe.push("// eslint-disable-next-line @typescript-eslint/no-explicit-any"),
            xe.push("export type Any = any;"),
            ["SoldierKits"].forEach(at => {
                xe.push(`export type ${at} = Any;`)
            }
            ),
            xe.push(`
`);
            const Fe = new Set;
            Ie.values.forEach(at => {
                at.functionSignatures && at.functionSignatures.forEach(rt => {
                    rt.returnType && (ke.includes(rt.returnType) || Fe.add(rt.returnType))
                }
                )
            }
            ),
            Array.from(Fe).forEach(at => {
                if (at.startsWith("Enum_"))
                    return;
                const rt = `const ${at}Symbol: unique symbol;
export type ${at} = { _opaque: typeof ${at}Symbol };
`;
                xe.push(rt)
            }
            );
            const Xe = xe.join(`
`);
            _e.languages.typescript.typescriptDefaults.addExtraLib(`
                declare namespace mod {
                    ${Xe}
                }

                `, "types");
            const ze = [];
            Ie.objects.forEach(at => {
                ze.push(at.type)
            }
            );
            const Ze = `export type Object = ${ze.join(" | ")};`;
            _e.languages.typescript.typescriptDefaults.addExtraLib(`
                declare namespace mod {
                    ${Ze}
                }

                `, "object type declaration");
            const et = [];
            et.push(["", " export const stringkeys: Any;"]);
            const it = {};
            Ie.selectionLists.forEach(at => {
                const rt = at.listType;
                if (!rt)
                    return;
                const ft = at.selectionValues.map(St => {
                    let Ye = St.name;
                    return Ye.includes(" ") || Ye.includes("-") || Ye[0]in ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"] ? `"${Ye}"` : (Ye = Ye.replaceAll("&", "_"),
                    Ye = Ye.replaceAll("/", "_"),
                    Ye)
                }
                );
                rt in it ? ft.map(St => {
                    it[rt].add(St)
                }
                ) : it[rt] = new Set(ft)
            }
            ),
            Object.keys(it).forEach(at => {
                let rt = at;
                const ft = Array.from(it[rt]);
                ["SFX", "VE"].includes(rt) && (rt = "x" + rt);
                const Ye = `export enum ${rt} {
 ${ft.map(We => We).join(`,
`)}
}`;
                et.push([rt, Ye])
            }
            ),
            et.forEach(at => {
                _e.languages.typescript.typescriptDefaults.addExtraLib(`
                declare namespace mod {
                    ${at[1]}
                }

                `, `selection lists/${at[0]}`)
            }
            ),
            _e.languages.typescript.typescriptDefaults.addExtraLib(`
                declare namespace modlib {
                    ${modlib}
                }

                `, "modlib")
        }
    }
    , [_e, Ie, me]),
    jsxRuntimeExports.jsx(de, {
        height: X,
        defaultLanguage: V,
        language: V,
        value: ne,
        theme: J,
        onChange: () => {
            Te && !ge && Te()
        }
        ,
        onMount: ye => {
            ue && (ue.current = ye)
        }
        ,
        beforeMount: handleBeforeMount,
        options: {
            readOnly: accessMap[ce]
        }
    })
}
const standaloneBFScriptEditor = "_standaloneBFScriptEditor_16nun_1"
  , taskbar = "_taskbar_16nun_6"
  , taskbarLeftGroup = "_taskbarLeftGroup_16nun_16"
  , taskbarTextContainer = "_taskbarTextContainer_16nun_21"
  , flexibleEditorViewport = "_flexibleEditorViewport_16nun_27"
  , bfEditorTaskbarButton = "_bfEditorTaskbarButton_16nun_34"
  , selectorButton = "_selectorButton_16nun_42"
  , selected = "_selected_16nun_51"
  , selectorButtonContainer = "_selectorButtonContainer_16nun_58"
  , selectorPanelContainer = "_selectorPanelContainer_16nun_64"
  , selectorPanel = "_selectorPanel_16nun_64"
  , editorContainer = "_editorContainer_16nun_78"
  , errorTitle = "_errorTitle_16nun_84"
  , styles$a = {
    standaloneBFScriptEditor,
    taskbar,
    taskbarLeftGroup,
    taskbarTextContainer,
    flexibleEditorViewport,
    bfEditorTaskbarButton,
    selectorButton,
    selected,
    selectorButtonContainer,
    selectorPanelContainer,
    selectorPanel,
    editorContainer,
    errorTitle
}
  , StandaloneBFScriptEditor = ({children: V}) => {
    var Gt, Ht, Kt, Ot, kt, Xt, vt, Jt, Ct, Mt, nn, tn, mn, dn;
    const [X,J] = useAtom(attachmentsAtom)
      , {t: ne} = useTranslation()
      , ue = new TextDecoder
      , ce = X.find(Qt => Qt.attachmentType === AttachmentType.ATTACHMENT_TYPE_SCRIPT)
      , me = (Gt = ce == null ? void 0 : ce.attachmentData) == null ? void 0 : Gt.original
      , ge = X.find(Qt => Qt.attachmentType === AttachmentType.ATTACHMENT_TYPE_STRINGS)
      , Te = useAtomValue(isOwnerAtom)
      , _e = (Ht = ge == null ? void 0 : ge.attachmentData) == null ? void 0 : Ht.original
      , [Se,Ie] = useAtom(attachmentIdsPendingDeletionAtom)
      , [ye] = useAtom(scriptAttachmentAtom)
      , [$e] = useAtom(stringsAttachmentAtom)
      , [Ne,ve] = reactExports.useState("")
      , [ke,xe] = reactExports.useState(WARNING_VARIANTS.PROMPT)
      , [we,Fe] = reactExports.useState(!1)
      , [je] = useDebounce( () => {
        ve(""),
        Fe(!1)
    }
    , 1500)
      , [Xe,ze] = useDebounce( () => {
        Ke()
    }
    , 3e3)
      , qe = me ? ue.decode(me) : ye ? ue.decode(ye) : void 0
      , Ze = _e ? ue.decode(_e) : $e ? ue.decode($e) : void 0
      , et = (Kt = X.find(Qt => Qt.attachmentType === AttachmentType.ATTACHMENT_TYPE_SCRIPT)) == null ? void 0 : Kt.errors
      , it = (Ot = X.find(Qt => Qt.attachmentType === AttachmentType.ATTACHMENT_TYPE_STRINGS)) == null ? void 0 : Ot.errors
      , at = reactExports.useRef(null)
      , rt = [];
    qe != null && rt.push({
        language: "typescript",
        data: qe,
        fileType: AttachmentType.ATTACHMENT_TYPE_SCRIPT,
        fileName: (ce == null ? void 0 : ce.filename) ?? "Script.ts",
        access: Te ? "RW" : "R",
        isError: !1,
        fileId: ce == null ? void 0 : ce.id
    }),
    Ze != null && rt.push({
        language: "json",
        data: JSON.stringify(JSON.parse(Ze), void 0, 2),
        fileType: AttachmentType.ATTACHMENT_TYPE_STRINGS,
        fileName: (ge == null ? void 0 : ge.filename) ?? "Strings.json",
        access: Te ? "RW" : "R",
        isError: !1,
        fileId: ge == null ? void 0 : ge.id
    }),
    et != null && et.length > 0 && rt.push({
        language: "text",
        data: et.join(`
`),
        fileType: AttachmentType.UNRECOGNIZED,
        fileName: `Script.ts - ${et.length} Errors`,
        access: "R",
        isError: !0
    }),
    it != null && it.length > 0 && rt.push({
        language: "text",
        data: it.join(`
`),
        fileType: AttachmentType.UNRECOGNIZED,
        fileName: `Strings.json - ${it.length} Errors`,
        access: "R",
        isError: !0
    });
    const [ft,St] = reactExports.useState(rt.length > 0 ? 0 : -1)
      , [Ye,We] = reactExports.useState(!0)
      , nt = Qt => () => {
        ze(),
        Ke(),
        St(Qt)
    }
      , ct = Qt => {
        let on = "";
        switch (Qt) {
        case AttachmentType.ATTACHMENT_TYPE_SCRIPT:
            on = "Script";
            break;
        case AttachmentType.ATTACHMENT_TYPE_STRINGS:
            on = "Strings File";
            break;
        default:
            on = ""
        }
        return on
    }
      , Et = () => at.current.getValue() ?? ""
      , Ke = () => {
        if (rt[ft].isError)
            return;
        let Qt = "";
        if (rt[ft].fileType === AttachmentType.ATTACHMENT_TYPE_SCRIPT)
            Qt = Et();
        else if (rt[ft].fileType === AttachmentType.ATTACHMENT_TYPE_STRINGS) {
            Qt = Et();
            try {
                JSON.parse(Qt)
            } catch {
                Nt("Staging failed. Strings file does not have valid Json.", WARNING_VARIANTS.ERROR);
                return
            }
        }
        const {attachments: on, deletionIds: zt} = updateAttachmentsAndDeletionIds(X, Qt, rt[ft].fileId ?? "");
        J([...on]),
        zt.length && Ie([...Se, ...zt]),
        Nt("Changes staged", WARNING_VARIANTS.PROMPT)
    }
      , mt = () => {
        const Qt = generateAttachments("// Script starter", void 0)
          , {attachments: on, deletionIds: zt} = getNewAttachmentsAndDeletionIds(X, Qt);
        J([...on]),
        zt.length && Ie([...Se, ...zt])
    }
      , lt = () => {
        const Qt = generateAttachments(void 0, "{}")
          , {attachments: on, deletionIds: zt} = getNewAttachmentsAndDeletionIds(X, Qt);
        J([...on]),
        zt.length && Ie([...Se, ...zt])
    }
      , Qe = () => {
        const Qt = rt.find(Ut => Ut.fileType === AttachmentType.ATTACHMENT_TYPE_SCRIPT);
        if (Qt == null)
            return;
        const on = generateAttachments(void 0, generateStringFile(Qt.data))
          , {attachments: zt, deletionIds: $t} = getNewAttachmentsAndDeletionIds(X, on);
        J([...zt]),
        $t.length && Ie([...Se, ...$t])
    }
      , gt = Qt => () => {
        const on = X.filter(zt => zt.filename !== rt[Qt].fileName);
        J([...on]),
        Qt >= ft && St(common_utils.clamp(ft - 1, 0, ft))
    }
      , Nt = (Qt, on) => {
        ve(Qt),
        xe(on),
        Fe(!0),
        je()
    }
    ;
    return reactExports.useEffect( () => {
        const Qt = on => {
            (on.metaKey || on.ctrlKey) && on.key === "s" && (on.preventDefault(),
            Ke(),
            ze())
        }
        ;
        return window.addEventListener("keydown", Qt),
        () => {
            window.removeEventListener("keydown", Qt)
        }
    }
    , [ft]),
    reactExports.useEffect( () => {
        St(rt.length > 0 ? 0 : -1)
    }
    , [rt.length]),
    jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsxs("div", {
            className: styles$a.standaloneBFScriptEditor,
            children: [jsxRuntimeExports.jsxs("div", {
                className: styles$a.taskbar,
                children: [jsxRuntimeExports.jsxs("div", {
                    className: styles$a.taskbarLeftGroup,
                    children: [jsxRuntimeExports.jsx(IconButton, {
                        icon: ICON_NAMES.CHEVRON_LEFT,
                        className: styles$a.bfEditorTaskbarButton,
                        onClick: () => {
                            We(!Ye)
                        }
                        ,
                        transparent: !0
                    }), ft >= 0 && jsxRuntimeExports.jsx("div", {
                        className: styles$a.taskbarTextContainer,
                        children: jsxRuntimeExports.jsx("h4", {
                            children: `${(kt = rt[ft]) == null ? void 0 : kt.fileName} (${ct((Xt = rt[ft]) == null ? void 0 : Xt.fileType)})`
                        })
                    })]
                }), jsxRuntimeExports.jsx(ButtonGroup, {
                    children: V
                })]
            }), jsxRuntimeExports.jsxs("div", {
                className: styles$a.flexibleEditorViewport,
                children: [Ye && jsxRuntimeExports.jsxs("div", {
                    className: styles$a.selectorPanel,
                    children: [me === void 0 && jsxRuntimeExports.jsx("button", {
                        className: styles$a.selectorButton,
                        onClick: mt,
                        children: jsxRuntimeExports.jsx("div", {
                            className: styles$a.selectorButtonContainer,
                            children: jsxRuntimeExports.jsxs(Space, {
                                gapSize: SPACE_GAP_SIZE.XS,
                                children: [jsxRuntimeExports.jsx("div", {
                                    children: ne("general.create-blank-script-file")
                                }), jsxRuntimeExports.jsx(Icon, {
                                    size: ICON_SIZES.XS,
                                    name: ICON_NAMES.PLUS2
                                })]
                            })
                        })
                    }), _e === void 0 && jsxRuntimeExports.jsx("button", {
                        className: styles$a.selectorButton,
                        onClick: lt,
                        children: jsxRuntimeExports.jsx("div", {
                            className: styles$a.selectorButtonContainer,
                            children: jsxRuntimeExports.jsxs(Space, {
                                gapSize: SPACE_GAP_SIZE.XS,
                                children: [jsxRuntimeExports.jsx("div", {
                                    children: ne("general.create-blank-strings-file")
                                }), jsxRuntimeExports.jsx(Icon, {
                                    size: ICON_SIZES.XS,
                                    name: ICON_NAMES.PLUS2
                                })]
                            })
                        })
                    }), _e === void 0 && me !== void 0 && jsxRuntimeExports.jsx("button", {
                        className: styles$a.selectorButton,
                        onClick: Qe,
                        children: jsxRuntimeExports.jsx("div", {
                            className: styles$a.selectorButtonContainer,
                            children: jsxRuntimeExports.jsxs(Space, {
                                gapSize: SPACE_GAP_SIZE.XS,
                                children: [jsxRuntimeExports.jsx("div", {
                                    children: ne("general.generate-strings-file-from-script")
                                }), jsxRuntimeExports.jsx(Icon, {
                                    size: ICON_SIZES.XS,
                                    name: ICON_NAMES.PLUS2
                                })]
                            })
                        })
                    }), rt.map( (Qt, on) => jsxRuntimeExports.jsx("div", {
                        className: styles$a.selectorButtonContainer,
                        children: jsxRuntimeExports.jsxs(Space, {
                            className: Qt.isError ? styles$a.errorTitle : void 0,
                            children: [jsxRuntimeExports.jsx("button", {
                                onClick: nt(on),
                                className: common_utils.classNames(styles$a.selectorButton, ft === on && styles$a.selected),
                                children: Qt.fileName
                            }), !Qt.isError && jsxRuntimeExports.jsx(Tooltip, {
                                tip: ne("general.delete"),
                                children: jsxRuntimeExports.jsx(IconButton, {
                                    size: ICON_BUTTON_SIZE.XXXS,
                                    icon: ICON_NAMES.TRASH,
                                    transparent: !0,
                                    onClick: gt(on)
                                })
                            })]
                        })
                    }, `file-${on}`))]
                }), jsxRuntimeExports.jsxs("div", {
                    className: styles$a.editorContainer,
                    children: [ft < 0 && jsxRuntimeExports.jsx(BFScriptEditor, {
                        height: "70vh",
                        language: "txt",
                        contents: ne("general.create-get-started"),
                        theme: "vs-dark",
                        access: "R",
                        isDummy: !0,
                        isError: !0
                    }), ft >= 0 && !((vt = rt[ft]) != null && vt.isError) && jsxRuntimeExports.jsx(BFScriptEditor, {
                        height: "70vh",
                        language: ((Jt = rt[ft]) == null ? void 0 : Jt.language) ?? "typescript",
                        contents: ((Ct = rt[ft]) == null ? void 0 : Ct.data) ?? "",
                        theme: "vs-dark",
                        attachedRef: at,
                        access: (Mt = rt[ft]) == null ? void 0 : Mt.access,
                        isDummy: !1,
                        isError: (nn = rt[ft]) == null ? void 0 : nn.isError,
                        onChange: Xe
                    }), ft >= 0 && ((tn = rt[ft]) == null ? void 0 : tn.isError) && jsxRuntimeExports.jsx(BFScriptEditor, {
                        height: "70vh",
                        language: ((mn = rt[ft]) == null ? void 0 : mn.language) ?? "typescript",
                        contents: ((dn = rt[ft]) == null ? void 0 : dn.data) ?? "",
                        theme: "vs-dark",
                        attachedRef: at,
                        access: "R",
                        isDummy: !0,
                        isError: rt[ft].isError
                    })]
                })]
            })]
        }), jsxRuntimeExports.jsx("div", {
            children: we && jsxRuntimeExports.jsx(Warning, {
                text: Ne,
                variant: ke
            })
        })]
    })
}
  , title = "_title_1hfdw_1"
  , caption = "_caption_1hfdw_5"
  , styles$9 = {
    title,
    caption
}
  , logger$4 = Logger$1.get("ScriptManager")
  , ScriptManager = ({close: V}) => {
    const {colors: X, spacings: J} = reactExports.useContext(ThemeContext)
      , {addToast: ne} = reactExports.useContext(ToastContext)
      , [ue,ce] = useAtom(scriptAttachmentAtom)
      , [me,ge] = useAtom(stringsAttachmentAtom)
      , [Te,_e] = useAtom(attachmentsAtom)
      , [Se,Ie] = useAtom(attachmentIdsPendingDeletionAtom)
      , [ye,$e] = reactExports.useState("")
      , [Ne,ve] = reactExports.useState("")
      , [ke,xe] = reactExports.useState(0)
      , [we,Fe] = reactExports.useState("")
      , [je,Xe] = reactExports.useState("")
      , [ze,qe] = reactExports.useState(0)
      , Ze = Te.find(Ke => Ke.attachmentType === AttachmentType.ATTACHMENT_TYPE_SCRIPT)
      , et = Te.find(Ke => Ke.attachmentType === AttachmentType.ATTACHMENT_TYPE_STRINGS)
      , it = (ue || Ze) && !ye
      , at = (me || et) && !we
      , rt = () => {
        $e(""),
        ve(""),
        xe(0)
    }
      , ft = () => {
        rt()
    }
      , St = () => {
        loadFile( (Ke, mt, lt) => {
            var Qe, gt;
            if (typeof ((Qe = Ke.target) == null ? void 0 : Qe.result) == "string")
                try {
                    const Nt = (gt = Ke.target) == null ? void 0 : gt.result;
                    $e(Nt),
                    ve(mt ?? ""),
                    xe(lt ?? 0)
                } catch (Nt) {
                    console.error("Failed to read file", Nt)
                }
        }
        , [".ts", "application/typescript"])
    }
      , Ye = () => {
        Fe(""),
        Xe(""),
        qe(0)
    }
      , We = () => {
        Ye()
    }
      , nt = () => {
        loadFile( (Ke, mt, lt) => {
            var Qe, gt;
            if (typeof ((Qe = Ke.target) == null ? void 0 : Qe.result) == "string")
                try {
                    const Nt = (gt = Ke.target) == null ? void 0 : gt.result;
                    Fe(Nt),
                    Xe(mt ?? ""),
                    qe(lt ?? 0)
                } catch (Nt) {
                    console.error("Failed to read file", Nt)
                }
        }
        , [".json", "application/json"])
    }
      , ct = () => {
        const Ke = [];
        if (ye) {
            ce(null);
            const mt = {
                attachmentData: {
                    original: new TextEncoder().encode(ye),
                    compiled: void 0
                },
                attachmentType: AttachmentType.ATTACHMENT_TYPE_SCRIPT,
                errors: [],
                filename: Ne,
                id: generateUUID(),
                isProcessable: !0,
                metadata: void 0,
                processingStatus: ProcessingStatus.PROCESSING_STATUS_PENDING,
                version: SCRIPT_ATTACHMENT_TEMP_VERSION
            };
            Ke.push(mt)
        }
        if (we) {
            ge(null);
            try {
                JSON.parse(we);
                const mt = {
                    attachmentData: {
                        original: new TextEncoder().encode(we),
                        compiled: void 0
                    },
                    attachmentType: AttachmentType.ATTACHMENT_TYPE_STRINGS,
                    errors: [],
                    filename: je,
                    id: generateUUID(),
                    isProcessable: !1,
                    metadata: void 0,
                    processingStatus: ProcessingStatus.PROCESSING_STATUS_PROCESSED,
                    version: STRINGS_ATTACHMENT_TEMP_VERSION
                };
                Ke.push(mt)
            } catch (mt) {
                logger$4.debug("Error parsing Strings file", mt),
                ne(t$1("general.error-parsing-strings"))
            }
        } else if (!at && !we) {
            const mt = generateStringFile(ye);
            if (mt != "{}") {
                const lt = {
                    attachmentData: {
                        original: new TextEncoder().encode(mt),
                        compiled: void 0
                    },
                    attachmentType: AttachmentType.ATTACHMENT_TYPE_STRINGS,
                    errors: [],
                    filename: je,
                    id: generateUUID(),
                    isProcessable: !1,
                    metadata: void 0,
                    processingStatus: ProcessingStatus.PROCESSING_STATUS_PROCESSED,
                    version: STRINGS_ATTACHMENT_TEMP_VERSION
                };
                Ke.push(lt)
            }
        }
        if (Ke.length) {
            const {attachments: mt, deletionIds: lt} = getNewAttachmentsAndDeletionIds(Te, Ke);
            _e([...mt]),
            lt.length && (console.debug(`${lt == null ? void 0 : lt.length} existing script/string Attachments to delete upon next save`, lt),
            Ie([...Se, ...lt]))
        }
        rt(),
        Ye(),
        V()
    }
      , Et = () => {
        rt(),
        Ye(),
        V()
    }
    ;
    return jsxRuntimeExports.jsx(OffCanvasContent, {
        header: jsxRuntimeExports.jsxs(Space, {
            className: styles$9.title,
            children: [jsxRuntimeExports.jsx(Icon, {
                name: ICON_NAMES.IMPORT_EXPORT
            }), jsxRuntimeExports.jsx(Heading, {
                trimY: !0,
                variant: HEADING_VARIANT.SECONDARY_SUBHEADING,
                children: t$1("general.script-manager")
            })]
        }),
        footer: jsxRuntimeExports.jsxs(ButtonGroup, {
            className: styles$9.footerButtons,
            children: [jsxRuntimeExports.jsx(Button, {
                fillWidth: !0,
                color: X.primary,
                type: BUTTON_TYPES.SUBMIT,
                onClick: ct,
                children: t$1("general.import-file-s")
            }), jsxRuntimeExports.jsx(Button, {
                fillWidth: !0,
                variant: BUTTON_VARIANTS.SECONDARY,
                type: BUTTON_TYPES.SUBMIT,
                onClick: Et,
                children: t$1("general.cancel")
            })]
        }),
        id: DIALOG_ID.SCRIPT_MANAGER_OFF_CANVAS,
        children: jsxRuntimeExports.jsxs("div", {
            className: styles$9.scriptManager,
            children: [jsxRuntimeExports.jsxs(Section, {
                children: [jsxRuntimeExports.jsxs(Section, {
                    subsection: !0,
                    split: !0,
                    trimY: !0,
                    children: [jsxRuntimeExports.jsx(Heading, {
                        variant: HEADING_VARIANT.FIELD_LABEL,
                        children: t$1("general.custom-script")
                    }), jsxRuntimeExports.jsx(Tooltip, {
                        tip: t$1("general.choose-custom-typescript-file-to-use-as-custom-logic"),
                        placement: PLACEMENT.LEFT,
                        children: jsxRuntimeExports.jsx(Icon, {
                            name: ICON_NAMES.INFO,
                            color: X.gray500
                        })
                    })]
                }), jsxRuntimeExports.jsxs(Section, {
                    subsection: !0,
                    children: [" ", jsxRuntimeExports.jsx(ButtonGroup, {
                        fillWidth: !0,
                        gap: J.xxs,
                        children: jsxRuntimeExports.jsx(TextInput, {
                            label: t$1("general.import-file"),
                            placeholder: t$1("general.load-file"),
                            value: Ne,
                            action: {
                                text: t$1(Ne ? "general.cancel-current-script" : "general.select-file"),
                                onClick: Ne ? ft : St,
                                icon: Ne ? ICON_NAMES.TRASH : ICON_NAMES.FOLDER,
                                iconOnly: !0
                            },
                            fillWidth: !0,
                            readOnly: !0
                        })
                    }), jsxRuntimeExports.jsxs("div", {
                        className: styles$9.caption,
                        children: [jsxRuntimeExports.jsxs(Caption, {
                            children: [(ke / 1024).toFixed(2), "kb / 1024kb"]
                        }), jsxRuntimeExports.jsxs(Caption, {
                            children: [t$1("general.supported-files"), ": .ts"]
                        })]
                    }), it && jsxRuntimeExports.jsx(Warning, {
                        text: t$1("general.warning-already-have-custom-script-file-override")
                    })]
                })]
            }), jsxRuntimeExports.jsxs(Section, {
                children: [jsxRuntimeExports.jsxs(Section, {
                    subsection: !0,
                    split: !0,
                    trimY: !0,
                    children: [jsxRuntimeExports.jsx(Heading, {
                        variant: HEADING_VARIANT.FIELD_LABEL,
                        children: t$1("general.text-strings")
                    }), jsxRuntimeExports.jsx(Tooltip, {
                        tip: t$1("general.choose-json-file-key-value-pairs"),
                        placement: PLACEMENT.LEFT,
                        children: jsxRuntimeExports.jsx(Icon, {
                            name: ICON_NAMES.INFO,
                            color: X.gray500
                        })
                    })]
                }), jsxRuntimeExports.jsxs(Section, {
                    subsection: !0,
                    children: [jsxRuntimeExports.jsx(ButtonGroup, {
                        fillWidth: !0,
                        gap: J.xxs,
                        children: jsxRuntimeExports.jsx(TextInput, {
                            label: t$1("general.import-file"),
                            placeholder: t$1("general.load-file"),
                            value: je,
                            action: {
                                text: t$1(je ? "general.cancel-current-strings-file-import" : "general.select-file"),
                                onClick: je ? We : nt,
                                icon: je ? ICON_NAMES.TRASH : ICON_NAMES.FOLDER,
                                iconOnly: !0
                            },
                            fillWidth: !0,
                            readOnly: !0
                        })
                    }), jsxRuntimeExports.jsxs("div", {
                        className: styles$9.caption,
                        children: [jsxRuntimeExports.jsxs(Caption, {
                            children: [(ze / 1024).toFixed(2), "kb / 1024kb"]
                        }), jsxRuntimeExports.jsxs(Caption, {
                            children: [t$1("general.supported-files"), ": .json"]
                        })]
                    }), at && jsxRuntimeExports.jsx(Warning, {
                        text: t$1("general.warning-you-already-have-strings-file-will-override")
                    })]
                })]
            })]
        })
    })
}
  , checkBoxContainer = "_checkBoxContainer_1tixq_1"
  , styles$8 = {
    checkBoxContainer
}
  , ScriptEditorPage = () => {
    var mn, dn, Qt, on;
    const {colors: V} = reactExports.useContext(ThemeContext)
      , {blueprint: X} = reactExports.useContext(BlueprintContext)
      , J = useAtomValue(nameAtom)
      , ne = sanitizeFilename(J)
      , [ue,ce] = reactExports.useState(`${ne}_strings.json`)
      , [me,ge] = reactExports.useState(`${ne}_script.ts`)
      , [Te,_e] = reactExports.useState(`${ne}_spatial.json`)
      , [Se,Ie] = reactExports.useState(!1)
      , [ye,$e] = reactExports.useState(!1)
      , [Ne,ve] = reactExports.useState(!1)
      , ke = useAtomValue(spatialDataAttachmentAtom)
      , [xe,we] = useAtom(scriptAttachmentAtom)
      , [Fe,je] = useAtom(stringsAttachmentAtom)
      , [Xe,ze] = useAtom(attachmentsAtom)
      , qe = useAtomValue(workspaceAtom)
      , Ze = useAtomValue(isOwnerAtom)
      , et = reactExports.useRef(null)
      , {open: it} = useDialog(DIALOG_ID.BLOCK_TO_SCRIPT_EXPORT)
      , {open: at} = useDialog(DIALOG_ID.SCRIPT_EDITOR_CONFIRM_DELETE_SCRIPTS)
      , {open: rt, close: ft} = useOffCanvas(DIALOG_ID.SCRIPT_MANAGER_OFF_CANVAS)
      , {isMounted: St, loadRules: Ye, getWorkspaceExport: We} = usePyriteBlockly({
        mount: et,
        rulesVersion: (X == null ? void 0 : X.rulesVersion) ?? 0,
        definitions: X == null ? void 0 : X.blocklyDefinitions
    })
      , {open: nt} = useDialog(DIALOG_ID.EXPORT_SCRIPTS)
      , ct = new TextDecoder
      , Et = (dn = (mn = Xe.find(zt => zt.attachmentType === AttachmentType.ATTACHMENT_TYPE_SCRIPT)) == null ? void 0 : mn.attachmentData) == null ? void 0 : dn.original
      , Ke = (on = (Qt = Xe.find(zt => zt.attachmentType === AttachmentType.ATTACHMENT_TYPE_STRINGS)) == null ? void 0 : Qt.attachmentData) == null ? void 0 : on.original
      , mt = Et ? ct.decode(Et) : xe ? ct.decode(xe) : ""
      , lt = Ke ? ct.decode(Ke) : Fe ? ct.decode(Fe) : ""
      , Qe = ke ? ct.decode(ke) : ""
      , gt = mt || Qe || lt;
    St && Ye(qe);
    const Nt = zt => `${(new Blob([zt]).size / 1024).toFixed(2)}kb`
      , Gt = () => {
        rt()
    }
      , Ht = () => {
        nt()
    }
      , Kt = () => {
        at()
    }
      , Ot = () => {
        we(null),
        je(null),
        ze(Xe.filter(zt => zt.attachmentType !== AttachmentType.ATTACHMENT_TYPE_SCRIPT && zt.attachmentType !== AttachmentType.ATTACHMENT_TYPE_STRINGS))
    }
      , kt = () => {
        ye && mt && downloadFile(me || "script.ts", mt),
        Ne && Qe && downloadFile(Te || "spatial.json", Qe),
        Se && lt && downloadFile(ue || "strings.json", lt)
    }
      , Xt = zt => {
        ce(zt)
    }
      , vt = zt => {
        ge(zt)
    }
      , Jt = zt => {
        _e(zt)
    }
      , Ct = zt => {
        Ie(zt)
    }
      , Mt = zt => {
        $e(zt)
    }
      , nn = zt => {
        ve(zt)
    }
      , tn = () => {
        it()
    }
    ;
    return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsx(ExperienceHeading, {
            heading: t$1("general.rules-editor"),
            subheading: t$1("general.script"),
            title: t$1("general.edit-script")
        }), jsxRuntimeExports.jsxs(PageWrapper, {
            children: [jsxRuntimeExports.jsx("div", {
                ref: et,
                style: {
                    display: "none"
                }
            }), jsxRuntimeExports.jsx(StandaloneBFScriptEditor, {
                children: jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
                    children: jsxRuntimeExports.jsxs(ButtonGroup, {
                        children: [Ze && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                            children: [jsxRuntimeExports.jsx(Tooltip, {
                                tip: t$1("general.manage-scripts"),
                                children: jsxRuntimeExports.jsx(IconButton, {
                                    variant: ICON_BUTTON_VARIANT.TRANSPARENT,
                                    size: ICON_BUTTON_SIZE.SM,
                                    icon: ICON_NAMES.IMPORT_EXPORT,
                                    onClick: Gt,
                                    testId: TEST_ID.WORKSPACE_EXPORT_BUTTON
                                })
                            }), jsxRuntimeExports.jsx(Tooltip, {
                                tip: t$1("general.generate-script-from-blocks"),
                                children: jsxRuntimeExports.jsx(IconButton, {
                                    variant: ICON_BUTTON_VARIANT.TRANSPARENT,
                                    size: ICON_BUTTON_SIZE.SM,
                                    icon: ICON_NAMES.EXPORT,
                                    onClick: tn,
                                    testId: TEST_ID.EXPORT_BLOCKS_TO_SCRIPT
                                })
                            })]
                        }), gt && jsxRuntimeExports.jsx(Tooltip, {
                            tip: t$1("general.export-scripts"),
                            children: jsxRuntimeExports.jsx(IconButton, {
                                variant: ICON_BUTTON_VARIANT.TRANSPARENT,
                                size: ICON_BUTTON_SIZE.SM,
                                icon: ICON_NAMES.DOWNLOAD2,
                                onClick: Ht,
                                testId: TEST_ID.EXPORT_SCRIPTS
                            })
                        }), Ze && jsxRuntimeExports.jsx(Tooltip, {
                            tip: t$1("general.delete-all-scripts"),
                            children: jsxRuntimeExports.jsx(IconButton, {
                                variant: ICON_BUTTON_VARIANT.TRANSPARENT,
                                size: ICON_BUTTON_SIZE.SM,
                                icon: ICON_NAMES.TRASH,
                                onClick: Kt,
                                testId: TEST_ID.DELETE_ALL_SCRIPTS
                            })
                        })]
                    })
                })
            }), jsxRuntimeExports.jsxs(DialogContent, {
                id: DIALOG_ID.EXPORT_SCRIPTS,
                footer: jsxRuntimeExports.jsxs(ButtonGroup, {
                    fillWidth: !0,
                    children: [jsxRuntimeExports.jsx(Button, {
                        fillWidth: !0,
                        color: V.primary,
                        type: BUTTON_TYPES$1.SUBMIT,
                        isDisabled: !Se && !ye && !Ne,
                        onClick: kt,
                        children: t$1("general.export")
                    }), jsxRuntimeExports.jsx(Button, {
                        fillWidth: !0,
                        variant: BUTTON_VARIANTS.SECONDARY,
                        type: BUTTON_TYPES$1.SUBMIT,
                        children: t$1("general.cancel")
                    })]
                }),
                children: [lt && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                    children: [jsxRuntimeExports.jsx(Heading, {
                        variant: HEADING_VARIANT.FIELD_LABEL,
                        children: t$1("general.strings-file")
                    }), jsxRuntimeExports.jsxs(Section, {
                        subsection: !0,
                        trimY: !0,
                        split: !0,
                        children: [jsxRuntimeExports.jsx(TextInput, {
                            placeholder: t$1("general.filename"),
                            label: t$1("general.strings-file"),
                            value: ue,
                            onChange: Xt,
                            fillWidth: !0
                        }), jsxRuntimeExports.jsx("div", {
                            className: styles$8.checkBoxContainer,
                            children: jsxRuntimeExports.jsx(Checkbox, {
                                label: t$1("general.include-strings-file"),
                                checked: Se,
                                onChange: Ct
                            })
                        })]
                    }), jsxRuntimeExports.jsxs(Section, {
                        subsection: !0,
                        split: !0,
                        trimTop: !0,
                        children: [jsxRuntimeExports.jsx(Caption, {
                            children: Nt(lt)
                        }), jsxRuntimeExports.jsxs(Caption, {
                            children: [t$1("general.format"), ": .json"]
                        })]
                    })]
                }), mt && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                    children: [jsxRuntimeExports.jsx(Heading, {
                        variant: HEADING_VARIANT.FIELD_LABEL,
                        children: t$1("general.script-file")
                    }), jsxRuntimeExports.jsxs(Section, {
                        subsection: !0,
                        trimY: !0,
                        split: !0,
                        children: [jsxRuntimeExports.jsx(TextInput, {
                            placeholder: t$1("general.filename"),
                            label: t$1("general.script-file"),
                            value: me,
                            onChange: vt,
                            fillWidth: !0
                        }), jsxRuntimeExports.jsx("div", {
                            className: styles$8.checkBoxContainer,
                            children: jsxRuntimeExports.jsx(Checkbox, {
                                label: "Include Script File",
                                checked: ye,
                                onChange: Mt
                            })
                        })]
                    }), jsxRuntimeExports.jsxs(Section, {
                        subsection: !0,
                        split: !0,
                        trimTop: !0,
                        children: [jsxRuntimeExports.jsx(Caption, {
                            children: Nt(mt)
                        }), jsxRuntimeExports.jsxs(Caption, {
                            children: [t$1("general.format"), ": .js, .ts"]
                        })]
                    })]
                }), Qe && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                    children: [jsxRuntimeExports.jsx(Heading, {
                        variant: HEADING_VARIANT.FIELD_LABEL,
                        children: t$1("general.spatial-file")
                    }), jsxRuntimeExports.jsxs(Section, {
                        subsection: !0,
                        trimY: !0,
                        split: !0,
                        children: [jsxRuntimeExports.jsx(TextInput, {
                            placeholder: t$1("general.filename"),
                            label: t$1("general.spatial-file"),
                            value: Te,
                            onChange: Jt,
                            fillWidth: !0
                        }), jsxRuntimeExports.jsx("div", {
                            className: styles$8.checkBoxContainer,
                            children: jsxRuntimeExports.jsx(Checkbox, {
                                label: t$1("general.include-spatial-file"),
                                checked: Ne,
                                onChange: nn
                            })
                        })]
                    }), jsxRuntimeExports.jsxs(Section, {
                        subsection: !0,
                        split: !0,
                        trimTop: !0,
                        children: [jsxRuntimeExports.jsx(Caption, {
                            children: Nt(Qe)
                        }), jsxRuntimeExports.jsxs(Caption, {
                            children: [t$1("general.format"), ": .json"]
                        })]
                    })]
                })]
            }), jsxRuntimeExports.jsx(GenerateScriptDialog, {
                dialogId: DIALOG_ID.BLOCK_TO_SCRIPT_EXPORT,
                exportWorkspaceFn: We
            }), jsxRuntimeExports.jsx(DialogContent, {
                id: DIALOG_ID.SCRIPT_EDITOR_CONFIRM_DELETE_SCRIPTS,
                header: "Delete All Scripts",
                footer: jsxRuntimeExports.jsxs(ButtonGroup, {
                    fillWidth: !0,
                    children: [jsxRuntimeExports.jsx(Button, {
                        fillWidth: !0,
                        variant: BUTTON_VARIANTS.SECONDARY,
                        type: BUTTON_TYPES$1.SUBMIT,
                        testId: TEST_ID.DELETE_ALL_SCRIPTS_CANCEL,
                        children: t$1("general.cancel")
                    }), jsxRuntimeExports.jsx(Button, {
                        fillWidth: !0,
                        color: V.primary,
                        type: BUTTON_TYPES$1.SUBMIT,
                        onClick: Ot,
                        testId: TEST_ID.DELETE_ALL_SCRIPTS_CONFIRM,
                        children: t$1("general.confirm")
                    })]
                }),
                children: t$1("general.are-you-sure-delete-all-scripts")
            }), jsxRuntimeExports.jsx(ScriptManager, {
                close: ft
            })]
        })]
    })
}
  , grid = "_grid_1xx7v_1"
  , accordionHeading = "_accordionHeading_1xx7v_8"
  , topLevelAccordionHeading = "_topLevelAccordionHeading_1xx7v_16"
  , styles$7 = {
    grid,
    accordionHeading,
    topLevelAccordionHeading
}
  , MutatorAccordion = ({topLevelAccordion: V, mutatorElemArr: X}) => {
    const [J,ne] = reactExports.useState(new Set([V.id]))
      , {blueprint: ue} = reactExports.useContext(BlueprintContext)
      , {t: ce} = useTranslation()
      , me = X.reduce( (Ie, ye) => {
        const $e = ue == null ? void 0 : ue.mutators[ye.id].category;
        return $e && $e in Ie ? Ie[$e].push(ye) : $e ? Ie[$e] = [ye] : "misc"in Ie ? Ie.misc.push(ye) : Ie.misc = [ye],
        Ie
    }
    , {})
      , [ge,Te] = reactExports.useState(new Set(Object.keys(me)))
      , _e = Ie => {
        Te(new Set([...Ie]))
    }
      , Se = Ie => {
        ne(new Set(Array.from(Ie)))
    }
    ;
    return jsxRuntimeExports.jsx(Accordion, {
        activeIds: J,
        onChange: Se,
        items: [{
            id: V.id,
            header: jsxRuntimeExports.jsx("div", {
                className: common_utils.classNames(styles$7.accordionHeading, styles$7.topLevelAccordionHeading),
                children: jsxRuntimeExports.jsx(Heading, {
                    variant: HEADING_VARIANT.SECONDARY_SUBHEADING,
                    trimY: !0,
                    children: V.heading
                })
            }),
            body: jsxRuntimeExports.jsx(Accordion, {
                activeIds: ge,
                onChange: _e,
                items: Object.entries(me).sort( (Ie, ye) => {
                    const $e = ce(`mutator-categories.${Ie[0]}`)
                      , Ne = ce(`mutator-categories.${ye[0]}`);
                    return $e < Ne ? -1 : $e > Ne ? 1 : 0
                }
                ).map( ([Ie,ye]) => ({
                    id: Ie,
                    header: jsxRuntimeExports.jsx("div", {
                        className: styles$7.accordionHeading,
                        children: jsxRuntimeExports.jsx(Heading, {
                            variant: HEADING_VARIANT.SECONDARY_SUBHEADING,
                            trimY: !0,
                            children: Ie
                        })
                    }),
                    body: jsxRuntimeExports.jsx(Section, {
                        trimX: !0,
                        className: styles$7.grid,
                        children: ye.sort( ($e, Ne) => {
                            const ve = ue == null ? void 0 : ue.mutators[$e.id]
                              , ke = ue == null ? void 0 : ue.mutators[Ne.id]
                              , xe = ce((ve == null ? void 0 : ve.translationIds.name) ?? $e.id)
                              , we = ce((ke == null ? void 0 : ke.translationIds.name) ?? Ne.id)
                              , Fe = (ve == null ? void 0 : ve.displayPriority) ?? 0
                              , je = (ke == null ? void 0 : ke.displayPriority) ?? 0;
                            return Fe < je ? -1 : Fe > je ? 1 : xe < we ? -1 : xe > we ? 1 : 0
                        }
                        ).map( ($e, Ne) => jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
                            children: $e.elem
                        }, $e.id + Ne))
                    })
                }))
            })
        }]
    })
}
  , getTimeFormatter = V => ({
    format: X => {
        const J = V === RANGE_MUTATOR_DISPLAY_FORMAT.SECONDS ? "s" : "m"
          , ne = V === RANGE_MUTATOR_DISPLAY_FORMAT.SECONDS ? "m" : "h";
        if (typeof X == "number") {
            const ue = X < 0
              , ce = Math.abs(X)
              , me = Math.floor(ce / 60)
              , ge = ce % 60;
            return `${ue ? "-" : ""}${me || ""}${me ? `${ne}` : ""}${!ge && me ? "" : `${ge}${J}`}`.trim()
        } else
            return X
    }
    ,
    parse: X => {
        const J = X == null ? void 0 : X.trim()
          , ne = V === RANGE_MUTATOR_DISPLAY_FORMAT.SECONDS ? /^(\d+m)?(\d+s)?$/ : /^(\d+h)?(\d+m)?$/
          , ue = J == null ? void 0 : J.startsWith("-")
          , ce = ue ? J == null ? void 0 : J.substring(1) : J;
        if (ce && ne.test(ce)) {
            const me = ce.match(/(\d+)m/)
              , ge = me ? Number(me[1]) : 0;
            if (V === RANGE_MUTATOR_DISPLAY_FORMAT.SECONDS) {
                const Te = ce.match(/(\d+)s/)
                  , _e = Te ? Number(Te[1]) : 0
                  , Ie = ge * 60 + _e
                  , ye = isNaN(Ie) ? 0 : Ie;
                return ue && ye !== 0 ? -ye : ye
            } else {
                const Te = ce.match(/(\d+)h/)
                  , Ie = (Te ? Number(Te[1]) : 0) * 60 + ge
                  , ye = isNaN(Ie) ? 0 : Ie;
                return ue && ye !== 0 ? -ye : ye
            }
        } else
            return isNaN(Number(X)) ? void 0 : Number(X)
    }
})
  , percentFormatter = {
    format: V => {
        const X = Number(V);
        return isNaN(X) || V === void 0 || V === "" ? void 0 : `${V}%`
    }
    ,
    parse: V => {
        const X = V == null ? void 0 : V.toString().replaceAll("%", "");
        if (X !== void 0)
            return isNaN(+X) ? void 0 : +X
    }
}
  , mutatorTitle = "_mutatorTitle_dkknz_1"
  , wrapper$1 = "_wrapper_dkknz_7"
  , mutator = "_mutator_dkknz_1"
  , styles$6 = {
    mutatorTitle,
    wrapper: wrapper$1,
    mutator
}
  , Mutators = ({items: V, teamIdx: X, isDisabled: J, perTeamMutatorsSlot: ne=[], globalMutatorsSlot: ue=[], showConflictWarningOverride: ce, showValidationErrors: me}) => {
    const {blueprint: ge} = reactExports.useContext(BlueprintContext)
      , [Te,_e] = useAtom(mutatorsAtom)
      , Se = useAtomValue(isOwnerAtom)
      , Ie = useAtomValue(numberOfTeamsAtom)
      , ye = useAtomValue(currentTeamsBeingEditedAtom)
      , $e = useAtomValue(isCustomGameModeAtom)
      , {t: Ne} = useTranslation()
      , [ve,ke] = reactExports.useState([])
      , [xe,we] = reactExports.useState()
      , {open: Fe} = useDialog(DIALOG_ID.CONFIRM_SYNC_TEAMS, {
        onSubmit: () => {
            xe && (xe(),
            we(void 0))
        }
    })
      , je = api.get(COOKIE_KEY.ACCEPTED_CONFLICT_DIALOG);
    let Xe = !1;
    const ze = We => nt => {
        ge && (_e(getPatchedMutatorValue({
            newValue: nt,
            mutatorsState: Te,
            mutatorId: We,
            mutatorMeta: ge.mutators[We],
            numberOfTeams: Ie,
            teamIndexes: ye
        })),
        ve.includes(We) || ke([...ve, We]))
    }
      , qe = We => nt => ct => {
        if (!ge)
            return;
        let Et = ct;
        We === RANGE_MUTATOR_DISPLAY_FORMAT.PERCENT && (Et = typeof ct == "number" ? common_utils.roundToPrecision(ct / 100, 100) : ct),
        _e(getPatchedMutatorValue({
            newValue: Et,
            mutatorsState: Te,
            mutatorId: nt,
            mutatorMeta: ge.mutators[nt],
            numberOfTeams: Ie,
            teamIndexes: ye
        })),
        ve.includes(nt) || ke([...ve, nt])
    }
      , Ze = (We, nt, ct) => Et => {
        nt && !je ? (we( () => () => {
            ct(We)(Et)
        }
        ),
        Fe()) : ct(We)(Et)
    }
      , et = We => nt => {
        ge && (nt === void 0 || nt === "") && _e(getPatchedMutatorValue({
            newValue: ge.mutators[We].defaultValue,
            mutatorsState: Te,
            mutatorId: We,
            mutatorMeta: ge.mutators[We],
            numberOfTeams: Ie,
            teamIndexes: ye
        }))
    }
      , at = Object.keys(Te).filter(We => {
        var ct;
        const nt = ge == null ? void 0 : ge.mutators[We];
        return nt && nt.parentActiveValue !== void 0 && ((ct = nt.childMutators) == null ? void 0 : ct.length) && Te[We] === nt.parentActiveValue
    }
    ).flatMap(We => {
        var nt;
        return ((nt = ge == null ? void 0 : ge.mutators[We].childMutators) == null ? void 0 : nt.map( ({name: ct}) => ct)) ?? []
    }
    )
      , rt = Object.entries(V).filter(We => !We[1].isInternal).map( ([We,nt]) => {
        const {mutatorUi: ct, translationIds: Et, isDisabled: Ke, parentActiveValue: mt, childMutators: lt} = nt
          , Qe = nt.defaultValue
          , gt = Ne(Et.name)
          , Nt = Et.description ? Ne(Et.description) : void 0
          , Gt = at.includes(We)
          , Ht = getTeamsGroupedByMutatorOrAssetTagValue({
            mutator: Te[We],
            teamIndexesToCheck: ye ?? []
        })
          , Kt = ye !== void 0 && Ht.length > 1;
        Kt && (Xe = !0);
        const Ot = mt !== void 0 && (lt != null && lt.length) || Gt ? jsxRuntimeExports.jsxs("div", {
            className: styles$6.mutatorTitle,
            children: [gt, " ", jsxRuntimeExports.jsx(Icon, {
                name: ICON_NAMES.SKULL
            })]
        }) : gt
          , kt = {
            caption: Nt,
            title: Ot,
            isDisabled: J || Ke || !Se || Gt,
            className: styles$6.mutator,
            testId: We,
            unavailable: Kt
        };
        switch (ct) {
        case MUTATOR_UI_NAMES.NUMBER:
            if (nt.range) {
                const Xt = getMutatorValue(Te[We], ve.includes(We) ? void 0 : Qe, X);
                let vt, Jt = nt.range.min, Ct = nt.range.max, Mt = Number(Xt), nn = nt.step;
                switch (nt.displayFormat) {
                case RANGE_MUTATOR_DISPLAY_FORMAT.MINUTES:
                    {
                        vt = getTimeFormatter(RANGE_MUTATOR_DISPLAY_FORMAT.MINUTES);
                        break
                    }
                case RANGE_MUTATOR_DISPLAY_FORMAT.SECONDS:
                    {
                        vt = getTimeFormatter(RANGE_MUTATOR_DISPLAY_FORMAT.SECONDS);
                        break
                    }
                case RANGE_MUTATOR_DISPLAY_FORMAT.PERCENT:
                    {
                        vt = percentFormatter,
                        Jt = common_utils.roundToPrecision(nt.range.min * 100),
                        Ct = common_utils.roundToPrecision(nt.range.max * 100),
                        Mt = typeof Xt == "number" ? common_utils.roundToPrecision(Xt * 100) : 0,
                        nn = nt.step * 100;
                        break
                    }
                }
                return {
                    id: We,
                    elem: jsxRuntimeExports.jsx(NumberMutator, {
                        formatter: vt,
                        step: nn,
                        onChange: Ze(We, Kt, qe(nt.displayFormat)),
                        options: {
                            min: Jt,
                            max: Ct,
                            label: gt
                        },
                        value: Kt ? "--" : typeof Xt == "boolean" ? void 0 : typeof Xt == "number" ? Mt : Xt,
                        onBlur: et(We),
                        ...kt
                    }, We)
                }
            }
            break;
        case MUTATOR_UI_NAMES.SELECT:
            {
                const Xt = nt.availableValues;
                if (Xt) {
                    const vt = {
                        items: Xt.map(Ct => {
                            var Mt, nn;
                            return {
                                label: Ne(((nn = (Mt = nt == null ? void 0 : nt.translationIds) == null ? void 0 : Mt.options) == null ? void 0 : nn.get(Ct.toString())) ?? Ct.toString()),
                                value: Ct
                            }
                        }
                        )
                    }
                      , Jt = Kt ? void 0 : getMutatorValue(Te[We], Qe, X);
                    return {
                        id: We,
                        elem: jsxRuntimeExports.jsx(SelectMutator, {
                            onChange: Ze(We, Kt, ze),
                            value: Jt,
                            options: vt,
                            ...kt
                        }, We)
                    }
                }
                break
            }
        case MUTATOR_UI_NAMES.BOOL:
            {
                const Xt = {
                    name: "",
                    off: {
                        label: Ne("general.off"),
                        value: !1
                    },
                    on: {
                        label: Ne("general.on"),
                        value: !0
                    }
                }
                  , vt = Kt ? void 0 : getMutatorValue(Te[We], Qe, X);
                return {
                    id: We,
                    elem: jsxRuntimeExports.jsx(BoolMutator, {
                        onChange: Ze(We, Kt, ze),
                        value: Kt ? !1 : vt,
                        options: Xt,
                        ...kt
                    }, We)
                }
            }
        }
    }
    ).filter(We => We !== void 0)
      , ft = [...rt.filter( ({id: We}) => ge == null ? void 0 : ge.mutators[We].isPerTeam), ...ne]
      , St = [...rt.filter( ({id: We}) => !(ge != null && ge.mutators[We].isPerTeam)), ...ue]
      , Ye = St.length || ue.length || !$e && (ne || ft.length);
    return jsxRuntimeExports.jsxs(PageWrapper, {
        paddingSize: PAGE_WRAPPER_PADDING.NONE,
        className: styles$6.wrapper,
        children: [me && jsxRuntimeExports.jsx(ValidationFails, {
            keyFilters: Array.isArray(me) ? me : void 0
        }), Ye ? jsxRuntimeExports.jsx(MutatorAccordion, {
            mutatorElemArr: $e ? St : [...ft, ...St],
            topLevelAccordion: {
                id: "global",
                heading: Ne("general.global-settings")
            }
        }) : null, $e && ft.length ? jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [(Xe || ce) && jsxRuntimeExports.jsx(Warning, {
                text: Ne("experience.team-values-conflicting")
            }), jsxRuntimeExports.jsx(TeamSelect, {
                children: jsxRuntimeExports.jsx("div", {
                    className: styles$6.perTeamMutatorsSection,
                    children: jsxRuntimeExports.jsx(MutatorAccordion, {
                        mutatorElemArr: ft,
                        topLevelAccordion: {
                            id: "per-team",
                            heading: Ne("general.team-settings")
                        }
                    })
                })
            })]
        }) : null]
    })
}
  , StandardModifiersPage = ({tags: V=[], mutatorIds: X=[]}) => {
    var ge;
    const {blueprint: J} = reactExports.useContext(BlueprintContext)
      , ne = (ge = useAtomValue(currentTeamsBeingEditedAtom)) == null ? void 0 : ge[0]
      , ue = useAtomValue(gameModeAtom)
      , {mutators: ce={}} = J ?? {}
      , me = getMutatorsForPage({
        mutators: ce,
        tags: V,
        gameMode: ue,
        mutatorIds: X
    });
    return jsxRuntimeExports.jsx(PageWrapper, {
        children: jsxRuntimeExports.jsx(Mutators, {
            items: me,
            teamIdx: ne
        })
    })
}
  , logger$3 = Logger$1.get("createModDataVersion")
  , useCreateModDataVersion = () => {
    const {sessionId: V} = reactExports.useContext(SessionContext)
      , X = useAtomValue(playElementIdAtom)
      , J = useMutation({
        mutationFn: () => V ? clients.play.createModDataVersion({
            playElementId: X
        }, new grpcWebClient_umdExports.grpc.Metadata({
            "x-gateway-session-id": V
        })) : Promise.reject()
    });
    return async (ue, ce) => {
        try {
            const me = await J.mutateAsync();
            me && (logger$3.log("Created Mod Data Version Successfully!", me),
            ue && ue(me))
        } catch (me) {
            Logger$1.error("Failed to create mod data version: ", me),
            ce && ce()
        }
    }
}
  , useUploadModData = () => {
    const V = async (X, J) => await fetch(X, {
        method: "PUT",
        body: J
    });
    return useMutation({
        mutationFn: ({url: X, payload: J}) => V(X, J)
    })
}
;
async function getModDataVersionList(V, X) {
    if (!X) {
        const J = new Error("Missing session!");
        throw J.name = "Unauthenticated",
        J
    }
    return await clients.play.listModDataVersions(V, new grpcWebClient_umdExports.grpc.Metadata({
        "x-gateway-session-id": X
    }))
}
const useListModDataVersions = V => {
    const {sessionId: X} = reactExports.useContext(SessionContext)
      , {data: J, isFetching: ne, error: ue} = useQuery({
        queryKey: [QUERY_KEY.LIST_MOD_DATA_VERSIONS, V],
        queryFn: () => getModDataVersionList({
            playElementId: V
        }, X),
        staleTime: MS_30_SECONDS
    });
    return {
        versions: (J == null ? void 0 : J.modDataVersions.sort( (me, ge) => {
            var Te, _e;
            return (((Te = me.created) == null ? void 0 : Te.getTime()) ?? 0) > (((_e = ge.created) == null ? void 0 : _e.getTime()) ?? 0) ? -1 : 1
        }
        )) ?? [],
        isFetching: ne,
        error: ue
    }
}
  , cell = "_cell_f9g69_1"
  , styles$5 = {
    cell
}
  , logger$2 = Logger$1.get("SuperUser")
  , SuperUserPage = () => {
    var qe;
    const V = useCreateModDataVersion()
      , X = useAtomValue(isOwnerAtom)
      , J = useAtomValue(playElementIdAtom)
      , [ne,ue] = useAtom(patchIdAtom)
      , [ce,me] = reactExports.useState()
      , [ge,Te] = reactExports.useState(null)
      , {mutate: _e, status: Se} = useUploadModData()
      , {colors: Ie} = reactExports.useContext(ThemeContext)
      , {versions: ye, isFetching: $e, error: Ne} = useListModDataVersions(J)
      , [ve,ke] = reactExports.useState("")
      , {t: xe} = useTranslation()
      , we = () => {
        loadFile( (Ze, et, it) => {
            var at, rt;
            if (typeof ((at = Ze.target) == null ? void 0 : at.result) == "string")
                try {
                    const ft = (rt = Ze.target) == null ? void 0 : rt.result;
                    logger$2.debug(`Reading attachment ${et}, ${it}`),
                    Te(ft),
                    ke(et ?? "")
                } catch (ft) {
                    console.error("Failed to read file", ft)
                }
        }
        , [".json", "application/json"])
    }
      , Fe = Ze => {
        ue(Ze ? Ze.toString() : null)
    }
      , je = Ze => {
        Ze && ge && (_e({
            payload: ge,
            url: Ze.signedUrl
        }),
        me(Ze))
    }
      , Xe = () => {
        V(je)
    }
      , ze = ["pending", "error", "success", "noBuildAvailable"];
    return jsxRuntimeExports.jsxs(PageWrapper, {
        children: [jsxRuntimeExports.jsx(Section, {
            children: $e ? jsxRuntimeExports.jsx(Heading, {
                children: xe("general.loading-version-statuses")
            }) : Ne ? jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                children: [xe("general.error-load-versions"), ": ", JSON.stringify(Ne)]
            }) : jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                children: [jsxRuntimeExports.jsx(Heading, {
                    children: xe("general.current-versions")
                }), jsxRuntimeExports.jsxs(Table, {
                    children: [jsxRuntimeExports.jsxs(TableRow, {
                        children: [jsxRuntimeExports.jsx(TableCell, {
                            children: xe("general.build-info")
                        }), jsxRuntimeExports.jsx(TableCell, {
                            children: xe("general.details")
                        }), jsxRuntimeExports.jsx(TableCell, {
                            children: xe("general.id")
                        }), jsxRuntimeExports.jsx(TableCell, {
                            children: xe("general.create-date")
                        })]
                    }), ye.map( ({id: Ze, created: et, buildInfo: it}) => {
                        const at = ze.find(rt => it && it[rt] !== void 0);
                        return jsxRuntimeExports.jsxs(TableRow, {
                            children: [jsxRuntimeExports.jsx(TableCell, {
                                color: Ie.white,
                                children: at === void 0 ? "–" : jsxRuntimeExports.jsxs("div", {
                                    className: styles$5.cell,
                                    children: [at === "error" && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                                        children: [jsxRuntimeExports.jsx(Icon, {
                                            name: ICON_NAMES.CLOSE,
                                            color: Ie.dangerVibrant
                                        }), " ", xe("general.error"), jsxRuntimeExports.jsx(Tooltip, {
                                            tip: xe("general.cook-patch-error"),
                                            children: jsxRuntimeExports.jsx(Icon, {
                                                name: ICON_NAMES.INFO,
                                                color: Ie.gray600
                                            })
                                        })]
                                    }), at === "pending" && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                                        children: [xe("general.pending"), jsxRuntimeExports.jsx(Tooltip, {
                                            tip: xe("general.cook-patch-complete"),
                                            children: jsxRuntimeExports.jsx(Icon, {
                                                name: ICON_NAMES.INFO,
                                                color: Ie.gray600
                                            })
                                        })]
                                    }), at === "noBuildAvailable" && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                                        children: [xe("general.no-build-available"), jsxRuntimeExports.jsx(Tooltip, {
                                            tip: xe("general.cook-patch-not-available"),
                                            children: jsxRuntimeExports.jsx(Icon, {
                                                name: ICON_NAMES.INFO,
                                                color: Ie.gray600
                                            })
                                        })]
                                    }), at === "success" && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                                        children: [jsxRuntimeExports.jsx(Icon, {
                                            name: ICON_NAMES.CHECK,
                                            color: "green"
                                        }), " ", xe("general.success"), jsxRuntimeExports.jsx(Tooltip, {
                                            tip: xe("general.cook-patch-success"),
                                            children: jsxRuntimeExports.jsx(Icon, {
                                                name: ICON_NAMES.INFO,
                                                color: Ie.gray600
                                            })
                                        })]
                                    })]
                                })
                            }), jsxRuntimeExports.jsx(TableCell, {
                                color: Ie.white,
                                children: at ? JSON.stringify(it == null ? void 0 : it[at]) : "–"
                            }), jsxRuntimeExports.jsx(TableCell, {
                                color: Ie.white,
                                children: Ze
                            }), jsxRuntimeExports.jsx(TableCell, {
                                color: Ie.white,
                                children: (et == null ? void 0 : et.toLocaleString()) ?? ""
                            })]
                        }, Ze)
                    }
                    )]
                })]
            })
        }), jsxRuntimeExports.jsxs(Section, {
            split: !0,
            children: [jsxRuntimeExports.jsxs(Section, {
                subsection: !0,
                children: [jsxRuntimeExports.jsx(Heading, {
                    children: xe("general.upload-mod-strings")
                }), jsxRuntimeExports.jsx(TextInput, {
                    disabled: !X,
                    label: xe("general.import-file"),
                    placeholder: xe("general.load-file"),
                    value: ve,
                    action: {
                        text: xe("general.select-file"),
                        onClick: we,
                        icon: ICON_NAMES.FOLDER
                    }
                }), ge && jsxRuntimeExports.jsx(Button, {
                    onClick: Xe,
                    children: xe("general.upload")
                }), ce && jsxRuntimeExports.jsxs(Section, {
                    subsection: !0,
                    children: [jsxRuntimeExports.jsx(Heading, {
                        children: xe("general.details")
                    }), jsxRuntimeExports.jsxs(List, {
                        children: [jsxRuntimeExports.jsxs(ListItem, {
                            children: [xe("general.signed-url"), jsxRuntimeExports.jsx(TextInput, {
                                fillWidth: !0,
                                readOnly: !0,
                                value: ce.signedUrl,
                                label: xe("general.signed-url")
                            })]
                        }), jsxRuntimeExports.jsxs(ListItem, {
                            children: [xe("general.valid-until"), ": ", jsxRuntimeExports.jsx(Chip, {
                                children: (qe = ce.validUntil) == null ? void 0 : qe.toString()
                            })]
                        }), jsxRuntimeExports.jsxs(ListItem, {
                            children: [xe("general.mod-level-data-id"), ": ", jsxRuntimeExports.jsx(Chip, {
                                children: ce.modLevelDataId
                            })]
                        }), jsxRuntimeExports.jsxs(ListItem, {
                            children: [xe("general.status"), ":", " ", Se === "pending" && jsxRuntimeExports.jsx(LoadingSpinner, {
                                statusText: xe("general.uploading")
                            }), Se === "success" && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                                children: [xe("general.upload-successful"), jsxRuntimeExports.jsx(Icon, {
                                    name: ICON_NAMES.CHECK,
                                    color: Ie.primary
                                })]
                            }), Se === "error" && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                                children: [xe("general.upload-failed"), jsxRuntimeExports.jsx(Icon, {
                                    name: ICON_NAMES.CLOSE,
                                    color: Ie.dangerVibrant
                                })]
                            })]
                        })]
                    })]
                })]
            }), jsxRuntimeExports.jsx(Section, {
                subsection: !0,
                children: jsxRuntimeExports.jsx(TextInput, {
                    label: xe("general.patch-id"),
                    value: ne ?? void 0,
                    onChange: Fe,
                    dir: "ltr",
                    placeholder: xe("general.patch-id")
                })
            })]
        })]
    })
}
  , confirmContent = "_confirmContent_iqv9s_1"
  , label = "_label_iqv9s_5"
  , doNotShowAgainContent = "_doNotShowAgainContent_iqv9s_10"
  , styles$4 = {
    confirmContent,
    label,
    doNotShowAgainContent
}
  , TeamDistributionPage = () => {
    var Wt, ut;
    const {blueprint: V} = reactExports.useContext(BlueprintContext)
      , X = useAtomValue(gameModeAtom)
      , [J=[],ne] = useAtom(currentTeamsBeingEditedAtom)
      , ue = useAtomValue(isTeamsSyncedAtom)
      , [ce,me] = useAtom(teamCompositionAtom)
      , [ge,Te] = useAtom(mutatorsAtom)
      , _e = useAtomValue(numberOfTeamsAtom)
      , Se = useAtomValue(gameSizeAtom)
      , Ie = useAtomValue(isCustomGameModeAtom)
      , {open: ye, close: $e} = useDialog(DIALOG_ID.EQUALIZE_TEAMS, {
        onSubmit: () => {
            We !== void 0 && (We(),
            nt(void 0))
        }
    })
      , [Ne,ve] = reactExports.useState(_e)
      , [ke,xe] = reactExports.useState(!1)
      , we = V == null ? void 0 : V.mutators[MAX_PLAYER_COUNT_MUTATOR_ID]
      , Fe = V == null ? void 0 : V.gameModes.find( ({id: Ge}) => Ge === X)
      , je = (Fe == null ? void 0 : Fe.teamRange.min) ?? DEFAULT_MIN_TEAM_COUNT
      , Xe = (Fe == null ? void 0 : Fe.teamRange.max) ?? DEFAULT_GAME_SIZE_MAX
      , ze = (Fe == null ? void 0 : Fe.playerSize.range.min) ?? DEFAULT_MIN_TEAM_COUNT
      , qe = (Fe == null ? void 0 : Fe.playerSize.range.max) ?? DEFAULT_GAME_SIZE_MAX
      , Ze = Array.from(ce ?? [])
      , et = useAtomValue(aiTypeAtom)
      , it = Ze.filter( ([Ge]) => J.includes(Ge - 1))
      , at = it.every(Ge => Ge[1].humanCapacity === it[0][1].humanCapacity)
      , rt = it.every(Ge => Ge[1].aiCapacity === it[0][1].aiCapacity)
      , ft = Ze.every(Ge => {
        const {humanCapacity: st=0, aiType: ht, aiCapacity: At=0} = Ge[1]
          , {humanCapacity: Ft=0, aiCapacity: an=0} = Ze[0][1]
          , Sn = st - Ft;
        if (ht === InternalCapacityType.AI_STATIC) {
            const Rn = At - an;
            if (Rn < -1 || Rn > 1)
                return !1
        }
        return !(Sn < -1 || Sn > 1)
    }
    )
      , [St,Ye] = reactExports.useState()
      , [We,nt] = reactExports.useState()
      , {open: ct} = useDialog(DIALOG_ID.CONFIRM_SYNC_TEAMS, {
        onSubmit: () => {
            St && (St(),
            Ye(void 0))
        }
    })
      , Et = api.get(COOKIE_KEY.ACCEPTED_CONFLICT_DIALOG)
      , Ke = api.get(COOKIE_KEY.DO_NOT_AGAIN_EQUALIZE_TEAMS_DIALOG)
      , mt = getIsConflict(ge[MAX_PLAYER_COUNT_MUTATOR_ID], J, !0)
      , lt = getIsConflict(ge[AI_MAX_COUNT_MUTATOR_ID], J, !0)
      , Qe = getIsConflict(ge[SPAWN_TYPE_MUTATOR_ID], J)
      , gt = mt || lt || Qe
      , Nt = at ? (Wt = ce == null ? void 0 : ce.get((J[0] ?? DEFAULT_SELECTED_TEAM_ID) + 1)) == null ? void 0 : Wt.humanCapacity : void 0
      , Gt = rt ? (ut = ce == null ? void 0 : ce.get((J[0] ?? DEFAULT_SELECTED_TEAM_ID) + 1)) == null ? void 0 : ut.aiCapacity : void 0
      , {t: Ht} = useTranslation()
      , Kt = Ge => {
        const st = getNewTeamDistribution(Se ?? 0, Ge ?? 1, MUTATOR_AI_SPAWN_TYPE_TO_CAPACITY_TYPE.get(Number(et)));
        me(st),
        ve(Ge);
        const ht = J.filter(At => At < (Ge ?? DEFAULT_SELECTED_TEAM_ID));
        ht.length !== J.length && ne(ht)
    }
      , Ot = Ge => {
        J.length ? J.forEach(st => {
            const ht = st + 1
              , At = (ce == null ? void 0 : ce.get(ht)) ?? {
                humanCapacity: 0,
                aiCapacity: 0
            };
            ce == null || ce.set(ht, {
                ...At,
                humanCapacity: Ge
            })
        }
        ) : Array.from(ce ?? []).forEach( ([st,ht]) => {
            ce == null || ce.set(st, {
                ...ht,
                humanCapacity: Ge
            })
        }
        ),
        me(new Map(ce))
    }
      , kt = Ge => {
        J.length ? J.forEach(st => {
            const ht = st + 1
              , At = (ce == null ? void 0 : ce.get(ht)) ?? {
                humanCapacity: 0,
                aiCapacity: 0
            };
            ce == null || ce.set(ht, {
                ...At,
                aiCapacity: Ge,
                aiType: MUTATOR_AI_SPAWN_TYPE_TO_CAPACITY_TYPE.get(Number(et))
            })
        }
        ) : Array.from(ce ?? []).forEach( ([st,ht]) => {
            ce == null || ce.set(st, {
                ...ht,
                aiCapacity: Ge,
                aiType: MUTATOR_AI_SPAWN_TYPE_TO_CAPACITY_TYPE.get(Number(et))
            })
        }
        ),
        me(new Map(ce))
    }
      , Xt = Ge => {
        if (V != null && V.mutators[SPAWN_TYPE_MUTATOR_ID]) {
            const st = getPatchedMutatorValue({
                newValue: Ge,
                mutatorsState: ge,
                mutatorId: SPAWN_TYPE_MUTATOR_ID,
                mutatorMeta: V.mutators[SPAWN_TYPE_MUTATOR_ID],
                numberOfTeams: _e,
                teamIndexes: J
            });
            Te({
                ...st
            })
        }
    }
      , vt = Ge => {
        if (Ge !== void 0) {
            const st = getNewTeamDistribution(Ge, _e ?? 1, MUTATOR_AI_SPAWN_TYPE_TO_CAPACITY_TYPE.get(Number(et)));
            me(st)
        } else
            me(Ge)
    }
      , Jt = Ge => {
        Ge ? api.set(COOKIE_KEY.DO_NOT_AGAIN_EQUALIZE_TEAMS_DIALOG, "true", {
            expires: S_ONE_YEAR
        }) : api.remove(COOKIE_KEY.DO_NOT_AGAIN_EQUALIZE_TEAMS_DIALOG),
        xe(Ge)
    }
      , Ct = (Ge, st) => ht => {
        Ge && !Et ? (Ye( () => () => {
            st(ht)
        }
        ),
        ct()) : st(ht)
    }
      , Mt = Ge => st => {
        ft || Ke ? Ge(st) : (nt( () => () => {
            Ge(st)
        }
        ),
        ye())
    }
      , nn = Xe > (Se ?? 0) ? Se : Xe
      , tn = [{
        value: AI_SPAWN_TYPE_MUTATOR_NO_AI_VALUE,
        label: Ht("general.no-bots")
    }, {
        value: AI_SPAWN_TYPE_MUTATOR_PVP_VALUE,
        label: Ht("general.backfill")
    }];
    Ie && tn.push({
        value: AI_SPAWN_TYPE_MUTATOR_PVE_VALUE,
        label: Ht("general.static")
    });
    const mn = getMutatorsForPage({
        mutators: (V == null ? void 0 : V.mutators) ?? {},
        tags: [MUTATOR_TAG.TEAM_SETTINGS],
        gameMode: X
    })
      , dn = [MAX_TEAM_COUNT_MUTATOR_ID, SPAWN_TYPE_MUTATOR_ID, AI_MAX_COUNT_MUTATOR_ID, MAX_PLAYER_COUNT_MUTATOR_ID]
      , Qt = Object.entries(mn).reduce( (Ge, [st,ht]) => (dn.includes(st) || (Ge[st] = ht),
    Ge), {})
      , on = ue ? _e : it.length
      , zt = qe - (Se ?? 0)
      , $t = Math.floor(qe / (on || 1))
      , Ut = zt ? $t : Nt
      , An = zt ? $t : Gt
      , yt = GAME_MODES_THAT_DO_SUPPORT_BOTS.includes(X)
      , Dt = [{
        id: MAX_PLAYER_COUNT_MUTATOR_ID,
        elem: jsxRuntimeExports.jsx(IncrementMutator, {
            onChange: Ct(mt, Ot),
            unavailable: mt,
            min: 0,
            max: Ut,
            caption: Ht((V == null ? void 0 : V.mutators[MAX_PLAYER_COUNT_MUTATOR_ID].translationIds.description) ?? ""),
            value: mt ? void 0 : Nt,
            labels: {
                count: Ht("general.player-count"),
                increment: Ht("general.add"),
                decrement: Ht("general.remove")
            },
            title: Ht(Ie ? "general.human-players" : "general.human-players-per-team")
        }, "team-player-count")
    }, {
        id: AI_MAX_COUNT_MUTATOR_ID,
        elem: jsxRuntimeExports.jsx(IncrementMutator, {
            onChange: Ct(lt, kt),
            min: et === AI_SPAWN_TYPE_MUTATOR_PVE_VALUE ? 0 : void 0,
            max: et === AI_SPAWN_TYPE_MUTATOR_PVE_VALUE ? An : void 0,
            unavailable: lt,
            disabled: et !== AI_SPAWN_TYPE_MUTATOR_PVE_VALUE || yt,
            value: lt || et !== AI_SPAWN_TYPE_MUTATOR_PVE_VALUE ? void 0 : Gt,
            caption: Ht((V == null ? void 0 : V.mutators[AI_MAX_COUNT_MUTATOR_ID].translationIds.description) ?? ""),
            labels: {
                count: Ht("general.bot-count"),
                increment: Ht("general.add"),
                decrement: Ht("general.remove")
            },
            title: Ht(Ie ? "general.bot-count" : "general.bot-count-per-team")
        }, "team-ai-count")
    }]
      , Bt = [{
        id: MAX_TEAM_COUNT_MUTATOR_ID,
        elem: jsxRuntimeExports.jsx(IncrementMutator, {
            onChange: Mt(vt),
            labels: {
                count: (we == null ? void 0 : we.translationIds.name) ?? "",
                increment: Ht("general.add"),
                decrement: Ht("general.remove")
            },
            enforceStep: !Ie,
            disabled: !0,
            step: _e,
            value: Se,
            min: ze,
            max: qe,
            title: Ht("general.max-game-size"),
            caption: Ht("general.max-game-description")
        }, "gameSize")
    }, {
        id: MAX_TEAM_COUNT_MUTATOR_ID,
        elem: jsxRuntimeExports.jsx(IncrementMutator, {
            title: Ht("general.number-of-teams"),
            caption: Ht((V == null ? void 0 : V.mutators[MAX_TEAM_COUNT_MUTATOR_ID].translationIds.description) ?? ""),
            labels: {
                count: Ht("general.team-count"),
                increment: Ht("general.add"),
                decrement: Ht("general.remove")
            },
            value: Ne,
            disabled: je === nn && _e === Xe,
            min: je,
            max: nn,
            onChange: Mt(Kt)
        }, "teamsCount")
    }, {
        id: SPAWN_TYPE_MUTATOR_ID,
        elem: jsxRuntimeExports.jsx(SelectMutator, {
            title: Ht("general.bot-spawn-type"),
            onChange: Xt,
            caption: Ht((V == null ? void 0 : V.mutators[SPAWN_TYPE_MUTATOR_ID].translationIds.description) ?? ""),
            unavailable: Qe,
            options: {
                items: tn
            },
            isDisabled: yt,
            value: getMutatorValue(ge[SPAWN_TYPE_MUTATOR_ID], V == null ? void 0 : V.mutators[SPAWN_TYPE_MUTATOR_ID].defaultValue)
        }, "ai-spawn-type")
    }];
    return jsxRuntimeExports.jsxs(PageWrapper, {
        children: [jsxRuntimeExports.jsx(Mutators, {
            teamIdx: J[0],
            globalMutatorsSlot: Bt,
            perTeamMutatorsSlot: Dt,
            items: Qt,
            showConflictWarningOverride: gt,
            showValidationErrors: [VALIDATION_FIELD_KEY.GAME_SIZE]
        }), jsxRuntimeExports.jsx(DialogContent, {
            id: DIALOG_ID.EQUALIZE_TEAMS,
            header: jsxRuntimeExports.jsxs(Space, {
                children: [jsxRuntimeExports.jsx(Icon, {
                    name: ICON_NAMES.WARNING
                }), Ht("general.warning")]
            }),
            footer: jsxRuntimeExports.jsxs(ButtonGroup, {
                fillWidth: !0,
                children: [jsxRuntimeExports.jsx(Button, {
                    fillWidth: !0,
                    type: BUTTON_TYPES$1.SUBMIT,
                    children: Ht("general.continue")
                }), jsxRuntimeExports.jsx(Button, {
                    fillWidth: !0,
                    variant: BUTTON_VARIANTS.SECONDARY,
                    onClick: $e,
                    children: Ht("general.cancel")
                })]
            }),
            children: jsxRuntimeExports.jsxs("div", {
                className: styles$4.confirmContent,
                children: [jsxRuntimeExports.jsx(Paragraph, {
                    children: Ht("experience.equalize-player-counts-dialog")
                }), jsxRuntimeExports.jsx(Paragraph, {
                    children: Ht("experience.are-you-sure-to-continue")
                }), jsxRuntimeExports.jsx(Section, {
                    trimBottom: !0,
                    children: jsxRuntimeExports.jsx("label", {
                        className: styles$4.label,
                        children: jsxRuntimeExports.jsxs(Space, {
                            align: SPACE_ALIGN.START,
                            className: styles$4.doNotShowAgainContent,
                            children: [jsxRuntimeExports.jsx(Checkbox, {
                                checked: ke,
                                onChange: Jt
                            }), Ht("experience.do-not-show-msg-again")]
                        })
                    })
                })]
            })
        })]
    })
}
  , VehiclesPage = () => jsxRuntimeExports.jsx(RestrictionPage, {
    category: RESTRICTION_PAGE_CATEGORY.VEHICLES,
    itemType: RESTRICTION_PAGE_ITEM_TYPE.VEHICLE
})
  , tableWrapper = "_tableWrapper_1eeoj_1"
  , styles$3 = {
    tableWrapper
}
  , VersionPage = () => jsxRuntimeExports.jsx(PageWrapper, {
    children: jsxRuntimeExports.jsxs("div", {
        className: styles$3.tableWrapper,
        children: [jsxRuntimeExports.jsx(Section, {
            children: jsxRuntimeExports.jsx(Heading, {
                children: "App Version"
            })
        }), jsxRuntimeExports.jsx(Section, {
            trimTop: !0,
            children: jsxRuntimeExports.jsxs(Table, {
                evenWidth: !0,
                children: [jsxRuntimeExports.jsxs(TableRow, {
                    children: [jsxRuntimeExports.jsx(TableCell, {
                        children: "Node Environment"
                    }), jsxRuntimeExports.jsx(TableCell, {
                        children: "--"
                    })]
                }), jsxRuntimeExports.jsxs(TableRow, {
                    children: [jsxRuntimeExports.jsx(TableCell, {
                        children: "App Environment"
                    }), jsxRuntimeExports.jsx(TableCell, {
                        children: VITE_ENVIRONMENT
                    })]
                }), jsxRuntimeExports.jsxs(TableRow, {
                    children: [jsxRuntimeExports.jsx(TableCell, {
                        children: "Version"
                    }), jsxRuntimeExports.jsx(TableCell, {
                        children: VITE_VERSION
                    })]
                }), jsxRuntimeExports.jsxs(TableRow, {
                    children: [jsxRuntimeExports.jsx(TableCell, {
                        children: "App Version"
                    }), jsxRuntimeExports.jsx(TableCell, {
                        children: "1.0.1.0c"
                    })]
                }), jsxRuntimeExports.jsxs(TableRow, {
                    children: [jsxRuntimeExports.jsx(TableCell, {
                        children: "Preferred Arrival Patch Version"
                    }), jsxRuntimeExports.jsx(TableCell, {
                        children: getCurrentArrivalPatchVersion() ?? "Default"
                    })]
                })]
            })
        })]
    })
});
function _setPrototypeOf(V, X) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(J, ne) {
        return J.__proto__ = ne,
        J
    }
    ,
    _setPrototypeOf(V, X)
}
function _inheritsLoose(V, X) {
    V.prototype = Object.create(X.prototype),
    V.prototype.constructor = V,
    _setPrototypeOf(V, X)
}
var changedArray = function V(X, J) {
    return X === void 0 && (X = []),
    J === void 0 && (J = []),
    X.length !== J.length || X.some(function(ne, ue) {
        return !Object.is(ne, J[ue])
    })
}
  , initialState = {
    error: null
}
  , ErrorBoundary = function(V) {
    _inheritsLoose(X, V);
    function X() {
        for (var ne, ue = arguments.length, ce = new Array(ue), me = 0; me < ue; me++)
            ce[me] = arguments[me];
        return ne = V.call.apply(V, [this].concat(ce)) || this,
        ne.state = initialState,
        ne.resetErrorBoundary = function() {
            for (var ge, Te = arguments.length, _e = new Array(Te), Se = 0; Se < Te; Se++)
                _e[Se] = arguments[Se];
            ne.props.onReset == null || (ge = ne.props).onReset.apply(ge, _e),
            ne.reset()
        }
        ,
        ne
    }
    X.getDerivedStateFromError = function(ue) {
        return {
            error: ue
        }
    }
    ;
    var J = X.prototype;
    return J.reset = function() {
        this.setState(initialState)
    }
    ,
    J.componentDidCatch = function(ue, ce) {
        var me, ge;
        (me = (ge = this.props).onError) == null || me.call(ge, ue, ce)
    }
    ,
    J.componentDidUpdate = function(ue, ce) {
        var me = this.state.error
          , ge = this.props.resetKeys;
        if (me !== null && ce.error !== null && changedArray(ue.resetKeys, ge)) {
            var Te, _e;
            (Te = (_e = this.props).onResetKeysChange) == null || Te.call(_e, ue.resetKeys, ge),
            this.reset()
        }
    }
    ,
    J.render = function() {
        var ue = this.state.error
          , ce = this.props
          , me = ce.fallbackRender
          , ge = ce.FallbackComponent
          , Te = ce.fallback;
        if (ue !== null) {
            var _e = {
                error: ue,
                resetErrorBoundary: this.resetErrorBoundary
            };
            if (reactExports.isValidElement(Te))
                return Te;
            if (typeof me == "function")
                return me(_e);
            if (ge)
                return reactExports.createElement(ge, _e);
            throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop")
        }
        return this.props.children
    }
    ,
    X
}(reactExports.Component);
const errorBoundaryContainer = "_errorBoundaryContainer_16pdx_1"
  , errorMessage = "_errorMessage_16pdx_5"
  , styles$2 = {
    errorBoundaryContainer,
    errorMessage
}
  , logger$1 = Logger$1.get("ErrorBoundary")
  , SuspenseErrorBoundary = ({children: V, fallback: X}) => {
    const J = (ne, ue) => {
        logger$1.error(ne, ue)
    }
    ;
    return jsxRuntimeExports.jsx(QueryErrorResetBoundary, {
        children: jsxRuntimeExports.jsx(ErrorBoundary, {
            FallbackComponent: ({error: ne, resetErrorBoundary: ue}) => jsxRuntimeExports.jsxs("div", {
                className: styles$2.errorBoundaryContainer,
                children: [jsxRuntimeExports.jsx("div", {
                    className: styles$2.errorMessage,
                    children: "Oh no! A runtime error occurred."
                }), jsxRuntimeExports.jsx("pre", {
                    children: ne.message
                }), jsxRuntimeExports.jsx("button", {
                    type: BUTTON_TYPES.BUTTON,
                    onClick: ue,
                    children: "Reset error and try again"
                }), jsxRuntimeExports.jsx("p", {
                    children: jsxRuntimeExports.jsx("a", {
                        href: window.location.href,
                        onClick: () => window.location.reload(),
                        children: "Refresh the page to continue."
                    })
                })]
            }),
            onError: J,
            children: jsxRuntimeExports.jsx(reactExports.Suspense, {
                fallback: X || null,
                children: V
            })
        })
    })
}
  , usePageTracking = () => {
    const V = useLocation();
    reactExports.useEffect( () => {
        telemetryHelper.pageView({
            next: V.pathname + V.search
        })
    }
    , [V])
}
  , logger = Logger$1.get("App")
  , authLogger = logger.extend("auth")
  , useSession = () => {
    const V = useLocation()
      , [X,J] = useSearchParams()
      , ne = useNavigate()
      , ue = X.get(QUERY_PARAM_KEY.CODE) ?? ""
      , ce = X.get(QUERY_PARAM_KEY.STATE) ?? ""
      , me = V.pathname.includes(ROUTE.LOGIN)
      , ge = V.pathname.includes(ROUTE.LOGOUT)
      , {sessionId: Te} = reactExports.useContext(SessionContext);
    let _e = !1, Se = "", Ie;
    const ye = hasSessionInCookies()
      , $e = useSearchParams()[0]
      , Ne = getCurrentArrivalPatchVersion();
    ye ? (Se = getSessionIdFromCookie() ?? "",
    Ie = getPlayerFromCookie()) : !ue && !ye ? logger.log("No auth code!") : ue && (_e = !0);
    const ve = $e.get(QUERY_PARAM_KEY.STATE)
      , ke = ve || buildUrl(["https://portal.battlefield.com", V.pathname], {
        endWithSlash: !0
    })
      , {data: xe, isLoading: we, isError: Fe} = useQuery({
        queryKey: [QUERY_KEY.AUTH, Ne, ue],
        queryFn: async () => (logger.log("Requesting new session via auth code: ", ue),
        logger.log("Using patch version: ", Ne),
        await clients.authentication.viaAuthCode({
            authCode: ue,
            redirectUri: ke,
            platform: Platform.PC,
            patchVersion: Ne
        })),
        enabled: _e
    });
    return reactExports.useEffect( () => {
        me && Te ? (authLogger.debug("Session found - redirecting..."),
        ce && !ce.includes(ROUTE.LOGIN) ? ne(ce, {
            replace: !0
        }) : ne(getAbsolutePathWithLocale(`/${ROUTE.HOME}`), {
            replace: !0
        })) : (ge && !Te || !ue && !Te && !Se && !me) && (authLogger.debug("No session found - redirecting..."),
        ne(getAbsolutePathWithLocale(`/${ROUTE.LOGIN}`), {
            replace: !0,
            state: V
        })),
        Te && (ue && (X.delete(QUERY_PARAM_KEY.CODE),
        J(X)),
        ce && (X.delete(QUERY_PARAM_KEY.STATE),
        J(X)))
    }
    , [ge, ne, Te, me, ue, ce, V, X, J, Se]),
    xe && (Se = xe.sessionId,
    Ie = xe.player,
    logger.info("Successfully authenticated against gateway!"),
    logger.debug("player:", Ie),
    logger.debug("sessionId:", Se),
    Se && Ie && setSessionCookies(Se, Ie)),
    {
        session: Se,
        player: Ie ? {
            nucleusId: Ie.nucleusId,
            personaId: Ie.personaId,
            platform: Ie.platform
        } : void 0,
        isLoading: we,
        isError: Fe
    }
}
  , useTrustArcConsent = () => {
    const V = reactExports.useCallback(X => {
        X.data && typeof X.data == "string" && X.data.includes("preference_manager") && JSON.parse(X.data).message === "submit_preferences" && telemetryHelper.setTelemetryOptOut(getTrustArcPreference() === TrustArcPreference.REQUIRED)
    }
    , []);
    reactExports.useEffect( () => (window.addEventListener("message", V),
    () => {
        window.removeEventListener("message", V)
    }
    ), [V])
}
  , eaNavSpaceFiller = "_eaNavSpaceFiller_xseqn_19"
  , appWrapper = "_appWrapper_xseqn_24"
  , appContainer = "_appContainer_xseqn_30"
  , styles$1 = {
    eaNavSpaceFiller,
    appWrapper,
    appContainer
}
  , App = () => {
    const {pathname: V} = useLocation()
      , {isLoading: X, session: J, player: ne, isError: ue} = useSession()
      , ce = V.includes(`/${ROUTE.SERVICE_UNAVAILABLE}`)
      , {updateSession: me} = reactExports.useContext(SessionContext)
      , ge = useNavigate()
      , {isFetching: Te, rawBlueprint: _e, isError: Se} = reactExports.useContext(BlueprintContext)
      , {t: Ie} = useTranslation();
    return usePageTracking(),
    useTrustArcConsent(),
    reactExports.useEffect( () => {
        X || me({
            isError: ue,
            sessionId: J,
            player: ne,
            isLoading: X
        })
    }
    , [X]),
    reactExports.useEffect( () => {
        Te || (JSON.stringify(_e) === "{}" || Se ? ge({
            pathname: getAbsolutePathWithLocale(`/${ROUTE.SERVICE_UNAVAILABLE}`, V)
        }, {
            replace: !0
        }) : ce && ge({
            pathname: getAbsolutePathWithLocale(`/${ROUTE.HOME}`, V)
        }, {
            replace: !0
        }))
    }
    , [_e, Te, Se, ce, ge, V]),
    jsxRuntimeExports.jsx(SuspenseErrorBoundary, {
        children: jsxRuntimeExports.jsxs("div", {
            className: styles$1.appWrapper,
            children: [jsxRuntimeExports.jsx(W, {
                children: jsxRuntimeExports.jsx("title", {
                    children: "Battlefield™ Portal - Electronic Arts"
                })
            }), jsxRuntimeExports.jsx(ScrollRestoration, {}), jsxRuntimeExports.jsx("div", {
                className: styles$1.eaNavSpaceFiller
            }), jsxRuntimeExports.jsx("div", {
                className: styles$1.appContainer,
                children: jsxRuntimeExports.jsxs(AppProvider, {
                    children: [jsxRuntimeExports.jsx(Outlet, {}), X && jsxRuntimeExports.jsx(LoadingSpinner, {
                        statusText: Ie("general.authenticating")
                    })]
                })
            })]
        })
    })
}
  , AppRouter = () => {
    const {t: V} = useTranslation()
      , X = [{
        index: !0,
        element: jsxRuntimeExports.jsx(AuthRequired, {
            children: jsxRuntimeExports.jsx(Navigate, {
                to: ROUTE.HOME,
                replace: !0
            })
        }, "base")
    }, {
        path: ROUTE.EXPERIENCE_NOT_FOUND,
        element: jsxRuntimeExports.jsx(AuthRequired, {
            children: jsxRuntimeExports.jsx(ErrorPage, {
                errorText: V("experience.could-not-find-experience"),
                includeBack: !0
            })
        }, ROUTE.EXPERIENCE_NOT_FOUND)
    }, {
        path: ROUTE.VERSION,
        element: jsxRuntimeExports.jsx(VersionPage, {})
    }, {
        path: ROUTE.LOGIN,
        element: jsxRuntimeExports.jsx(LoginPage, {})
    }, {
        path: ROUTE.LOGOUT,
        element: jsxRuntimeExports.jsx(LogoutPage, {})
    }, {
        path: ROUTE.HOME,
        element: jsxRuntimeExports.jsx(AuthRequired, {
            children: jsxRuntimeExports.jsx(ExperiencesPage, {})
        })
    }, {
        path: ROUTE.SERVICE_UNAVAILABLE,
        element: jsxRuntimeExports.jsx(AuthRequired, {
            children: jsxRuntimeExports.jsx(ErrorPage, {
                errorText: V("experience.service-unavailable"),
                description: jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                    children: [jsxRuntimeExports.jsx(Paragraph, {
                        children: V("experience.service-unavailable")
                    }), jsxRuntimeExports.jsx(Paragraph, {
                        children: V("experience.service-unavailable-description")
                    })]
                }),
                includeReload: !0
            })
        }, ROUTE.SERVICE_UNAVAILABLE)
    }, {
        path: ROUTE.EXPERIENCE,
        element: jsxRuntimeExports.jsx(AuthRequired, {
            children: jsxRuntimeExports.jsx(PlayElementProvider, {
                children: jsxRuntimeExports.jsx(ExperienceDataProvider, {
                    children: jsxRuntimeExports.jsx(Outlet, {})
                })
            })
        }, ROUTE.EXPERIENCE),
        children: [{
            index: !0,
            element: jsxRuntimeExports.jsx(PreservedSearchNavigate, {
                pathname: getAbsolutePathWithLocale(`/${ROUTE.EXPERIENCE}/${ROUTE.SETTINGS}/${ROUTE.MODE}`),
                replace: !0
            })
        }, {
            element: jsxRuntimeExports.jsx(GameModePage, {}),
            path: ROUTE.GAME_MODE
        }, {
            path: ROUTE.MAP_ROTATION,
            element: jsxRuntimeExports.jsx(ExperienceMainNavLayout, {
                children: jsxRuntimeExports.jsx(ExperiencePageLayout, {
                    title: V("experience.custom-maps-layout"),
                    heading: V("general.map-rotation"),
                    prev: {
                        label: V("general.settings"),
                        route: ROUTE.SETTINGS
                    },
                    next: {
                        label: V("general.teams"),
                        route: ROUTE.DISTRIBUTION
                    },
                    children: jsxRuntimeExports.jsx(MapRotationPage, {})
                })
            }, ROUTE.MAP_ROTATION)
        }, {
            path: ROUTE.SUPER_USER,
            element: jsxRuntimeExports.jsx(VipGate, {
                children: jsxRuntimeExports.jsx(ExperienceMainNavLayout, {
                    children: jsxRuntimeExports.jsx(ExperiencePageLayout, {
                        title: V("experience.import-patches"),
                        heading: V("general.mod"),
                        subheading: V("general.super-user"),
                        children: jsxRuntimeExports.jsx(SuperUserPage, {})
                    })
                })
            }, ROUTE.SUPER_USER)
        }, {
            path: ROUTE.SETTINGS,
            element: jsxRuntimeExports.jsx(ExperienceMainNavLayout, {
                children: jsxRuntimeExports.jsx(Outlet, {})
            }, ROUTE.SETTINGS),
            children: [{
                index: !0,
                element: jsxRuntimeExports.jsx(PreservedSearchNavigate, {
                    pathname: ROUTE.MODE,
                    replace: !0
                })
            }, {
                path: ROUTE.MODE,
                element: jsxRuntimeExports.jsx(ExperiencePageLayout, {
                    title: V("general.mode-settings"),
                    heading: V("general.settings"),
                    subheading: V("general.mode"),
                    next: {
                        label: V("general.map-rotation"),
                        route: `../${ROUTE.MAP_ROTATION}`
                    },
                    children: jsxRuntimeExports.jsx(StandardModifiersPage, {
                        tags: [MUTATOR_TAG.SETTINGS]
                    })
                }, ROUTE.MODE)
            }]
        }, {
            path: ROUTE.DISTRIBUTION,
            element: jsxRuntimeExports.jsx(ExperienceMainNavLayout, {
                children: jsxRuntimeExports.jsx(ExperiencePageLayout, {
                    title: V("general.team-settings"),
                    heading: V("general.teams"),
                    prev: {
                        label: V("general.map-rotation"),
                        route: ROUTE.MAP_ROTATION
                    },
                    next: {
                        label: V("general.modifiers"),
                        route: ROUTE.MODIFIERS
                    },
                    children: jsxRuntimeExports.jsx(TeamDistributionPage, {})
                })
            }, ROUTE.DISTRIBUTION)
        }, {
            path: ROUTE.MODIFIERS,
            element: jsxRuntimeExports.jsx(ExperienceMainNavLayout, {
                children: jsxRuntimeExports.jsx(Outlet, {})
            }),
            children: [{
                index: !0,
                element: jsxRuntimeExports.jsx(PreservedSearchNavigate, {
                    pathname: ROUTE.GAMEPLAY,
                    replace: !0
                })
            }, {
                path: ROUTE.GAMEPLAY,
                element: jsxRuntimeExports.jsx(ExperiencePageLayout, {
                    title: V("general.gameplay-settings"),
                    heading: V("general.modifiers"),
                    subheading: V("general.gameplay"),
                    prev: {
                        label: V("general.teams"),
                        route: `../${ROUTE.DISTRIBUTION}`
                    },
                    next: {
                        label: V("general.soldier"),
                        route: ROUTE.SOLDIER
                    },
                    children: jsxRuntimeExports.jsx(StandardModifiersPage, {
                        tags: [MUTATOR_TAG.GAMEPLAY_SETTINGS]
                    })
                }, ROUTE.GAMEPLAY)
            }, {
                path: ROUTE.SOLDIER,
                element: jsxRuntimeExports.jsx(ExperiencePageLayout, {
                    title: V("general.soldier-settings"),
                    heading: V("general.modifiers"),
                    subheading: V("general.soldier"),
                    prev: {
                        label: V("general.gameplay"),
                        route: ROUTE.GAMEPLAY
                    },
                    next: {
                        label: V("general.vehicle"),
                        route: ROUTE.VEHICLE
                    },
                    children: jsxRuntimeExports.jsx(StandardModifiersPage, {
                        tags: [MUTATOR_TAG.SOLDIER_SETTINGS]
                    })
                }, ROUTE.SOLDIER)
            }, {
                path: ROUTE.VEHICLE,
                element: jsxRuntimeExports.jsx(ExperiencePageLayout, {
                    title: V("general.vehicle-settings"),
                    heading: V("general.modifiers"),
                    subheading: V("general.vehicle"),
                    prev: {
                        label: V("general.soldier"),
                        route: ROUTE.SOLDIER
                    },
                    next: {
                        label: V("general.ui"),
                        route: ROUTE.UI
                    },
                    children: jsxRuntimeExports.jsx(StandardModifiersPage, {
                        tags: [MUTATOR_TAG.VEHICLE_SETTINGS]
                    })
                }, ROUTE.VEHICLE)
            }, {
                path: ROUTE.UI,
                element: jsxRuntimeExports.jsx(ExperiencePageLayout, {
                    title: V("general.ui-settings"),
                    heading: V("general.modifiers"),
                    subheading: V("general.ui"),
                    prev: {
                        label: V("general.vehicle"),
                        route: ROUTE.VEHICLE
                    },
                    next: {
                        label: V("general.bots"),
                        route: ROUTE.AI
                    },
                    children: jsxRuntimeExports.jsx(StandardModifiersPage, {
                        tags: [MUTATOR_TAG.UI_SETTINGS]
                    })
                }, ROUTE.UI)
            }, {
                path: ROUTE.AI,
                element: jsxRuntimeExports.jsx(ExperiencePageLayout, {
                    title: V("general.bot-settings"),
                    heading: V("general.modifiers"),
                    subheading: V("general.bots"),
                    prev: {
                        label: V("general.ui"),
                        route: ROUTE.UI
                    },
                    next: {
                        label: V("general.restrictions"),
                        route: `../${ROUTE.RESTRICTIONS}`
                    },
                    children: jsxRuntimeExports.jsx(StandardModifiersPage, {
                        tags: [MUTATOR_TAG.AI_SETTINGS, MUTATOR_TAG.AI_SYNC_SETTINGS]
                    })
                }, ROUTE.AI)
            }]
        }, {
            path: ROUTE.RESTRICTIONS,
            element: jsxRuntimeExports.jsx(ExperienceMainNavLayout, {
                children: jsxRuntimeExports.jsx(Outlet, {})
            }),
            children: [{
                index: !0,
                element: jsxRuntimeExports.jsx(PreservedSearchNavigate, {
                    pathname: ROUTE.CLASSES,
                    replace: !0
                })
            }, {
                path: ROUTE.CLASSES,
                element: jsxRuntimeExports.jsx(ExperiencePageLayout, {
                    title: V("general.class-select"),
                    heading: V("general.restrictions"),
                    subheading: V("general.classes"),
                    prev: {
                        label: V("general.bots"),
                        route: `../${ROUTE.MODIFIERS}/${ROUTE.AI}`
                    },
                    next: {
                        label: V("general.weapons"),
                        route: ROUTE.WEAPONS
                    },
                    children: jsxRuntimeExports.jsx(ClassesPage, {})
                }, ROUTE.CLASSES)
            }, {
                path: ROUTE.WEAPONS,
                element: jsxRuntimeExports.jsx(ExperiencePageLayout, {
                    title: V("general.weapon-select"),
                    heading: V("general.restrictions"),
                    subheading: V("general.weapons"),
                    prev: {
                        label: V("general.classes"),
                        route: ROUTE.CLASSES
                    },
                    next: {
                        label: V("general.vehicles"),
                        route: ROUTE.VEHICLES
                    },
                    children: jsxRuntimeExports.jsx(RestrictionPage, {
                        category: RESTRICTION_PAGE_CATEGORY.WEAPONS,
                        itemType: RESTRICTION_PAGE_ITEM_TYPE.WEAPON
                    })
                }, RESTRICTION_PAGE_ITEM_TYPE.WEAPON)
            }, {
                path: ROUTE.VEHICLES,
                element: jsxRuntimeExports.jsx(ExperiencePageLayout, {
                    title: V("general.vehicle-select"),
                    heading: V("general.restrictions"),
                    subheading: V("general.vehicles"),
                    prev: {
                        label: V("general.weapons"),
                        route: ROUTE.WEAPONS
                    },
                    next: {
                        label: V("general.gadgets"),
                        route: ROUTE.GADGETS
                    },
                    children: jsxRuntimeExports.jsx(VehiclesPage, {})
                }, RESTRICTION_PAGE_ITEM_TYPE.VEHICLE)
            }, {
                path: ROUTE.GADGETS,
                element: jsxRuntimeExports.jsx(ExperiencePageLayout, {
                    title: V("general.gadget-select"),
                    heading: V("general.restrictions"),
                    subheading: V("general.gadgets"),
                    prev: {
                        label: V("general.vehicles"),
                        route: ROUTE.VEHICLES
                    },
                    next: {
                        label: V("general.publish"),
                        route: `../${ROUTE.PUBLISH}`
                    },
                    children: jsxRuntimeExports.jsx(RestrictionPage, {
                        category: RESTRICTION_PAGE_CATEGORY.GADGETS,
                        itemType: RESTRICTION_PAGE_ITEM_TYPE.GADGET
                    })
                }, RESTRICTION_PAGE_ITEM_TYPE.GADGET)
            }]
        }, {
            path: ROUTE.RULES_EDITOR,
            element: jsxRuntimeExports.jsx(ExperienceMainNavLayout, {
                children: jsxRuntimeExports.jsx(Outlet, {})
            }),
            children: [{
                index: !0,
                element: jsxRuntimeExports.jsx(PreservedSearchNavigate, {
                    pathname: ROUTE.BLOCKS,
                    replace: !0
                })
            }, {
                path: ROUTE.BLOCKS,
                element: jsxRuntimeExports.jsx(RuleEditorGate, {
                    children: jsxRuntimeExports.jsx(ExperiencePageLayout, {
                        prev: {
                            label: V("general.gadgets"),
                            route: `../${ROUTE.RESTRICTIONS}/${ROUTE.GADGETS}`
                        },
                        next: {
                            label: V("general.script"),
                            route: ROUTE.SCRIPT_EDITOR
                        },
                        children: jsxRuntimeExports.jsx(RulesEditorPage, {})
                    })
                }, ROUTE.BLOCKS)
            }, {
                path: ROUTE.SCRIPT_EDITOR,
                element: jsxRuntimeExports.jsx(RuleEditorGate, {
                    children: jsxRuntimeExports.jsx(ExperiencePageLayout, {
                        prev: {
                            label: V("general.blocks"),
                            route: ROUTE.BLOCKS
                        },
                        next: {
                            label: V("general.publish"),
                            route: `../${ROUTE.PUBLISH}`
                        },
                        children: jsxRuntimeExports.jsx(ScriptEditorPage, {})
                    })
                }, ROUTE.SCRIPT_EDITOR)
            }]
        }, {
            path: ROUTE.PUBLISH,
            element: jsxRuntimeExports.jsx(ExperienceMainNavLayout, {
                children: jsxRuntimeExports.jsx(Outlet, {})
            }, ROUTE.PUBLISH),
            children: [{
                index: !0,
                element: jsxRuntimeExports.jsx(PreservedSearchNavigate, {
                    pathname: ROUTE.PUBLISH_STEP_ONE,
                    replace: !0
                })
            }, {
                path: ROUTE.PUBLISH_STEP_ONE,
                element: jsxRuntimeExports.jsx(ExperiencePageLayout, {
                    title: V("general.name-and-description"),
                    heading: V("general.publish"),
                    subheading: V("general.step-1"),
                    prev: {
                        label: V("general.rules-editor"),
                        route: `../${ROUTE.RULES_EDITOR}`
                    },
                    next: {
                        label: V("general.step-2"),
                        route: ROUTE.PUBLISH_STEP_TWO
                    },
                    hidePublishIconButton: !0,
                    children: jsxRuntimeExports.jsx(PublishPageLayout, {
                        children: jsxRuntimeExports.jsx(PublishStepOnePage, {})
                    })
                }, ROUTE.PUBLISH_STEP_ONE)
            }, {
                path: ROUTE.PUBLISH_STEP_TWO,
                element: jsxRuntimeExports.jsx(ExperiencePageLayout, {
                    title: V("general.image-select"),
                    heading: V("general.publish"),
                    subheading: V("general.step-2"),
                    prev: {
                        label: V("general.step-1"),
                        route: ROUTE.PUBLISH_STEP_ONE
                    },
                    next: {
                        label: V("general.step-3"),
                        route: ROUTE.PUBLISH_STEP_THREE
                    },
                    hidePublishIconButton: !0,
                    children: jsxRuntimeExports.jsx(PublishPageLayout, {
                        children: jsxRuntimeExports.jsx(PublishStepTwoPage, {})
                    })
                }, ROUTE.PUBLISH_STEP_TWO)
            }, {
                path: ROUTE.PUBLISH_STEP_THREE,
                element: jsxRuntimeExports.jsx(ExperiencePageLayout, {
                    title: V("general.publish-experience"),
                    heading: V("general.publish"),
                    subheading: V("general.step-3"),
                    prev: {
                        label: V("general.step-2"),
                        route: ROUTE.PUBLISH_STEP_TWO
                    },
                    hidePublishIconButton: !0,
                    showFinishButton: !0,
                    children: jsxRuntimeExports.jsx(PublishPageLayout, {
                        children: jsxRuntimeExports.jsx(PublishStepThreePage, {})
                    })
                }, ROUTE.PUBLISH_STEP_THREE)
            }]
        }]
    }];
    return jsxRuntimeExports.jsx(RouterProvider2, {
        router: createBrowserRouter([{
            path: "/bf6/",
            element: jsxRuntimeExports.jsx(App, {}),
            children: [{
                path: "",
                element: jsxRuntimeExports.jsx(LocaleGate, {}),
                children: X
            }, {
                path: ":lang",
                element: jsxRuntimeExports.jsx(LocaleGate, {}),
                children: X
            }, {
                path: "*",
                element: jsxRuntimeExports.jsx(ErrorPage, {
                    errorText: V("app.status-404"),
                    includeBack: !0
                })
            }]
        }])
    })
}
;
function _classCallCheck$1(V, X) {
    if (!(V instanceof X))
        throw new TypeError("Cannot call a class as a function")
}
function _typeof$3(V) {
    "@babel/helpers - typeof";
    return _typeof$3 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(X) {
        return typeof X
    }
    : function(X) {
        return X && typeof Symbol == "function" && X.constructor === Symbol && X !== Symbol.prototype ? "symbol" : typeof X
    }
    ,
    _typeof$3(V)
}
function toPrimitive(V, X) {
    if (_typeof$3(V) != "object" || !V)
        return V;
    var J = V[Symbol.toPrimitive];
    if (J !== void 0) {
        var ne = J.call(V, X);
        if (_typeof$3(ne) != "object")
            return ne;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return String(V)
}
function toPropertyKey(V) {
    var X = toPrimitive(V, "string");
    return _typeof$3(X) == "symbol" ? X : X + ""
}
function _defineProperties$1(V, X) {
    for (var J = 0; J < X.length; J++) {
        var ne = X[J];
        ne.enumerable = ne.enumerable || !1,
        ne.configurable = !0,
        "value"in ne && (ne.writable = !0),
        Object.defineProperty(V, toPropertyKey(ne.key), ne)
    }
}
function _createClass$1(V, X, J) {
    return X && _defineProperties$1(V.prototype, X),
    Object.defineProperty(V, "prototype", {
        writable: !1
    }),
    V
}
var arr = []
  , each = arr.forEach
  , slice = arr.slice;
function defaults(V) {
    return each.call(slice.call(arguments, 1), function(X) {
        if (X)
            for (var J in X)
                V[J] === void 0 && (V[J] = X[J])
    }),
    V
}
var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/
  , serializeCookie = function V(X, J, ne) {
    var ue = ne || {};
    ue.path = ue.path || "/";
    var ce = encodeURIComponent(J)
      , me = "".concat(X, "=").concat(ce);
    if (ue.maxAge > 0) {
        var ge = ue.maxAge - 0;
        if (Number.isNaN(ge))
            throw new Error("maxAge should be a Number");
        me += "; Max-Age=".concat(Math.floor(ge))
    }
    if (ue.domain) {
        if (!fieldContentRegExp.test(ue.domain))
            throw new TypeError("option domain is invalid");
        me += "; Domain=".concat(ue.domain)
    }
    if (ue.path) {
        if (!fieldContentRegExp.test(ue.path))
            throw new TypeError("option path is invalid");
        me += "; Path=".concat(ue.path)
    }
    if (ue.expires) {
        if (typeof ue.expires.toUTCString != "function")
            throw new TypeError("option expires is invalid");
        me += "; Expires=".concat(ue.expires.toUTCString())
    }
    if (ue.httpOnly && (me += "; HttpOnly"),
    ue.secure && (me += "; Secure"),
    ue.sameSite) {
        var Te = typeof ue.sameSite == "string" ? ue.sameSite.toLowerCase() : ue.sameSite;
        switch (Te) {
        case !0:
            me += "; SameSite=Strict";
            break;
        case "lax":
            me += "; SameSite=Lax";
            break;
        case "strict":
            me += "; SameSite=Strict";
            break;
        case "none":
            me += "; SameSite=None";
            break;
        default:
            throw new TypeError("option sameSite is invalid")
        }
    }
    return me
}
  , cookie = {
    create: function V(X, J, ne, ue) {
        var ce = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
            path: "/",
            sameSite: "strict"
        };
        ne && (ce.expires = new Date,
        ce.expires.setTime(ce.expires.getTime() + ne * 60 * 1e3)),
        ue && (ce.domain = ue),
        document.cookie = serializeCookie(X, encodeURIComponent(J), ce)
    },
    read: function V(X) {
        for (var J = "".concat(X, "="), ne = document.cookie.split(";"), ue = 0; ue < ne.length; ue++) {
            for (var ce = ne[ue]; ce.charAt(0) === " "; )
                ce = ce.substring(1, ce.length);
            if (ce.indexOf(J) === 0)
                return ce.substring(J.length, ce.length)
        }
        return null
    },
    remove: function V(X) {
        this.create(X, "", -1)
    }
}
  , cookie$1 = {
    name: "cookie",
    lookup: function V(X) {
        var J;
        if (X.lookupCookie && typeof document < "u") {
            var ne = cookie.read(X.lookupCookie);
            ne && (J = ne)
        }
        return J
    },
    cacheUserLanguage: function V(X, J) {
        J.lookupCookie && typeof document < "u" && cookie.create(J.lookupCookie, X, J.cookieMinutes, J.cookieDomain, J.cookieOptions)
    }
}
  , querystring = {
    name: "querystring",
    lookup: function V(X) {
        var J;
        if (typeof window < "u") {
            var ne = window.location.search;
            !window.location.search && window.location.hash && window.location.hash.indexOf("?") > -1 && (ne = window.location.hash.substring(window.location.hash.indexOf("?")));
            for (var ue = ne.substring(1), ce = ue.split("&"), me = 0; me < ce.length; me++) {
                var ge = ce[me].indexOf("=");
                if (ge > 0) {
                    var Te = ce[me].substring(0, ge);
                    Te === X.lookupQuerystring && (J = ce[me].substring(ge + 1))
                }
            }
        }
        return J
    }
}
  , hasLocalStorageSupport = null
  , localStorageAvailable = function V() {
    if (hasLocalStorageSupport !== null)
        return hasLocalStorageSupport;
    try {
        hasLocalStorageSupport = window !== "undefined" && window.localStorage !== null;
        var X = "i18next.translate.boo";
        window.localStorage.setItem(X, "foo"),
        window.localStorage.removeItem(X)
    } catch {
        hasLocalStorageSupport = !1
    }
    return hasLocalStorageSupport
}
  , localStorage$1 = {
    name: "localStorage",
    lookup: function V(X) {
        var J;
        if (X.lookupLocalStorage && localStorageAvailable()) {
            var ne = window.localStorage.getItem(X.lookupLocalStorage);
            ne && (J = ne)
        }
        return J
    },
    cacheUserLanguage: function V(X, J) {
        J.lookupLocalStorage && localStorageAvailable() && window.localStorage.setItem(J.lookupLocalStorage, X)
    }
}
  , hasSessionStorageSupport = null
  , sessionStorageAvailable = function V() {
    if (hasSessionStorageSupport !== null)
        return hasSessionStorageSupport;
    try {
        hasSessionStorageSupport = window !== "undefined" && window.sessionStorage !== null;
        var X = "i18next.translate.boo";
        window.sessionStorage.setItem(X, "foo"),
        window.sessionStorage.removeItem(X)
    } catch {
        hasSessionStorageSupport = !1
    }
    return hasSessionStorageSupport
}
  , sessionStorage$1 = {
    name: "sessionStorage",
    lookup: function V(X) {
        var J;
        if (X.lookupSessionStorage && sessionStorageAvailable()) {
            var ne = window.sessionStorage.getItem(X.lookupSessionStorage);
            ne && (J = ne)
        }
        return J
    },
    cacheUserLanguage: function V(X, J) {
        J.lookupSessionStorage && sessionStorageAvailable() && window.sessionStorage.setItem(J.lookupSessionStorage, X)
    }
}
  , navigator$1 = {
    name: "navigator",
    lookup: function V(X) {
        var J = [];
        if (typeof navigator < "u") {
            if (navigator.languages)
                for (var ne = 0; ne < navigator.languages.length; ne++)
                    J.push(navigator.languages[ne]);
            navigator.userLanguage && J.push(navigator.userLanguage),
            navigator.language && J.push(navigator.language)
        }
        return J.length > 0 ? J : void 0
    }
}
  , htmlTag = {
    name: "htmlTag",
    lookup: function V(X) {
        var J, ne = X.htmlTag || (typeof document < "u" ? document.documentElement : null);
        return ne && typeof ne.getAttribute == "function" && (J = ne.getAttribute("lang")),
        J
    }
}
  , path = {
    name: "path",
    lookup: function V(X) {
        var J;
        if (typeof window < "u") {
            var ne = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
            if (ne instanceof Array)
                if (typeof X.lookupFromPathIndex == "number") {
                    if (typeof ne[X.lookupFromPathIndex] != "string")
                        return;
                    J = ne[X.lookupFromPathIndex].replace("/", "")
                } else
                    J = ne[0].replace("/", "")
        }
        return J
    }
}
  , subdomain = {
    name: "subdomain",
    lookup: function V(X) {
        var J = typeof X.lookupFromSubdomainIndex == "number" ? X.lookupFromSubdomainIndex + 1 : 1
          , ne = typeof window < "u" && window.location && window.location.hostname && window.location.hostname.match(/^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i);
        if (ne)
            return ne[J]
    }
};
function getDefaults$1() {
    return {
        order: ["querystring", "cookie", "localStorage", "sessionStorage", "navigator", "htmlTag"],
        lookupQuerystring: "lng",
        lookupCookie: "i18next",
        lookupLocalStorage: "i18nextLng",
        lookupSessionStorage: "i18nextLng",
        caches: ["localStorage"],
        excludeCacheFor: ["cimode"],
        convertDetectedLanguage: function(X) {
            return X
        }
    }
}
var Browser = function() {
    function V(X) {
        var J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck$1(this, V),
        this.type = "languageDetector",
        this.detectors = {},
        this.init(X, J)
    }
    return _createClass$1(V, [{
        key: "init",
        value: function(J) {
            var ne = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
              , ue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            this.services = J || {
                languageUtils: {}
            },
            this.options = defaults(ne, this.options || {}, getDefaults$1()),
            typeof this.options.convertDetectedLanguage == "string" && this.options.convertDetectedLanguage.indexOf("15897") > -1 && (this.options.convertDetectedLanguage = function(ce) {
                return ce.replace("-", "_")
            }
            ),
            this.options.lookupFromUrlIndex && (this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex),
            this.i18nOptions = ue,
            this.addDetector(cookie$1),
            this.addDetector(querystring),
            this.addDetector(localStorage$1),
            this.addDetector(sessionStorage$1),
            this.addDetector(navigator$1),
            this.addDetector(htmlTag),
            this.addDetector(path),
            this.addDetector(subdomain)
        }
    }, {
        key: "addDetector",
        value: function(J) {
            return this.detectors[J.name] = J,
            this
        }
    }, {
        key: "detect",
        value: function(J) {
            var ne = this;
            J || (J = this.options.order);
            var ue = [];
            return J.forEach(function(ce) {
                if (ne.detectors[ce]) {
                    var me = ne.detectors[ce].lookup(ne.options);
                    me && typeof me == "string" && (me = [me]),
                    me && (ue = ue.concat(me))
                }
            }),
            ue = ue.map(function(ce) {
                return ne.options.convertDetectedLanguage(ce)
            }),
            this.services.languageUtils.getBestMatchFromCodes ? ue : ue.length > 0 ? ue[0] : null
        }
    }, {
        key: "cacheUserLanguage",
        value: function(J, ne) {
            var ue = this;
            ne || (ne = this.options.caches),
            ne && (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(J) > -1 || ne.forEach(function(ce) {
                ue.detectors[ce] && ue.detectors[ce].cacheUserLanguage(J, ue.options)
            }))
        }
    }]),
    V
}();
Browser.type = "languageDetector";
function _typeof$2(V) {
    "@babel/helpers - typeof";
    return _typeof$2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(X) {
        return typeof X
    }
    : function(X) {
        return X && typeof Symbol == "function" && X.constructor === Symbol && X !== Symbol.prototype ? "symbol" : typeof X
    }
    ,
    _typeof$2(V)
}
function hasXMLHttpRequest() {
    return typeof XMLHttpRequest == "function" || (typeof XMLHttpRequest > "u" ? "undefined" : _typeof$2(XMLHttpRequest)) === "object"
}
function isPromise(V) {
    return !!V && typeof V.then == "function"
}
function makePromise(V) {
    return isPromise(V) ? V : Promise.resolve(V)
}
function commonjsRequire(V) {
    throw new Error('Could not dynamically require "' + V + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')
}
var getFetch$1 = {
    exports: {}
}, browserPonyfill = {
    exports: {}
}, hasRequiredBrowserPonyfill;
function requireBrowserPonyfill() {
    return hasRequiredBrowserPonyfill || (hasRequiredBrowserPonyfill = 1,
    function(V, X) {
        var J = typeof globalThis < "u" && globalThis || typeof self < "u" && self || typeof commonjsGlobal < "u" && commonjsGlobal
          , ne = function() {
            function ce() {
                this.fetch = !1,
                this.DOMException = J.DOMException
            }
            return ce.prototype = J,
            new ce
        }();
        (function(ce) {
            (function(me) {
                var ge = typeof ce < "u" && ce || typeof self < "u" && self || typeof ge < "u" && ge
                  , Te = {
                    searchParams: "URLSearchParams"in ge,
                    iterable: "Symbol"in ge && "iterator"in Symbol,
                    blob: "FileReader"in ge && "Blob"in ge && function() {
                        try {
                            return new Blob,
                            !0
                        } catch {
                            return !1
                        }
                    }(),
                    formData: "FormData"in ge,
                    arrayBuffer: "ArrayBuffer"in ge
                };
                function _e(Ye) {
                    return Ye && DataView.prototype.isPrototypeOf(Ye)
                }
                if (Te.arrayBuffer)
                    var Se = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"]
                      , Ie = ArrayBuffer.isView || function(Ye) {
                        return Ye && Se.indexOf(Object.prototype.toString.call(Ye)) > -1
                    }
                    ;
                function ye(Ye) {
                    if (typeof Ye != "string" && (Ye = String(Ye)),
                    /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(Ye) || Ye === "")
                        throw new TypeError('Invalid character in header field name: "' + Ye + '"');
                    return Ye.toLowerCase()
                }
                function $e(Ye) {
                    return typeof Ye != "string" && (Ye = String(Ye)),
                    Ye
                }
                function Ne(Ye) {
                    var We = {
                        next: function() {
                            var nt = Ye.shift();
                            return {
                                done: nt === void 0,
                                value: nt
                            }
                        }
                    };
                    return Te.iterable && (We[Symbol.iterator] = function() {
                        return We
                    }
                    ),
                    We
                }
                function ve(Ye) {
                    this.map = {},
                    Ye instanceof ve ? Ye.forEach(function(We, nt) {
                        this.append(nt, We)
                    }, this) : Array.isArray(Ye) ? Ye.forEach(function(We) {
                        this.append(We[0], We[1])
                    }, this) : Ye && Object.getOwnPropertyNames(Ye).forEach(function(We) {
                        this.append(We, Ye[We])
                    }, this)
                }
                ve.prototype.append = function(Ye, We) {
                    Ye = ye(Ye),
                    We = $e(We);
                    var nt = this.map[Ye];
                    this.map[Ye] = nt ? nt + ", " + We : We
                }
                ,
                ve.prototype.delete = function(Ye) {
                    delete this.map[ye(Ye)]
                }
                ,
                ve.prototype.get = function(Ye) {
                    return Ye = ye(Ye),
                    this.has(Ye) ? this.map[Ye] : null
                }
                ,
                ve.prototype.has = function(Ye) {
                    return this.map.hasOwnProperty(ye(Ye))
                }
                ,
                ve.prototype.set = function(Ye, We) {
                    this.map[ye(Ye)] = $e(We)
                }
                ,
                ve.prototype.forEach = function(Ye, We) {
                    for (var nt in this.map)
                        this.map.hasOwnProperty(nt) && Ye.call(We, this.map[nt], nt, this)
                }
                ,
                ve.prototype.keys = function() {
                    var Ye = [];
                    return this.forEach(function(We, nt) {
                        Ye.push(nt)
                    }),
                    Ne(Ye)
                }
                ,
                ve.prototype.values = function() {
                    var Ye = [];
                    return this.forEach(function(We) {
                        Ye.push(We)
                    }),
                    Ne(Ye)
                }
                ,
                ve.prototype.entries = function() {
                    var Ye = [];
                    return this.forEach(function(We, nt) {
                        Ye.push([nt, We])
                    }),
                    Ne(Ye)
                }
                ,
                Te.iterable && (ve.prototype[Symbol.iterator] = ve.prototype.entries);
                function ke(Ye) {
                    if (Ye.bodyUsed)
                        return Promise.reject(new TypeError("Already read"));
                    Ye.bodyUsed = !0
                }
                function xe(Ye) {
                    return new Promise(function(We, nt) {
                        Ye.onload = function() {
                            We(Ye.result)
                        }
                        ,
                        Ye.onerror = function() {
                            nt(Ye.error)
                        }
                    }
                    )
                }
                function we(Ye) {
                    var We = new FileReader
                      , nt = xe(We);
                    return We.readAsArrayBuffer(Ye),
                    nt
                }
                function Fe(Ye) {
                    var We = new FileReader
                      , nt = xe(We);
                    return We.readAsText(Ye),
                    nt
                }
                function je(Ye) {
                    for (var We = new Uint8Array(Ye), nt = new Array(We.length), ct = 0; ct < We.length; ct++)
                        nt[ct] = String.fromCharCode(We[ct]);
                    return nt.join("")
                }
                function Xe(Ye) {
                    if (Ye.slice)
                        return Ye.slice(0);
                    var We = new Uint8Array(Ye.byteLength);
                    return We.set(new Uint8Array(Ye)),
                    We.buffer
                }
                function ze() {
                    return this.bodyUsed = !1,
                    this._initBody = function(Ye) {
                        this.bodyUsed = this.bodyUsed,
                        this._bodyInit = Ye,
                        Ye ? typeof Ye == "string" ? this._bodyText = Ye : Te.blob && Blob.prototype.isPrototypeOf(Ye) ? this._bodyBlob = Ye : Te.formData && FormData.prototype.isPrototypeOf(Ye) ? this._bodyFormData = Ye : Te.searchParams && URLSearchParams.prototype.isPrototypeOf(Ye) ? this._bodyText = Ye.toString() : Te.arrayBuffer && Te.blob && _e(Ye) ? (this._bodyArrayBuffer = Xe(Ye.buffer),
                        this._bodyInit = new Blob([this._bodyArrayBuffer])) : Te.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(Ye) || Ie(Ye)) ? this._bodyArrayBuffer = Xe(Ye) : this._bodyText = Ye = Object.prototype.toString.call(Ye) : this._bodyText = "",
                        this.headers.get("content-type") || (typeof Ye == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : Te.searchParams && URLSearchParams.prototype.isPrototypeOf(Ye) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
                    }
                    ,
                    Te.blob && (this.blob = function() {
                        var Ye = ke(this);
                        if (Ye)
                            return Ye;
                        if (this._bodyBlob)
                            return Promise.resolve(this._bodyBlob);
                        if (this._bodyArrayBuffer)
                            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                        if (this._bodyFormData)
                            throw new Error("could not read FormData body as blob");
                        return Promise.resolve(new Blob([this._bodyText]))
                    }
                    ,
                    this.arrayBuffer = function() {
                        if (this._bodyArrayBuffer) {
                            var Ye = ke(this);
                            return Ye || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength)) : Promise.resolve(this._bodyArrayBuffer))
                        } else
                            return this.blob().then(we)
                    }
                    ),
                    this.text = function() {
                        var Ye = ke(this);
                        if (Ye)
                            return Ye;
                        if (this._bodyBlob)
                            return Fe(this._bodyBlob);
                        if (this._bodyArrayBuffer)
                            return Promise.resolve(je(this._bodyArrayBuffer));
                        if (this._bodyFormData)
                            throw new Error("could not read FormData body as text");
                        return Promise.resolve(this._bodyText)
                    }
                    ,
                    Te.formData && (this.formData = function() {
                        return this.text().then(it)
                    }
                    ),
                    this.json = function() {
                        return this.text().then(JSON.parse)
                    }
                    ,
                    this
                }
                var qe = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
                function Ze(Ye) {
                    var We = Ye.toUpperCase();
                    return qe.indexOf(We) > -1 ? We : Ye
                }
                function et(Ye, We) {
                    if (!(this instanceof et))
                        throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                    We = We || {};
                    var nt = We.body;
                    if (Ye instanceof et) {
                        if (Ye.bodyUsed)
                            throw new TypeError("Already read");
                        this.url = Ye.url,
                        this.credentials = Ye.credentials,
                        We.headers || (this.headers = new ve(Ye.headers)),
                        this.method = Ye.method,
                        this.mode = Ye.mode,
                        this.signal = Ye.signal,
                        !nt && Ye._bodyInit != null && (nt = Ye._bodyInit,
                        Ye.bodyUsed = !0)
                    } else
                        this.url = String(Ye);
                    if (this.credentials = We.credentials || this.credentials || "same-origin",
                    (We.headers || !this.headers) && (this.headers = new ve(We.headers)),
                    this.method = Ze(We.method || this.method || "GET"),
                    this.mode = We.mode || this.mode || null,
                    this.signal = We.signal || this.signal,
                    this.referrer = null,
                    (this.method === "GET" || this.method === "HEAD") && nt)
                        throw new TypeError("Body not allowed for GET or HEAD requests");
                    if (this._initBody(nt),
                    (this.method === "GET" || this.method === "HEAD") && (We.cache === "no-store" || We.cache === "no-cache")) {
                        var ct = /([?&])_=[^&]*/;
                        if (ct.test(this.url))
                            this.url = this.url.replace(ct, "$1_=" + new Date().getTime());
                        else {
                            var Et = /\?/;
                            this.url += (Et.test(this.url) ? "&" : "?") + "_=" + new Date().getTime()
                        }
                    }
                }
                et.prototype.clone = function() {
                    return new et(this,{
                        body: this._bodyInit
                    })
                }
                ;
                function it(Ye) {
                    var We = new FormData;
                    return Ye.trim().split("&").forEach(function(nt) {
                        if (nt) {
                            var ct = nt.split("=")
                              , Et = ct.shift().replace(/\+/g, " ")
                              , Ke = ct.join("=").replace(/\+/g, " ");
                            We.append(decodeURIComponent(Et), decodeURIComponent(Ke))
                        }
                    }),
                    We
                }
                function at(Ye) {
                    var We = new ve
                      , nt = Ye.replace(/\r?\n[\t ]+/g, " ");
                    return nt.split("\r").map(function(ct) {
                        return ct.indexOf(`
`) === 0 ? ct.substr(1, ct.length) : ct
                    }).forEach(function(ct) {
                        var Et = ct.split(":")
                          , Ke = Et.shift().trim();
                        if (Ke) {
                            var mt = Et.join(":").trim();
                            We.append(Ke, mt)
                        }
                    }),
                    We
                }
                ze.call(et.prototype);
                function rt(Ye, We) {
                    if (!(this instanceof rt))
                        throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
                    We || (We = {}),
                    this.type = "default",
                    this.status = We.status === void 0 ? 200 : We.status,
                    this.ok = this.status >= 200 && this.status < 300,
                    this.statusText = We.statusText === void 0 ? "" : "" + We.statusText,
                    this.headers = new ve(We.headers),
                    this.url = We.url || "",
                    this._initBody(Ye)
                }
                ze.call(rt.prototype),
                rt.prototype.clone = function() {
                    return new rt(this._bodyInit,{
                        status: this.status,
                        statusText: this.statusText,
                        headers: new ve(this.headers),
                        url: this.url
                    })
                }
                ,
                rt.error = function() {
                    var Ye = new rt(null,{
                        status: 0,
                        statusText: ""
                    });
                    return Ye.type = "error",
                    Ye
                }
                ;
                var ft = [301, 302, 303, 307, 308];
                rt.redirect = function(Ye, We) {
                    if (ft.indexOf(We) === -1)
                        throw new RangeError("Invalid status code");
                    return new rt(null,{
                        status: We,
                        headers: {
                            location: Ye
                        }
                    })
                }
                ,
                me.DOMException = ge.DOMException;
                try {
                    new me.DOMException
                } catch {
                    me.DOMException = function(We, nt) {
                        this.message = We,
                        this.name = nt;
                        var ct = Error(We);
                        this.stack = ct.stack
                    }
                    ,
                    me.DOMException.prototype = Object.create(Error.prototype),
                    me.DOMException.prototype.constructor = me.DOMException
                }
                function St(Ye, We) {
                    return new Promise(function(nt, ct) {
                        var Et = new et(Ye,We);
                        if (Et.signal && Et.signal.aborted)
                            return ct(new me.DOMException("Aborted","AbortError"));
                        var Ke = new XMLHttpRequest;
                        function mt() {
                            Ke.abort()
                        }
                        Ke.onload = function() {
                            var Qe = {
                                status: Ke.status,
                                statusText: Ke.statusText,
                                headers: at(Ke.getAllResponseHeaders() || "")
                            };
                            Qe.url = "responseURL"in Ke ? Ke.responseURL : Qe.headers.get("X-Request-URL");
                            var gt = "response"in Ke ? Ke.response : Ke.responseText;
                            setTimeout(function() {
                                nt(new rt(gt,Qe))
                            }, 0)
                        }
                        ,
                        Ke.onerror = function() {
                            setTimeout(function() {
                                ct(new TypeError("Network request failed"))
                            }, 0)
                        }
                        ,
                        Ke.ontimeout = function() {
                            setTimeout(function() {
                                ct(new TypeError("Network request failed"))
                            }, 0)
                        }
                        ,
                        Ke.onabort = function() {
                            setTimeout(function() {
                                ct(new me.DOMException("Aborted","AbortError"))
                            }, 0)
                        }
                        ;
                        function lt(Qe) {
                            try {
                                return Qe === "" && ge.location.href ? ge.location.href : Qe
                            } catch {
                                return Qe
                            }
                        }
                        Ke.open(Et.method, lt(Et.url), !0),
                        Et.credentials === "include" ? Ke.withCredentials = !0 : Et.credentials === "omit" && (Ke.withCredentials = !1),
                        "responseType"in Ke && (Te.blob ? Ke.responseType = "blob" : Te.arrayBuffer && Et.headers.get("Content-Type") && Et.headers.get("Content-Type").indexOf("application/octet-stream") !== -1 && (Ke.responseType = "arraybuffer")),
                        We && typeof We.headers == "object" && !(We.headers instanceof ve) ? Object.getOwnPropertyNames(We.headers).forEach(function(Qe) {
                            Ke.setRequestHeader(Qe, $e(We.headers[Qe]))
                        }) : Et.headers.forEach(function(Qe, gt) {
                            Ke.setRequestHeader(gt, Qe)
                        }),
                        Et.signal && (Et.signal.addEventListener("abort", mt),
                        Ke.onreadystatechange = function() {
                            Ke.readyState === 4 && Et.signal.removeEventListener("abort", mt)
                        }
                        ),
                        Ke.send(typeof Et._bodyInit > "u" ? null : Et._bodyInit)
                    }
                    )
                }
                return St.polyfill = !0,
                ge.fetch || (ge.fetch = St,
                ge.Headers = ve,
                ge.Request = et,
                ge.Response = rt),
                me.Headers = ve,
                me.Request = et,
                me.Response = rt,
                me.fetch = St,
                me
            }
            )({})
        }
        )(ne),
        ne.fetch.ponyfill = !0,
        delete ne.fetch.polyfill;
        var ue = J.fetch ? J : ne;
        X = ue.fetch,
        X.default = ue.fetch,
        X.fetch = ue.fetch,
        X.Headers = ue.Headers,
        X.Request = ue.Request,
        X.Response = ue.Response,
        V.exports = X
    }(browserPonyfill, browserPonyfill.exports)),
    browserPonyfill.exports
}
(function(V, X) {
    var J;
    if (typeof fetch == "function" && (typeof commonjsGlobal < "u" && commonjsGlobal.fetch ? J = commonjsGlobal.fetch : typeof window < "u" && window.fetch ? J = window.fetch : J = fetch),
    typeof commonjsRequire < "u" && typeof window > "u") {
        var ne = J || requireBrowserPonyfill();
        ne.default && (ne = ne.default),
        X.default = ne,
        V.exports = X.default
    }
}
)(getFetch$1, getFetch$1.exports);
var getFetchExports = getFetch$1.exports;
const getFetch = getDefaultExportFromCjs(getFetchExports)
  , fetchNode = _mergeNamespaces({
    __proto__: null,
    default: getFetch
}, [getFetchExports]);
function ownKeys$1(V, X) {
    var J = Object.keys(V);
    if (Object.getOwnPropertySymbols) {
        var ne = Object.getOwnPropertySymbols(V);
        X && (ne = ne.filter(function(ue) {
            return Object.getOwnPropertyDescriptor(V, ue).enumerable
        })),
        J.push.apply(J, ne)
    }
    return J
}
function _objectSpread$1(V) {
    for (var X = 1; X < arguments.length; X++) {
        var J = arguments[X] != null ? arguments[X] : {};
        X % 2 ? ownKeys$1(Object(J), !0).forEach(function(ne) {
            _defineProperty$1(V, ne, J[ne])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(V, Object.getOwnPropertyDescriptors(J)) : ownKeys$1(Object(J)).forEach(function(ne) {
            Object.defineProperty(V, ne, Object.getOwnPropertyDescriptor(J, ne))
        })
    }
    return V
}
function _defineProperty$1(V, X, J) {
    return (X = _toPropertyKey$1(X))in V ? Object.defineProperty(V, X, {
        value: J,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : V[X] = J,
    V
}
function _toPropertyKey$1(V) {
    var X = _toPrimitive$1(V, "string");
    return _typeof$1(X) == "symbol" ? X : X + ""
}
function _toPrimitive$1(V, X) {
    if (_typeof$1(V) != "object" || !V)
        return V;
    var J = V[Symbol.toPrimitive];
    if (J !== void 0) {
        var ne = J.call(V, X || "default");
        if (_typeof$1(ne) != "object")
            return ne;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (X === "string" ? String : Number)(V)
}
function _typeof$1(V) {
    "@babel/helpers - typeof";
    return _typeof$1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(X) {
        return typeof X
    }
    : function(X) {
        return X && typeof Symbol == "function" && X.constructor === Symbol && X !== Symbol.prototype ? "symbol" : typeof X
    }
    ,
    _typeof$1(V)
}
var fetchApi;
typeof fetch == "function" && (typeof global < "u" && global.fetch ? fetchApi = global.fetch : typeof window < "u" && window.fetch ? fetchApi = window.fetch : fetchApi = fetch);
var XmlHttpRequestApi;
hasXMLHttpRequest() && (typeof global < "u" && global.XMLHttpRequest ? XmlHttpRequestApi = global.XMLHttpRequest : typeof window < "u" && window.XMLHttpRequest && (XmlHttpRequestApi = window.XMLHttpRequest));
var ActiveXObjectApi;
typeof ActiveXObject == "function" && (typeof global < "u" && global.ActiveXObject ? ActiveXObjectApi = global.ActiveXObject : typeof window < "u" && window.ActiveXObject && (ActiveXObjectApi = window.ActiveXObject));
!fetchApi && fetchNode && !XmlHttpRequestApi && !ActiveXObjectApi && (fetchApi = getFetch || fetchNode);
typeof fetchApi != "function" && (fetchApi = void 0);
var addQueryString = function V(X, J) {
    if (J && _typeof$1(J) === "object") {
        var ne = "";
        for (var ue in J)
            ne += "&" + encodeURIComponent(ue) + "=" + encodeURIComponent(J[ue]);
        if (!ne)
            return X;
        X = X + (X.indexOf("?") !== -1 ? "&" : "?") + ne.slice(1)
    }
    return X
}
  , fetchIt = function V(X, J, ne, ue) {
    var ce = function(Te) {
        if (!Te.ok)
            return ne(Te.statusText || "Error", {
                status: Te.status
            });
        Te.text().then(function(_e) {
            ne(null, {
                status: Te.status,
                data: _e
            })
        }).catch(ne)
    };
    if (ue) {
        var me = ue(X, J);
        if (me instanceof Promise) {
            me.then(ce).catch(ne);
            return
        }
    }
    typeof fetch == "function" ? fetch(X, J).then(ce).catch(ne) : fetchApi(X, J).then(ce).catch(ne)
}
  , omitFetchOptions = !1
  , requestWithFetch = function V(X, J, ne, ue) {
    X.queryStringParams && (J = addQueryString(J, X.queryStringParams));
    var ce = _objectSpread$1({}, typeof X.customHeaders == "function" ? X.customHeaders() : X.customHeaders);
    typeof window > "u" && typeof global < "u" && typeof global.process < "u" && global.process.versions && global.process.versions.node && (ce["User-Agent"] = "i18next-http-backend (node/".concat(global.process.version, "; ").concat(global.process.platform, " ").concat(global.process.arch, ")")),
    ne && (ce["Content-Type"] = "application/json");
    var me = typeof X.requestOptions == "function" ? X.requestOptions(ne) : X.requestOptions
      , ge = _objectSpread$1({
        method: ne ? "POST" : "GET",
        body: ne ? X.stringify(ne) : void 0,
        headers: ce
    }, omitFetchOptions ? {} : me)
      , Te = typeof X.alternateFetch == "function" && X.alternateFetch.length >= 1 ? X.alternateFetch : void 0;
    try {
        fetchIt(J, ge, ue, Te)
    } catch (_e) {
        if (!me || Object.keys(me).length === 0 || !_e.message || _e.message.indexOf("not implemented") < 0)
            return ue(_e);
        try {
            Object.keys(me).forEach(function(Se) {
                delete ge[Se]
            }),
            fetchIt(J, ge, ue, Te),
            omitFetchOptions = !0
        } catch (Se) {
            ue(Se)
        }
    }
}
  , requestWithXmlHttpRequest = function V(X, J, ne, ue) {
    ne && _typeof$1(ne) === "object" && (ne = addQueryString("", ne).slice(1)),
    X.queryStringParams && (J = addQueryString(J, X.queryStringParams));
    try {
        var ce;
        XmlHttpRequestApi ? ce = new XmlHttpRequestApi : ce = new ActiveXObjectApi("MSXML2.XMLHTTP.3.0"),
        ce.open(ne ? "POST" : "GET", J, 1),
        X.crossDomain || ce.setRequestHeader("X-Requested-With", "XMLHttpRequest"),
        ce.withCredentials = !!X.withCredentials,
        ne && ce.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"),
        ce.overrideMimeType && ce.overrideMimeType("application/json");
        var me = X.customHeaders;
        if (me = typeof me == "function" ? me() : me,
        me)
            for (var ge in me)
                ce.setRequestHeader(ge, me[ge]);
        ce.onreadystatechange = function() {
            ce.readyState > 3 && ue(ce.status >= 400 ? ce.statusText : null, {
                status: ce.status,
                data: ce.responseText
            })
        }
        ,
        ce.send(ne)
    } catch (Te) {
        console && console.log(Te)
    }
}
  , request = function V(X, J, ne, ue) {
    if (typeof ne == "function" && (ue = ne,
    ne = void 0),
    ue = ue || function() {}
    ,
    fetchApi && J.indexOf("file:") !== 0)
        return requestWithFetch(X, J, ne, ue);
    if (hasXMLHttpRequest() || typeof ActiveXObject == "function")
        return requestWithXmlHttpRequest(X, J, ne, ue);
    ue(new Error("No fetch and no xhr implementation found!"))
};
function _typeof(V) {
    "@babel/helpers - typeof";
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(X) {
        return typeof X
    }
    : function(X) {
        return X && typeof Symbol == "function" && X.constructor === Symbol && X !== Symbol.prototype ? "symbol" : typeof X
    }
    ,
    _typeof(V)
}
function ownKeys(V, X) {
    var J = Object.keys(V);
    if (Object.getOwnPropertySymbols) {
        var ne = Object.getOwnPropertySymbols(V);
        X && (ne = ne.filter(function(ue) {
            return Object.getOwnPropertyDescriptor(V, ue).enumerable
        })),
        J.push.apply(J, ne)
    }
    return J
}
function _objectSpread(V) {
    for (var X = 1; X < arguments.length; X++) {
        var J = arguments[X] != null ? arguments[X] : {};
        X % 2 ? ownKeys(Object(J), !0).forEach(function(ne) {
            _defineProperty(V, ne, J[ne])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(V, Object.getOwnPropertyDescriptors(J)) : ownKeys(Object(J)).forEach(function(ne) {
            Object.defineProperty(V, ne, Object.getOwnPropertyDescriptor(J, ne))
        })
    }
    return V
}
function _classCallCheck(V, X) {
    if (!(V instanceof X))
        throw new TypeError("Cannot call a class as a function")
}
function _defineProperties(V, X) {
    for (var J = 0; J < X.length; J++) {
        var ne = X[J];
        ne.enumerable = ne.enumerable || !1,
        ne.configurable = !0,
        "value"in ne && (ne.writable = !0),
        Object.defineProperty(V, _toPropertyKey(ne.key), ne)
    }
}
function _createClass(V, X, J) {
    return X && _defineProperties(V.prototype, X),
    Object.defineProperty(V, "prototype", {
        writable: !1
    }),
    V
}
function _defineProperty(V, X, J) {
    return (X = _toPropertyKey(X))in V ? Object.defineProperty(V, X, {
        value: J,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : V[X] = J,
    V
}
function _toPropertyKey(V) {
    var X = _toPrimitive(V, "string");
    return _typeof(X) == "symbol" ? X : X + ""
}
function _toPrimitive(V, X) {
    if (_typeof(V) != "object" || !V)
        return V;
    var J = V[Symbol.toPrimitive];
    if (J !== void 0) {
        var ne = J.call(V, X || "default");
        if (_typeof(ne) != "object")
            return ne;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (X === "string" ? String : Number)(V)
}
var getDefaults = function V() {
    return {
        loadPath: "/locales/{{lng}}/{{ns}}.json",
        addPath: "/locales/add/{{lng}}/{{ns}}",
        parse: function(J) {
            return JSON.parse(J)
        },
        stringify: JSON.stringify,
        parsePayload: function(J, ne, ue) {
            return _defineProperty({}, ne, ue || "")
        },
        parseLoadPayload: function(J, ne) {},
        request,
        reloadInterval: typeof window < "u" ? !1 : 60 * 60 * 1e3,
        customHeaders: {},
        queryStringParams: {},
        crossDomain: !1,
        withCredentials: !1,
        overrideMimeType: !1,
        requestOptions: {
            mode: "cors",
            credentials: "same-origin",
            cache: "default"
        }
    }
}
  , Backend = function() {
    function V(X) {
        var J = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
          , ne = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        _classCallCheck(this, V),
        this.services = X,
        this.options = J,
        this.allOptions = ne,
        this.type = "backend",
        this.init(X, J, ne)
    }
    return _createClass(V, [{
        key: "init",
        value: function(J) {
            var ne = this
              , ue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
              , ce = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            if (this.services = J,
            this.options = _objectSpread(_objectSpread(_objectSpread({}, getDefaults()), this.options || {}), ue),
            this.allOptions = ce,
            this.services && this.options.reloadInterval) {
                var me = setInterval(function() {
                    return ne.reload()
                }, this.options.reloadInterval);
                _typeof(me) === "object" && typeof me.unref == "function" && me.unref()
            }
        }
    }, {
        key: "readMulti",
        value: function(J, ne, ue) {
            this._readAny(J, J, ne, ne, ue)
        }
    }, {
        key: "read",
        value: function(J, ne, ue) {
            this._readAny([J], J, [ne], ne, ue)
        }
    }, {
        key: "_readAny",
        value: function(J, ne, ue, ce, me) {
            var ge = this
              , Te = this.options.loadPath;
            typeof this.options.loadPath == "function" && (Te = this.options.loadPath(J, ue)),
            Te = makePromise(Te),
            Te.then(function(_e) {
                if (!_e)
                    return me(null, {});
                var Se = ge.services.interpolator.interpolate(_e, {
                    lng: J.join("+"),
                    ns: ue.join("+")
                });
                ge.loadUrl(Se, me, ne, ce)
            })
        }
    }, {
        key: "loadUrl",
        value: function(J, ne, ue, ce) {
            var me = this
              , ge = typeof ue == "string" ? [ue] : ue
              , Te = typeof ce == "string" ? [ce] : ce
              , _e = this.options.parseLoadPayload(ge, Te);
            this.options.request(this.options, J, _e, function(Se, Ie) {
                if (Ie && (Ie.status >= 500 && Ie.status < 600 || !Ie.status))
                    return ne("failed loading " + J + "; status code: " + Ie.status, !0);
                if (Ie && Ie.status >= 400 && Ie.status < 500)
                    return ne("failed loading " + J + "; status code: " + Ie.status, !1);
                if (!Ie && Se && Se.message) {
                    var ye = Se.message.toLowerCase()
                      , $e = ["failed", "fetch", "network", "load"].find(function(ke) {
                        return ye.indexOf(ke) > -1
                    });
                    if ($e)
                        return ne("failed loading " + J + ": " + Se.message, !0)
                }
                if (Se)
                    return ne(Se, !1);
                var Ne, ve;
                try {
                    typeof Ie.data == "string" ? Ne = me.options.parse(Ie.data, ue, ce) : Ne = Ie.data
                } catch {
                    ve = "failed parsing " + J + " to json"
                }
                if (ve)
                    return ne(ve, !1);
                ne(null, Ne)
            })
        }
    }, {
        key: "create",
        value: function(J, ne, ue, ce, me) {
            var ge = this;
            if (this.options.addPath) {
                typeof J == "string" && (J = [J]);
                var Te = this.options.parsePayload(ne, ue, ce)
                  , _e = 0
                  , Se = []
                  , Ie = [];
                J.forEach(function(ye) {
                    var $e = ge.options.addPath;
                    typeof ge.options.addPath == "function" && ($e = ge.options.addPath(ye, ne));
                    var Ne = ge.services.interpolator.interpolate($e, {
                        lng: ye,
                        ns: ne
                    });
                    ge.options.request(ge.options, Ne, Te, function(ve, ke) {
                        _e += 1,
                        Se.push(ve),
                        Ie.push(ke),
                        _e === J.length && typeof me == "function" && me(Se, Ie)
                    })
                })
            }
        }
    }, {
        key: "reload",
        value: function() {
            var J = this
              , ne = this.services
              , ue = ne.backendConnector
              , ce = ne.languageUtils
              , me = ne.logger
              , ge = ue.language;
            if (!(ge && ge.toLowerCase() === "cimode")) {
                var Te = []
                  , _e = function(Ie) {
                    var ye = ce.toResolveHierarchy(Ie);
                    ye.forEach(function($e) {
                        Te.indexOf($e) < 0 && Te.push($e)
                    })
                };
                _e(ge),
                this.allOptions.preload && this.allOptions.preload.forEach(function(Se) {
                    return _e(Se)
                }),
                Te.forEach(function(Se) {
                    J.allOptions.ns.forEach(function(Ie) {
                        ue.read(Se, Ie, "read", null, null, function(ye, $e) {
                            ye && me.warn("loading namespace ".concat(Ie, " for language ").concat(Se, " failed"), ye),
                            !ye && $e && me.log("loaded namespace ".concat(Ie, " for language ").concat(Se), $e),
                            ue.loaded("".concat(Se, "|").concat(Ie), ye, $e)
                        })
                    })
                })
            }
        }
    }])
}();
Backend.type = "backend";
instance.use(Backend).use(Browser).use(initReactI18next).init({
    detection: {
        lookupQuerystring: "setLocale",
        lookupCookie: COOKIE_KEY.LOCALE,
        order: ["querystring", "cookie", "navigator"]
    },
    supportedLngs: SUPPORTED_LOCALES,
    fallbackLng: DEFAULT_LOCALE,
    backend: {
        loadPath: getAssetPath("/i18n/{{lng}}.json")
    },
    ns: I18N_NAMESPACE_KEY,
    defaultNS: I18N_NAMESPACE_KEY,
    debug: !1,
    interpolation: {
        nestingPrefix: "%{",
        nestingSuffix: "}"
    }
});
const wrapper = "_wrapper_pptrk_1"
  , styles = {
    wrapper
};
if (document.location.pathname.startsWith("/games/battlefield") || document.location.pathname.startsWith("/" + getLanguageFromPath().toLowerCase() + "/games/battlefield")) {
    const V = new URL(document.location.pathname,"https://www.ea.com");
    window.location.replace(V.href)
}
const queryCache = new QueryCache({
    onError: async V => {
        console.error(V),
        V.code === 16 && (await clients.authentication.logout({}),
        clearSessionCookies(),
        window.location.reload())
    }
})
  , queryClient = new QueryClient({
    queryCache,
    defaultOptions: {
        queries: {
            gcTime: MS_24_HOURS
        }
    }
})
  , persister = createIndexedDBPersister();
(async () => {
    if (navigator.storage && navigator.storage.estimate) {
        const V = await navigator.storage.estimate();
        if (V.usage && V.quota) {
            const X = V.usage / V.quota * 100;
            console.log(`💾 Available storage used: ${X}% (${V.usage} bytes)`);
            const J = V.quota - V.usage;
            console.log(`💾 Remaining storage: ${J} bytes`)
        }
    }
    instance.changeLanguage(getLanguageFromPath())
}
)();
const helmetContext = {}
  , rootElement = document.getElementById("root");
if (!rootElement)
    throw new Error("Could not get root element!");
const root = ReactDOMClient.createRoot(rootElement);
root.render(jsxRuntimeExports.jsx(React$2.StrictMode, {
    children: jsxRuntimeExports.jsx(PersistQueryClientProvider, {
        client: queryClient,
        persistOptions: {
            persister,
            dehydrateOptions: {
                shouldDehydrateQuery: V => {
                    const {queryKey: X, state: J} = V;
                    if (X[0] === QUERY_KEY.BLUEPRINT) {
                        const ne = localStorage.getItem(LOCAL_STORAGE_KEY.BLUEPRINT_ID)
                          , ue = X[2];
                        if (!ne || ne && ue && ne !== ue)
                            return localStorage.removeItem(LOCAL_STORAGE_KEY.WEB_BLUEPRINT),
                            localStorage.setItem(LOCAL_STORAGE_KEY.BLUEPRINT_ID, ue),
                            !1
                    }
                    return !(J.isInvalidated || X[0] === QUERY_KEY.AUTH)
                }
            }
        },
        children: jsxRuntimeExports.jsx(q, {
            context: helmetContext,
            children: jsxRuntimeExports.jsx(SessionProvider, {
                children: jsxRuntimeExports.jsx(ThemeProvider, {
                    children: jsxRuntimeExports.jsx(SessionContext.Consumer, {
                        children: ({sessionId: V, player: X}) => jsxRuntimeExports.jsx(TelemetryProvider, {
                            player: X,
                            children: jsxRuntimeExports.jsx(BlueprintProvider, {
                                sessionId: V,
                                children: jsxRuntimeExports.jsx(BlueprintContext.Consumer, {
                                    children: ({sids: J}) => jsxRuntimeExports.jsx(TranslationsProvider, {
                                        sids: J,
                                        session: V,
                                        children: jsxRuntimeExports.jsxs("div", {
                                            className: styles.wrapper,
                                            children: [jsxRuntimeExports.jsx(EAHeader, {
                                                sessionId: V,
                                                player: X
                                            }), jsxRuntimeExports.jsx(OffCanvasProvider, {
                                                children: jsxRuntimeExports.jsx(DialogProvider, {
                                                    children: jsxRuntimeExports.jsx(CurrentBreakpointProvider, {
                                                        children: jsxRuntimeExports.jsxs(ToastProvider, {
                                                            children: [jsxRuntimeExports.jsx(AppRouter, {}), jsxRuntimeExports.jsx(ToastList, {})]
                                                        })
                                                    })
                                                })
                                            }), jsxRuntimeExports.jsx(EAFooter, {})]
                                        })
                                    })
                                })
                            })
                        })
                    })
                })
            })
        })
    })
}));
